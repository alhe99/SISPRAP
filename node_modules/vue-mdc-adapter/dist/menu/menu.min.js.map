{"version":3,"file":"menu.min.js","sources":["../../components/base/custom-event.js","../../components/base/uniqueid-mixin.js","../../node_modules/@material/base/foundation.js","../../node_modules/@material/menu/constants.js","../../node_modules/@material/menu/adapter.js","../../node_modules/@material/menu/foundation.js","../../node_modules/@material/menu/util.js","../../components/base/base-plugin.js","../../components/base/auto-init.js","../../components/menu/entry.js"],"sourcesContent":["/* global CustomEvent */\n\nexport function emitCustomEvent(el, evtType, evtData, shouldBubble = false) {\n  let evt\n  if (typeof CustomEvent === 'function') {\n    evt = new CustomEvent(evtType, {\n      detail: evtData,\n      bubbles: shouldBubble\n    })\n  } else {\n    evt = document.createEvent('CustomEvent')\n    evt.initCustomEvent(evtType, shouldBubble, false, evtData)\n  }\n  el.dispatchEvent(evt)\n}\n","const scope =\n  Math.floor(Math.random() * Math.floor(0x10000000)).toString() + '-'\n\nexport const VMAUniqueIdMixin = {\n  beforeCreate() {\n    this.vma_uid_ = scope + this._uid\n  }\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @template A\n */\nclass MDCFoundation {\n  /** @return enum{cssClasses} */\n  static get cssClasses() {\n    // Classes extending MDCFoundation should implement this method to return an object which exports every\n    // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}\n    return {};\n  }\n\n  /** @return enum{strings} */\n  static get strings() {\n    // Classes extending MDCFoundation should implement this method to return an object which exports all\n    // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}\n    return {};\n  }\n\n  /** @return enum{numbers} */\n  static get numbers() {\n    // Classes extending MDCFoundation should implement this method to return an object which exports all\n    // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}\n    return {};\n  }\n\n  /** @return {!Object} */\n  static get defaultAdapter() {\n    // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient\n    // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter\n    // validation.\n    return {};\n  }\n\n  /**\n   * @param {A=} adapter\n   */\n  constructor(adapter = {}) {\n    /** @protected {!A} */\n    this.adapter_ = adapter;\n  }\n\n  init() {\n    // Subclasses should override this method to perform initialization routines (registering events, etc.)\n  }\n\n  destroy() {\n    // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)\n  }\n}\n\nexport default MDCFoundation;\n","/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @enum {string} */\nconst cssClasses = {\n  ROOT: 'mdc-menu',\n  OPEN: 'mdc-menu--open',\n  ANIMATING_OPEN: 'mdc-menu--animating-open',\n  ANIMATING_CLOSED: 'mdc-menu--animating-closed',\n  SELECTED_LIST_ITEM: 'mdc-list-item--selected',\n};\n\n/** @enum {string} */\nconst strings = {\n  ITEMS_SELECTOR: '.mdc-menu__items',\n  SELECTED_EVENT: 'MDCMenu:selected',\n  CANCEL_EVENT: 'MDCMenu:cancel',\n  ARIA_DISABLED_ATTR: 'aria-disabled',\n};\n\n/** @enum {number} */\nconst numbers = {\n  // Amount of time to wait before triggering a selected event on the menu. Note that this time\n  // will most likely be bumped up once interactive lists are supported to allow for the ripple to\n  // animate before closing the menu\n  SELECTED_TRIGGER_DELAY: 50,\n  // Total duration of menu open animation.\n  TRANSITION_OPEN_DURATION: 120,\n  // Total duration of menu close animation.\n  TRANSITION_CLOSE_DURATION: 75,\n  // Margin left to the edge of the viewport when menu is at maximum possible height.\n  MARGIN_TO_EDGE: 32,\n  // Ratio of anchor width to menu width for switching from corner positioning to center positioning.\n  ANCHOR_TO_MENU_WIDTH_RATIO: 0.67,\n  // Ratio of vertical offset to menu height for switching from corner to mid-way origin positioning.\n  OFFSET_TO_MENU_HEIGHT_RATIO: 0.1,\n};\n\n/**\n * Enum for bits in the {@see Corner) bitmap.\n * @enum {number}\n */\nconst CornerBit = {\n  BOTTOM: 1,\n  CENTER: 2,\n  RIGHT: 4,\n  FLIP_RTL: 8,\n};\n\n/**\n * Enum for representing an element corner for positioning the menu.\n *\n * The START constants map to LEFT if element directionality is left\n * to right and RIGHT if the directionality is right to left.\n * Likewise END maps to RIGHT or LEFT depending on the directionality.\n *\n * @enum {number}\n */\nconst Corner = {\n  TOP_LEFT: 0,\n  TOP_RIGHT: CornerBit.RIGHT,\n  BOTTOM_LEFT: CornerBit.BOTTOM,\n  BOTTOM_RIGHT: CornerBit.BOTTOM | CornerBit.RIGHT,\n  TOP_START: CornerBit.FLIP_RTL,\n  TOP_END: CornerBit.FLIP_RTL | CornerBit.RIGHT,\n  BOTTOM_START: CornerBit.BOTTOM | CornerBit.FLIP_RTL,\n  BOTTOM_END: CornerBit.BOTTOM | CornerBit.RIGHT | CornerBit.FLIP_RTL,\n};\n\n\nexport {cssClasses, strings, numbers, CornerBit, Corner};\n","/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint no-unused-vars: [2, {\"args\": \"none\"}] */\n\n/**\n * Adapter for MDC Menu. Provides an interface for managing\n * - classes\n * - dom\n * - focus\n * - position\n * - dimensions\n * - event handlers\n *\n * Additionally, provides type information for the adapter to the Closure\n * compiler.\n *\n * Implement this adapter for your framework of choice to delegate updates to\n * the component in your framework of choice. See architecture documentation\n * for more details.\n * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md\n *\n * @record\n */\nclass MDCMenuAdapter {\n  /** @param {string} className */\n  addClass(className) {}\n\n  /** @param {string} className */\n  removeClass(className) {}\n\n  /**\n   * @param {string} className\n   * @return {boolean}\n   */\n  hasClass(className) {}\n\n  /** @return {boolean} */\n  hasNecessaryDom() {}\n\n  /**\n   * @param {EventTarget} target\n   * @param {string} attributeName\n   * @return {string}\n   */\n  getAttributeForEventTarget(target, attributeName) {}\n\n  /** @return {{ width: number, height: number }} */\n  getInnerDimensions() {}\n\n  /** @return {boolean} */\n  hasAnchor() {}\n\n  /** @return {{width: number, height: number, top: number, right: number, bottom: number, left: number}} */\n  getAnchorDimensions() {}\n\n  /** @return {{ width: number, height: number }} */\n  getWindowDimensions() {}\n\n  /** @return {number} */\n  getNumberOfItems() {}\n\n  /**\n   * @param {string} type\n   * @param {function(!Event)} handler\n   */\n  registerInteractionHandler(type, handler) {}\n\n  /**\n   * @param {string} type\n   * @param {function(!Event)} handler\n   */\n  deregisterInteractionHandler(type, handler) {}\n\n  /** @param {function(!Event)} handler */\n  registerBodyClickHandler(handler) {}\n\n  /** @param {function(!Event)} handler */\n  deregisterBodyClickHandler(handler) {}\n\n  /**\n   * @param {EventTarget} target\n   * @return {number}\n   */\n  getIndexForEventTarget(target) {}\n\n  /** @param {{index: number}} evtData */\n  notifySelected(evtData) {}\n\n  notifyCancel() {}\n\n  saveFocus() {}\n\n  restoreFocus() {}\n\n  /** @return {boolean} */\n  isFocused() {}\n\n  focus() {}\n\n  /** @return {number} */\n  getFocusedItemIndex() /* number */ {}\n\n  /** @param {number} index */\n  focusItemAtIndex(index) {}\n\n  /** @return {boolean} */\n  isRtl() {}\n\n  /** @param {string} origin */\n  setTransformOrigin(origin) {}\n\n  /** @param {{\n  *   top: (string|undefined),\n  *   right: (string|undefined),\n  *   bottom: (string|undefined),\n  *   left: (string|undefined)\n  * }} position */\n  setPosition(position) {}\n\n  /** @param {string} height */\n  setMaxHeight(height) {}\n\n  /**\n   * @param {number} index\n   * @param {string} attr\n   * @param {string} value\n   */\n  setAttrForOptionAtIndex(index, attr, value) {}\n\n  /**\n   * @param {number} index\n   * @param {string} attr\n   */\n  rmAttrForOptionAtIndex(index, attr) {}\n\n  /**\n   * @param {number} index\n   * @param {string} className\n   */\n  addClassForOptionAtIndex(index, className) {}\n\n  /**\n   * @param {number} index\n   * @param {string} className\n   */\n  rmClassForOptionAtIndex(index, className) {}\n}\n\nexport {MDCMenuAdapter};\n","/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @typedef {{\n *   top: number,\n *   right: number,\n *   bottom: number,\n *   left: number\n * }}\n */\nlet AnchorMargin;\n\n/* eslint-disable no-unused-vars */\n/**\n * @typedef {{\n *   viewport: { width: number, height: number },\n *   viewportDistance: {top: number, right: number, bottom: number, left: number},\n *   anchorHeight: number,\n *   anchorWidth: number,\n *   menuHeight: number,\n *   menuWidth: number,\n * }}\n */\nlet AutoLayoutMeasurements;\n/* eslint-enable no-unused-vars */\n\nimport MDCFoundation from '@material/base/foundation';\nimport {MDCMenuAdapter} from './adapter';\nimport {cssClasses, strings, numbers, Corner, CornerBit} from './constants';\n\n/**\n * @extends {MDCFoundation<!MDCMenuAdapter>}\n */\nclass MDCMenuFoundation extends MDCFoundation {\n  /** @return enum{cssClasses} */\n  static get cssClasses() {\n    return cssClasses;\n  }\n\n  /** @return enum{strings} */\n  static get strings() {\n    return strings;\n  }\n\n  /** @return enum{numbers} */\n  static get numbers() {\n    return numbers;\n  }\n\n  /** @return enum{number} */\n  static get Corner() {\n    return Corner;\n  }\n\n  /**\n   * {@see MDCMenuAdapter} for typing information on parameters and return\n   * types.\n   * @return {!MDCMenuAdapter}\n   */\n  static get defaultAdapter() {\n    return /** @type {!MDCMenuAdapter} */ ({\n      addClass: () => {},\n      removeClass: () => {},\n      hasClass: () => false,\n      hasNecessaryDom: () => false,\n      getAttributeForEventTarget: () => {},\n      getInnerDimensions: () => ({}),\n      hasAnchor: () => false,\n      getAnchorDimensions: () => ({}),\n      getWindowDimensions: () => ({}),\n      getNumberOfItems: () => 0,\n      registerInteractionHandler: () => {},\n      deregisterInteractionHandler: () => {},\n      registerBodyClickHandler: () => {},\n      deregisterBodyClickHandler: () => {},\n      getIndexForEventTarget: () => 0,\n      notifySelected: () => {},\n      notifyCancel: () => {},\n      saveFocus: () => {},\n      restoreFocus: () => {},\n      isFocused: () => false,\n      focus: () => {},\n      getFocusedItemIndex: () => -1,\n      focusItemAtIndex: () => {},\n      isRtl: () => false,\n      setTransformOrigin: () => {},\n      setPosition: () => {},\n      setMaxHeight: () => {},\n      setAttrForOptionAtIndex: () => {},\n      rmAttrForOptionAtIndex: () => {},\n      addClassForOptionAtIndex: () => {},\n      rmClassForOptionAtIndex: () => {},\n    });\n  }\n\n  /** @param {!MDCMenuAdapter} adapter */\n  constructor(adapter) {\n    super(Object.assign(MDCMenuFoundation.defaultAdapter, adapter));\n\n    /** @private {function(!Event)} */\n    this.clickHandler_ = (evt) => this.handlePossibleSelected_(evt);\n    /** @private {function(!Event)} */\n    this.keydownHandler_ = (evt) => this.handleKeyboardDown_(evt);\n    /** @private {function(!Event)} */\n    this.keyupHandler_ = (evt) => this.handleKeyboardUp_(evt);\n    /** @private {function(!Event)} */\n    this.documentClickHandler_ = (evt) => this.handleDocumentClick_(evt);\n    /** @private {boolean} */\n    this.isOpen_ = false;\n    /** @private {number} */\n    this.openAnimationEndTimerId_ = 0;\n    /** @private {number} */\n    this.closeAnimationEndTimerId_ = 0;\n    /** @private {number} */\n    this.selectedTriggerTimerId_ = 0;\n    /** @private {number} */\n    this.animationRequestId_ = 0;\n    /** @private {!{ width: number, height: number }} */\n    this.dimensions_;\n    /** @private {number} */\n    this.itemHeight_;\n    /** @private {Corner} */\n    this.anchorCorner_ = Corner.TOP_START;\n    /** @private {AnchorMargin} */\n    this.anchorMargin_ = {top: 0, right: 0, bottom: 0, left: 0};\n    /** @private {?AutoLayoutMeasurements} */\n    this.measures_ = null;\n    /** @private {number} */\n    this.selectedIndex_ = -1;\n    /** @private {boolean} */\n    this.rememberSelection_ = false;\n    /** @private {boolean} */\n    this.quickOpen_ = false;\n\n    // A keyup event on the menu needs to have a corresponding keydown\n    // event on the menu. If the user opens the menu with a keydown event on a\n    // button, the menu will only get the key up event causing buggy behavior with selected elements.\n    /** @private {boolean} */\n    this.keyDownWithinMenu_ = false;\n  }\n\n  init() {\n    const {ROOT, OPEN} = MDCMenuFoundation.cssClasses;\n\n    if (!this.adapter_.hasClass(ROOT)) {\n      throw new Error(`${ROOT} class required in root element.`);\n    }\n\n    if (!this.adapter_.hasNecessaryDom()) {\n      throw new Error(`Required DOM nodes missing in ${ROOT} component.`);\n    }\n\n    if (this.adapter_.hasClass(OPEN)) {\n      this.isOpen_ = true;\n    }\n\n    this.adapter_.registerInteractionHandler('click', this.clickHandler_);\n    this.adapter_.registerInteractionHandler('keyup', this.keyupHandler_);\n    this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);\n  }\n\n  destroy() {\n    clearTimeout(this.selectedTriggerTimerId_);\n    clearTimeout(this.openAnimationEndTimerId_);\n    clearTimeout(this.closeAnimationEndTimerId_);\n    // Cancel any currently running animations.\n    cancelAnimationFrame(this.animationRequestId_);\n    this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);\n    this.adapter_.deregisterInteractionHandler('keyup', this.keyupHandler_);\n    this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);\n    this.adapter_.deregisterBodyClickHandler(this.documentClickHandler_);\n  }\n\n  /**\n   * @param {!Corner} corner Default anchor corner alignment of top-left menu corner.\n   */\n  setAnchorCorner(corner) {\n    this.anchorCorner_ = corner;\n  }\n\n  /**\n   * @param {!AnchorMargin} margin 4-plet of margins from anchor.\n   */\n  setAnchorMargin(margin) {\n    this.anchorMargin_.top = typeof margin.top === 'number' ? margin.top : 0;\n    this.anchorMargin_.right = typeof margin.right === 'number' ? margin.right : 0;\n    this.anchorMargin_.bottom = typeof margin.bottom === 'number' ? margin.bottom : 0;\n    this.anchorMargin_.left = typeof margin.left === 'number' ? margin.left : 0;\n  }\n\n  /** @param {boolean} rememberSelection */\n  setRememberSelection(rememberSelection) {\n    this.rememberSelection_ = rememberSelection;\n    this.setSelectedIndex(-1);\n  }\n\n  /** @param {boolean} quickOpen */\n  setQuickOpen(quickOpen) {\n    this.quickOpen_ = quickOpen;\n  }\n\n  /**\n   * @param {?number} focusIndex\n   * @private\n   */\n  focusOnOpen_(focusIndex) {\n    if (focusIndex === null) {\n      // If this instance of MDCMenu remembers selections, and the user has\n      // made a selection, then focus the last selected item\n      if (this.rememberSelection_ && this.selectedIndex_ >= 0) {\n        this.adapter_.focusItemAtIndex(this.selectedIndex_);\n        return;\n      }\n\n      this.adapter_.focus();\n      // If that doesn't work, focus first item instead.\n      if (!this.adapter_.isFocused()) {\n        this.adapter_.focusItemAtIndex(0);\n      }\n    } else {\n      this.adapter_.focusItemAtIndex(focusIndex);\n    }\n  }\n\n  /**\n   * Handle clicks and cancel the menu if not a child list-item\n   * @param {!Event} evt\n   * @private\n   */\n  handleDocumentClick_(evt) {\n    let el = evt.target;\n\n    while (el && el !== document.documentElement) {\n      if (this.adapter_.getIndexForEventTarget(el) !== -1) {\n        return;\n      }\n      el = el.parentNode;\n    }\n\n    this.adapter_.notifyCancel();\n    this.close(evt);\n  };\n\n  /**\n   * Handle keys that we want to repeat on hold (tab and arrows).\n   * @param {!Event} evt\n   * @return {boolean}\n   * @private\n   */\n  handleKeyboardDown_(evt) {\n    // Do nothing if Alt, Ctrl or Meta are pressed.\n    if (evt.altKey || evt.ctrlKey || evt.metaKey) {\n      return true;\n    }\n\n    const {keyCode, key, shiftKey} = evt;\n    const isTab = key === 'Tab' || keyCode === 9;\n    const isArrowUp = key === 'ArrowUp' || keyCode === 38;\n    const isArrowDown = key === 'ArrowDown' || keyCode === 40;\n    const isSpace = key === 'Space' || keyCode === 32;\n    const isEnter = key === 'Enter' || keyCode === 13;\n    // The menu needs to know if the keydown event was triggered on the menu\n    this.keyDownWithinMenu_ = isEnter || isSpace;\n\n    const focusedItemIndex = this.adapter_.getFocusedItemIndex();\n    const lastItemIndex = this.adapter_.getNumberOfItems() - 1;\n\n    if (shiftKey && isTab && focusedItemIndex === 0) {\n      this.adapter_.focusItemAtIndex(lastItemIndex);\n      evt.preventDefault();\n      return false;\n    }\n\n    if (!shiftKey && isTab && focusedItemIndex === lastItemIndex) {\n      this.adapter_.focusItemAtIndex(0);\n      evt.preventDefault();\n      return false;\n    }\n\n    // Ensure Arrow{Up,Down} and space do not cause inadvertent scrolling\n    if (isArrowUp || isArrowDown || isSpace) {\n      evt.preventDefault();\n    }\n\n    if (isArrowUp) {\n      if (focusedItemIndex === 0 || this.adapter_.isFocused()) {\n        this.adapter_.focusItemAtIndex(lastItemIndex);\n      } else {\n        this.adapter_.focusItemAtIndex(focusedItemIndex - 1);\n      }\n    } else if (isArrowDown) {\n      if (focusedItemIndex === lastItemIndex || this.adapter_.isFocused()) {\n        this.adapter_.focusItemAtIndex(0);\n      } else {\n        this.adapter_.focusItemAtIndex(focusedItemIndex + 1);\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle keys that we don't want to repeat on hold (Enter, Space, Escape).\n   * @param {!Event} evt\n   * @return {boolean}\n   * @private\n   */\n  handleKeyboardUp_(evt) {\n    // Do nothing if Alt, Ctrl or Meta are pressed.\n    if (evt.altKey || evt.ctrlKey || evt.metaKey) {\n      return true;\n    }\n\n    const {keyCode, key} = evt;\n    const isEnter = key === 'Enter' || keyCode === 13;\n    const isSpace = key === 'Space' || keyCode === 32;\n    const isEscape = key === 'Escape' || keyCode === 27;\n\n    if (isEnter || isSpace) {\n      // If the keydown event didn't occur on the menu, then it should\n      // disregard the possible selected event.\n      if (this.keyDownWithinMenu_) {\n        this.handlePossibleSelected_(evt);\n      }\n      this.keyDownWithinMenu_ = false;\n    }\n\n    if (isEscape) {\n      this.adapter_.notifyCancel();\n      this.close();\n    }\n\n    return true;\n  }\n\n  /**\n   * @param {!Event} evt\n   * @private\n   */\n  handlePossibleSelected_(evt) {\n    if (this.adapter_.getAttributeForEventTarget(evt.target, strings.ARIA_DISABLED_ATTR) === 'true') {\n      return;\n    }\n    const targetIndex = this.adapter_.getIndexForEventTarget(evt.target);\n    if (targetIndex < 0) {\n      return;\n    }\n    // Debounce multiple selections\n    if (this.selectedTriggerTimerId_) {\n      return;\n    }\n    this.selectedTriggerTimerId_ = setTimeout(() => {\n      this.selectedTriggerTimerId_ = 0;\n      this.close();\n      if (this.rememberSelection_) {\n        this.setSelectedIndex(targetIndex);\n      }\n      this.adapter_.notifySelected({index: targetIndex});\n    }, numbers.SELECTED_TRIGGER_DELAY);\n  }\n\n  /**\n   * @return {AutoLayoutMeasurements} Measurements used to position menu popup.\n   */\n  getAutoLayoutMeasurements_() {\n    const anchorRect = this.adapter_.getAnchorDimensions();\n    const viewport = this.adapter_.getWindowDimensions();\n\n    return {\n      viewport: viewport,\n      viewportDistance: {\n        top: anchorRect.top,\n        right: viewport.width - anchorRect.right,\n        left: anchorRect.left,\n        bottom: viewport.height - anchorRect.bottom,\n      },\n      anchorHeight: anchorRect.height,\n      anchorWidth: anchorRect.width,\n      menuHeight: this.dimensions_.height,\n      menuWidth: this.dimensions_.width,\n    };\n  }\n\n  /**\n   * Computes the corner of the anchor from which to animate and position the menu.\n   * @return {Corner}\n   * @private\n   */\n  getOriginCorner_() {\n    // Defaults: open from the top left.\n    let corner = Corner.TOP_LEFT;\n\n    const {viewportDistance, anchorHeight, anchorWidth, menuHeight, menuWidth} = this.measures_;\n    const isBottomAligned = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);\n    const availableTop = isBottomAligned ? viewportDistance.top + anchorHeight + this.anchorMargin_.bottom\n      : viewportDistance.top + this.anchorMargin_.top;\n    const availableBottom = isBottomAligned ? viewportDistance.bottom - this.anchorMargin_.bottom\n      : viewportDistance.bottom + anchorHeight - this.anchorMargin_.top;\n\n    const topOverflow = menuHeight - availableTop;\n    const bottomOverflow = menuHeight - availableBottom;\n    if (bottomOverflow > 0 && topOverflow < bottomOverflow) {\n      corner |= CornerBit.BOTTOM;\n    }\n\n    const isRtl = this.adapter_.isRtl();\n    const isFlipRtl = Boolean(this.anchorCorner_ & CornerBit.FLIP_RTL);\n    const avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);\n    const isAlignedRight = (avoidHorizontalOverlap && !isRtl) ||\n      (!avoidHorizontalOverlap && isFlipRtl && isRtl);\n    const availableLeft = isAlignedRight ? viewportDistance.left + anchorWidth + this.anchorMargin_.right :\n      viewportDistance.left + this.anchorMargin_.left;\n    const availableRight = isAlignedRight ? viewportDistance.right - this.anchorMargin_.right :\n      viewportDistance.right + anchorWidth - this.anchorMargin_.left;\n\n    const leftOverflow = menuWidth - availableLeft;\n    const rightOverflow = menuWidth - availableRight;\n\n    if ((leftOverflow < 0 && isAlignedRight && isRtl) ||\n        (avoidHorizontalOverlap && !isAlignedRight && leftOverflow < 0) ||\n        (rightOverflow > 0 && leftOverflow < rightOverflow)) {\n      corner |= CornerBit.RIGHT;\n    }\n\n    return corner;\n  }\n\n  /**\n   * @param {Corner} corner Origin corner of the menu.\n   * @return {number} Horizontal offset of menu origin corner from corresponding anchor corner.\n   * @private\n   */\n  getHorizontalOriginOffset_(corner) {\n    const {anchorWidth} = this.measures_;\n    const isRightAligned = Boolean(corner & CornerBit.RIGHT);\n    const avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);\n    let x = 0;\n    if (isRightAligned) {\n      const rightOffset = avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.left : this.anchorMargin_.right;\n      x = rightOffset;\n    } else {\n      const leftOffset = avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.right : this.anchorMargin_.left;\n      x = leftOffset;\n    }\n    return x;\n  }\n\n  /**\n   * @param {Corner} corner Origin corner of the menu.\n   * @return {number} Vertical offset of menu origin corner from corresponding anchor corner.\n   * @private\n   */\n  getVerticalOriginOffset_(corner) {\n    const {viewport, viewportDistance, anchorHeight, menuHeight} = this.measures_;\n    const isBottomAligned = Boolean(corner & CornerBit.BOTTOM);\n    const {MARGIN_TO_EDGE} = MDCMenuFoundation.numbers;\n    const avoidVerticalOverlap = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);\n    const canOverlapVertically = !avoidVerticalOverlap;\n    let y = 0;\n\n    if (isBottomAligned) {\n      y = avoidVerticalOverlap ? anchorHeight - this.anchorMargin_.top : -this.anchorMargin_.bottom;\n      // adjust for when menu can overlap anchor, but too tall to be aligned to bottom\n      // anchor corner. Bottom margin is ignored in such cases.\n      if (canOverlapVertically && menuHeight > viewportDistance.top + anchorHeight) {\n        y = -(Math.min(menuHeight, viewport.height - MARGIN_TO_EDGE) - (viewportDistance.top + anchorHeight));\n      }\n    } else {\n      y = avoidVerticalOverlap ? (anchorHeight + this.anchorMargin_.bottom) : this.anchorMargin_.top;\n      // adjust for when menu can overlap anchor, but too tall to be aligned to top\n      // anchor corners. Top margin is ignored in that case.\n      if (canOverlapVertically && menuHeight > viewportDistance.bottom + anchorHeight) {\n        y = -(Math.min(menuHeight, viewport.height - MARGIN_TO_EDGE) - (viewportDistance.bottom + anchorHeight));\n      }\n    }\n    return y;\n  }\n\n  /**\n   * @param {Corner} corner Origin corner of the menu.\n   * @return {number} Maximum height of the menu, based on available space. 0 indicates should not be set.\n   * @private\n   */\n  getMenuMaxHeight_(corner) {\n    let maxHeight = 0;\n    const {viewportDistance} = this.measures_;\n    const isBottomAligned = Boolean(corner & CornerBit.BOTTOM);\n\n    // When maximum height is not specified, it is handled from css.\n    if (this.anchorCorner_ & CornerBit.BOTTOM) {\n      if (isBottomAligned) {\n        maxHeight = viewportDistance.top + this.anchorMargin_.top;\n      } else {\n        maxHeight = viewportDistance.bottom - this.anchorMargin_.bottom;\n      }\n    }\n\n    return maxHeight;\n  }\n\n  /** @private */\n  autoPosition_() {\n    if (!this.adapter_.hasAnchor()) {\n      return;\n    }\n\n    // Compute measurements for autoposition methods reuse.\n    this.measures_ = this.getAutoLayoutMeasurements_();\n\n    const corner = this.getOriginCorner_();\n    const maxMenuHeight = this.getMenuMaxHeight_(corner);\n    let verticalAlignment = (corner & CornerBit.BOTTOM) ? 'bottom' : 'top';\n    let horizontalAlignment = (corner & CornerBit.RIGHT) ? 'right' : 'left';\n    const horizontalOffset = this.getHorizontalOriginOffset_(corner);\n    const verticalOffset = this.getVerticalOriginOffset_(corner);\n    const position = {\n      [horizontalAlignment]: horizontalOffset ? horizontalOffset + 'px' : '0',\n      [verticalAlignment]: verticalOffset ? verticalOffset + 'px' : '0',\n    };\n    const {anchorWidth, menuHeight, menuWidth} = this.measures_;\n    // Center align when anchor width is comparable or greater than menu, otherwise keep corner.\n    if (anchorWidth / menuWidth > numbers.ANCHOR_TO_MENU_WIDTH_RATIO) {\n      horizontalAlignment = 'center';\n    }\n\n    // Adjust vertical origin when menu is positioned with significant offset from anchor. This is done so that\n    // scale animation is \"anchored\" on the anchor.\n    if (!(this.anchorCorner_ & CornerBit.BOTTOM) &&\n        Math.abs(verticalOffset / menuHeight) > numbers.OFFSET_TO_MENU_HEIGHT_RATIO) {\n      const verticalOffsetPercent = Math.abs(verticalOffset / menuHeight) * 100;\n      const originPercent = (corner & CornerBit.BOTTOM) ? 100 - verticalOffsetPercent : verticalOffsetPercent;\n      verticalAlignment = Math.round(originPercent * 100) / 100 + '%';\n    }\n\n    this.adapter_.setTransformOrigin(`${horizontalAlignment} ${verticalAlignment}`);\n    this.adapter_.setPosition(position);\n    this.adapter_.setMaxHeight(maxMenuHeight ? maxMenuHeight + 'px' : '');\n\n    // Clear measures after positioning is complete.\n    this.measures_ = null;\n  }\n\n  /**\n   * Open the menu.\n   * @param {{focusIndex: ?number}=} options\n   */\n  open({focusIndex = null} = {}) {\n    this.adapter_.saveFocus();\n\n    if (!this.quickOpen_) {\n      this.adapter_.addClass(MDCMenuFoundation.cssClasses.ANIMATING_OPEN);\n    }\n\n    this.animationRequestId_ = requestAnimationFrame(() => {\n      this.dimensions_ = this.adapter_.getInnerDimensions();\n      this.autoPosition_();\n      this.adapter_.addClass(MDCMenuFoundation.cssClasses.OPEN);\n      this.focusOnOpen_(focusIndex);\n      this.adapter_.registerBodyClickHandler(this.documentClickHandler_);\n      if (!this.quickOpen_) {\n        this.openAnimationEndTimerId_ = setTimeout(() => {\n          this.openAnimationEndTimerId_ = 0;\n          this.adapter_.removeClass(MDCMenuFoundation.cssClasses.ANIMATING_OPEN);\n        }, numbers.TRANSITION_OPEN_DURATION);\n      }\n    });\n    this.isOpen_ = true;\n  }\n\n  /**\n   * Closes the menu.\n   * @param {Event=} evt\n   */\n  close(evt = null) {\n    const targetIsDisabled = evt ?\n      this.adapter_.getAttributeForEventTarget(evt.target, strings.ARIA_DISABLED_ATTR) === 'true' :\n      false;\n\n    if (targetIsDisabled) {\n      return;\n    }\n\n    this.adapter_.deregisterBodyClickHandler(this.documentClickHandler_);\n\n    if (!this.quickOpen_) {\n      this.adapter_.addClass(MDCMenuFoundation.cssClasses.ANIMATING_CLOSED);\n    }\n\n    requestAnimationFrame(() => {\n      this.adapter_.removeClass(MDCMenuFoundation.cssClasses.OPEN);\n      if (!this.quickOpen_) {\n        this.closeAnimationEndTimerId_ = setTimeout(() => {\n          this.closeAnimationEndTimerId_ = 0;\n          this.adapter_.removeClass(MDCMenuFoundation.cssClasses.ANIMATING_CLOSED);\n        }, numbers.TRANSITION_CLOSE_DURATION);\n      }\n    });\n    this.isOpen_ = false;\n    this.adapter_.restoreFocus();\n  }\n\n  /** @return {boolean} */\n  isOpen() {\n    return this.isOpen_;\n  }\n\n  /** @return {number} */\n  getSelectedIndex() {\n    return this.selectedIndex_;\n  }\n\n  /**\n   * @param {number} index Index of the item to set as selected.\n   */\n  setSelectedIndex(index) {\n    if (index === this.selectedIndex_) {\n      return;\n    }\n\n    const prevSelectedIndex = this.selectedIndex_;\n    if (prevSelectedIndex >= 0) {\n      this.adapter_.rmAttrForOptionAtIndex(prevSelectedIndex, 'aria-selected');\n      this.adapter_.rmClassForOptionAtIndex(prevSelectedIndex, cssClasses.SELECTED_LIST_ITEM);\n    }\n\n    this.selectedIndex_ = index >= 0 && index < this.adapter_.getNumberOfItems() ? index : -1;\n    if (this.selectedIndex_ >= 0) {\n      this.adapter_.setAttrForOptionAtIndex(this.selectedIndex_, 'aria-selected', 'true');\n      this.adapter_.addClassForOptionAtIndex(this.selectedIndex_, cssClasses.SELECTED_LIST_ITEM);\n    }\n  }\n}\n\nexport {MDCMenuFoundation, AnchorMargin};\n","/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @type {string|undefined} */\nlet storedTransformPropertyName_;\n\n/**\n * Returns the name of the correct transform property to use on the current browser.\n * @param {!Window} globalObj\n * @param {boolean=} forceRefresh\n * @return {string}\n */\nfunction getTransformPropertyName(globalObj, forceRefresh = false) {\n  if (storedTransformPropertyName_ === undefined || forceRefresh) {\n    const el = globalObj.document.createElement('div');\n    const transformPropertyName = ('transform' in el.style ? 'transform' : 'webkitTransform');\n    storedTransformPropertyName_ = transformPropertyName;\n  }\n\n  return storedTransformPropertyName_;\n}\n\n/**\n * Clamps a value between the minimum and the maximum, returning the clamped value.\n * @param {number} value\n * @param {number} min\n * @param {number} max\n * @return {number}\n */\nfunction clamp(value, min = 0, max = 1) {\n  return Math.min(max, Math.max(min, value));\n}\n\n\n/**\n * Returns the easing value to apply at time t, for a given cubic bezier curve.\n * Control points P0 and P3 are assumed to be (0,0) and (1,1), respectively.\n * Parameters are as follows:\n * - time: The current time in the animation, scaled between 0 and 1.\n * - x1: The x value of control point P1.\n * - y1: The y value of control point P1.\n * - x2: The x value of control point P2.\n * - y2: The y value of control point P2.\n * @param {number} time\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @return {number}\n */\nfunction bezierProgress(time, x1, y1, x2, y2) {\n  return getBezierCoordinate_(solvePositionFromXValue_(time, x1, x2), y1, y2);\n}\n\n/**\n * Compute a single coordinate at a position point between 0 and 1.\n * c1 and c2 are the matching coordinate on control points P1 and P2, respectively.\n * Control points P0 and P3 are assumed to be (0,0) and (1,1), respectively.\n * Adapted from https://github.com/google/closure-library/blob/master/closure/goog/math/bezier.js.\n * @param {number} t\n * @param {number} c1\n * @param {number} c2\n * @return {number}\n */\nfunction getBezierCoordinate_(t, c1, c2) {\n  // Special case start and end.\n  if (t === 0 || t === 1) {\n    return t;\n  }\n\n  // Step one - from 4 points to 3\n  let ic0 = t * c1;\n  let ic1 = c1 + t * (c2 - c1);\n  const ic2 = c2 + t * (1 - c2);\n\n  // Step two - from 3 points to 2\n  ic0 += t * (ic1 - ic0);\n  ic1 += t * (ic2 - ic1);\n\n  // Final step - last point\n  return ic0 + t * (ic1 - ic0);\n}\n\n/**\n * Project a point onto the Bezier curve, from a given X. Calculates the position t along the curve.\n * Adapted from https://github.com/google/closure-library/blob/master/closure/goog/math/bezier.js.\n * @param {number} xVal\n * @param {number} x1\n * @param {number} x2\n * @return {number}\n */\nfunction solvePositionFromXValue_(xVal, x1, x2) {\n  const EPSILON = 1e-6;\n  const MAX_ITERATIONS = 8;\n\n  if (xVal <= 0) {\n    return 0;\n  } else if (xVal >= 1) {\n    return 1;\n  }\n\n  // Initial estimate of t using linear interpolation.\n  let t = xVal;\n\n  // Try gradient descent to solve for t. If it works, it is very fast.\n  let tMin = 0;\n  let tMax = 1;\n  let value = 0;\n  for (let i = 0; i < MAX_ITERATIONS; i++) {\n    value = getBezierCoordinate_(t, x1, x2);\n    const derivative = (getBezierCoordinate_(t + EPSILON, x1, x2) - value) / EPSILON;\n    if (Math.abs(value - xVal) < EPSILON) {\n      return t;\n    } else if (Math.abs(derivative) < EPSILON) {\n      break;\n    } else {\n      if (value < xVal) {\n        tMin = t;\n      } else {\n        tMax = t;\n      }\n      t -= (value - xVal) / derivative;\n    }\n  }\n\n  // If the gradient descent got stuck in a local minimum, e.g. because\n  // the derivative was close to 0, use a Dichotomy refinement instead.\n  // We limit the number of interations to 8.\n  for (let i = 0; Math.abs(value - xVal) > EPSILON && i < MAX_ITERATIONS; i++) {\n    if (value < xVal) {\n      tMin = t;\n      t = (t + tMax) / 2;\n    } else {\n      tMax = t;\n      t = (t + tMin) / 2;\n    }\n    value = getBezierCoordinate_(t, x1, x2);\n  }\n  return t;\n}\n\nexport {getTransformPropertyName, clamp, bezierProgress};\n","export function BasePlugin(components) {\n  return {\n    version: '__VERSION__',\n    install: vm => {\n      for (let key in components) {\n        let component = components[key]\n        vm.component(component.name, component)\n      }\n    },\n    components\n  }\n}\n","export function autoInit(plugin) {\n  // Auto-install\n  let _Vue = null\n  if (typeof window !== 'undefined') {\n    _Vue = window.Vue\n  } else if (typeof global !== 'undefined') {\n    /*global global*/\n    _Vue = global.Vue\n  }\n  if (_Vue) {\n    _Vue.use(plugin)\n  }\n}\n","import './styles.scss'\nimport { autoInit } from '../base'\nimport plugin from './index.js'\nexport default plugin\n\nautoInit(plugin)\n"],"names":["emitCustomEvent","el","evtType","evtData","shouldBubble","evt","CustomEvent","document","createEvent","initCustomEvent","dispatchEvent","Math","floor","random","toString","MDCFoundation","adapter","adapter_","cssClasses","className","target","attributeName","type","handler","index","origin","position","height","attr","value","strings","numbers","CornerBit","Corner","MDCMenuFoundation","babelHelpers.extends","defaultAdapter","clickHandler_","_this","handlePossibleSelected_","keydownHandler_","handleKeyboardDown_","keyupHandler_","handleKeyboardUp_","documentClickHandler_","handleDocumentClick_","isOpen_","openAnimationEndTimerId_","closeAnimationEndTimerId_","selectedTriggerTimerId_","animationRequestId_","dimensions_","itemHeight_","anchorCorner_","TOP_START","anchorMargin_","top","right","bottom","left","measures_","selectedIndex_","rememberSelection_","quickOpen_","keyDownWithinMenu_","ROOT","OPEN","this","hasClass","Error","hasNecessaryDom","registerInteractionHandler","deregisterInteractionHandler","deregisterBodyClickHandler","corner","margin","rememberSelection","setSelectedIndex","quickOpen","focusIndex","focusItemAtIndex","focus","isFocused","documentElement","getIndexForEventTarget","parentNode","notifyCancel","close","altKey","ctrlKey","metaKey","keyCode","key","shiftKey","isTab","isArrowUp","isArrowDown","isSpace","isEnter","focusedItemIndex","getFocusedItemIndex","lastItemIndex","getNumberOfItems","preventDefault","isEscape","getAttributeForEventTarget","ARIA_DISABLED_ATTR","targetIndex","setTimeout","_this2","notifySelected","SELECTED_TRIGGER_DELAY","anchorRect","getAnchorDimensions","viewport","getWindowDimensions","width","TOP_LEFT","viewportDistance","anchorHeight","anchorWidth","menuHeight","menuWidth","isBottomAligned","Boolean","availableTop","bottomOverflow","isRtl","isFlipRtl","avoidHorizontalOverlap","isAlignedRight","leftOverflow","rightOverflow","isRightAligned","x","MARGIN_TO_EDGE","avoidVerticalOverlap","canOverlapVertically","y","min","maxHeight","hasAnchor","getAutoLayoutMeasurements_","getOriginCorner_","maxMenuHeight","getMenuMaxHeight_","verticalAlignment","horizontalAlignment","horizontalOffset","getHorizontalOriginOffset_","verticalOffset","getVerticalOriginOffset_","ANCHOR_TO_MENU_WIDTH_RATIO","abs","OFFSET_TO_MENU_HEIGHT_RATIO","verticalOffsetPercent","originPercent","round","setTransformOrigin","setPosition","setMaxHeight","saveFocus","addClass","ANIMATING_OPEN","requestAnimationFrame","_this3","getInnerDimensions","autoPosition_","focusOnOpen_","registerBodyClickHandler","removeClass","TRANSITION_OPEN_DURATION","ANIMATING_CLOSED","_this4","TRANSITION_CLOSE_DURATION","restoreFocus","prevSelectedIndex","rmAttrForOptionAtIndex","rmClassForOptionAtIndex","SELECTED_LIST_ITEM","setAttrForOptionAtIndex","addClassForOptionAtIndex","storedTransformPropertyName_","globalObj","forceRefresh","undefined","transformPropertyName","createElement","style","components","component","name","plugin","_Vue","window","Vue","global","use"],"mappings":"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"}