/**
* @module vue-mdc-adapter 0.18.2
* @exports VueMDCAdapter
* @copyright (c) 2017-present, Sebastien Tasson
* @license https://opensource.org/licenses/MIT
* @implements {"@material/tabs":"0.38.0","material-components-web":"0.38.2"}
* @requires {"vue":"^2.5.6"}
* @see https://github.com/stasson/vue-mdc-adapter
*/

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.VueMDCAdapter = factory());
}(this, (function () { 'use strict';

  var supportsPassive_ = void 0;

  /**
   * Determine whether the current browser supports passive event listeners, and if so, use them.
   * @param {!Window=} globalObj
   * @param {boolean=} forceRefresh
   * @return {boolean|{passive: boolean}}
   */
  function applyPassive() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (supportsPassive_ === undefined || forceRefresh) {
      var isSupported = false;
      try {
        globalObj.document.addEventListener('test', null, {
          get passive() {
            isSupported = { passive: true };
          }
        });
      } catch (e) {
        //empty
      }

      supportsPassive_ = isSupported;
    }

    return supportsPassive_;
  }

  function autoInit(plugin) {
    // Auto-install
    var _Vue = null;
    if (typeof window !== 'undefined') {
      _Vue = window.Vue;
    } else if (typeof global !== 'undefined') {
      /*global global*/
      _Vue = global.Vue;
    }
    if (_Vue) {
      _Vue.use(plugin);
    }
  }

  function BasePlugin(components) {
    return {
      version: '0.18.2',
      install: function install(vm) {
        for (var key in components) {
          var component = components[key];
          vm.component(component.name, component);
        }
      },
      components: components
    };
  }

  var CustomElement = {
    functional: true,
    render: function render(createElement, context) {
      return createElement(context.props.is || context.props.tag || 'div', context.data, context.children);
    }
  };

  var CustomElementMixin = {
    components: {
      CustomElement: CustomElement
    }
  };

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  var inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  var possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  var toConsumableArray = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    } else {
      return Array.from(arr);
    }
  };

  var CustomLink = {
    name: 'custom-link',
    functional: true,
    props: {
      tag: { type: String, default: 'a' },
      link: Object
    },
    render: function render(h, context) {
      var element = void 0;
      var data = _extends({}, context.data);

      if (context.props.link && context.parent.$router) {
        // router-link case
        element = context.parent.$root.$options.components['router-link'];
        data.props = _extends({ tag: context.props.tag }, context.props.link);
        if (data.on.click) {
          data.nativeOn = { click: data.on.click };
        }
      } else {
        // element fallback
        element = context.props.tag;
      }

      return h(element, data, context.children);
    }
  };

  var CustomLinkMixin = {
    props: {
      to: [String, Object],
      exact: Boolean,
      append: Boolean,
      replace: Boolean,
      activeClass: String,
      exactActiveClass: String
    },
    computed: {
      link: function link() {
        return this.to && {
          to: this.to,
          exact: this.exact,
          append: this.append,
          replace: this.replace,
          activeClass: this.activeClass,
          exactActiveClass: this.exactActiveClass
        };
      }
    },
    components: {
      CustomLink: CustomLink
    }
  };

  /* global CustomEvent */

  function emitCustomEvent(el, evtType, evtData) {
    var shouldBubble = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var evt = void 0;
    if (typeof CustomEvent === 'function') {
      evt = new CustomEvent(evtType, {
        detail: evtData,
        bubbles: shouldBubble
      });
    } else {
      evt = document.createEvent('CustomEvent');
      evt.initCustomEvent(evtType, shouldBubble, false, evtData);
    }
    el.dispatchEvent(evt);
  }

  var CustomButton = {
    name: 'custom-button',
    functional: true,
    props: {
      link: Object
    },
    render: function render(h, context) {
      var element = void 0;
      var data = _extends({}, context.data);

      if (context.props.link && context.parent.$router) {
        // router-link case
        element = context.parent.$root.$options.components['router-link'];
        data.props = _extends({ tag: context.props.tag }, context.props.link);
        data.attrs.role = 'button';
        if (data.on.click) {
          data.nativeOn = { click: data.on.click };
        }
      } else if (data.attrs && data.attrs.href) {
        // href case
        element = 'a';
        data.attrs.role = 'button';
      } else {
        // button fallback
        element = 'button';
      }

      return h(element, data, context.children);
    }
  };

  var CustomButtonMixin = {
    props: {
      href: String,
      disabled: Boolean,
      to: [String, Object],
      exact: Boolean,
      append: Boolean,
      replace: Boolean,
      activeClass: String,
      exactActiveClass: String
    },
    computed: {
      link: function link() {
        return this.to && {
          to: this.to,
          exact: this.exact,
          append: this.append,
          replace: this.replace,
          activeClass: this.activeClass,
          exactActiveClass: this.exactActiveClass
        };
      }
    },
    components: {
      CustomButton: CustomButton
    }
  };

  function extractIconProp(iconProp) {
    if (typeof iconProp === 'string') {
      return {
        classes: { 'material-icons': true },
        content: iconProp
      };
    } else if (iconProp instanceof Array) {
      return {
        classes: iconProp.reduce(function (result, value) {
          return _extends(result, defineProperty({}, value, true));
        }, {})
      };
    } else if ((typeof iconProp === 'undefined' ? 'undefined' : _typeof(iconProp)) === 'object') {
      return {
        classes: iconProp.className.split(' ').reduce(function (result, value) {
          return _extends(result, defineProperty({}, value, true));
        }, {}),
        content: iconProp.textContent
      };
    }
  }

  var DispatchEventMixin = {
    props: {
      event: String,
      'event-target': Object,
      'event-args': Array
    },
    methods: {
      dispatchEvent: function dispatchEvent(evt) {
        evt && this.$emit(evt.type, evt);
        if (this.event) {
          var target = this.eventTarget || this.$root;
          var args = this.eventArgs || [];
          target.$emit.apply(target, [this.event].concat(toConsumableArray(args)));
        }
      }
    },
    computed: {
      listeners: function listeners() {
        var _this = this;

        return _extends({}, this.$listeners, {
          click: function click(e) {
            return _this.dispatchEvent(e);
          }
        });
      }
    }
  };

  var DispatchFocusMixin = {
    data: function data() {
      return { hasFocus: false };
    },

    methods: {
      onMouseDown: function onMouseDown() {
        this._active = true;
      },
      onMouseUp: function onMouseUp() {
        this._active = false;
      },
      onFocusEvent: function onFocusEvent() {
        var _this = this;

        // dispatch async to let time to other focus event to propagate
        setTimeout(function () {
          return _this.dispatchFocusEvent();
        }, 0);
      },
      onBlurEvent: function onBlurEvent() {
        var _this2 = this;

        // dispatch async to let time to other focus event to propagate
        // also filtur blur if mousedown
        this._active || setTimeout(function () {
          return _this2.dispatchFocusEvent();
        }, 0);
      },
      dispatchFocusEvent: function dispatchFocusEvent() {
        var hasFocus = this.$el === document.activeElement || this.$el.contains(document.activeElement);
        if (hasFocus != this.hasFocus) {
          this.$emit(hasFocus ? 'focus' : 'blur');
          this.hasFocus = hasFocus;
        }
      }
    },
    mounted: function mounted() {
      this.$el.addEventListener('focusin', this.onFocusEvent);
      this.$el.addEventListener('focusout', this.onBlurEvent);
      this.$el.addEventListener('mousedown', this.onMouseDown);
      this.$el.addEventListener('mouseup', this.onMouseUp);
    },
    beforeDestroy: function beforeDestroy() {
      this.$el.removeEventListener('focusin', this.onFocusEvent);
      this.$el.removeEventListener('focusout', this.onBlurEvent);
      this.$el.removeEventListener('mousedown', this.onMouseDown);
      this.$el.removeEventListener('mouseup', this.onMouseUp);
    }
  };

  var scope = Math.floor(Math.random() * Math.floor(0x10000000)).toString() + '-';

  var VMAUniqueIdMixin = {
    beforeCreate: function beforeCreate() {
      this.vma_uid_ = scope + this._uid;
    }
  };

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @template A
   */
  var MDCFoundation = function () {
    createClass(MDCFoundation, null, [{
      key: "cssClasses",

      /** @return enum{cssClasses} */
      get: function get$$1() {
        // Classes extending MDCFoundation should implement this method to return an object which exports every
        // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
        return {};
      }

      /** @return enum{strings} */

    }, {
      key: "strings",
      get: function get$$1() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
        return {};
      }

      /** @return enum{numbers} */

    }, {
      key: "numbers",
      get: function get$$1() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
        return {};
      }

      /** @return {!Object} */

    }, {
      key: "defaultAdapter",
      get: function get$$1() {
        // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
        // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
        // validation.
        return {};
      }

      /**
       * @param {A=} adapter
       */

    }]);

    function MDCFoundation() {
      var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      classCallCheck(this, MDCFoundation);

      /** @protected {!A} */
      this.adapter_ = adapter;
    }

    createClass(MDCFoundation, [{
      key: "init",
      value: function init() {
        // Subclasses should override this method to perform initialization routines (registering events, etc.)
      }
    }, {
      key: "destroy",
      value: function destroy() {
        // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
      }
    }]);
    return MDCFoundation;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Ripple. Provides an interface for managing
   * - classes
   * - dom
   * - CSS variables
   * - position
   * - dimensions
   * - scroll position
   * - event handlers
   * - unbounded, active and disabled states
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCRippleAdapter = function () {
    function MDCRippleAdapter() {
      classCallCheck(this, MDCRippleAdapter);
    }

    createClass(MDCRippleAdapter, [{
      key: "browserSupportsCssVars",

      /** @return {boolean} */
      value: function browserSupportsCssVars() {}

      /** @return {boolean} */

    }, {
      key: "isUnbounded",
      value: function isUnbounded() {}

      /** @return {boolean} */

    }, {
      key: "isSurfaceActive",
      value: function isSurfaceActive() {}

      /** @return {boolean} */

    }, {
      key: "isSurfaceDisabled",
      value: function isSurfaceDisabled() {}

      /** @param {string} className */

    }, {
      key: "addClass",
      value: function addClass(className) {}

      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /** @param {!EventTarget} target */

    }, {
      key: "containsEventTarget",
      value: function containsEventTarget(target) {}

      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(evtType, handler) {}

      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(evtType, handler) {}

      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "registerDocumentInteractionHandler",
      value: function registerDocumentInteractionHandler(evtType, handler) {}

      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "deregisterDocumentInteractionHandler",
      value: function deregisterDocumentInteractionHandler(evtType, handler) {}

      /**
       * @param {!Function} handler
       */

    }, {
      key: "registerResizeHandler",
      value: function registerResizeHandler(handler) {}

      /**
       * @param {!Function} handler
       */

    }, {
      key: "deregisterResizeHandler",
      value: function deregisterResizeHandler(handler) {}

      /**
       * @param {string} varName
       * @param {?number|string} value
       */

    }, {
      key: "updateCssVariable",
      value: function updateCssVariable(varName, value) {}

      /** @return {!ClientRect} */

    }, {
      key: "computeBoundingRect",
      value: function computeBoundingRect() {}

      /** @return {{x: number, y: number}} */

    }, {
      key: "getWindowPageOffset",
      value: function getWindowPageOffset() {}
    }]);
    return MDCRippleAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses = {
    // Ripple is a special case where the "root" component is really a "mixin" of sorts,
    // given that it's an 'upgrade' to an existing component. That being said it is the root
    // CSS class that all other CSS classes derive from.
    ROOT: 'mdc-ripple-upgraded',
    UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
    BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
    FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
    FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
  };

  var strings = {
    VAR_LEFT: '--mdc-ripple-left',
    VAR_TOP: '--mdc-ripple-top',
    VAR_FG_SIZE: '--mdc-ripple-fg-size',
    VAR_FG_SCALE: '--mdc-ripple-fg-scale',
    VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
    VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
  };

  var numbers = {
    PADDING: 10,
    INITIAL_ORIGIN_SCALE: 0.6,
    DEACTIVATION_TIMEOUT_MS: 225, // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
    FG_DEACTIVATION_MS: 150, // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
    TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
   * @private {boolean|undefined}
   */
  var supportsCssVariables_ = void 0;

  /**
   * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
   * @private {boolean|undefined}
   */
  var supportsPassive_$1 = void 0;

  /**
   * @param {!Window} windowObj
   * @return {boolean}
   */
  function detectEdgePseudoVarBug(windowObj) {
    // Detect versions of Edge with buggy var() support
    // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
    var document = windowObj.document;
    var node = document.createElement('div');
    node.className = 'mdc-ripple-surface--test-edge-var-bug';
    document.body.appendChild(node);

    // The bug exists if ::before style ends up propagating to the parent element.
    // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
    // but Firefox is known to support CSS custom properties correctly.
    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397
    var computedStyle = windowObj.getComputedStyle(node);
    var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
    node.remove();
    return hasPseudoVarBug;
  }

  /**
   * @param {!Window} windowObj
   * @param {boolean=} forceRefresh
   * @return {boolean|undefined}
   */

  function supportsCssVariables(windowObj) {
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var supportsCssVariables = supportsCssVariables_;
    if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {
      return supportsCssVariables;
    }

    var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';
    if (!supportsFunctionPresent) {
      return;
    }

    var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes');
    // See: https://bugs.webkit.org/show_bug.cgi?id=154669
    // See: README section on Safari
    var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

    if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
      supportsCssVariables = !detectEdgePseudoVarBug(windowObj);
    } else {
      supportsCssVariables = false;
    }

    if (!forceRefresh) {
      supportsCssVariables_ = supportsCssVariables;
    }
    return supportsCssVariables;
  }

  //
  /**
   * Determine whether the current browser supports passive event listeners, and if so, use them.
   * @param {!Window=} globalObj
   * @param {boolean=} forceRefresh
   * @return {boolean|{passive: boolean}}
   */
  function applyPassive$1() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (supportsPassive_$1 === undefined || forceRefresh) {
      var isSupported = false;
      try {
        globalObj.document.addEventListener('test', null, { get passive() {
            isSupported = true;
          } });
      } catch (e) {}

      supportsPassive_$1 = isSupported;
    }

    return supportsPassive_$1 ? { passive: true } : false;
  }

  /**
   * @param {!Object} HTMLElementPrototype
   * @return {!Array<string>}
   */
  function getMatchesProperty(HTMLElementPrototype) {
    return ['webkitMatchesSelector', 'msMatchesSelector', 'matches'].filter(function (p) {
      return p in HTMLElementPrototype;
    }).pop();
  }

  /**
   * @param {!Event} ev
   * @param {{x: number, y: number}} pageOffset
   * @param {!ClientRect} clientRect
   * @return {{x: number, y: number}}
   */
  function getNormalizedEventCoords(ev, pageOffset, clientRect) {
    var x = pageOffset.x,
        y = pageOffset.y;

    var documentX = x + clientRect.left;
    var documentY = y + clientRect.top;

    var normalizedX = void 0;
    var normalizedY = void 0;
    // Determine touch point relative to the ripple container.
    if (ev.type === 'touchstart') {
      normalizedX = ev.changedTouches[0].pageX - documentX;
      normalizedY = ev.changedTouches[0].pageY - documentY;
    } else {
      normalizedX = ev.pageX - documentX;
      normalizedY = ev.pageY - documentY;
    }

    return { x: normalizedX, y: normalizedY };
  }

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  // Activation events registered on the root element of each instance for activation
  var ACTIVATION_EVENT_TYPES = ['touchstart', 'pointerdown', 'mousedown', 'keydown'];

  // Deactivation events registered on documentElement when a pointer-related down event occurs
  var POINTER_DEACTIVATION_EVENT_TYPES = ['touchend', 'pointerup', 'mouseup'];

  // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations
  /** @type {!Array<!EventTarget>} */
  var activatedTargets = [];

  /**
   * @extends {MDCFoundation<!MDCRippleAdapter>}
   */

  var MDCRippleFoundation = function (_MDCFoundation) {
    inherits(MDCRippleFoundation, _MDCFoundation);
    createClass(MDCRippleFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings;
      }
    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          browserSupportsCssVars: function browserSupportsCssVars() /* boolean - cached */{},
          isUnbounded: function isUnbounded() /* boolean */{},
          isSurfaceActive: function isSurfaceActive() /* boolean */{},
          isSurfaceDisabled: function isSurfaceDisabled() /* boolean */{},
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          containsEventTarget: function containsEventTarget() /* target: !EventTarget */{},
          registerInteractionHandler: function registerInteractionHandler() /* evtType: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* evtType: string, handler: EventListener */{},
          registerDocumentInteractionHandler: function registerDocumentInteractionHandler() /* evtType: string, handler: EventListener */{},
          deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler() /* evtType: string, handler: EventListener */{},
          registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
          deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
          updateCssVariable: function updateCssVariable() /* varName: string, value: string */{},
          computeBoundingRect: function computeBoundingRect() /* ClientRect */{},
          getWindowPageOffset: function getWindowPageOffset() /* {x: number, y: number} */{}
        };
      }
    }]);

    function MDCRippleFoundation(adapter) {
      classCallCheck(this, MDCRippleFoundation);

      /** @private {number} */
      var _this = possibleConstructorReturn(this, (MDCRippleFoundation.__proto__ || Object.getPrototypeOf(MDCRippleFoundation)).call(this, _extends(MDCRippleFoundation.defaultAdapter, adapter)));

      _this.layoutFrame_ = 0;

      /** @private {!ClientRect} */
      _this.frame_ = /** @type {!ClientRect} */{ width: 0, height: 0 };

      /** @private {!ActivationStateType} */
      _this.activationState_ = _this.defaultActivationState_();

      /** @private {number} */
      _this.initialSize_ = 0;

      /** @private {number} */
      _this.maxRadius_ = 0;

      /** @private {function(!Event)} */
      _this.activateHandler_ = function (e) {
        return _this.activate_(e);
      };

      /** @private {function(!Event)} */
      _this.deactivateHandler_ = function (e) {
        return _this.deactivate_(e);
      };

      /** @private {function(?Event=)} */
      _this.focusHandler_ = function () {
        return _this.handleFocus();
      };

      /** @private {function(?Event=)} */
      _this.blurHandler_ = function () {
        return _this.handleBlur();
      };

      /** @private {!Function} */
      _this.resizeHandler_ = function () {
        return _this.layout();
      };

      /** @private {{left: number, top:number}} */
      _this.unboundedCoords_ = {
        left: 0,
        top: 0
      };

      /** @private {number} */
      _this.fgScale_ = 0;

      /** @private {number} */
      _this.activationTimer_ = 0;

      /** @private {number} */
      _this.fgDeactivationRemovalTimer_ = 0;

      /** @private {boolean} */
      _this.activationAnimationHasEnded_ = false;

      /** @private {!Function} */
      _this.activationTimerCallback_ = function () {
        _this.activationAnimationHasEnded_ = true;
        _this.runDeactivationUXLogicIfReady_();
      };

      /** @private {?Event} */
      _this.previousActivationEvent_ = null;
      return _this;
    }

    /**
     * We compute this property so that we are not querying information about the client
     * until the point in time where the foundation requests it. This prevents scenarios where
     * client-side feature-detection may happen too early, such as when components are rendered on the server
     * and then initialized at mount time on the client.
     * @return {boolean}
     * @private
     */


    createClass(MDCRippleFoundation, [{
      key: 'isSupported_',
      value: function isSupported_() {
        return this.adapter_.browserSupportsCssVars();
      }

      /**
       * @return {!ActivationStateType}
       */

    }, {
      key: 'defaultActivationState_',
      value: function defaultActivationState_() {
        return {
          isActivated: false,
          hasDeactivationUXRun: false,
          wasActivatedByPointer: false,
          wasElementMadeActive: false,
          activationEvent: null,
          isProgrammatic: false
        };
      }

      /** @override */

    }, {
      key: 'init',
      value: function init() {
        var _this2 = this;

        if (!this.isSupported_()) {
          return;
        }
        this.registerRootHandlers_();

        var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
            ROOT = _MDCRippleFoundation$.ROOT,
            UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;

        requestAnimationFrame(function () {
          _this2.adapter_.addClass(ROOT);
          if (_this2.adapter_.isUnbounded()) {
            _this2.adapter_.addClass(UNBOUNDED);
            // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple
            _this2.layoutInternal_();
          }
        });
      }

      /** @override */

    }, {
      key: 'destroy',
      value: function destroy() {
        var _this3 = this;

        if (!this.isSupported_()) {
          return;
        }

        if (this.activationTimer_) {
          clearTimeout(this.activationTimer_);
          this.activationTimer_ = 0;
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;

          this.adapter_.removeClass(FG_ACTIVATION);
        }

        this.deregisterRootHandlers_();
        this.deregisterDeactivationHandlers_();

        var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
            ROOT = _MDCRippleFoundation$2.ROOT,
            UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;

        requestAnimationFrame(function () {
          _this3.adapter_.removeClass(ROOT);
          _this3.adapter_.removeClass(UNBOUNDED);
          _this3.removeCssVars_();
        });
      }

      /** @private */

    }, {
      key: 'registerRootHandlers_',
      value: function registerRootHandlers_() {
        var _this4 = this;

        ACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
        });
        this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
        this.adapter_.registerInteractionHandler('blur', this.blurHandler_);

        if (this.adapter_.isUnbounded()) {
          this.adapter_.registerResizeHandler(this.resizeHandler_);
        }
      }

      /**
       * @param {!Event} e
       * @private
       */

    }, {
      key: 'registerDeactivationHandlers_',
      value: function registerDeactivationHandlers_(e) {
        var _this5 = this;

        if (e.type === 'keydown') {
          this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
        } else {
          POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
            _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
          });
        }
      }

      /** @private */

    }, {
      key: 'deregisterRootHandlers_',
      value: function deregisterRootHandlers_() {
        var _this6 = this;

        ACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
        });
        this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
        this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

        if (this.adapter_.isUnbounded()) {
          this.adapter_.deregisterResizeHandler(this.resizeHandler_);
        }
      }

      /** @private */

    }, {
      key: 'deregisterDeactivationHandlers_',
      value: function deregisterDeactivationHandlers_() {
        var _this7 = this;

        this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
        POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
        });
      }

      /** @private */

    }, {
      key: 'removeCssVars_',
      value: function removeCssVars_() {
        var _this8 = this;

        var strings$$1 = MDCRippleFoundation.strings;

        Object.keys(strings$$1).forEach(function (k) {
          if (k.indexOf('VAR_') === 0) {
            _this8.adapter_.updateCssVariable(strings$$1[k], null);
          }
        });
      }

      /**
       * @param {?Event} e
       * @private
       */

    }, {
      key: 'activate_',
      value: function activate_(e) {
        var _this9 = this;

        if (this.adapter_.isSurfaceDisabled()) {
          return;
        }

        var activationState = this.activationState_;
        if (activationState.isActivated) {
          return;
        }

        // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction
        var previousActivationEvent = this.previousActivationEvent_;
        var isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;
        if (isSameInteraction) {
          return;
        }

        activationState.isActivated = true;
        activationState.isProgrammatic = e === null;
        activationState.activationEvent = e;
        activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown';

        var hasActivatedChild = e && activatedTargets.length > 0 && activatedTargets.some(function (target) {
          return _this9.adapter_.containsEventTarget(target);
        });
        if (hasActivatedChild) {
          // Immediately reset activation state, while preserving logic that prevents touch follow-on events
          this.resetActivationState_();
          return;
        }

        if (e) {
          activatedTargets.push( /** @type {!EventTarget} */e.target);
          this.registerDeactivationHandlers_(e);
        }

        activationState.wasElementMadeActive = this.checkElementMadeActive_(e);
        if (activationState.wasElementMadeActive) {
          this.animateActivation_();
        }

        requestAnimationFrame(function () {
          // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
          activatedTargets = [];

          if (!activationState.wasElementMadeActive && (e.key === ' ' || e.keyCode === 32)) {
            // If space was pressed, try again within an rAF call to detect :active, because different UAs report
            // active states inconsistently when they're called within event handling code:
            // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
            // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
            // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
            // variable is set within a rAF callback for a submit button interaction (#2241).
            activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);
            if (activationState.wasElementMadeActive) {
              _this9.animateActivation_();
            }
          }

          if (!activationState.wasElementMadeActive) {
            // Reset activation state immediately if element was not made active.
            _this9.activationState_ = _this9.defaultActivationState_();
          }
        });
      }

      /**
       * @param {?Event} e
       * @private
       */

    }, {
      key: 'checkElementMadeActive_',
      value: function checkElementMadeActive_(e) {
        return e && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
      }

      /**
       * @param {?Event=} event Optional event containing position information.
       */

    }, {
      key: 'activate',
      value: function activate() {
        var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        this.activate_(event);
      }

      /** @private */

    }, {
      key: 'animateActivation_',
      value: function animateActivation_() {
        var _this10 = this;

        var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
            VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
            VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
        var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
            FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
            FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
        var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;


        this.layoutInternal_();

        var translateStart = '';
        var translateEnd = '';

        if (!this.adapter_.isUnbounded()) {
          var _getFgTranslationCoor = this.getFgTranslationCoordinates_(),
              startPoint = _getFgTranslationCoor.startPoint,
              endPoint = _getFgTranslationCoor.endPoint;

          translateStart = startPoint.x + 'px, ' + startPoint.y + 'px';
          translateEnd = endPoint.x + 'px, ' + endPoint.y + 'px';
        }

        this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
        this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
        // Cancel any ongoing activation/deactivation animations
        clearTimeout(this.activationTimer_);
        clearTimeout(this.fgDeactivationRemovalTimer_);
        this.rmBoundedActivationClasses_();
        this.adapter_.removeClass(FG_DEACTIVATION);

        // Force layout in order to re-trigger the animation.
        this.adapter_.computeBoundingRect();
        this.adapter_.addClass(FG_ACTIVATION);
        this.activationTimer_ = setTimeout(function () {
          return _this10.activationTimerCallback_();
        }, DEACTIVATION_TIMEOUT_MS);
      }

      /**
       * @private
       * @return {{startPoint: PointType, endPoint: PointType}}
       */

    }, {
      key: 'getFgTranslationCoordinates_',
      value: function getFgTranslationCoordinates_() {
        var _activationState_ = this.activationState_,
            activationEvent = _activationState_.activationEvent,
            wasActivatedByPointer = _activationState_.wasActivatedByPointer;


        var startPoint = void 0;
        if (wasActivatedByPointer) {
          startPoint = getNormalizedEventCoords(
          /** @type {!Event} */activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
        } else {
          startPoint = {
            x: this.frame_.width / 2,
            y: this.frame_.height / 2
          };
        }
        // Center the element around the start point.
        startPoint = {
          x: startPoint.x - this.initialSize_ / 2,
          y: startPoint.y - this.initialSize_ / 2
        };

        var endPoint = {
          x: this.frame_.width / 2 - this.initialSize_ / 2,
          y: this.frame_.height / 2 - this.initialSize_ / 2
        };

        return { startPoint: startPoint, endPoint: endPoint };
      }

      /** @private */

    }, {
      key: 'runDeactivationUXLogicIfReady_',
      value: function runDeactivationUXLogicIfReady_() {
        var _this11 = this;

        // This method is called both when a pointing device is released, and when the activation animation ends.
        // The deactivation animation should only run after both of those occur.
        var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
        var _activationState_2 = this.activationState_,
            hasDeactivationUXRun = _activationState_2.hasDeactivationUXRun,
            isActivated = _activationState_2.isActivated;

        var activationHasEnded = hasDeactivationUXRun || !isActivated;

        if (activationHasEnded && this.activationAnimationHasEnded_) {
          this.rmBoundedActivationClasses_();
          this.adapter_.addClass(FG_DEACTIVATION);
          this.fgDeactivationRemovalTimer_ = setTimeout(function () {
            _this11.adapter_.removeClass(FG_DEACTIVATION);
          }, numbers.FG_DEACTIVATION_MS);
        }
      }

      /** @private */

    }, {
      key: 'rmBoundedActivationClasses_',
      value: function rmBoundedActivationClasses_() {
        var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;

        this.adapter_.removeClass(FG_ACTIVATION);
        this.activationAnimationHasEnded_ = false;
        this.adapter_.computeBoundingRect();
      }
    }, {
      key: 'resetActivationState_',
      value: function resetActivationState_() {
        var _this12 = this;

        this.previousActivationEvent_ = this.activationState_.activationEvent;
        this.activationState_ = this.defaultActivationState_();
        // Touch devices may fire additional events for the same interaction within a short time.
        // Store the previous event until it's safe to assume that subsequent events are for new interactions.
        setTimeout(function () {
          return _this12.previousActivationEvent_ = null;
        }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
      }

      /**
       * @param {?Event} e
       * @private
       */

    }, {
      key: 'deactivate_',
      value: function deactivate_(e) {
        var _this13 = this;

        var activationState = this.activationState_;
        // This can happen in scenarios such as when you have a keyup event that blurs the element.
        if (!activationState.isActivated) {
          return;
        }

        var state = /** @type {!ActivationStateType} */_extends({}, activationState);

        if (activationState.isProgrammatic) {
          var evtObject = null;
          requestAnimationFrame(function () {
            return _this13.animateDeactivation_(evtObject, state);
          });
          this.resetActivationState_();
        } else {
          this.deregisterDeactivationHandlers_();
          requestAnimationFrame(function () {
            _this13.activationState_.hasDeactivationUXRun = true;
            _this13.animateDeactivation_(e, state);
            _this13.resetActivationState_();
          });
        }
      }

      /**
       * @param {?Event=} event Optional event containing position information.
       */

    }, {
      key: 'deactivate',
      value: function deactivate() {
        var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        this.deactivate_(event);
      }

      /**
       * @param {Event} e
       * @param {!ActivationStateType} options
       * @private
       */

    }, {
      key: 'animateDeactivation_',
      value: function animateDeactivation_(e, _ref) {
        var wasActivatedByPointer = _ref.wasActivatedByPointer,
            wasElementMadeActive = _ref.wasElementMadeActive;

        if (wasActivatedByPointer || wasElementMadeActive) {
          this.runDeactivationUXLogicIfReady_();
        }
      }
    }, {
      key: 'layout',
      value: function layout() {
        var _this14 = this;

        if (this.layoutFrame_) {
          cancelAnimationFrame(this.layoutFrame_);
        }
        this.layoutFrame_ = requestAnimationFrame(function () {
          _this14.layoutInternal_();
          _this14.layoutFrame_ = 0;
        });
      }

      /** @private */

    }, {
      key: 'layoutInternal_',
      value: function layoutInternal_() {
        var _this15 = this;

        this.frame_ = this.adapter_.computeBoundingRect();
        var maxDim = Math.max(this.frame_.height, this.frame_.width);

        // Surface diameter is treated differently for unbounded vs. bounded ripples.
        // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
        // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
        // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
        // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
        // `overflow: hidden`.
        var getBoundedRadius = function getBoundedRadius() {
          var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
          return hypotenuse + MDCRippleFoundation.numbers.PADDING;
        };

        this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius();

        // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform
        this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;
        this.fgScale_ = this.maxRadius_ / this.initialSize_;

        this.updateLayoutCssVars_();
      }

      /** @private */

    }, {
      key: 'updateLayoutCssVars_',
      value: function updateLayoutCssVars_() {
        var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
            VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
            VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
            VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
            VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;


        this.adapter_.updateCssVariable(VAR_FG_SIZE, this.initialSize_ + 'px');
        this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

        if (this.adapter_.isUnbounded()) {
          this.unboundedCoords_ = {
            left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
            top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
          };

          this.adapter_.updateCssVariable(VAR_LEFT, this.unboundedCoords_.left + 'px');
          this.adapter_.updateCssVariable(VAR_TOP, this.unboundedCoords_.top + 'px');
        }
      }

      /** @param {boolean} unbounded */

    }, {
      key: 'setUnbounded',
      value: function setUnbounded(unbounded) {
        var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

        if (unbounded) {
          this.adapter_.addClass(UNBOUNDED);
        } else {
          this.adapter_.removeClass(UNBOUNDED);
        }
      }
    }, {
      key: 'handleFocus',
      value: function handleFocus() {
        var _this16 = this;

        requestAnimationFrame(function () {
          return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
        });
      }
    }, {
      key: 'handleBlur',
      value: function handleBlur() {
        var _this17 = this;

        requestAnimationFrame(function () {
          return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
        });
      }
    }]);
    return MDCRippleFoundation;
  }(MDCFoundation);

  var RippleBase = function (_MDCRippleFoundation) {
    inherits(RippleBase, _MDCRippleFoundation);
    createClass(RippleBase, null, [{
      key: 'isSurfaceActive',
      value: function isSurfaceActive(ref) {
        return ref[RippleBase.MATCHES](':active');
      }
    }, {
      key: 'MATCHES',
      get: function get$$1() {
        /* global HTMLElement */
        return RippleBase._matches || (RippleBase._matches = getMatchesProperty(HTMLElement.prototype));
      }
    }]);

    function RippleBase(vm, options) {
      classCallCheck(this, RippleBase);
      return possibleConstructorReturn(this, (RippleBase.__proto__ || Object.getPrototypeOf(RippleBase)).call(this, _extends({
        browserSupportsCssVars: function browserSupportsCssVars() {
          return supportsCssVariables(window);
        },
        isUnbounded: function isUnbounded() {
          return false;
        },
        isSurfaceActive: function isSurfaceActive() {
          return vm.$el[RippleBase.MATCHES](':active');
        },
        isSurfaceDisabled: function isSurfaceDisabled() {
          return vm.disabled;
        },
        addClass: function addClass(className) {
          vm.$set(vm.classes, className, true);
        },
        removeClass: function removeClass(className) {
          vm.$delete(vm.classes, className);
        },

        containsEventTarget: function containsEventTarget(target) {
          return vm.$el.contains(target);
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          vm.$el.addEventListener(evt, handler, applyPassive$1());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          vm.$el.removeEventListener(evt, handler, applyPassive$1());
        },
        registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
          return document.documentElement.addEventListener(evtType, handler, applyPassive$1());
        },
        deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
          return document.documentElement.removeEventListener(evtType, handler, applyPassive$1());
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          return window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          return window.removeEventListener('resize', handler);
        },
        updateCssVariable: function updateCssVariable(varName, value) {
          vm.$set(vm.styles, varName, value);
        },
        computeBoundingRect: function computeBoundingRect() {
          return vm.$el.getBoundingClientRect();
        },
        getWindowPageOffset: function getWindowPageOffset() {
          return { x: window.pageXOffset, y: window.pageYOffset };
        }
      }, options)));
    }

    return RippleBase;
  }(MDCRippleFoundation);

  var RippleMixin = {
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },
    mounted: function mounted() {
      this.ripple = new RippleBase(this);
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.ripple.destroy();
    }
  };

  //

  var script = {
    name: 'mdc-ripple',
    mixins: [CustomElementMixin, RippleMixin],
    props: {
      tag: String
    }
  };

  /* script */
  var __vue_script__ = script;

  /* template */
  var __vue_render__ = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("custom-element", {
      staticClass: "mdc-ripple",
      attrs: { tag: _vm.tag, classes: _vm.classes, styles: _vm.styles }
    }, [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__ = [];
  __vue_render__._withStripped = true;

  /* style */
  var __vue_inject_styles__ = undefined;
  /* scoped */
  var __vue_scope_id__ = undefined;
  /* module identifier */
  var __vue_module_identifier__ = undefined;
  /* functional template */
  var __vue_is_functional_template__ = false;
  /* component normalizer */
  function __vue_normalize__(template, style, script$$1, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script$$1 === 'function' ? script$$1.options : script$$1) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/ripple/mdc-ripple.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__.styles || (__vue_create_injector__.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcRipple = __vue_normalize__({ render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ }, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, __vue_create_injector__, undefined);

  var VueMDCRipple = BasePlugin({
    mdcRipple: mdcRipple
  });

  //

  var script$1 = {
    name: 'mdc-button-base',
    mixins: [DispatchEventMixin, CustomButtonMixin, RippleMixin],
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    }
  };

  /* script */
  var __vue_script__$1 = script$1;

  /* template */
  var __vue_render__$1 = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("custom-button", _vm._g({
      ref: "root",
      class: _vm.classes,
      style: _vm.styles,
      attrs: { href: _vm.href, link: _vm.link, disabled: _vm.disabled }
    }, _vm.listeners), [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$1 = [];
  __vue_render__$1._withStripped = true;

  /* style */
  var __vue_inject_styles__$1 = undefined;
  /* scoped */
  var __vue_scope_id__$1 = undefined;
  /* module identifier */
  var __vue_module_identifier__$1 = undefined;
  /* functional template */
  var __vue_is_functional_template__$1 = false;
  /* component normalizer */
  function __vue_normalize__$1(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/button/mdc-button-base.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$1() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$1.styles || (__vue_create_injector__$1.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcButtonBase = __vue_normalize__$1({ render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 }, __vue_inject_styles__$1, __vue_script__$1, __vue_scope_id__$1, __vue_is_functional_template__$1, __vue_module_identifier__$1, __vue_create_injector__$1, undefined);

  var script$2 = {
    name: 'mdc-button',
    extends: mdcButtonBase,
    props: {
      raised: Boolean,
      unelevated: Boolean,
      outlined: Boolean,
      dense: Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-button': true,
          'mdc-button--raised': this.raised,
          'mdc-button--unelevated': this.unelevated,
          'mdc-button--outlined': this.outlined,
          'mdc-button--dense': this.dense
        }
      };
    },

    watch: {
      raised: function raised() {
        this.$set(this.classes, 'mdc-button--raised', this.raised);
      },
      unelevated: function unelevated() {
        this.$set(this.classes, 'mdc-button--unelevated', this.unelevated);
      },
      outlined: function outlined() {
        this.$set(this.classes, 'mdc-button--outlined', this.outlined);
      },
      dense: function dense() {
        this.$set(this.classes, 'mdc-button--dense', this.dense);
      }
    }
  };

  /* script */
  var __vue_script__$2 = script$2;

  /* template */

  /* style */
  var __vue_inject_styles__$2 = undefined;
  /* scoped */
  var __vue_scope_id__$2 = undefined;
  /* module identifier */
  var __vue_module_identifier__$2 = undefined;
  /* functional template */
  var __vue_is_functional_template__$2 = undefined;
  /* component normalizer */
  function __vue_normalize__$2(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/button/mdc-button.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$2() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$2.styles || (__vue_create_injector__$2.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcButton = __vue_normalize__$2({}, __vue_inject_styles__$2, __vue_script__$2, __vue_scope_id__$2, __vue_is_functional_template__$2, __vue_module_identifier__$2, __vue_create_injector__$2, undefined);

  var VueMDCButton = BasePlugin({
    mdcButton: mdcButton
  });

  //
  //
  //
  //
  //
  //
  //
  //

  var script$3 = {
    name: 'mdc-card',
    props: {
      outlined: Boolean
    }
  };

  /* script */
  var __vue_script__$3 = script$3;

  /* template */
  var __vue_render__$2 = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { staticClass: "mdc-card", class: { "mdc-card--outlined": _vm.outlined } }, [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$2 = [];
  __vue_render__$2._withStripped = true;

  /* style */
  var __vue_inject_styles__$3 = undefined;
  /* scoped */
  var __vue_scope_id__$3 = undefined;
  /* module identifier */
  var __vue_module_identifier__$3 = undefined;
  /* functional template */
  var __vue_is_functional_template__$3 = false;
  /* component normalizer */
  function __vue_normalize__$3(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/card/mdc-card.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$3() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$3.styles || (__vue_create_injector__$3.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcCard = __vue_normalize__$3({ render: __vue_render__$2, staticRenderFns: __vue_staticRenderFns__$2 }, __vue_inject_styles__$3, __vue_script__$3, __vue_scope_id__$3, __vue_is_functional_template__$3, __vue_module_identifier__$3, __vue_create_injector__$3, undefined);

  //
  var script$4 = {
    name: 'mdc-card-primary-action',
    mixins: [DispatchEventMixin, CustomLinkMixin, RippleMixin],
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    }
  };

  /* script */
  var __vue_script__$4 = script$4;

  /* template */
  var __vue_render__$3 = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("custom-link", _vm._g({
      staticClass: "mdc-card-primary-action mdc-card__primary-action",
      class: _vm.classes,
      style: _vm.styles,
      attrs: { link: _vm.link }
    }, _vm.listeners), [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$3 = [];
  __vue_render__$3._withStripped = true;

  /* style */
  var __vue_inject_styles__$4 = undefined;
  /* scoped */
  var __vue_scope_id__$4 = undefined;
  /* module identifier */
  var __vue_module_identifier__$4 = undefined;
  /* functional template */
  var __vue_is_functional_template__$4 = false;
  /* component normalizer */
  function __vue_normalize__$4(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/card/mdc-card-primary-action.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$4() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$4.styles || (__vue_create_injector__$4.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcCardPrimaryAction = __vue_normalize__$4({ render: __vue_render__$3, staticRenderFns: __vue_staticRenderFns__$3 }, __vue_inject_styles__$4, __vue_script__$4, __vue_scope_id__$4, __vue_is_functional_template__$4, __vue_module_identifier__$4, __vue_create_injector__$4, undefined);

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //

  var script$5 = {
    name: 'mdc-card-media',
    props: {
      src: String,
      square: Boolean
    },
    computed: {
      styles: function styles() {
        var styles = {
          backgroundImage: 'url(' + this.src + ')'
        };

        return styles;
      },
      classes: function classes() {
        return this.square ? 'mdc-card__media--square' : 'mdc-card__media--16-9';
      }
    }
  };

  /* script */
  var __vue_script__$5 = script$5;

  /* template */
  var __vue_render__$4 = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("section", {
      staticClass: "mdc-card-media mdc-card__media",
      class: _vm.classes,
      style: _vm.styles
    }, [_vm.$slots.default ? _c("div", { staticClass: "mdc-card__media-content" }, [_vm._t("default")], 2) : _vm._e()]);
  };
  var __vue_staticRenderFns__$4 = [];
  __vue_render__$4._withStripped = true;

  /* style */
  var __vue_inject_styles__$5 = undefined;
  /* scoped */
  var __vue_scope_id__$5 = undefined;
  /* module identifier */
  var __vue_module_identifier__$5 = undefined;
  /* functional template */
  var __vue_is_functional_template__$5 = false;
  /* component normalizer */
  function __vue_normalize__$5(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/card/mdc-card-media.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$5() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$5.styles || (__vue_create_injector__$5.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcCardMedia = __vue_normalize__$5({ render: __vue_render__$4, staticRenderFns: __vue_staticRenderFns__$4 }, __vue_inject_styles__$5, __vue_script__$5, __vue_scope_id__$5, __vue_is_functional_template__$5, __vue_module_identifier__$5, __vue_create_injector__$5, undefined);

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //

  var script$6 = {
    name: 'mdc-card-header',
    props: {
      title: String,
      subtitle: String,
      'large-title': { type: Boolean, default: true }
    }
  };

  /* script */
  var __vue_script__$6 = script$6;

  /* template */
  var __vue_render__$5 = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("section", { staticClass: "mdc-card-header mdc-card__primary" }, [_vm._t("default", [_vm.title ? _c("h1", {
      staticClass: "mdc-card__title",
      class: { "mdc-card__title--large": _vm.largeTitle }
    }, [_vm._v("\n      " + _vm._s(_vm.title) + "\n    ")]) : _vm._e(), _vm._v(" "), _vm.subtitle ? _c("h2", { staticClass: "mdc-card__subtitle" }, [_vm._v("\n      " + _vm._s(_vm.subtitle) + " \n    ")]) : _vm._e()])], 2);
  };
  var __vue_staticRenderFns__$5 = [];
  __vue_render__$5._withStripped = true;

  /* style */
  var __vue_inject_styles__$6 = undefined;
  /* scoped */
  var __vue_scope_id__$6 = undefined;
  /* module identifier */
  var __vue_module_identifier__$6 = undefined;
  /* functional template */
  var __vue_is_functional_template__$6 = false;
  /* component normalizer */
  function __vue_normalize__$6(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/card/mdc-card-header.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$6() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$6.styles || (__vue_create_injector__$6.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcCardHeader = __vue_normalize__$6({ render: __vue_render__$5, staticRenderFns: __vue_staticRenderFns__$5 }, __vue_inject_styles__$6, __vue_script__$6, __vue_scope_id__$6, __vue_is_functional_template__$6, __vue_module_identifier__$6, __vue_create_injector__$6, undefined);

  //
  //
  //
  //
  //
  //
  //
  //

  var script$7 = {
    name: 'mdc-card-title',
    props: {
      large: Boolean
    }
  };

  /* script */
  var __vue_script__$7 = script$7;

  /* template */
  var __vue_render__$6 = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("h1", {
      staticClass: "mdc-card-title mdc-card__title",
      class: { "mdc-card__title--large": _vm.large }
    }, [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$6 = [];
  __vue_render__$6._withStripped = true;

  /* style */
  var __vue_inject_styles__$7 = undefined;
  /* scoped */
  var __vue_scope_id__$7 = undefined;
  /* module identifier */
  var __vue_module_identifier__$7 = undefined;
  /* functional template */
  var __vue_is_functional_template__$7 = false;
  /* component normalizer */
  function __vue_normalize__$7(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/card/mdc-card-title.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$7() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$7.styles || (__vue_create_injector__$7.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcCardTitle = __vue_normalize__$7({ render: __vue_render__$6, staticRenderFns: __vue_staticRenderFns__$6 }, __vue_inject_styles__$7, __vue_script__$7, __vue_scope_id__$7, __vue_is_functional_template__$7, __vue_module_identifier__$7, __vue_create_injector__$7, undefined);

  //
  //
  //
  //
  //
  //
  //
  //

  var script$8 = {
    name: 'mdc-card-subtitle'
  };

  /* script */
  var __vue_script__$8 = script$8;

  /* template */
  var __vue_render__$7 = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("h2", { staticClass: "mdc-card-subtitle mdc-card__subtitle" }, [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$7 = [];
  __vue_render__$7._withStripped = true;

  /* style */
  var __vue_inject_styles__$8 = undefined;
  /* scoped */
  var __vue_scope_id__$8 = undefined;
  /* module identifier */
  var __vue_module_identifier__$8 = undefined;
  /* functional template */
  var __vue_is_functional_template__$8 = false;
  /* component normalizer */
  function __vue_normalize__$8(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/card/mdc-card-subtitle.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$8() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$8.styles || (__vue_create_injector__$8.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcCardSubtitle = __vue_normalize__$8({ render: __vue_render__$7, staticRenderFns: __vue_staticRenderFns__$7 }, __vue_inject_styles__$8, __vue_script__$8, __vue_scope_id__$8, __vue_is_functional_template__$8, __vue_module_identifier__$8, __vue_create_injector__$8, undefined);

  //
  //
  //
  //
  //
  //

  var script$9 = {
    name: 'mdc-card-text'
  };

  /* script */
  var __vue_script__$9 = script$9;

  /* template */
  var __vue_render__$8 = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("section", { staticClass: "mdc-card-text mdc-card__supporting-text" }, [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$8 = [];
  __vue_render__$8._withStripped = true;

  /* style */
  var __vue_inject_styles__$9 = undefined;
  /* scoped */
  var __vue_scope_id__$9 = undefined;
  /* module identifier */
  var __vue_module_identifier__$9 = undefined;
  /* functional template */
  var __vue_is_functional_template__$9 = false;
  /* component normalizer */
  function __vue_normalize__$9(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/card/mdc-card-text.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$9() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$9.styles || (__vue_create_injector__$9.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcCardText = __vue_normalize__$9({ render: __vue_render__$8, staticRenderFns: __vue_staticRenderFns__$8 }, __vue_inject_styles__$9, __vue_script__$9, __vue_scope_id__$9, __vue_is_functional_template__$9, __vue_module_identifier__$9, __vue_create_injector__$9, undefined);

  //
  //
  //
  //
  //
  //
  //
  //

  var script$a = {
    name: 'mdc-card-actions',
    props: {
      fullBleed: Boolean
    },
    computed: {
      classes: function classes() {
        return {
          'mdc-card__actions--full-bleed': this.fullBleed
        };
      }
    }
  };

  /* script */
  var __vue_script__$a = script$a;

  /* template */
  var __vue_render__$9 = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("section", { staticClass: "mdc-card-actions mdc-card__actions", class: _vm.classes }, [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$9 = [];
  __vue_render__$9._withStripped = true;

  /* style */
  var __vue_inject_styles__$a = undefined;
  /* scoped */
  var __vue_scope_id__$a = undefined;
  /* module identifier */
  var __vue_module_identifier__$a = undefined;
  /* functional template */
  var __vue_is_functional_template__$a = false;
  /* component normalizer */
  function __vue_normalize__$a(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/card/mdc-card-actions.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$a() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$a.styles || (__vue_create_injector__$a.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcCardActions = __vue_normalize__$a({ render: __vue_render__$9, staticRenderFns: __vue_staticRenderFns__$9 }, __vue_inject_styles__$a, __vue_script__$a, __vue_scope_id__$a, __vue_is_functional_template__$a, __vue_module_identifier__$a, __vue_create_injector__$a, undefined);

  //
  //
  //
  //
  //
  //

  var script$b = {
    name: 'mdc-card-action-buttons'
  };

  /* script */
  var __vue_script__$b = script$b;

  /* template */
  var __vue_render__$a = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { staticClass: "mdc-card-action-buttons mdc-card__action-buttons" }, [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$a = [];
  __vue_render__$a._withStripped = true;

  /* style */
  var __vue_inject_styles__$b = undefined;
  /* scoped */
  var __vue_scope_id__$b = undefined;
  /* module identifier */
  var __vue_module_identifier__$b = undefined;
  /* functional template */
  var __vue_is_functional_template__$b = false;
  /* component normalizer */
  function __vue_normalize__$b(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/card/mdc-card-action-buttons.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$b() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$b.styles || (__vue_create_injector__$b.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcCardActionButtons = __vue_normalize__$b({ render: __vue_render__$a, staticRenderFns: __vue_staticRenderFns__$a }, __vue_inject_styles__$b, __vue_script__$b, __vue_scope_id__$b, __vue_is_functional_template__$b, __vue_module_identifier__$b, __vue_create_injector__$b, undefined);

  var script$c = {
    name: 'mdc-card-action-button',
    extends: mdcButtonBase,
    data: function data() {
      return {
        classes: {
          'mdc-button': true,
          'mdc-card__action': true,
          'mdc-card-action-button': true
        }
      };
    }
  };

  /* script */
  var __vue_script__$c = script$c;

  /* template */

  /* style */
  var __vue_inject_styles__$c = undefined;
  /* scoped */
  var __vue_scope_id__$c = undefined;
  /* module identifier */
  var __vue_module_identifier__$c = undefined;
  /* functional template */
  var __vue_is_functional_template__$c = undefined;
  /* component normalizer */
  function __vue_normalize__$c(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/card/mdc-card-action-button.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$c() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$c.styles || (__vue_create_injector__$c.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcCardActionButton = __vue_normalize__$c({}, __vue_inject_styles__$c, __vue_script__$c, __vue_scope_id__$c, __vue_is_functional_template__$c, __vue_module_identifier__$c, __vue_create_injector__$c, undefined);

  //
  //
  //
  //
  //
  //

  var script$d = {
    name: 'mdc-card-action-icons'
  };

  /* script */
  var __vue_script__$d = script$d;

  /* template */
  var __vue_render__$b = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { staticClass: "mdc-card-action-icons mdc-card__action-icons" }, [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$b = [];
  __vue_render__$b._withStripped = true;

  /* style */
  var __vue_inject_styles__$d = undefined;
  /* scoped */
  var __vue_scope_id__$d = undefined;
  /* module identifier */
  var __vue_module_identifier__$d = undefined;
  /* functional template */
  var __vue_is_functional_template__$d = false;
  /* component normalizer */
  function __vue_normalize__$d(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/card/mdc-card-action-icons.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$d() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$d.styles || (__vue_create_injector__$d.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcCardActionIcons = __vue_normalize__$d({ render: __vue_render__$b, staticRenderFns: __vue_staticRenderFns__$b }, __vue_inject_styles__$d, __vue_script__$d, __vue_scope_id__$d, __vue_is_functional_template__$d, __vue_module_identifier__$d, __vue_create_injector__$d, undefined);

  //

  var script$e = {
    name: 'mdc-card-action-icon',
    mixins: [DispatchEventMixin],
    props: {
      icon: String
    },
    data: function data() {
      return {
        classes: {
          'mdc-card-action-icon': true,
          'material-icons': !!this.icon,
          'mdc-card__action': true,
          'mdc-card__action--icon': true,
          'mdc-icon-toggle': true
        },
        styles: {}
      };
    },

    watch: {
      icon: function icon() {
        this.$set(this.classes, 'material-icons', !!this.icon);
      }
    },
    mounted: function mounted() {
      this.ripple = new RippleBase(this, {
        isUnbounded: function isUnbounded() {
          return true;
        }
      });
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.ripple.destroy();
    }
  };

  /* script */
  var __vue_script__$e = script$e;

  /* template */
  var __vue_render__$c = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("span", _vm._g({ class: _vm.classes, style: _vm.styles }, _vm.listeners), [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2);
  };
  var __vue_staticRenderFns__$c = [];
  __vue_render__$c._withStripped = true;

  /* style */
  var __vue_inject_styles__$e = undefined;
  /* scoped */
  var __vue_scope_id__$e = undefined;
  /* module identifier */
  var __vue_module_identifier__$e = undefined;
  /* functional template */
  var __vue_is_functional_template__$e = false;
  /* component normalizer */
  function __vue_normalize__$e(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/card/mdc-card-action-icon.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$e() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$e.styles || (__vue_create_injector__$e.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcCardActionIcon = __vue_normalize__$e({ render: __vue_render__$c, staticRenderFns: __vue_staticRenderFns__$c }, __vue_inject_styles__$e, __vue_script__$e, __vue_scope_id__$e, __vue_is_functional_template__$e, __vue_module_identifier__$e, __vue_create_injector__$e, undefined);

  var VueMDCCard = BasePlugin({
    mdcCard: mdcCard,
    mdcCardPrimaryAction: mdcCardPrimaryAction,
    mdcCardMedia: mdcCardMedia,
    mdcCardHeader: mdcCardHeader,
    mdcCardTitle: mdcCardTitle,
    mdcCardSubtitle: mdcCardSubtitle,
    mdcCardText: mdcCardText,
    mdcCardActions: mdcCardActions,
    mdcCardActionButtons: mdcCardActionButtons,
    mdcCardActionButton: mdcCardActionButton,
    mdcCardActionIcons: mdcCardActionIcons,
    mdcCardActionIcon: mdcCardActionIcon
  });

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @template F
   */

  var MDCComponent = function () {
    createClass(MDCComponent, null, [{
      key: 'attachTo',

      /**
       * @param {!Element} root
       * @return {!MDCComponent}
       */
      value: function attachTo(root) {
        // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
        // returns an instantiated component with its root set to that element. Also note that in the cases of
        // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
        // from getDefaultFoundation().
        return new MDCComponent(root, new MDCFoundation());
      }

      /**
       * @param {!Element} root
       * @param {F=} foundation
       * @param {...?} args
       */

    }]);

    function MDCComponent(root) {
      var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      classCallCheck(this, MDCComponent);

      /** @protected {!Element} */
      this.root_ = root;

      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      this.initialize.apply(this, args);
      // Note that we initialize foundation here and not within the constructor's default param so that
      // this.root_ is defined and can be used within the foundation class.
      /** @protected {!F} */
      this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
      this.foundation_.init();
      this.initialSyncWithDOM();
    }

    createClass(MDCComponent, [{
      key: 'initialize',
      value: function initialize() /* ...args */{}
      // Subclasses can override this to do any additional setup work that would be considered part of a
      // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
      // initialized. Any additional arguments besides root and foundation will be passed in here.


      /**
       * @return {!F} foundation
       */

    }, {
      key: 'getDefaultFoundation',
      value: function getDefaultFoundation() {
        // Subclasses must override this method to return a properly configured foundation class for the
        // component.
        throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
      }
    }, {
      key: 'initialSyncWithDOM',
      value: function initialSyncWithDOM() {
        // Subclasses should override this method if they need to perform work to synchronize with a host DOM
        // object. An example of this would be a form control wrapper that needs to synchronize its internal state
        // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
        // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        // Subclasses may implement this method to release any resources / deregister any listeners they have
        // attached. An example of this might be deregistering a resize event from the window object.
        this.foundation_.destroy();
      }

      /**
       * Wrapper method to add an event listener to the component's root element. This is most useful when
       * listening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: 'listen',
      value: function listen(evtType, handler) {
        this.root_.addEventListener(evtType, handler);
      }

      /**
       * Wrapper method to remove an event listener to the component's root element. This is most useful when
       * unlistening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: 'unlisten',
      value: function unlisten(evtType, handler) {
        this.root_.removeEventListener(evtType, handler);
      }

      /**
       * Fires a cross-browser-compatible custom event from the component root of the given type,
       * with the given data.
       * @param {string} evtType
       * @param {!Object} evtData
       * @param {boolean=} shouldBubble
       */

    }, {
      key: 'emit',
      value: function emit(evtType, evtData) {
        var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        var evt = void 0;
        if (typeof CustomEvent === 'function') {
          evt = new CustomEvent(evtType, {
            detail: evtData,
            bubbles: shouldBubble
          });
        } else {
          evt = document.createEvent('CustomEvent');
          evt.initCustomEvent(evtType, shouldBubble, false, evtData);
        }

        this.root_.dispatchEvent(evt);
      }
    }]);
    return MDCComponent;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Ripple. Provides an interface for managing
   * - classes
   * - dom
   * - CSS variables
   * - position
   * - dimensions
   * - scroll position
   * - event handlers
   * - unbounded, active and disabled states
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCRippleAdapter$1 = function () {
    function MDCRippleAdapter() {
      classCallCheck(this, MDCRippleAdapter);
    }

    createClass(MDCRippleAdapter, [{
      key: "browserSupportsCssVars",

      /** @return {boolean} */
      value: function browserSupportsCssVars() {}

      /** @return {boolean} */

    }, {
      key: "isUnbounded",
      value: function isUnbounded() {}

      /** @return {boolean} */

    }, {
      key: "isSurfaceActive",
      value: function isSurfaceActive() {}

      /** @return {boolean} */

    }, {
      key: "isSurfaceDisabled",
      value: function isSurfaceDisabled() {}

      /** @param {string} className */

    }, {
      key: "addClass",
      value: function addClass(className) {}

      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /** @param {!EventTarget} target */

    }, {
      key: "containsEventTarget",
      value: function containsEventTarget(target) {}

      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(evtType, handler) {}

      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(evtType, handler) {}

      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "registerDocumentInteractionHandler",
      value: function registerDocumentInteractionHandler(evtType, handler) {}

      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "deregisterDocumentInteractionHandler",
      value: function deregisterDocumentInteractionHandler(evtType, handler) {}

      /**
       * @param {!Function} handler
       */

    }, {
      key: "registerResizeHandler",
      value: function registerResizeHandler(handler) {}

      /**
       * @param {!Function} handler
       */

    }, {
      key: "deregisterResizeHandler",
      value: function deregisterResizeHandler(handler) {}

      /**
       * @param {string} varName
       * @param {?number|string} value
       */

    }, {
      key: "updateCssVariable",
      value: function updateCssVariable(varName, value) {}

      /** @return {!ClientRect} */

    }, {
      key: "computeBoundingRect",
      value: function computeBoundingRect() {}

      /** @return {{x: number, y: number}} */

    }, {
      key: "getWindowPageOffset",
      value: function getWindowPageOffset() {}
    }]);
    return MDCRippleAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$1 = {
    // Ripple is a special case where the "root" component is really a "mixin" of sorts,
    // given that it's an 'upgrade' to an existing component. That being said it is the root
    // CSS class that all other CSS classes derive from.
    ROOT: 'mdc-ripple-upgraded',
    UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
    BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
    FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
    FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
  };

  var strings$1 = {
    VAR_LEFT: '--mdc-ripple-left',
    VAR_TOP: '--mdc-ripple-top',
    VAR_FG_SIZE: '--mdc-ripple-fg-size',
    VAR_FG_SCALE: '--mdc-ripple-fg-scale',
    VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
    VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
  };

  var numbers$1 = {
    PADDING: 10,
    INITIAL_ORIGIN_SCALE: 0.6,
    DEACTIVATION_TIMEOUT_MS: 225, // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
    FG_DEACTIVATION_MS: 150, // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
    TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
   * @private {boolean|undefined}
   */
  var supportsCssVariables_$1 = void 0;

  /**
   * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
   * @private {boolean|undefined}
   */
  var supportsPassive_$2 = void 0;

  /**
   * @param {!Window} windowObj
   * @return {boolean}
   */
  function detectEdgePseudoVarBug$1(windowObj) {
    // Detect versions of Edge with buggy var() support
    // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
    var document = windowObj.document;
    var node = document.createElement('div');
    node.className = 'mdc-ripple-surface--test-edge-var-bug';
    document.body.appendChild(node);

    // The bug exists if ::before style ends up propagating to the parent element.
    // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
    // but Firefox is known to support CSS custom properties correctly.
    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397
    var computedStyle = windowObj.getComputedStyle(node);
    var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
    node.remove();
    return hasPseudoVarBug;
  }

  /**
   * @param {!Window} windowObj
   * @param {boolean=} forceRefresh
   * @return {boolean|undefined}
   */

  function supportsCssVariables$1(windowObj) {
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var supportsCssVariables = supportsCssVariables_$1;
    if (typeof supportsCssVariables_$1 === 'boolean' && !forceRefresh) {
      return supportsCssVariables;
    }

    var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';
    if (!supportsFunctionPresent) {
      return;
    }

    var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes');
    // See: https://bugs.webkit.org/show_bug.cgi?id=154669
    // See: README section on Safari
    var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

    if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
      supportsCssVariables = !detectEdgePseudoVarBug$1(windowObj);
    } else {
      supportsCssVariables = false;
    }

    if (!forceRefresh) {
      supportsCssVariables_$1 = supportsCssVariables;
    }
    return supportsCssVariables;
  }

  //
  /**
   * Determine whether the current browser supports passive event listeners, and if so, use them.
   * @param {!Window=} globalObj
   * @param {boolean=} forceRefresh
   * @return {boolean|{passive: boolean}}
   */
  function applyPassive$2() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (supportsPassive_$2 === undefined || forceRefresh) {
      var isSupported = false;
      try {
        globalObj.document.addEventListener('test', null, { get passive() {
            isSupported = true;
          } });
      } catch (e) {}

      supportsPassive_$2 = isSupported;
    }

    return supportsPassive_$2 ? { passive: true } : false;
  }

  /**
   * @param {!Object} HTMLElementPrototype
   * @return {!Array<string>}
   */
  function getMatchesProperty$1(HTMLElementPrototype) {
    return ['webkitMatchesSelector', 'msMatchesSelector', 'matches'].filter(function (p) {
      return p in HTMLElementPrototype;
    }).pop();
  }

  /**
   * @param {!Event} ev
   * @param {{x: number, y: number}} pageOffset
   * @param {!ClientRect} clientRect
   * @return {{x: number, y: number}}
   */
  function getNormalizedEventCoords$1(ev, pageOffset, clientRect) {
    var x = pageOffset.x,
        y = pageOffset.y;

    var documentX = x + clientRect.left;
    var documentY = y + clientRect.top;

    var normalizedX = void 0;
    var normalizedY = void 0;
    // Determine touch point relative to the ripple container.
    if (ev.type === 'touchstart') {
      normalizedX = ev.changedTouches[0].pageX - documentX;
      normalizedY = ev.changedTouches[0].pageY - documentY;
    } else {
      normalizedX = ev.pageX - documentX;
      normalizedY = ev.pageY - documentY;
    }

    return { x: normalizedX, y: normalizedY };
  }

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  // Activation events registered on the root element of each instance for activation
  var ACTIVATION_EVENT_TYPES$1 = ['touchstart', 'pointerdown', 'mousedown', 'keydown'];

  // Deactivation events registered on documentElement when a pointer-related down event occurs
  var POINTER_DEACTIVATION_EVENT_TYPES$1 = ['touchend', 'pointerup', 'mouseup'];

  // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations
  /** @type {!Array<!EventTarget>} */
  var activatedTargets$1 = [];

  /**
   * @extends {MDCFoundation<!MDCRippleAdapter>}
   */

  var MDCRippleFoundation$1 = function (_MDCFoundation) {
    inherits(MDCRippleFoundation, _MDCFoundation);
    createClass(MDCRippleFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$1;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$1;
      }
    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers$1;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          browserSupportsCssVars: function browserSupportsCssVars() /* boolean - cached */{},
          isUnbounded: function isUnbounded() /* boolean */{},
          isSurfaceActive: function isSurfaceActive() /* boolean */{},
          isSurfaceDisabled: function isSurfaceDisabled() /* boolean */{},
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          containsEventTarget: function containsEventTarget() /* target: !EventTarget */{},
          registerInteractionHandler: function registerInteractionHandler() /* evtType: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* evtType: string, handler: EventListener */{},
          registerDocumentInteractionHandler: function registerDocumentInteractionHandler() /* evtType: string, handler: EventListener */{},
          deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler() /* evtType: string, handler: EventListener */{},
          registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
          deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
          updateCssVariable: function updateCssVariable() /* varName: string, value: string */{},
          computeBoundingRect: function computeBoundingRect() /* ClientRect */{},
          getWindowPageOffset: function getWindowPageOffset() /* {x: number, y: number} */{}
        };
      }
    }]);

    function MDCRippleFoundation(adapter) {
      classCallCheck(this, MDCRippleFoundation);

      /** @private {number} */
      var _this = possibleConstructorReturn(this, (MDCRippleFoundation.__proto__ || Object.getPrototypeOf(MDCRippleFoundation)).call(this, _extends(MDCRippleFoundation.defaultAdapter, adapter)));

      _this.layoutFrame_ = 0;

      /** @private {!ClientRect} */
      _this.frame_ = /** @type {!ClientRect} */{ width: 0, height: 0 };

      /** @private {!ActivationStateType} */
      _this.activationState_ = _this.defaultActivationState_();

      /** @private {number} */
      _this.initialSize_ = 0;

      /** @private {number} */
      _this.maxRadius_ = 0;

      /** @private {function(!Event)} */
      _this.activateHandler_ = function (e) {
        return _this.activate_(e);
      };

      /** @private {function(!Event)} */
      _this.deactivateHandler_ = function (e) {
        return _this.deactivate_(e);
      };

      /** @private {function(?Event=)} */
      _this.focusHandler_ = function () {
        return _this.handleFocus();
      };

      /** @private {function(?Event=)} */
      _this.blurHandler_ = function () {
        return _this.handleBlur();
      };

      /** @private {!Function} */
      _this.resizeHandler_ = function () {
        return _this.layout();
      };

      /** @private {{left: number, top:number}} */
      _this.unboundedCoords_ = {
        left: 0,
        top: 0
      };

      /** @private {number} */
      _this.fgScale_ = 0;

      /** @private {number} */
      _this.activationTimer_ = 0;

      /** @private {number} */
      _this.fgDeactivationRemovalTimer_ = 0;

      /** @private {boolean} */
      _this.activationAnimationHasEnded_ = false;

      /** @private {!Function} */
      _this.activationTimerCallback_ = function () {
        _this.activationAnimationHasEnded_ = true;
        _this.runDeactivationUXLogicIfReady_();
      };

      /** @private {?Event} */
      _this.previousActivationEvent_ = null;
      return _this;
    }

    /**
     * We compute this property so that we are not querying information about the client
     * until the point in time where the foundation requests it. This prevents scenarios where
     * client-side feature-detection may happen too early, such as when components are rendered on the server
     * and then initialized at mount time on the client.
     * @return {boolean}
     * @private
     */


    createClass(MDCRippleFoundation, [{
      key: 'supportsPressRipple_',
      value: function supportsPressRipple_() {
        return this.adapter_.browserSupportsCssVars();
      }

      /**
       * @return {!ActivationStateType}
       */

    }, {
      key: 'defaultActivationState_',
      value: function defaultActivationState_() {
        return {
          isActivated: false,
          hasDeactivationUXRun: false,
          wasActivatedByPointer: false,
          wasElementMadeActive: false,
          activationEvent: null,
          isProgrammatic: false
        };
      }

      /** @override */

    }, {
      key: 'init',
      value: function init() {
        var _this2 = this;

        var supportsPressRipple = this.supportsPressRipple_();

        this.registerRootHandlers_(supportsPressRipple);

        if (supportsPressRipple) {
          var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$.ROOT,
              UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;

          requestAnimationFrame(function () {
            _this2.adapter_.addClass(ROOT);
            if (_this2.adapter_.isUnbounded()) {
              _this2.adapter_.addClass(UNBOUNDED);
              // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple
              _this2.layoutInternal_();
            }
          });
        }
      }

      /** @override */

    }, {
      key: 'destroy',
      value: function destroy() {
        var _this3 = this;

        if (this.supportsPressRipple_()) {
          if (this.activationTimer_) {
            clearTimeout(this.activationTimer_);
            this.activationTimer_ = 0;
            var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;

            this.adapter_.removeClass(FG_ACTIVATION);
          }

          var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$2.ROOT,
              UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;

          requestAnimationFrame(function () {
            _this3.adapter_.removeClass(ROOT);
            _this3.adapter_.removeClass(UNBOUNDED);
            _this3.removeCssVars_();
          });
        }

        this.deregisterRootHandlers_();
        this.deregisterDeactivationHandlers_();
      }

      /**
       * @param {boolean} supportsPressRipple Passed from init to save a redundant function call
       * @private
       */

    }, {
      key: 'registerRootHandlers_',
      value: function registerRootHandlers_(supportsPressRipple) {
        var _this4 = this;

        if (supportsPressRipple) {
          ACTIVATION_EVENT_TYPES$1.forEach(function (type) {
            _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
          });
          if (this.adapter_.isUnbounded()) {
            this.adapter_.registerResizeHandler(this.resizeHandler_);
          }
        }

        this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
        this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
      }

      /**
       * @param {!Event} e
       * @private
       */

    }, {
      key: 'registerDeactivationHandlers_',
      value: function registerDeactivationHandlers_(e) {
        var _this5 = this;

        if (e.type === 'keydown') {
          this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
        } else {
          POINTER_DEACTIVATION_EVENT_TYPES$1.forEach(function (type) {
            _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
          });
        }
      }

      /** @private */

    }, {
      key: 'deregisterRootHandlers_',
      value: function deregisterRootHandlers_() {
        var _this6 = this;

        ACTIVATION_EVENT_TYPES$1.forEach(function (type) {
          _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
        });
        this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
        this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

        if (this.adapter_.isUnbounded()) {
          this.adapter_.deregisterResizeHandler(this.resizeHandler_);
        }
      }

      /** @private */

    }, {
      key: 'deregisterDeactivationHandlers_',
      value: function deregisterDeactivationHandlers_() {
        var _this7 = this;

        this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
        POINTER_DEACTIVATION_EVENT_TYPES$1.forEach(function (type) {
          _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
        });
      }

      /** @private */

    }, {
      key: 'removeCssVars_',
      value: function removeCssVars_() {
        var _this8 = this;

        var strings = MDCRippleFoundation.strings;

        Object.keys(strings).forEach(function (k) {
          if (k.indexOf('VAR_') === 0) {
            _this8.adapter_.updateCssVariable(strings[k], null);
          }
        });
      }

      /**
       * @param {?Event} e
       * @private
       */

    }, {
      key: 'activate_',
      value: function activate_(e) {
        var _this9 = this;

        if (this.adapter_.isSurfaceDisabled()) {
          return;
        }

        var activationState = this.activationState_;
        if (activationState.isActivated) {
          return;
        }

        // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction
        var previousActivationEvent = this.previousActivationEvent_;
        var isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;
        if (isSameInteraction) {
          return;
        }

        activationState.isActivated = true;
        activationState.isProgrammatic = e === null;
        activationState.activationEvent = e;
        activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown';

        var hasActivatedChild = e && activatedTargets$1.length > 0 && activatedTargets$1.some(function (target) {
          return _this9.adapter_.containsEventTarget(target);
        });
        if (hasActivatedChild) {
          // Immediately reset activation state, while preserving logic that prevents touch follow-on events
          this.resetActivationState_();
          return;
        }

        if (e) {
          activatedTargets$1.push( /** @type {!EventTarget} */e.target);
          this.registerDeactivationHandlers_(e);
        }

        activationState.wasElementMadeActive = this.checkElementMadeActive_(e);
        if (activationState.wasElementMadeActive) {
          this.animateActivation_();
        }

        requestAnimationFrame(function () {
          // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
          activatedTargets$1 = [];

          if (!activationState.wasElementMadeActive && (e.key === ' ' || e.keyCode === 32)) {
            // If space was pressed, try again within an rAF call to detect :active, because different UAs report
            // active states inconsistently when they're called within event handling code:
            // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
            // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
            // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
            // variable is set within a rAF callback for a submit button interaction (#2241).
            activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);
            if (activationState.wasElementMadeActive) {
              _this9.animateActivation_();
            }
          }

          if (!activationState.wasElementMadeActive) {
            // Reset activation state immediately if element was not made active.
            _this9.activationState_ = _this9.defaultActivationState_();
          }
        });
      }

      /**
       * @param {?Event} e
       * @private
       */

    }, {
      key: 'checkElementMadeActive_',
      value: function checkElementMadeActive_(e) {
        return e && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
      }

      /**
       * @param {?Event=} event Optional event containing position information.
       */

    }, {
      key: 'activate',
      value: function activate() {
        var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        this.activate_(event);
      }

      /** @private */

    }, {
      key: 'animateActivation_',
      value: function animateActivation_() {
        var _this10 = this;

        var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
            VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
            VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
        var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
            FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
            FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
        var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;


        this.layoutInternal_();

        var translateStart = '';
        var translateEnd = '';

        if (!this.adapter_.isUnbounded()) {
          var _getFgTranslationCoor = this.getFgTranslationCoordinates_(),
              startPoint = _getFgTranslationCoor.startPoint,
              endPoint = _getFgTranslationCoor.endPoint;

          translateStart = startPoint.x + 'px, ' + startPoint.y + 'px';
          translateEnd = endPoint.x + 'px, ' + endPoint.y + 'px';
        }

        this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
        this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
        // Cancel any ongoing activation/deactivation animations
        clearTimeout(this.activationTimer_);
        clearTimeout(this.fgDeactivationRemovalTimer_);
        this.rmBoundedActivationClasses_();
        this.adapter_.removeClass(FG_DEACTIVATION);

        // Force layout in order to re-trigger the animation.
        this.adapter_.computeBoundingRect();
        this.adapter_.addClass(FG_ACTIVATION);
        this.activationTimer_ = setTimeout(function () {
          return _this10.activationTimerCallback_();
        }, DEACTIVATION_TIMEOUT_MS);
      }

      /**
       * @private
       * @return {{startPoint: PointType, endPoint: PointType}}
       */

    }, {
      key: 'getFgTranslationCoordinates_',
      value: function getFgTranslationCoordinates_() {
        var _activationState_ = this.activationState_,
            activationEvent = _activationState_.activationEvent,
            wasActivatedByPointer = _activationState_.wasActivatedByPointer;


        var startPoint = void 0;
        if (wasActivatedByPointer) {
          startPoint = getNormalizedEventCoords$1(
          /** @type {!Event} */activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
        } else {
          startPoint = {
            x: this.frame_.width / 2,
            y: this.frame_.height / 2
          };
        }
        // Center the element around the start point.
        startPoint = {
          x: startPoint.x - this.initialSize_ / 2,
          y: startPoint.y - this.initialSize_ / 2
        };

        var endPoint = {
          x: this.frame_.width / 2 - this.initialSize_ / 2,
          y: this.frame_.height / 2 - this.initialSize_ / 2
        };

        return { startPoint: startPoint, endPoint: endPoint };
      }

      /** @private */

    }, {
      key: 'runDeactivationUXLogicIfReady_',
      value: function runDeactivationUXLogicIfReady_() {
        var _this11 = this;

        // This method is called both when a pointing device is released, and when the activation animation ends.
        // The deactivation animation should only run after both of those occur.
        var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
        var _activationState_2 = this.activationState_,
            hasDeactivationUXRun = _activationState_2.hasDeactivationUXRun,
            isActivated = _activationState_2.isActivated;

        var activationHasEnded = hasDeactivationUXRun || !isActivated;

        if (activationHasEnded && this.activationAnimationHasEnded_) {
          this.rmBoundedActivationClasses_();
          this.adapter_.addClass(FG_DEACTIVATION);
          this.fgDeactivationRemovalTimer_ = setTimeout(function () {
            _this11.adapter_.removeClass(FG_DEACTIVATION);
          }, numbers$1.FG_DEACTIVATION_MS);
        }
      }

      /** @private */

    }, {
      key: 'rmBoundedActivationClasses_',
      value: function rmBoundedActivationClasses_() {
        var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;

        this.adapter_.removeClass(FG_ACTIVATION);
        this.activationAnimationHasEnded_ = false;
        this.adapter_.computeBoundingRect();
      }
    }, {
      key: 'resetActivationState_',
      value: function resetActivationState_() {
        var _this12 = this;

        this.previousActivationEvent_ = this.activationState_.activationEvent;
        this.activationState_ = this.defaultActivationState_();
        // Touch devices may fire additional events for the same interaction within a short time.
        // Store the previous event until it's safe to assume that subsequent events are for new interactions.
        setTimeout(function () {
          return _this12.previousActivationEvent_ = null;
        }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
      }

      /**
       * @param {?Event} e
       * @private
       */

    }, {
      key: 'deactivate_',
      value: function deactivate_(e) {
        var _this13 = this;

        var activationState = this.activationState_;
        // This can happen in scenarios such as when you have a keyup event that blurs the element.
        if (!activationState.isActivated) {
          return;
        }

        var state = /** @type {!ActivationStateType} */_extends({}, activationState);

        if (activationState.isProgrammatic) {
          var evtObject = null;
          requestAnimationFrame(function () {
            return _this13.animateDeactivation_(evtObject, state);
          });
          this.resetActivationState_();
        } else {
          this.deregisterDeactivationHandlers_();
          requestAnimationFrame(function () {
            _this13.activationState_.hasDeactivationUXRun = true;
            _this13.animateDeactivation_(e, state);
            _this13.resetActivationState_();
          });
        }
      }

      /**
       * @param {?Event=} event Optional event containing position information.
       */

    }, {
      key: 'deactivate',
      value: function deactivate() {
        var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        this.deactivate_(event);
      }

      /**
       * @param {Event} e
       * @param {!ActivationStateType} options
       * @private
       */

    }, {
      key: 'animateDeactivation_',
      value: function animateDeactivation_(e, _ref) {
        var wasActivatedByPointer = _ref.wasActivatedByPointer,
            wasElementMadeActive = _ref.wasElementMadeActive;

        if (wasActivatedByPointer || wasElementMadeActive) {
          this.runDeactivationUXLogicIfReady_();
        }
      }
    }, {
      key: 'layout',
      value: function layout() {
        var _this14 = this;

        if (this.layoutFrame_) {
          cancelAnimationFrame(this.layoutFrame_);
        }
        this.layoutFrame_ = requestAnimationFrame(function () {
          _this14.layoutInternal_();
          _this14.layoutFrame_ = 0;
        });
      }

      /** @private */

    }, {
      key: 'layoutInternal_',
      value: function layoutInternal_() {
        var _this15 = this;

        this.frame_ = this.adapter_.computeBoundingRect();
        var maxDim = Math.max(this.frame_.height, this.frame_.width);

        // Surface diameter is treated differently for unbounded vs. bounded ripples.
        // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
        // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
        // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
        // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
        // `overflow: hidden`.
        var getBoundedRadius = function getBoundedRadius() {
          var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
          return hypotenuse + MDCRippleFoundation.numbers.PADDING;
        };

        this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius();

        // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform
        this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;
        this.fgScale_ = this.maxRadius_ / this.initialSize_;

        this.updateLayoutCssVars_();
      }

      /** @private */

    }, {
      key: 'updateLayoutCssVars_',
      value: function updateLayoutCssVars_() {
        var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
            VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
            VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
            VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
            VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;


        this.adapter_.updateCssVariable(VAR_FG_SIZE, this.initialSize_ + 'px');
        this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

        if (this.adapter_.isUnbounded()) {
          this.unboundedCoords_ = {
            left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
            top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
          };

          this.adapter_.updateCssVariable(VAR_LEFT, this.unboundedCoords_.left + 'px');
          this.adapter_.updateCssVariable(VAR_TOP, this.unboundedCoords_.top + 'px');
        }
      }

      /** @param {boolean} unbounded */

    }, {
      key: 'setUnbounded',
      value: function setUnbounded(unbounded) {
        var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

        if (unbounded) {
          this.adapter_.addClass(UNBOUNDED);
        } else {
          this.adapter_.removeClass(UNBOUNDED);
        }
      }
    }, {
      key: 'handleFocus',
      value: function handleFocus() {
        var _this16 = this;

        requestAnimationFrame(function () {
          return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
        });
      }
    }, {
      key: 'handleBlur',
      value: function handleBlur() {
        var _this17 = this;

        requestAnimationFrame(function () {
          return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
        });
      }
    }]);
    return MDCRippleFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends MDCComponent<!MDCRippleFoundation>
   */

  var MDCRipple = function (_MDCComponent) {
    inherits(MDCRipple, _MDCComponent);

    /** @param {...?} args */
    function MDCRipple() {
      var _ref;

      classCallCheck(this, MDCRipple);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      /** @type {boolean} */
      var _this = possibleConstructorReturn(this, (_ref = MDCRipple.__proto__ || Object.getPrototypeOf(MDCRipple)).call.apply(_ref, [this].concat(args)));

      _this.disabled = false;

      /** @private {boolean} */
      _this.unbounded_;
      return _this;
    }

    /**
     * @param {!Element} root
     * @param {{isUnbounded: (boolean|undefined)}=} options
     * @return {!MDCRipple}
     */


    createClass(MDCRipple, [{
      key: 'setUnbounded_',


      /**
       * Closure Compiler throws an access control error when directly accessing a
       * protected or private property inside a getter/setter, like unbounded above.
       * By accessing the protected property inside a method, we solve that problem.
       * That's why this function exists.
       * @private
       */
      value: function setUnbounded_() {
        this.foundation_.setUnbounded(this.unbounded_);
      }
    }, {
      key: 'activate',
      value: function activate() {
        this.foundation_.activate();
      }
    }, {
      key: 'deactivate',
      value: function deactivate() {
        this.foundation_.deactivate();
      }
    }, {
      key: 'layout',
      value: function layout() {
        this.foundation_.layout();
      }

      /**
       * @return {!MDCRippleFoundation}
       * @override
       */

    }, {
      key: 'getDefaultFoundation',
      value: function getDefaultFoundation() {
        return new MDCRippleFoundation$1(MDCRipple.createAdapter(this));
      }

      /** @override */

    }, {
      key: 'initialSyncWithDOM',
      value: function initialSyncWithDOM() {
        this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
      }
    }, {
      key: 'unbounded',


      /** @return {boolean} */
      get: function get$$1() {
        return this.unbounded_;
      }

      /** @param {boolean} unbounded */
      ,
      set: function set$$1(unbounded) {
        this.unbounded_ = Boolean(unbounded);
        this.setUnbounded_();
      }
    }], [{
      key: 'attachTo',
      value: function attachTo(root) {
        var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            _ref2$isUnbounded = _ref2.isUnbounded,
            isUnbounded = _ref2$isUnbounded === undefined ? undefined : _ref2$isUnbounded;

        var ripple = new MDCRipple(root);
        // Only override unbounded behavior if option is explicitly specified
        if (isUnbounded !== undefined) {
          ripple.unbounded = /** @type {boolean} */isUnbounded;
        }
        return ripple;
      }

      /**
       * @param {!RippleCapableSurface} instance
       * @return {!MDCRippleAdapter}
       */

    }, {
      key: 'createAdapter',
      value: function createAdapter(instance) {
        var MATCHES = getMatchesProperty$1(HTMLElement.prototype);

        return {
          browserSupportsCssVars: function browserSupportsCssVars() {
            return supportsCssVariables$1(window);
          },
          isUnbounded: function isUnbounded() {
            return instance.unbounded;
          },
          isSurfaceActive: function isSurfaceActive() {
            return instance.root_[MATCHES](':active');
          },
          isSurfaceDisabled: function isSurfaceDisabled() {
            return instance.disabled;
          },
          addClass: function addClass(className) {
            return instance.root_.classList.add(className);
          },
          removeClass: function removeClass(className) {
            return instance.root_.classList.remove(className);
          },
          containsEventTarget: function containsEventTarget(target) {
            return instance.root_.contains(target);
          },
          registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
            return instance.root_.addEventListener(evtType, handler, applyPassive$2());
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
            return instance.root_.removeEventListener(evtType, handler, applyPassive$2());
          },
          registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
            return document.documentElement.addEventListener(evtType, handler, applyPassive$2());
          },
          deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
            return document.documentElement.removeEventListener(evtType, handler, applyPassive$2());
          },
          registerResizeHandler: function registerResizeHandler(handler) {
            return window.addEventListener('resize', handler);
          },
          deregisterResizeHandler: function deregisterResizeHandler(handler) {
            return window.removeEventListener('resize', handler);
          },
          updateCssVariable: function updateCssVariable(varName, value) {
            return instance.root_.style.setProperty(varName, value);
          },
          computeBoundingRect: function computeBoundingRect() {
            return instance.root_.getBoundingClientRect();
          },
          getWindowPageOffset: function getWindowPageOffset() {
            return { x: window.pageXOffset, y: window.pageYOffset };
          }
        };
      }
    }]);
    return MDCRipple;
  }(MDCComponent);

  /**
   * See Material Design spec for more details on when to use ripples.
   * https://material.io/guidelines/motion/choreography.html#choreography-creation
   * @record
   */


  var RippleCapableSurface = function RippleCapableSurface() {
    classCallCheck(this, RippleCapableSurface);
  };

  /** @protected {!Element} */


  RippleCapableSurface.prototype.root_;

  /**
   * Whether or not the ripple bleeds out of the bounds of the element.
   * @type {boolean|undefined}
   */
  RippleCapableSurface.prototype.unbounded;

  /**
   * Whether or not the ripple is attached to a disabled component.
   * @type {boolean|undefined}
   */
  RippleCapableSurface.prototype.disabled;

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @record
   */

  var MDCSelectionControl = function () {
    function MDCSelectionControl() {
      classCallCheck(this, MDCSelectionControl);
    }

    createClass(MDCSelectionControl, [{
      key: 'ripple',

      /** @return {?MDCRipple} */
      get: function get$$1() {}
    }]);
    return MDCSelectionControl;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Checkbox. Provides an interface for managing
   * - classes
   * - dom
   * - event handlers
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */

  var MDCCheckboxAdapter = function () {
    function MDCCheckboxAdapter() {
      classCallCheck(this, MDCCheckboxAdapter);
    }

    createClass(MDCCheckboxAdapter, [{
      key: 'addClass',

      /** @param {string} className */
      value: function addClass(className) {}

      /** @param {string} className */

    }, {
      key: 'removeClass',
      value: function removeClass(className) {}

      /**
       * Sets an attribute with a given value on the input element.
       * @param {string} attr
       * @param {string} value
       */

    }, {
      key: 'setNativeControlAttr',
      value: function setNativeControlAttr(attr, value) {}

      /**
       * Removes an attribute from the input element.
       * @param {string} attr
       */

    }, {
      key: 'removeNativeControlAttr',
      value: function removeNativeControlAttr(attr) {}

      /** @param {!EventListener} handler */

    }, {
      key: 'registerAnimationEndHandler',
      value: function registerAnimationEndHandler(handler) {}

      /** @param {!EventListener} handler */

    }, {
      key: 'deregisterAnimationEndHandler',
      value: function deregisterAnimationEndHandler(handler) {}

      /** @param {!EventListener} handler */

    }, {
      key: 'registerChangeHandler',
      value: function registerChangeHandler(handler) {}

      /** @param {!EventListener} handler */

    }, {
      key: 'deregisterChangeHandler',
      value: function deregisterChangeHandler(handler) {}

      /** @return {!MDCSelectionControlState} */

    }, {
      key: 'getNativeControl',
      value: function getNativeControl() {}
    }, {
      key: 'forceLayout',
      value: function forceLayout() {}

      /** @return {boolean} */

    }, {
      key: 'isAttachedToDOM',
      value: function isAttachedToDOM() {}
    }]);
    return MDCCheckboxAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @const {string} */
  var ROOT = 'mdc-checkbox';

  /** @enum {string} */
  var cssClasses$2 = {
    UPGRADED: 'mdc-checkbox--upgraded',
    CHECKED: 'mdc-checkbox--checked',
    INDETERMINATE: 'mdc-checkbox--indeterminate',
    DISABLED: 'mdc-checkbox--disabled',
    ANIM_UNCHECKED_CHECKED: 'mdc-checkbox--anim-unchecked-checked',
    ANIM_UNCHECKED_INDETERMINATE: 'mdc-checkbox--anim-unchecked-indeterminate',
    ANIM_CHECKED_UNCHECKED: 'mdc-checkbox--anim-checked-unchecked',
    ANIM_CHECKED_INDETERMINATE: 'mdc-checkbox--anim-checked-indeterminate',
    ANIM_INDETERMINATE_CHECKED: 'mdc-checkbox--anim-indeterminate-checked',
    ANIM_INDETERMINATE_UNCHECKED: 'mdc-checkbox--anim-indeterminate-unchecked'
  };

  /** @enum {string} */
  var strings$2 = {
    NATIVE_CONTROL_SELECTOR: '.' + ROOT + '__native-control',
    TRANSITION_STATE_INIT: 'init',
    TRANSITION_STATE_CHECKED: 'checked',
    TRANSITION_STATE_UNCHECKED: 'unchecked',
    TRANSITION_STATE_INDETERMINATE: 'indeterminate',
    ARIA_CHECKED_ATTR: 'aria-checked',
    ARIA_CHECKED_INDETERMINATE_VALUE: 'mixed'
  };

  /** @enum {number} */
  var numbers$2 = {
    ANIM_END_LATCH_MS: 250
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @const {!Array<string>} */
  var CB_PROTO_PROPS = ['checked', 'indeterminate'];

  /**
   * @extends {MDCFoundation<!MDCCheckboxAdapter>}
   */

  var MDCCheckboxFoundation = function (_MDCFoundation) {
    inherits(MDCCheckboxFoundation, _MDCFoundation);
    createClass(MDCCheckboxFoundation, null, [{
      key: 'cssClasses',

      /** @return enum {cssClasses} */
      get: function get$$1() {
        return cssClasses$2;
      }

      /** @return enum {strings} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$2;
      }

      /** @return enum {numbers} */

    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers$2;
      }

      /** @return {!MDCCheckboxAdapter} */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCCheckboxAdapter} */{
            addClass: function addClass() /* className: string */{},
            removeClass: function removeClass() /* className: string */{},
            setNativeControlAttr: function setNativeControlAttr() /* attr: string, value: string */{},
            removeNativeControlAttr: function removeNativeControlAttr() /* attr: string */{},
            registerAnimationEndHandler: function registerAnimationEndHandler() /* handler: EventListener */{},
            deregisterAnimationEndHandler: function deregisterAnimationEndHandler() /* handler: EventListener */{},
            registerChangeHandler: function registerChangeHandler() /* handler: EventListener */{},
            deregisterChangeHandler: function deregisterChangeHandler() /* handler: EventListener */{},
            getNativeControl: function getNativeControl() /* !MDCSelectionControlState */{},
            forceLayout: function forceLayout() {},
            isAttachedToDOM: function isAttachedToDOM() /* boolean */{}
          }
        );
      }
    }]);

    function MDCCheckboxFoundation(adapter) {
      classCallCheck(this, MDCCheckboxFoundation);

      /** @private {string} */
      var _this = possibleConstructorReturn(this, (MDCCheckboxFoundation.__proto__ || Object.getPrototypeOf(MDCCheckboxFoundation)).call(this, _extends(MDCCheckboxFoundation.defaultAdapter, adapter)));

      _this.currentCheckState_ = strings$2.TRANSITION_STATE_INIT;

      /** @private {string} */
      _this.currentAnimationClass_ = '';

      /** @private {number} */
      _this.animEndLatchTimer_ = 0;

      _this.animEndHandler_ = /** @private {!EventListener} */function () {
        return _this.handleAnimationEnd();
      };

      _this.changeHandler_ = /** @private {!EventListener} */function () {
        return _this.handleChange();
      };
      return _this;
    }

    /** @override */


    createClass(MDCCheckboxFoundation, [{
      key: 'init',
      value: function init() {
        this.currentCheckState_ = this.determineCheckState_(this.getNativeControl_());
        this.updateAriaChecked_();
        this.adapter_.addClass(cssClasses$2.UPGRADED);
        this.adapter_.registerChangeHandler(this.changeHandler_);
        this.installPropertyChangeHooks_();
      }

      /** @override */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterChangeHandler(this.changeHandler_);
        this.uninstallPropertyChangeHooks_();
      }

      /** @return {boolean} */

    }, {
      key: 'isChecked',
      value: function isChecked() {
        return this.getNativeControl_().checked;
      }

      /** @param {boolean} checked */

    }, {
      key: 'setChecked',
      value: function setChecked(checked) {
        this.getNativeControl_().checked = checked;
      }

      /** @return {boolean} */

    }, {
      key: 'isIndeterminate',
      value: function isIndeterminate() {
        return this.getNativeControl_().indeterminate;
      }

      /** @param {boolean} indeterminate */

    }, {
      key: 'setIndeterminate',
      value: function setIndeterminate(indeterminate) {
        this.getNativeControl_().indeterminate = indeterminate;
      }

      /** @return {boolean} */

    }, {
      key: 'isDisabled',
      value: function isDisabled() {
        return this.getNativeControl_().disabled;
      }

      /** @param {boolean} disabled */

    }, {
      key: 'setDisabled',
      value: function setDisabled(disabled) {
        this.getNativeControl_().disabled = disabled;
        if (disabled) {
          this.adapter_.addClass(cssClasses$2.DISABLED);
        } else {
          this.adapter_.removeClass(cssClasses$2.DISABLED);
        }
      }

      /** @return {?string} */

    }, {
      key: 'getValue',
      value: function getValue() {
        return this.getNativeControl_().value;
      }

      /** @param {?string} value */

    }, {
      key: 'setValue',
      value: function setValue(value) {
        this.getNativeControl_().value = value;
      }

      /**
       * Handles the animationend event for the checkbox
       */

    }, {
      key: 'handleAnimationEnd',
      value: function handleAnimationEnd() {
        var _this2 = this;

        clearTimeout(this.animEndLatchTimer_);
        this.animEndLatchTimer_ = setTimeout(function () {
          _this2.adapter_.removeClass(_this2.currentAnimationClass_);
          _this2.adapter_.deregisterAnimationEndHandler(_this2.animEndHandler_);
        }, numbers$2.ANIM_END_LATCH_MS);
      }

      /**
       * Handles the change event for the checkbox
       */

    }, {
      key: 'handleChange',
      value: function handleChange() {
        this.transitionCheckState_();
      }

      /** @private */

    }, {
      key: 'installPropertyChangeHooks_',
      value: function installPropertyChangeHooks_() {
        var _this3 = this;

        var nativeCb = this.getNativeControl_();
        var cbProto = Object.getPrototypeOf(nativeCb);

        CB_PROTO_PROPS.forEach(function (controlState) {
          var desc = Object.getOwnPropertyDescriptor(cbProto, controlState);
          // We have to check for this descriptor, since some browsers (Safari) don't support its return.
          // See: https://bugs.webkit.org/show_bug.cgi?id=49739
          if (validDescriptor(desc)) {
            var nativeCbDesc = /** @type {!ObjectPropertyDescriptor} */{
              get: desc.get,
              set: function set$$1(state) {
                desc.set.call(nativeCb, state);
                _this3.transitionCheckState_();
              },
              configurable: desc.configurable,
              enumerable: desc.enumerable
            };
            Object.defineProperty(nativeCb, controlState, nativeCbDesc);
          }
        });
      }

      /** @private */

    }, {
      key: 'uninstallPropertyChangeHooks_',
      value: function uninstallPropertyChangeHooks_() {
        var nativeCb = this.getNativeControl_();
        var cbProto = Object.getPrototypeOf(nativeCb);

        CB_PROTO_PROPS.forEach(function (controlState) {
          var desc = /** @type {!ObjectPropertyDescriptor} */Object.getOwnPropertyDescriptor(cbProto, controlState);
          if (validDescriptor(desc)) {
            Object.defineProperty(nativeCb, controlState, desc);
          }
        });
      }

      /** @private */

    }, {
      key: 'transitionCheckState_',
      value: function transitionCheckState_() {
        var nativeCb = this.adapter_.getNativeControl();
        if (!nativeCb) {
          return;
        }
        var oldState = this.currentCheckState_;
        var newState = this.determineCheckState_(nativeCb);
        if (oldState === newState) {
          return;
        }

        this.updateAriaChecked_();

        // Check to ensure that there isn't a previously existing animation class, in case for example
        // the user interacted with the checkbox before the animation was finished.
        if (this.currentAnimationClass_.length > 0) {
          clearTimeout(this.animEndLatchTimer_);
          this.adapter_.forceLayout();
          this.adapter_.removeClass(this.currentAnimationClass_);
        }

        this.currentAnimationClass_ = this.getTransitionAnimationClass_(oldState, newState);
        this.currentCheckState_ = newState;

        // Check for parentNode so that animations are only run when the element is attached
        // to the DOM.
        if (this.adapter_.isAttachedToDOM() && this.currentAnimationClass_.length > 0) {
          this.adapter_.addClass(this.currentAnimationClass_);
          this.adapter_.registerAnimationEndHandler(this.animEndHandler_);
        }
      }

      /**
       * @param {!MDCSelectionControlState} nativeCb
       * @return {string}
       * @private
       */

    }, {
      key: 'determineCheckState_',
      value: function determineCheckState_(nativeCb) {
        var TRANSITION_STATE_INDETERMINATE = strings$2.TRANSITION_STATE_INDETERMINATE,
            TRANSITION_STATE_CHECKED = strings$2.TRANSITION_STATE_CHECKED,
            TRANSITION_STATE_UNCHECKED = strings$2.TRANSITION_STATE_UNCHECKED;


        if (nativeCb.indeterminate) {
          return TRANSITION_STATE_INDETERMINATE;
        }
        return nativeCb.checked ? TRANSITION_STATE_CHECKED : TRANSITION_STATE_UNCHECKED;
      }

      /**
       * @param {string} oldState
       * @param {string} newState
       * @return {string}
       */

    }, {
      key: 'getTransitionAnimationClass_',
      value: function getTransitionAnimationClass_(oldState, newState) {
        var TRANSITION_STATE_INIT = strings$2.TRANSITION_STATE_INIT,
            TRANSITION_STATE_CHECKED = strings$2.TRANSITION_STATE_CHECKED,
            TRANSITION_STATE_UNCHECKED = strings$2.TRANSITION_STATE_UNCHECKED;
        var _MDCCheckboxFoundatio = MDCCheckboxFoundation.cssClasses,
            ANIM_UNCHECKED_CHECKED = _MDCCheckboxFoundatio.ANIM_UNCHECKED_CHECKED,
            ANIM_UNCHECKED_INDETERMINATE = _MDCCheckboxFoundatio.ANIM_UNCHECKED_INDETERMINATE,
            ANIM_CHECKED_UNCHECKED = _MDCCheckboxFoundatio.ANIM_CHECKED_UNCHECKED,
            ANIM_CHECKED_INDETERMINATE = _MDCCheckboxFoundatio.ANIM_CHECKED_INDETERMINATE,
            ANIM_INDETERMINATE_CHECKED = _MDCCheckboxFoundatio.ANIM_INDETERMINATE_CHECKED,
            ANIM_INDETERMINATE_UNCHECKED = _MDCCheckboxFoundatio.ANIM_INDETERMINATE_UNCHECKED;


        switch (oldState) {
          case TRANSITION_STATE_INIT:
            if (newState === TRANSITION_STATE_UNCHECKED) {
              return '';
            }
          // fallthrough
          case TRANSITION_STATE_UNCHECKED:
            return newState === TRANSITION_STATE_CHECKED ? ANIM_UNCHECKED_CHECKED : ANIM_UNCHECKED_INDETERMINATE;
          case TRANSITION_STATE_CHECKED:
            return newState === TRANSITION_STATE_UNCHECKED ? ANIM_CHECKED_UNCHECKED : ANIM_CHECKED_INDETERMINATE;
          // TRANSITION_STATE_INDETERMINATE
          default:
            return newState === TRANSITION_STATE_CHECKED ? ANIM_INDETERMINATE_CHECKED : ANIM_INDETERMINATE_UNCHECKED;
        }
      }
    }, {
      key: 'updateAriaChecked_',
      value: function updateAriaChecked_() {
        // Ensure aria-checked is set to mixed if checkbox is in indeterminate state.
        if (this.isIndeterminate()) {
          this.adapter_.setNativeControlAttr(strings$2.ARIA_CHECKED_ATTR, strings$2.ARIA_CHECKED_INDETERMINATE_VALUE);
        } else {
          this.adapter_.removeNativeControlAttr(strings$2.ARIA_CHECKED_ATTR);
        }
      }

      /**
       * @return {!MDCSelectionControlState}
       * @private
       */

    }, {
      key: 'getNativeControl_',
      value: function getNativeControl_() {
        return this.adapter_.getNativeControl() || {
          checked: false,
          indeterminate: false,
          disabled: false,
          value: null
        };
      }
    }]);
    return MDCCheckboxFoundation;
  }(MDCFoundation);

  /**
   * @param {ObjectPropertyDescriptor|undefined} inputPropDesc
   * @return {boolean}
   */


  function validDescriptor(inputPropDesc) {
    return !!inputPropDesc && typeof inputPropDesc.set === 'function';
  }

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Form Field. Provides an interface for managing
   * - event handlers
   * - ripple activation
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCFormFieldAdapter = function () {
    function MDCFormFieldAdapter() {
      classCallCheck(this, MDCFormFieldAdapter);
    }

    createClass(MDCFormFieldAdapter, [{
      key: "registerInteractionHandler",

      /**
       * @param {string} type
       * @param {!EventListener} handler
       */
      value: function registerInteractionHandler(type, handler) {}

      /**
       * @param {string} type
       * @param {!EventListener} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(type, handler) {}
    }, {
      key: "activateInputRipple",
      value: function activateInputRipple() {}
    }, {
      key: "deactivateInputRipple",
      value: function deactivateInputRipple() {}
    }]);
    return MDCFormFieldAdapter;
  }();

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$3 = {
    ROOT: 'mdc-form-field'
  };

  /** @enum {string} */
  var strings$3 = {
    LABEL_SELECTOR: '.mdc-form-field > label'
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCFormFieldAdapter>}
   */

  var MDCFormFieldFoundation = function (_MDCFoundation) {
    inherits(MDCFormFieldFoundation, _MDCFoundation);
    createClass(MDCFormFieldFoundation, null, [{
      key: 'cssClasses',

      /** @return enum {cssClasses} */
      get: function get$$1() {
        return cssClasses$3;
      }

      /** @return enum {strings} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$3;
      }

      /** @return {!MDCFormFieldAdapter} */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
          activateInputRipple: function activateInputRipple() {},
          deactivateInputRipple: function deactivateInputRipple() {}
        };
      }
    }]);

    function MDCFormFieldFoundation(adapter) {
      classCallCheck(this, MDCFormFieldFoundation);

      /** @private {!EventListener} */
      var _this = possibleConstructorReturn(this, (MDCFormFieldFoundation.__proto__ || Object.getPrototypeOf(MDCFormFieldFoundation)).call(this, _extends(MDCFormFieldFoundation.defaultAdapter, adapter)));

      _this.clickHandler_ = /** @type {!EventListener} */function () {
        return _this.handleClick_();
      };
      return _this;
    }

    createClass(MDCFormFieldFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerInteractionHandler('click', this.clickHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
      }

      /** @private */

    }, {
      key: 'handleClick_',
      value: function handleClick_() {
        var _this2 = this;

        this.adapter_.activateInputRipple();
        requestAnimationFrame(function () {
          return _this2.adapter_.deactivateInputRipple();
        });
      }
    }]);
    return MDCFormFieldFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @const {Object<string, !VendorPropertyMapType>} */
  var eventTypeMap = {
    'animationstart': {
      noPrefix: 'animationstart',
      webkitPrefix: 'webkitAnimationStart',
      styleProperty: 'animation'
    },
    'animationend': {
      noPrefix: 'animationend',
      webkitPrefix: 'webkitAnimationEnd',
      styleProperty: 'animation'
    },
    'animationiteration': {
      noPrefix: 'animationiteration',
      webkitPrefix: 'webkitAnimationIteration',
      styleProperty: 'animation'
    },
    'transitionend': {
      noPrefix: 'transitionend',
      webkitPrefix: 'webkitTransitionEnd',
      styleProperty: 'transition'
    }
  };

  /** @const {Object<string, !VendorPropertyMapType>} */
  var cssPropertyMap = {
    'animation': {
      noPrefix: 'animation',
      webkitPrefix: '-webkit-animation'
    },
    'transform': {
      noPrefix: 'transform',
      webkitPrefix: '-webkit-transform'
    },
    'transition': {
      noPrefix: 'transition',
      webkitPrefix: '-webkit-transition'
    }
  };

  /**
   * @param {!Object} windowObj
   * @return {boolean}
   */
  function hasProperShape(windowObj) {
    return windowObj['document'] !== undefined && typeof windowObj['document']['createElement'] === 'function';
  }

  /**
   * @param {string} eventType
   * @return {boolean}
   */
  function eventFoundInMaps(eventType) {
    return eventType in eventTypeMap || eventType in cssPropertyMap;
  }

  /**
   * @param {string} eventType
   * @param {!Object<string, !VendorPropertyMapType>} map
   * @param {!Element} el
   * @return {string}
   */
  function getJavaScriptEventName(eventType, map, el) {
    return map[eventType].styleProperty in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
  }

  /**
   * Helper function to determine browser prefix for CSS3 animation events
   * and property names.
   * @param {!Object} windowObj
   * @param {string} eventType
   * @return {string}
   */
  function getAnimationName(windowObj, eventType) {
    if (!hasProperShape(windowObj) || !eventFoundInMaps(eventType)) {
      return eventType;
    }

    var map = /** @type {!Object<string, !VendorPropertyMapType>} */eventType in eventTypeMap ? eventTypeMap : cssPropertyMap;
    var el = windowObj['document']['createElement']('div');
    var eventName = '';

    if (map === eventTypeMap) {
      eventName = getJavaScriptEventName(eventType, map, el);
    } else {
      eventName = map[eventType].noPrefix in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
    }

    return eventName;
  }

  // Public functions to access getAnimationName() for JavaScript events or CSS
  // property names.

  var transformStyleProperties = ['transform', 'WebkitTransform', 'MozTransform', 'OTransform', 'MSTransform'];

  /**
   * @param {!Object} windowObj
   * @param {string} eventType
   * @return {string}
   */
  function getCorrectEventName(windowObj, eventType) {
    return getAnimationName(windowObj, eventType);
  }

  /**
   * @param {!Object} windowObj
   * @param {string} eventType
   * @return {string}
   */
  function getCorrectPropertyName(windowObj, eventType) {
    return getAnimationName(windowObj, eventType);
  }

  //

  var script$f = {
    name: 'mdc-checkbox',
    mixins: [DispatchFocusMixin, VMAUniqueIdMixin],
    model: {
      prop: 'checked',
      event: 'change'
    },
    props: {
      checked: [Boolean, Array],
      indeterminate: Boolean,
      disabled: Boolean,
      label: String,
      'align-end': Boolean,
      value: {
        type: [String, Number],
        default: function _default() {
          return 'on';
        }
      },
      name: String
    },
    data: function data() {
      return {
        styles: {},
        classes: {}
      };
    },

    computed: {
      hasLabel: function hasLabel() {
        return this.label || this.$slots.default;
      },
      formFieldClasses: function formFieldClasses() {
        return {
          'mdc-form-field': this.hasLabel,
          'mdc-form-field--align-end': this.hasLabel && this.alignEnd
        };
      }
    },
    watch: {
      checked: 'setChecked',
      disabled: function disabled(value) {
        this.foundation.setDisabled(value);
      },
      indeterminate: function indeterminate(value) {
        this.foundation.setIndeterminate(value);
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCCheckboxFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        setNativeControlAttr: function setNativeControlAttr(attr, value) {
          _this.$refs.control.setAttribute(attr, value);
        },
        removeNativeControlAttr: function removeNativeControlAttr(attr) {
          _this.$refs.control.removeAttribute(attr);
        },
        registerAnimationEndHandler: function registerAnimationEndHandler(handler) {
          return _this.$refs.root.addEventListener(getCorrectEventName(window, 'animationend'), handler);
        },
        deregisterAnimationEndHandler: function deregisterAnimationEndHandler(handler) {
          return _this.$refs.root.removeEventListener(getCorrectEventName(window, 'animationend'), handler);
        },
        registerChangeHandler: function registerChangeHandler(handler) {
          return _this.$refs.control.addEventListener('change', handler);
        },
        deregisterChangeHandler: function deregisterChangeHandler(handler) {
          return _this.$refs.control.removeEventListener('change', handler);
        },
        getNativeControl: function getNativeControl() {
          return _this.$refs.control;
        },
        forceLayout: function forceLayout() {
          return _this.$refs.root.offsetWidth;
        },
        isAttachedToDOM: function isAttachedToDOM() {
          return Boolean(_this.$el.parentNode);
        }
      });

      this.ripple = new RippleBase(this, {
        isUnbounded: function isUnbounded() {
          return true;
        },
        isSurfaceActive: function isSurfaceActive() {
          return RippleBase.isSurfaceActive(_this.$refs.control);
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          _this.$refs.control.addEventListener(evt, handler, applyPassive());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          _this.$refs.control.removeEventListener(evt, handler, applyPassive());
        },
        computeBoundingRect: function computeBoundingRect() {
          return _this.$refs.root.getBoundingClientRect();
        }
      });

      this.formField = new MDCFormFieldFoundation({
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          _this.$refs.label.addEventListener(type, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          _this.$refs.label.removeEventListener(type, handler);
        },
        activateInputRipple: function activateInputRipple() {
          _this.ripple && _this.ripple.activate();
        },
        deactivateInputRipple: function deactivateInputRipple() {
          _this.ripple && _this.ripple.deactivate();
        }
      });

      this.foundation.init();
      this.ripple.init();
      this.formField.init();
      this.setChecked(this.checked);
      this.foundation.setDisabled(this.disabled);
      this.foundation.setIndeterminate(this.indeterminate);
    },
    beforeDestroy: function beforeDestroy() {
      this.formField.destroy();
      this.ripple.destroy();
      this.foundation.destroy();
    },

    methods: {
      setChecked: function setChecked(checked) {
        this.foundation.setChecked(Array.isArray(checked) ? checked.indexOf(this.value) > -1 : checked);
      },
      onChange: function onChange() {
        this.$emit('update:indeterminate', this.foundation.isIndeterminate());
        var isChecked = this.foundation.isChecked();

        if (Array.isArray(this.checked)) {
          var idx = this.checked.indexOf(this.value);
          if (isChecked) {
            idx < 0 && this.$emit('change', this.checked.concat(this.value));
          } else {
            idx > -1 && this.$emit('change', this.checked.slice(0, idx).concat(this.checked.slice(idx + 1)));
          }
        } else {
          this.$emit('change', isChecked);
        }
      }
    }
  };

  /* script */
  var __vue_script__$f = script$f;

  /* template */
  var __vue_render__$d = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { staticClass: "mdc-checkbox-wrapper", class: _vm.formFieldClasses }, [_c("div", {
      ref: "root",
      staticClass: "mdc-checkbox",
      class: _vm.classes,
      style: _vm.styles
    }, [_c("input", {
      ref: "control",
      staticClass: "mdc-checkbox__native-control",
      attrs: { id: _vm.vma_uid_, name: _vm.name, type: "checkbox" },
      domProps: { value: _vm.value },
      on: { change: _vm.onChange }
    }), _vm._v(" "), _c("div", { staticClass: "mdc-checkbox__background" }, [_c("svg", {
      staticClass: "mdc-checkbox__checkmark",
      attrs: { viewBox: "0 0 24 24" }
    }, [_c("path", {
      staticClass: "mdc-checkbox__checkmark-path",
      attrs: {
        fill: "none",
        stroke: "white",
        d: "M1.73,12.91 8.1,19.28 22.79,4.59"
      }
    })]), _vm._v(" "), _c("div", { staticClass: "mdc-checkbox__mixedmark" })])]), _vm._v(" "), _c("label", { ref: "label", attrs: { for: _vm.vma_uid_ } }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2)]);
  };
  var __vue_staticRenderFns__$d = [];
  __vue_render__$d._withStripped = true;

  /* style */
  var __vue_inject_styles__$f = undefined;
  /* scoped */
  var __vue_scope_id__$f = undefined;
  /* module identifier */
  var __vue_module_identifier__$f = undefined;
  /* functional template */
  var __vue_is_functional_template__$f = false;
  /* component normalizer */
  function __vue_normalize__$f(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/checkbox/mdc-checkbox.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$f() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$f.styles || (__vue_create_injector__$f.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcCheckbox = __vue_normalize__$f({ render: __vue_render__$d, staticRenderFns: __vue_staticRenderFns__$d }, __vue_inject_styles__$f, __vue_script__$f, __vue_scope_id__$f, __vue_is_functional_template__$f, __vue_module_identifier__$f, __vue_create_injector__$f, undefined);

  var VueMDCCheckbox = BasePlugin({
    mdcCheckbox: mdcCheckbox
  });

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Chip.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Chip into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCChipAdapter = function () {
    function MDCChipAdapter() {
      classCallCheck(this, MDCChipAdapter);
    }

    createClass(MDCChipAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the root element.
       * @param {string} className
       */
      value: function addClass(className) {}

      /**
       * Removes a class from the root element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * Returns true if the root element contains the given class.
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}

      /**
       * Adds a class to the leading icon element.
       * @param {string} className
       */

    }, {
      key: "addClassToLeadingIcon",
      value: function addClassToLeadingIcon(className) {}

      /**
       * Removes a class from the leading icon element.
       * @param {string} className
       */

    }, {
      key: "removeClassFromLeadingIcon",
      value: function removeClassFromLeadingIcon(className) {}

      /**
       * Returns true if target has className, false otherwise.
       * @param {!EventTarget} target
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "eventTargetHasClass",
      value: function eventTargetHasClass(target, className) {}

      /**
       * Emits a custom "MDCChip:interaction" event denoting the chip has been
       * interacted with (typically on click or keydown).
       */

    }, {
      key: "notifyInteraction",
      value: function notifyInteraction() {}

      /**
       * Emits a custom "MDCChip:trailingIconInteraction" event denoting the trailing icon has been
       * interacted with (typically on click or keydown).
       */

    }, {
      key: "notifyTrailingIconInteraction",
      value: function notifyTrailingIconInteraction() {}

      /**
       * Emits a custom event "MDCChip:removal" denoting the chip will be removed.
       */

    }, {
      key: "notifyRemoval",
      value: function notifyRemoval() {}

      /**
       * Returns the computed property value of the given style property on the root element.
       * @param {string} propertyName
       * @return {string}
       */

    }, {
      key: "getComputedStyleValue",
      value: function getComputedStyleValue(propertyName) {}

      /**
       * Sets the property value of the given style property on the root element.
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setStyleProperty",
      value: function setStyleProperty(propertyName, value) {}
    }]);
    return MDCChipAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$4 = {
    ENTRY_ANIMATION_NAME: 'mdc-chip-entry',
    INTERACTION_EVENT: 'MDCChip:interaction',
    TRAILING_ICON_INTERACTION_EVENT: 'MDCChip:trailingIconInteraction',
    REMOVAL_EVENT: 'MDCChip:removal',
    CHECKMARK_SELECTOR: '.mdc-chip__checkmark',
    LEADING_ICON_SELECTOR: '.mdc-chip__icon--leading',
    TRAILING_ICON_SELECTOR: '.mdc-chip__icon--trailing'
  };

  /** @enum {string} */
  var cssClasses$4 = {
    CHECKMARK: 'mdc-chip__checkmark',
    CHIP_EXIT: 'mdc-chip--exit',
    HIDDEN_LEADING_ICON: 'mdc-chip__icon--leading-hidden',
    LEADING_ICON: 'mdc-chip__icon--leading',
    TRAILING_ICON: 'mdc-chip__icon--trailing',
    SELECTED: 'mdc-chip--selected'
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCChipAdapter>}
   * @final
   */

  var MDCChipFoundation = function (_MDCFoundation) {
    inherits(MDCChipFoundation, _MDCFoundation);
    createClass(MDCChipFoundation, null, [{
      key: 'strings',

      /** @return enum {string} */
      get: function get$$1() {
        return strings$4;
      }

      /** @return enum {string} */

    }, {
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$4;
      }

      /**
       * {@see MDCChipAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCChipAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCChipAdapter} */{
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {},
            addClassToLeadingIcon: function addClassToLeadingIcon() {},
            removeClassFromLeadingIcon: function removeClassFromLeadingIcon() {},
            eventTargetHasClass: function eventTargetHasClass() {},
            notifyInteraction: function notifyInteraction() {},
            notifyTrailingIconInteraction: function notifyTrailingIconInteraction() {},
            notifyRemoval: function notifyRemoval() {},
            getComputedStyleValue: function getComputedStyleValue() {},
            setStyleProperty: function setStyleProperty() {}
          }
        );
      }

      /**
       * @param {!MDCChipAdapter} adapter
       */

    }]);

    function MDCChipFoundation(adapter) {
      classCallCheck(this, MDCChipFoundation);

      /**
       * Whether a trailing icon click should immediately trigger exit/removal of the chip.
       * @private {boolean}
       * */
      var _this = possibleConstructorReturn(this, (MDCChipFoundation.__proto__ || Object.getPrototypeOf(MDCChipFoundation)).call(this, _extends(MDCChipFoundation.defaultAdapter, adapter)));

      _this.shouldRemoveOnTrailingIconClick_ = true;
      return _this;
    }

    /**
     * @return {boolean}
     */


    createClass(MDCChipFoundation, [{
      key: 'isSelected',
      value: function isSelected() {
        return this.adapter_.hasClass(cssClasses$4.SELECTED);
      }

      /**
       * @param {boolean} selected
       */

    }, {
      key: 'setSelected',
      value: function setSelected(selected) {
        if (selected) {
          this.adapter_.addClass(cssClasses$4.SELECTED);
        } else {
          this.adapter_.removeClass(cssClasses$4.SELECTED);
        }
      }

      /**
       * @return {boolean}
       */

    }, {
      key: 'getShouldRemoveOnTrailingIconClick',
      value: function getShouldRemoveOnTrailingIconClick() {
        return this.shouldRemoveOnTrailingIconClick_;
      }

      /**
       * @param {boolean} shouldRemove
       */

    }, {
      key: 'setShouldRemoveOnTrailingIconClick',
      value: function setShouldRemoveOnTrailingIconClick(shouldRemove) {
        this.shouldRemoveOnTrailingIconClick_ = shouldRemove;
      }

      /**
       * Begins the exit animation which leads to removal of the chip.
       */

    }, {
      key: 'beginExit',
      value: function beginExit() {
        this.adapter_.addClass(cssClasses$4.CHIP_EXIT);
      }

      /**
       * Handles an interaction event on the root element.
       * @param {!Event} evt
       */

    }, {
      key: 'handleInteraction',
      value: function handleInteraction(evt) {
        if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
          this.adapter_.notifyInteraction();
        }
      }

      /**
       * Handles a transition end event on the root element.
       * @param {!Event} evt
       */

    }, {
      key: 'handleTransitionEnd',
      value: function handleTransitionEnd(evt) {
        var _this2 = this;

        // Handle transition end event on the chip when it is about to be removed.
        if (this.adapter_.eventTargetHasClass( /** @type {!EventTarget} */evt.target, cssClasses$4.CHIP_EXIT)) {
          if (evt.propertyName === 'width') {
            this.adapter_.notifyRemoval();
          } else if (evt.propertyName === 'opacity') {
            // See: https://css-tricks.com/using-css-transitions-auto-dimensions/#article-header-id-5
            var chipWidth = this.adapter_.getComputedStyleValue('width');

            // On the next frame (once we get the computed width), explicitly set the chip's width
            // to its current pixel width, so we aren't transitioning out of 'auto'.
            requestAnimationFrame(function () {
              _this2.adapter_.setStyleProperty('width', chipWidth);

              // To mitigate jitter, start transitioning padding and margin before width.
              _this2.adapter_.setStyleProperty('padding', '0');
              _this2.adapter_.setStyleProperty('margin', '0');

              // On the next frame (once width is explicitly set), transition width to 0.
              requestAnimationFrame(function () {
                _this2.adapter_.setStyleProperty('width', '0');
              });
            });
          }
          return;
        }

        // Handle a transition end event on the leading icon or checkmark, since the transition end event bubbles.
        if (evt.propertyName !== 'opacity') {
          return;
        }
        if (this.adapter_.eventTargetHasClass( /** @type {!EventTarget} */evt.target, cssClasses$4.LEADING_ICON) && this.adapter_.hasClass(cssClasses$4.SELECTED)) {
          this.adapter_.addClassToLeadingIcon(cssClasses$4.HIDDEN_LEADING_ICON);
        } else if (this.adapter_.eventTargetHasClass( /** @type {!EventTarget} */evt.target, cssClasses$4.CHECKMARK) && !this.adapter_.hasClass(cssClasses$4.SELECTED)) {
          this.adapter_.removeClassFromLeadingIcon(cssClasses$4.HIDDEN_LEADING_ICON);
        }
      }

      /**
       * Handles an interaction event on the trailing icon element. This is used to
       * prevent the ripple from activating on interaction with the trailing icon.
       * @param {!Event} evt
       */

    }, {
      key: 'handleTrailingIconInteraction',
      value: function handleTrailingIconInteraction(evt) {
        evt.stopPropagation();
        if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
          this.adapter_.notifyTrailingIconInteraction();
          if (this.shouldRemoveOnTrailingIconClick_) {
            this.beginExit();
          }
        }
      }
    }]);
    return MDCChipFoundation;
  }(MDCFoundation);

  //

  var script$g = {
    name: 'mdc-chip',
    mixins: [CustomLinkMixin],
    props: {
      leadingIcon: [String],
      trailingIcon: [String],
      leadingIconClasses: [Object],
      trailingIconClasses: [Object]
    },
    inject: ['mdcChipSet'],
    data: function data() {
      return {
        classes: {
          'mdc-chip': true
        },
        styles: {}
      };
    },

    computed: {
      isFilter: function isFilter() {
        return this.mdcChipSet && this.mdcChipSet.filter;
      },
      haveleadingIcon: function haveleadingIcon() {
        return !!this.leadingIcon || this.leadingIconClasses;
      },
      havetrailingIcon: function havetrailingIcon() {
        return !!this.trailingIcon || this.trailingIconClasses;
      },
      leadingClasses: function leadingClasses() {
        return _extends({}, {
          'material-icons': !!this.leadingIcon
        }, this.leadingIconClasses);
      },
      trailingClasses: function trailingClasses() {
        return _extends({}, {
          'material-icons': !!this.trailingIcon
        }, this.trailingIconClasses);
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCChipFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        hasClass: function hasClass(className) {
          return _this.$el.classList.contains(className);
        },
        addClassToLeadingIcon: function addClassToLeadingIcon(className) {
          if (_this.haveleadingIcon) {
            _this.$refs.leadingIcon.classList.add(className);
          }
        },
        removeClassFromLeadingIcon: function removeClassFromLeadingIcon(className) {
          if (_this.haveleadingIcon) {
            _this.$refs.leadingIcon.classList.remove(className);
          }
        },
        eventTargetHasClass: function eventTargetHasClass(target, className) {
          return target.classList.contains(className);
        },
        notifyInteraction: function notifyInteraction() {
          emitCustomEvent(_this.$el, MDCChipFoundation.strings.INTERACTION_EVENT, {
            chip: _this
          }, true);
          _this.mdcChipSet && _this.mdcChipSet.handleInteraction;
        },
        notifyTrailingIconInteraction: function notifyTrailingIconInteraction() {
          emitCustomEvent(_this.$el, MDCChipFoundation.strings.TRAILING_ICON_INTERACTION_EVENT, {
            chip: _this
          }, true);
        },
        notifyRemoval: function notifyRemoval() {
          emitCustomEvent(_this.$el, MDCChipFoundation.strings.REMOVAL_EVENT, { chip: _this }, true);
        },
        getComputedStyleValue: function getComputedStyleValue(propertyName) {
          return window.getComputedStyle(_this.$el).getPropertyValue(propertyName);
        },
        setStyleProperty: function setStyleProperty(property, value) {
          return _this.$set(_this.styles, property, value);
        }
      });

      this.foundation.init();

      this.ripple = new RippleBase(this);
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.ripple.destroy();
      this.foundation.destroy();
    },

    methods: {
      handleInteraction: function handleInteraction(evt) {
        this.foundation.handleInteraction(evt);
      },
      handleTransitionEnd: function handleTransitionEnd(evt) {
        this.foundation.handleTransitionEnd(evt);
      },
      handleTrailingIconInteraction: function handleTrailingIconInteraction(evt) {
        this.foundation.handleTrailingIconInteraction(evt);
      },
      toggleSelected: function toggleSelected() {
        this.foundation.toggleSelected();
      },
      isSelected: function isSelected() {
        return this.foundation.isSelected();
      }
    }
  };

  /* script */
  var __vue_script__$g = script$g;

  /* template */
  var __vue_render__$e = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", {
      class: _vm.classes,
      style: _vm.styles,
      attrs: { tabindex: "0" },
      on: {
        click: _vm.handleInteraction,
        keydown: _vm.handleInteraction,
        transitionend: _vm.handleTransitionEnd
      }
    }, [_vm.haveleadingIcon ? _c("i", {
      ref: "leadingIcon",
      staticClass: "mdc-chip__icon mdc-chip__icon--leading",
      class: _vm.leadingClasses
    }, [_vm._v(_vm._s(_vm.leadingIcon))]) : _vm._e(), _vm._v(" "), _vm.isFilter ? _c("div", { staticClass: "mdc-chip__checkmark" }, [_c("svg", {
      staticClass: "mdc-chip__checkmark-svg",
      attrs: { viewBox: "-2 -3 30 30" }
    }, [_c("path", {
      staticClass: "mdc-chip__checkmark-path",
      attrs: {
        fill: "none",
        stroke: "black",
        d: "M1.73,12.91 8.1,19.28 22.79,4.59"
      }
    })])]) : _vm._e(), _vm._v(" "), _c("div", { staticClass: "mdc-chip__text" }, [_vm._t("default")], 2), _vm._v(" "), _vm.havetrailingIcon ? _c("i", {
      ref: "trailingIcon",
      staticClass: "mdc-chip__icon mdc-chip__icon--trailing",
      class: _vm.trailingClasses,
      attrs: { tabindex: "0", role: "button" },
      on: {
        click: _vm.handleTrailingIconInteraction,
        keydown: _vm.handleTrailingIconInteraction
      }
    }, [_vm._v(_vm._s(_vm.trailingIcon))]) : _vm._e()]);
  };
  var __vue_staticRenderFns__$e = [];
  __vue_render__$e._withStripped = true;

  /* style */
  var __vue_inject_styles__$g = undefined;
  /* scoped */
  var __vue_scope_id__$g = undefined;
  /* module identifier */
  var __vue_module_identifier__$g = undefined;
  /* functional template */
  var __vue_is_functional_template__$g = false;
  /* component normalizer */
  function __vue_normalize__$g(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/chips/mdc-chip.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$g() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$g.styles || (__vue_create_injector__$g.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcChip = __vue_normalize__$g({ render: __vue_render__$e, staticRenderFns: __vue_staticRenderFns__$e }, __vue_inject_styles__$g, __vue_script__$g, __vue_scope_id__$g, __vue_is_functional_template__$g, __vue_module_identifier__$g, __vue_create_injector__$g, undefined);

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Chip Set.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Chip Set into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */

  var MDCChipSetAdapter = function () {
    function MDCChipSetAdapter() {
      classCallCheck(this, MDCChipSetAdapter);
    }

    createClass(MDCChipSetAdapter, [{
      key: 'hasClass',

      /**
       * Returns true if the root element contains the given class name.
       * @param {string} className
       * @return {boolean}
       */
      value: function hasClass(className) {}

      /**
       * Removes the chip object from the chip set.
       * @param {!Object} chip
       */

    }, {
      key: 'removeChip',
      value: function removeChip(chip) {}
    }]);
    return MDCChipSetAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$5 = {
    CHIP_SELECTOR: '.mdc-chip'
  };

  /** @enum {string} */
  var cssClasses$5 = {
    CHOICE: 'mdc-chip-set--choice',
    FILTER: 'mdc-chip-set--filter'
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCChipSetAdapter>}
   * @final
   */

  var MDCChipSetFoundation = function (_MDCFoundation) {
    inherits(MDCChipSetFoundation, _MDCFoundation);
    createClass(MDCChipSetFoundation, null, [{
      key: 'strings',

      /** @return enum {string} */
      get: function get$$1() {
        return strings$5;
      }

      /** @return enum {string} */

    }, {
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$5;
      }

      /**
       * {@see MDCChipSetAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCChipSetAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCChipSetAdapter} */{
            hasClass: function hasClass() {},
            removeChip: function removeChip() {}
          }
        );
      }

      /**
       * @param {!MDCChipSetAdapter} adapter
       */

    }]);

    function MDCChipSetFoundation(adapter) {
      classCallCheck(this, MDCChipSetFoundation);

      /**
       * The selected chips in the set. Only used for choice chip set or filter chip set.
       * @private {!Array<!MDCChipFoundation>}
       */
      var _this = possibleConstructorReturn(this, (MDCChipSetFoundation.__proto__ || Object.getPrototypeOf(MDCChipSetFoundation)).call(this, _extends(MDCChipSetFoundation.defaultAdapter, adapter)));

      _this.selectedChips_ = [];
      return _this;
    }

    /**
     * Selects the given chip. Deselects all other chips if the chip set is of the choice variant.
     * @param {!MDCChipFoundation} chipFoundation
     */


    createClass(MDCChipSetFoundation, [{
      key: 'select',
      value: function select(chipFoundation) {
        if (this.adapter_.hasClass(cssClasses$5.CHOICE)) {
          this.deselectAll_();
        }
        chipFoundation.setSelected(true);
        this.selectedChips_.push(chipFoundation);
      }

      /**
       * Deselects the given chip.
       * @param {!MDCChipFoundation} chipFoundation
       */

    }, {
      key: 'deselect',
      value: function deselect(chipFoundation) {
        var index = this.selectedChips_.indexOf(chipFoundation);
        if (index >= 0) {
          this.selectedChips_.splice(index, 1);
        }
        chipFoundation.setSelected(false);
      }

      /** Deselects all selected chips. */

    }, {
      key: 'deselectAll_',
      value: function deselectAll_() {
        this.selectedChips_.forEach(function (chipFoundation) {
          chipFoundation.setSelected(false);
        });
        this.selectedChips_.length = 0;
      }

      /**
       * Handles a chip interaction event
       * @param {!MDCChipInteractionEventType} evt
       * @private
       */

    }, {
      key: 'handleChipInteraction',
      value: function handleChipInteraction(evt) {
        var chipFoundation = evt.detail.chip.foundation;
        if (this.adapter_.hasClass(cssClasses$5.CHOICE) || this.adapter_.hasClass(cssClasses$5.FILTER)) {
          if (chipFoundation.isSelected()) {
            this.deselect(chipFoundation);
          } else {
            this.select(chipFoundation);
          }
        }
      }

      /**
       * Handles the event when a chip is removed.
       * @param {!MDCChipInteractionEventType} evt
       * @private
       */

    }, {
      key: 'handleChipRemoval',
      value: function handleChipRemoval(evt) {
        var chip = evt.detail.chip;

        this.deselect(chip.foundation);
        this.adapter_.removeChip(chip);
      }
    }]);
    return MDCChipSetFoundation;
  }(MDCFoundation);

  //

  var script$h = {
    name: 'mdc-chip-set',
    props: {
      choice: [Boolean],
      filter: [Boolean],
      input: [Boolean]
    },
    provide: function provide() {
      return { mdcChipSet: this };
    },
    data: function data() {
      return {
        classes: {
          'mdc-chip-set': true,
          'mdc-chip-set--choice': this.choice,
          'mdc-chip-set--filter': this.filter,
          'mdc-chip-set--input': this.input
        }
      };
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCChipSetFoundation({
        hasClass: function hasClass(className) {
          return _this.$el.classList.contains(className);
        },
        removeChip: function removeChip(chip) {
          // TODO: may need refactoring
          _this.$nextTick(function () {
            return chip.$destroy();
          });
        }
      });

      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    },

    methods: {
      handleChipInteraction: function handleChipInteraction(evt) {
        this.foundation.handleChipInteraction(evt);
      },
      handleChipRemoval: function handleChipRemoval(evt) {
        this.foundation.handleChipRemoval(evt);
      }
    },
    render: function render(h) {
      var _this2 = this,
          _on;

      return h('div', {
        class: this.classes,
        on: (_on = {}, defineProperty(_on, MDCChipFoundation.strings.INTERACTION_EVENT, function (evt) {
          return _this2.handleChipInteraction(evt);
        }), defineProperty(_on, MDCChipFoundation.strings.REMOVAL_EVENT, function (evt) {
          return _this2.handleChipRemoval(evt);
        }), _on)
      }, this.$slots.default);
    }
  };

  /* script */
  var __vue_script__$h = script$h;

  /* template */

  /* style */
  var __vue_inject_styles__$h = undefined;
  /* scoped */
  var __vue_scope_id__$h = undefined;
  /* module identifier */
  var __vue_module_identifier__$h = undefined;
  /* functional template */
  var __vue_is_functional_template__$h = undefined;
  /* component normalizer */
  function __vue_normalize__$h(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/chips/mdc-chip-set.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$h() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$h.styles || (__vue_create_injector__$h.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcChipSet = __vue_normalize__$h({}, __vue_inject_styles__$h, __vue_script__$h, __vue_scope_id__$h, __vue_is_functional_template__$h, __vue_module_identifier__$h, __vue_create_injector__$h, undefined);

  var VueMDCChipSet = BasePlugin({
    mdcChip: mdcChip,
    mdcChipSet: mdcChipSet
  });

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$6 = {
    ROOT: 'mdc-dialog',
    OPEN: 'mdc-dialog--open',
    ANIMATING: 'mdc-dialog--animating',
    BACKDROP: 'mdc-dialog__backdrop',
    SCROLL_LOCK: 'mdc-dialog-scroll-lock',
    ACCEPT_BTN: 'mdc-dialog__footer__button--accept',
    CANCEL_BTN: 'mdc-dialog__footer__button--cancel'
  };

  var strings$6 = {
    OPEN_DIALOG_SELECTOR: '.mdc-dialog--open',
    DIALOG_SURFACE_SELECTOR: '.mdc-dialog__surface',
    ACCEPT_SELECTOR: '.mdc-dialog__footer__button--accept',
    ACCEPT_EVENT: 'MDCDialog:accept',
    CANCEL_EVENT: 'MDCDialog:cancel'
  };

  var numbers$3 = {
    DIALOG_ANIMATION_TIME_MS: 120
  };

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCDialogFoundation = function (_MDCFoundation) {
    inherits(MDCDialogFoundation, _MDCFoundation);
    createClass(MDCDialogFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$6;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$6;
      }
    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers$3;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          addBodyClass: function addBodyClass() /* className: string */{},
          removeBodyClass: function removeBodyClass() /* className: string */{},
          eventTargetHasClass: function eventTargetHasClass() {
            return (/* target: EventTarget, className: string */ /* boolean */false
            );
          },
          registerInteractionHandler: function registerInteractionHandler() /* evt: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* evt: string, handler: EventListener */{},
          registerSurfaceInteractionHandler: function registerSurfaceInteractionHandler() /* evt: string, handler: EventListener */{},
          deregisterSurfaceInteractionHandler: function deregisterSurfaceInteractionHandler() /* evt: string, handler: EventListener */{},
          registerDocumentKeydownHandler: function registerDocumentKeydownHandler() /* handler: EventListener */{},
          deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler() /* handler: EventListener */{},
          notifyAccept: function notifyAccept() {},
          notifyCancel: function notifyCancel() {},
          trapFocusOnSurface: function trapFocusOnSurface() {},
          untrapFocusOnSurface: function untrapFocusOnSurface() {},
          isDialog: function isDialog() {
            return (/* el: Element */ /* boolean */false
            );
          }
        };
      }
    }]);

    function MDCDialogFoundation(adapter) {
      classCallCheck(this, MDCDialogFoundation);

      var _this = possibleConstructorReturn(this, (MDCDialogFoundation.__proto__ || Object.getPrototypeOf(MDCDialogFoundation)).call(this, _extends(MDCDialogFoundation.defaultAdapter, adapter)));

      _this.isOpen_ = false;
      _this.componentClickHandler_ = function (evt) {
        if (_this.adapter_.eventTargetHasClass(evt.target, cssClasses$6.BACKDROP)) {
          _this.cancel(true);
        }
      };
      _this.dialogClickHandler_ = function (evt) {
        return _this.handleDialogClick_(evt);
      };
      _this.documentKeydownHandler_ = function (evt) {
        if (evt.key && evt.key === 'Escape' || evt.keyCode === 27) {
          _this.cancel(true);
        }
      };

      _this.timerId_ = 0;
      _this.animationTimerEnd_ = function (evt) {
        return _this.handleAnimationTimerEnd_(evt);
      };
      return _this;
    }

    createClass(MDCDialogFoundation, [{
      key: 'destroy',
      value: function destroy() {
        // Ensure that dialog is cleaned up when destroyed
        if (this.isOpen_) {
          this.close();
        }
        // Final cleanup of animating class in case the timer has not completed.
        this.adapter_.removeClass(MDCDialogFoundation.cssClasses.ANIMATING);
        clearTimeout(this.timerId_);
      }
    }, {
      key: 'open',
      value: function open() {
        this.isOpen_ = true;
        this.disableScroll_();
        this.adapter_.registerDocumentKeydownHandler(this.documentKeydownHandler_);
        this.adapter_.registerSurfaceInteractionHandler('click', this.dialogClickHandler_);
        this.adapter_.registerInteractionHandler('click', this.componentClickHandler_);
        clearTimeout(this.timerId_);
        this.timerId_ = setTimeout(this.animationTimerEnd_, MDCDialogFoundation.numbers.DIALOG_ANIMATION_TIME_MS);
        this.adapter_.addClass(MDCDialogFoundation.cssClasses.ANIMATING);
        this.adapter_.addClass(MDCDialogFoundation.cssClasses.OPEN);
      }
    }, {
      key: 'close',
      value: function close() {
        this.isOpen_ = false;
        this.enableScroll_();
        this.adapter_.deregisterSurfaceInteractionHandler('click', this.dialogClickHandler_);
        this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
        this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
        this.adapter_.untrapFocusOnSurface();
        clearTimeout(this.timerId_);
        this.timerId_ = setTimeout(this.animationTimerEnd_, MDCDialogFoundation.numbers.DIALOG_ANIMATION_TIME_MS);
        this.adapter_.addClass(MDCDialogFoundation.cssClasses.ANIMATING);
        this.adapter_.removeClass(MDCDialogFoundation.cssClasses.OPEN);
      }
    }, {
      key: 'isOpen',
      value: function isOpen() {
        return this.isOpen_;
      }
    }, {
      key: 'accept',
      value: function accept(shouldNotify) {
        if (shouldNotify) {
          this.adapter_.notifyAccept();
        }

        this.close();
      }
    }, {
      key: 'cancel',
      value: function cancel(shouldNotify) {
        if (shouldNotify) {
          this.adapter_.notifyCancel();
        }

        this.close();
      }
    }, {
      key: 'handleDialogClick_',
      value: function handleDialogClick_(evt) {
        var target = evt.target;

        if (this.adapter_.eventTargetHasClass(target, cssClasses$6.ACCEPT_BTN)) {
          this.accept(true);
        } else if (this.adapter_.eventTargetHasClass(target, cssClasses$6.CANCEL_BTN)) {
          this.cancel(true);
        }
      }
    }, {
      key: 'handleAnimationTimerEnd_',
      value: function handleAnimationTimerEnd_() {
        this.adapter_.removeClass(MDCDialogFoundation.cssClasses.ANIMATING);
        if (this.isOpen_) {
          this.adapter_.trapFocusOnSurface();
        }
      }
    }, {
      key: 'disableScroll_',
      value: function disableScroll_() {
        this.adapter_.addBodyClass(cssClasses$6.SCROLL_LOCK);
      }
    }, {
      key: 'enableScroll_',
      value: function enableScroll_() {
        this.adapter_.removeBodyClass(cssClasses$6.SCROLL_LOCK);
      }
    }]);
    return MDCDialogFoundation;
  }(MDCFoundation);

  var tabbable = function (el, options) {
    options = options || {};

    var elementDocument = el.ownerDocument || el;
    var basicTabbables = [];
    var orderedTabbables = [];

    // A node is "available" if
    // - it's computed style
    var isUnavailable = createIsUnavailable(elementDocument);

    var candidateSelectors = ['input', 'select', 'a[href]', 'textarea', 'button', '[tabindex]'];

    var candidates = el.querySelectorAll(candidateSelectors.join(','));

    if (options.includeContainer) {
      var matches = Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

      if (candidateSelectors.some(function (candidateSelector) {
        return matches.call(el, candidateSelector);
      })) {
        candidates = Array.prototype.slice.apply(candidates);
        candidates.unshift(el);
      }
    }

    var candidate, candidateIndexAttr, candidateIndex;
    for (var i = 0, l = candidates.length; i < l; i++) {
      candidate = candidates[i];
      candidateIndexAttr = parseInt(candidate.getAttribute('tabindex'), 10);
      candidateIndex = isNaN(candidateIndexAttr) ? candidate.tabIndex : candidateIndexAttr;

      if (candidateIndex < 0 || candidate.tagName === 'INPUT' && candidate.type === 'hidden' || candidate.disabled || isUnavailable(candidate, elementDocument)) {
        continue;
      }

      if (candidateIndex === 0) {
        basicTabbables.push(candidate);
      } else {
        orderedTabbables.push({
          index: i,
          tabIndex: candidateIndex,
          node: candidate
        });
      }
    }

    var tabbableNodes = orderedTabbables.sort(function (a, b) {
      return a.tabIndex === b.tabIndex ? a.index - b.index : a.tabIndex - b.tabIndex;
    }).map(function (a) {
      return a.node;
    });

    Array.prototype.push.apply(tabbableNodes, basicTabbables);

    return tabbableNodes;
  };

  function createIsUnavailable(elementDocument) {
    // Node cache must be refreshed on every check, in case
    // the content of the element has changed
    var isOffCache = [];

    // "off" means `display: none;`, as opposed to "hidden",
    // which means `visibility: hidden;`. getComputedStyle
    // accurately reflects visiblity in context but not
    // "off" state, so we need to recursively check parents.

    function isOff(node, nodeComputedStyle) {
      if (node === elementDocument.documentElement) return false;

      // Find the cached node (Array.prototype.find not available in IE9)
      for (var i = 0, length = isOffCache.length; i < length; i++) {
        if (isOffCache[i][0] === node) return isOffCache[i][1];
      }

      nodeComputedStyle = nodeComputedStyle || elementDocument.defaultView.getComputedStyle(node);

      var result = false;

      if (nodeComputedStyle.display === 'none') {
        result = true;
      } else if (node.parentNode) {
        result = isOff(node.parentNode);
      }

      isOffCache.push([node, result]);

      return result;
    }

    return function isUnavailable(node) {
      if (node === elementDocument.documentElement) return false;

      var computedStyle = elementDocument.defaultView.getComputedStyle(node);

      if (isOff(node, computedStyle)) return true;

      return computedStyle.visibility === 'hidden';
    };
  }

  var listeningFocusTrap = null;

  function focusTrap(element, userOptions) {
    var tabbableNodes = [];
    var firstTabbableNode = null;
    var lastTabbableNode = null;
    var nodeFocusedBeforeActivation = null;
    var active = false;
    var paused = false;
    var tabEvent = null;

    var container = typeof element === 'string' ? document.querySelector(element) : element;

    var config = userOptions || {};
    config.returnFocusOnDeactivate = userOptions && userOptions.returnFocusOnDeactivate !== undefined ? userOptions.returnFocusOnDeactivate : true;
    config.escapeDeactivates = userOptions && userOptions.escapeDeactivates !== undefined ? userOptions.escapeDeactivates : true;

    var trap = {
      activate: activate,
      deactivate: deactivate,
      pause: pause,
      unpause: unpause
    };

    return trap;

    function activate(activateOptions) {
      if (active) return;

      var defaultedActivateOptions = {
        onActivate: activateOptions && activateOptions.onActivate !== undefined ? activateOptions.onActivate : config.onActivate
      };

      active = true;
      paused = false;
      nodeFocusedBeforeActivation = document.activeElement;

      if (defaultedActivateOptions.onActivate) {
        defaultedActivateOptions.onActivate();
      }

      addListeners();
      return trap;
    }

    function deactivate(deactivateOptions) {
      if (!active) return;

      var defaultedDeactivateOptions = {
        returnFocus: deactivateOptions && deactivateOptions.returnFocus !== undefined ? deactivateOptions.returnFocus : config.returnFocusOnDeactivate,
        onDeactivate: deactivateOptions && deactivateOptions.onDeactivate !== undefined ? deactivateOptions.onDeactivate : config.onDeactivate
      };

      removeListeners();

      if (defaultedDeactivateOptions.onDeactivate) {
        defaultedDeactivateOptions.onDeactivate();
      }

      if (defaultedDeactivateOptions.returnFocus) {
        setTimeout(function () {
          tryFocus(nodeFocusedBeforeActivation);
        }, 0);
      }

      active = false;
      paused = false;
      return this;
    }

    function pause() {
      if (paused || !active) return;
      paused = true;
      removeListeners();
    }

    function unpause() {
      if (!paused || !active) return;
      paused = false;
      addListeners();
    }

    function addListeners() {
      if (!active) return;

      // There can be only one listening focus trap at a time
      if (listeningFocusTrap) {
        listeningFocusTrap.pause();
      }
      listeningFocusTrap = trap;

      updateTabbableNodes();
      // Ensure that the focused element doesn't capture the event that caused the focus trap activation
      setTimeout(function () {
        tryFocus(firstFocusNode());
      }, 0);
      document.addEventListener('focus', checkFocus, true);
      document.addEventListener('click', checkClick, true);
      document.addEventListener('mousedown', checkPointerDown, true);
      document.addEventListener('touchstart', checkPointerDown, true);
      document.addEventListener('keydown', checkKey, true);

      return trap;
    }

    function removeListeners() {
      if (!active || listeningFocusTrap !== trap) return;

      document.removeEventListener('focus', checkFocus, true);
      document.removeEventListener('click', checkClick, true);
      document.removeEventListener('mousedown', checkPointerDown, true);
      document.removeEventListener('touchstart', checkPointerDown, true);
      document.removeEventListener('keydown', checkKey, true);

      listeningFocusTrap = null;

      return trap;
    }

    function getNodeForOption(optionName) {
      var optionValue = config[optionName];
      var node = optionValue;
      if (!optionValue) {
        return null;
      }
      if (typeof optionValue === 'string') {
        node = document.querySelector(optionValue);
        if (!node) {
          throw new Error('`' + optionName + '` refers to no known node');
        }
      }
      if (typeof optionValue === 'function') {
        node = optionValue();
        if (!node) {
          throw new Error('`' + optionName + '` did not return a node');
        }
      }
      return node;
    }

    function firstFocusNode() {
      var node;
      if (getNodeForOption('initialFocus') !== null) {
        node = getNodeForOption('initialFocus');
      } else if (container.contains(document.activeElement)) {
        node = document.activeElement;
      } else {
        node = tabbableNodes[0] || getNodeForOption('fallbackFocus');
      }

      if (!node) {
        throw new Error('You can\'t have a focus-trap without at least one focusable element');
      }

      return node;
    }

    // This needs to be done on mousedown and touchstart instead of click
    // so that it precedes the focus event
    function checkPointerDown(e) {
      if (config.clickOutsideDeactivates && !container.contains(e.target)) {
        deactivate({ returnFocus: false });
      }
    }

    function checkClick(e) {
      if (config.clickOutsideDeactivates) return;
      if (container.contains(e.target)) return;
      e.preventDefault();
      e.stopImmediatePropagation();
    }

    function checkFocus(e) {
      if (container.contains(e.target)) return;
      e.preventDefault();
      e.stopImmediatePropagation();
      // Checking for a blur method here resolves a Firefox issue (#15)
      if (typeof e.target.blur === 'function') e.target.blur();

      if (tabEvent) {
        readjustFocus(tabEvent);
      }
    }

    function checkKey(e) {
      if (e.key === 'Tab' || e.keyCode === 9) {
        handleTab(e);
      }

      if (config.escapeDeactivates !== false && isEscapeEvent(e)) {
        deactivate();
      }
    }

    function handleTab(e) {
      updateTabbableNodes();

      if (e.target.hasAttribute('tabindex') && Number(e.target.getAttribute('tabindex')) < 0) {
        return tabEvent = e;
      }

      e.preventDefault();
      var currentFocusIndex = tabbableNodes.indexOf(e.target);

      if (e.shiftKey) {
        if (e.target === firstTabbableNode || tabbableNodes.indexOf(e.target) === -1) {
          return tryFocus(lastTabbableNode);
        }
        return tryFocus(tabbableNodes[currentFocusIndex - 1]);
      }

      if (e.target === lastTabbableNode) return tryFocus(firstTabbableNode);

      tryFocus(tabbableNodes[currentFocusIndex + 1]);
    }

    function updateTabbableNodes() {
      tabbableNodes = tabbable(container);
      firstTabbableNode = tabbableNodes[0];
      lastTabbableNode = tabbableNodes[tabbableNodes.length - 1];
    }

    function readjustFocus(e) {
      if (e.shiftKey) return tryFocus(lastTabbableNode);

      tryFocus(firstTabbableNode);
    }
  }

  function isEscapeEvent(e) {
    return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;
  }

  function tryFocus(node) {
    if (!node || !node.focus) return;
    if (node === document.activeElement) return;

    node.focus();
    if (node.tagName.toLowerCase() === 'input') {
      node.select();
    }
  }

  var focusTrap_1 = focusTrap;

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  function createFocusTrapInstance(surfaceEl, acceptButtonEl) {
    var focusTrapFactory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : focusTrap_1;

    return focusTrapFactory(surfaceEl, {
      initialFocus: acceptButtonEl,
      clickOutsideDeactivates: true
    });
  }

  //

  var script$i = {
    name: 'mdc-dialog',
    components: {
      mdcButton: mdcButton
    },
    mixins: [VMAUniqueIdMixin],
    model: {
      prop: 'open',
      event: 'change'
    },
    props: {
      title: { type: String },
      accept: { type: String, default: 'Ok' },
      acceptDisabled: Boolean,
      cancel: { type: String },
      accent: Boolean,
      scrollable: Boolean,
      open: Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-theme--dark': this.dark
        },
        styles: {},
        surfaceClasses: {},
        bodyClasses: {
          'mdc-dialog__body--scrollable': this.scrollable
        }
      };
    },

    watch: { open: 'onOpen_' },
    mounted: function mounted() {
      var _this = this;

      if (this.accept) {
        this.focusTrap = createFocusTrapInstance(this.$refs.surface, this.$refs.accept);
      }

      this.foundation = new MDCDialogFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        addBodyClass: function addBodyClass(className) {
          return document.body.classList.add(className);
        },
        removeBodyClass: function removeBodyClass(className) {
          return document.body.classList.remove(className);
        },
        eventTargetHasClass: function eventTargetHasClass(target, className) {
          return target.classList.contains(className);
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          return _this.$refs.root.addEventListener(evt, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          return _this.$refs.root.removeEventListener(evt, handler);
        },
        registerSurfaceInteractionHandler: function registerSurfaceInteractionHandler() /*evt, handler*/{
          // VMA_HACK: handle button clicks ourselves
          // this.$refs.surface.addEventListener(evt, handler)
        },
        deregisterSurfaceInteractionHandler: function deregisterSurfaceInteractionHandler() /*evt, handler*/{
          // VMA_HACK: handle button clicks ourselves
          // this.$refs.surface.removeEventListener(evt, handler)
        },
        registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
          return document.addEventListener('keydown', handler);
        },
        deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
          return document.removeEventListener('keydown', handler);
        },
        notifyAccept: function notifyAccept() {
          _this.$emit('change', false);
          _this.$emit('accept');
        },
        notifyCancel: function notifyCancel() {
          _this.$emit('change', false);
          _this.$emit('cancel');
        },
        trapFocusOnSurface: function trapFocusOnSurface() {
          return _this.focusTrap && _this.focusTrap.activate();
        },
        untrapFocusOnSurface: function untrapFocusOnSurface() {
          return _this.focusTrap && _this.focusTrap.deactivate();
        },
        isDialog: function isDialog(el) {
          return _this.$refs.surface === el;
        }
      });

      this.foundation.init();
      this.open && this.foundation.open();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    },

    methods: {
      onOpen_: function onOpen_(value) {
        if (value) {
          this.foundation.open();
        } else {
          this.foundation.close();
        }
      },
      onCancel: function onCancel() {
        var _this2 = this;

        if (this.$listeners['validateCancel']) {
          this.$emit('validateCancel', {
            cancel: function cancel() {
              var notify = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

              // if notify = false, the dialog will close
              // but the notifyAccept method will not be called
              // so we need to notify listeners the open state
              // is changing.
              if (!notify) {
                _this2.$emit('change', false);
              }
              _this2.foundation.cancel(notify);
            }
          });
        } else {
          this.foundation.cancel(true);
        }
      },
      onAccept: function onAccept() {
        var _this3 = this;

        if (this.$listeners['validate']) {
          this.$emit('validate', {
            accept: function accept() {
              var notify = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

              // if notify = false, the dialog will close
              // but the notifyAccept method will not be called
              // so we need to notify listeners the open state
              // is changing.
              if (!notify) {
                _this3.$emit('change', false);
              }
              _this3.foundation.accept(notify);
            }
          });
        } else {
          this.foundation.accept(true);
        }
      },
      show: function show() {
        this.foundation.open();
      },
      close: function close() {
        this.foundation.close();
      }
    }
  };

  /* script */
  var __vue_script__$i = script$i;

  /* template */
  var __vue_render__$f = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("aside", {
      ref: "root",
      staticClass: "mdc-dialog",
      class: _vm.classes,
      style: _vm.styles,
      attrs: {
        "aria-labelledby": "label" + _vm.vma_uid_,
        "aria-describedby": "desc" + _vm.vma_uid_,
        role: "alertdialog"
      }
    }, [_c("div", {
      ref: "surface",
      staticClass: "mdc-dialog__surface",
      class: _vm.surfaceClasses
    }, [_vm.title ? _c("header", { staticClass: "mdc-dialog__header" }, [_c("h2", {
      staticClass: "mdc-dialog__header__title",
      attrs: { id: "label" + _vm.vma_uid_ }
    }, [_vm._v("\n        " + _vm._s(_vm.title) + "\n      ")])]) : _vm._e(), _vm._v(" "), _c("section", {
      staticClass: "mdc-dialog__body",
      class: _vm.bodyClasses,
      attrs: { id: "desc" + _vm.vma_uid_ }
    }, [_vm._t("default")], 2), _vm._v(" "), _vm.accept || _vm.cancel ? _c("footer", { staticClass: "mdc-dialog__footer" }, [_vm.cancel ? _c("mdcButton", {
      ref: "cancel",
      staticClass: "mdc-dialog__footer__button mdc-dialog__footer__button--cancel",
      class: { "mdc-dialog__action": _vm.accent },
      on: { click: _vm.onCancel }
    }, [_vm._v(_vm._s(_vm.cancel))]) : _vm._e(), _vm._v(" "), _c("mdcButton", {
      ref: "accept",
      staticClass: "mdc-dialog__footer__button mdc-dialog__footer__button--accept",
      class: { "mdc-dialog__action": _vm.accent },
      attrs: { disabled: _vm.acceptDisabled },
      on: { click: _vm.onAccept }
    }, [_vm._v(_vm._s(_vm.accept))])], 1) : _vm._e()]), _vm._v(" "), _c("div", { staticClass: "mdc-dialog__backdrop" })]);
  };
  var __vue_staticRenderFns__$f = [];
  __vue_render__$f._withStripped = true;

  /* style */
  var __vue_inject_styles__$i = undefined;
  /* scoped */
  var __vue_scope_id__$i = undefined;
  /* module identifier */
  var __vue_module_identifier__$i = undefined;
  /* functional template */
  var __vue_is_functional_template__$i = false;
  /* component normalizer */
  function __vue_normalize__$i(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/dialog/mdc-dialog.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$i() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$i.styles || (__vue_create_injector__$i.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcDialog = __vue_normalize__$i({ render: __vue_render__$f, staticRenderFns: __vue_staticRenderFns__$f }, __vue_inject_styles__$i, __vue_script__$i, __vue_scope_id__$i, __vue_is_functional_template__$i, __vue_module_identifier__$i, __vue_create_injector__$i, undefined);

  var VueMDCDialog = BasePlugin({
    mdcDialog: mdcDialog
  });

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //

  var script$j = {
    name: 'mdc-permanent-drawer',
    props: {
      'toolbar-spacer': Boolean
    }
  };

  /* script */
  var __vue_script__$j = script$j;

  /* template */
  var __vue_render__$g = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("nav", {
      staticClass: "mdc-permanent-drawer mdc-drawer--permanent mdc-typography"
    }, [_c("nav", { staticClass: "mdc-drawer__content" }, [_vm.toolbarSpacer ? _c("div", { staticClass: "mdc-drawer__toolbar-spacer" }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2)]);
  };
  var __vue_staticRenderFns__$g = [];
  __vue_render__$g._withStripped = true;

  /* style */
  var __vue_inject_styles__$j = undefined;
  /* scoped */
  var __vue_scope_id__$j = undefined;
  /* module identifier */
  var __vue_module_identifier__$j = undefined;
  /* functional template */
  var __vue_is_functional_template__$j = false;
  /* component normalizer */
  function __vue_normalize__$j(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/drawer/mdc-permanent-drawer.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$j() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$j.styles || (__vue_create_injector__$j.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcPermanentDrawer = __vue_normalize__$j({ render: __vue_render__$g, staticRenderFns: __vue_staticRenderFns__$g }, __vue_inject_styles__$j, __vue_script__$j, __vue_scope_id__$j, __vue_is_functional_template__$j, __vue_module_identifier__$j, __vue_create_injector__$j, undefined);

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var FOCUSABLE_ELEMENTS = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), ' + 'button:not([disabled]), iframe, object, embed, [tabindex], [contenteditable]';

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCSlidableDrawerFoundation = function (_MDCFoundation) {
    inherits(MDCSlidableDrawerFoundation, _MDCFoundation);
    createClass(MDCSlidableDrawerFoundation, null, [{
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          hasClass: function hasClass() /* className: string */{},
          hasNecessaryDom: function hasNecessaryDom() {
            return (/* boolean */false
            );
          },
          registerInteractionHandler: function registerInteractionHandler() /* evt: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* evt: string, handler: EventListener */{},
          registerDrawerInteractionHandler: function registerDrawerInteractionHandler() /* evt: string, handler: EventListener */{},
          deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler() /* evt: string, handler: EventListener */{},
          registerTransitionEndHandler: function registerTransitionEndHandler() /* handler: EventListener */{},
          deregisterTransitionEndHandler: function deregisterTransitionEndHandler() /* handler: EventListener */{},
          registerDocumentKeydownHandler: function registerDocumentKeydownHandler() /* handler: EventListener */{},
          deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler() /* handler: EventListener */{},
          setTranslateX: function setTranslateX() /* value: number | null */{},
          getFocusableElements: function getFocusableElements() /* NodeList */{},
          saveElementTabState: function saveElementTabState() /* el: Element */{},
          restoreElementTabState: function restoreElementTabState() /* el: Element */{},
          makeElementUntabbable: function makeElementUntabbable() /* el: Element */{},
          notifyOpen: function notifyOpen() {},
          notifyClose: function notifyClose() {},
          isRtl: function isRtl() {
            return (/* boolean */false
            );
          },
          getDrawerWidth: function getDrawerWidth() {
            return (/* number */0
            );
          }
        };
      }
    }]);

    function MDCSlidableDrawerFoundation(adapter, rootCssClass, animatingCssClass, openCssClass) {
      classCallCheck(this, MDCSlidableDrawerFoundation);

      var _this = possibleConstructorReturn(this, (MDCSlidableDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCSlidableDrawerFoundation)).call(this, _extends(MDCSlidableDrawerFoundation.defaultAdapter, adapter)));

      _this.rootCssClass_ = rootCssClass;
      _this.animatingCssClass_ = animatingCssClass;
      _this.openCssClass_ = openCssClass;

      _this.transitionEndHandler_ = function (evt) {
        return _this.handleTransitionEnd_(evt);
      };

      _this.inert_ = false;

      _this.componentTouchStartHandler_ = function (evt) {
        return _this.handleTouchStart_(evt);
      };
      _this.componentTouchMoveHandler_ = function (evt) {
        return _this.handleTouchMove_(evt);
      };
      _this.componentTouchEndHandler_ = function (evt) {
        return _this.handleTouchEnd_(evt);
      };
      _this.documentKeydownHandler_ = function (evt) {
        if (evt.key && evt.key === 'Escape' || evt.keyCode === 27) {
          _this.close();
        }
      };
      return _this;
    }

    createClass(MDCSlidableDrawerFoundation, [{
      key: 'init',
      value: function init() {
        var ROOT = this.rootCssClass_;
        var OPEN = this.openCssClass_;

        if (!this.adapter_.hasClass(ROOT)) {
          throw new Error(ROOT + ' class required in root element.');
        }

        if (!this.adapter_.hasNecessaryDom()) {
          throw new Error('Required DOM nodes missing in ' + ROOT + ' component.');
        }

        if (this.adapter_.hasClass(OPEN)) {
          this.isOpen_ = true;
        } else {
          this.detabinate_();
          this.isOpen_ = false;
        }

        this.adapter_.registerDrawerInteractionHandler('touchstart', this.componentTouchStartHandler_);
        this.adapter_.registerInteractionHandler('touchmove', this.componentTouchMoveHandler_);
        this.adapter_.registerInteractionHandler('touchend', this.componentTouchEndHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterDrawerInteractionHandler('touchstart', this.componentTouchStartHandler_);
        this.adapter_.deregisterInteractionHandler('touchmove', this.componentTouchMoveHandler_);
        this.adapter_.deregisterInteractionHandler('touchend', this.componentTouchEndHandler_);
        // Deregister the document keydown handler just in case the component is destroyed while the menu is open.
        this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
      }
    }, {
      key: 'open',
      value: function open() {
        this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
        this.adapter_.registerDocumentKeydownHandler(this.documentKeydownHandler_);
        this.adapter_.addClass(this.animatingCssClass_);
        this.adapter_.addClass(this.openCssClass_);
        this.retabinate_();
        // Debounce multiple calls
        if (!this.isOpen_) {
          this.adapter_.notifyOpen();
        }
        this.isOpen_ = true;
      }
    }, {
      key: 'close',
      value: function close() {
        this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
        this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
        this.adapter_.addClass(this.animatingCssClass_);
        this.adapter_.removeClass(this.openCssClass_);
        this.detabinate_();
        // Debounce multiple calls
        if (this.isOpen_) {
          this.adapter_.notifyClose();
        }
        this.isOpen_ = false;
      }
    }, {
      key: 'isOpen',
      value: function isOpen() {
        return this.isOpen_;
      }

      /**
       *  Render all children of the drawer inert when it's closed.
       */

    }, {
      key: 'detabinate_',
      value: function detabinate_() {
        if (this.inert_) {
          return;
        }

        var elements = this.adapter_.getFocusableElements();
        if (elements) {
          for (var i = 0; i < elements.length; i++) {
            this.adapter_.saveElementTabState(elements[i]);
            this.adapter_.makeElementUntabbable(elements[i]);
          }
        }

        this.inert_ = true;
      }

      /**
       *  Make all children of the drawer tabbable again when it's open.
       */

    }, {
      key: 'retabinate_',
      value: function retabinate_() {
        if (!this.inert_) {
          return;
        }

        var elements = this.adapter_.getFocusableElements();
        if (elements) {
          for (var i = 0; i < elements.length; i++) {
            this.adapter_.restoreElementTabState(elements[i]);
          }
        }

        this.inert_ = false;
      }
    }, {
      key: 'handleTouchStart_',
      value: function handleTouchStart_(evt) {
        if (!this.adapter_.hasClass(this.openCssClass_)) {
          return;
        }
        if (evt.pointerType && evt.pointerType !== 'touch') {
          return;
        }

        this.direction_ = this.adapter_.isRtl() ? -1 : 1;
        this.drawerWidth_ = this.adapter_.getDrawerWidth();
        this.startX_ = evt.touches ? evt.touches[0].pageX : evt.pageX;
        this.currentX_ = this.startX_;

        this.updateRaf_ = requestAnimationFrame(this.updateDrawer_.bind(this));
      }
    }, {
      key: 'handleTouchMove_',
      value: function handleTouchMove_(evt) {
        if (evt.pointerType && evt.pointerType !== 'touch') {
          return;
        }

        this.currentX_ = evt.touches ? evt.touches[0].pageX : evt.pageX;
      }
    }, {
      key: 'handleTouchEnd_',
      value: function handleTouchEnd_(evt) {
        if (evt.pointerType && evt.pointerType !== 'touch') {
          return;
        }

        this.prepareForTouchEnd_();

        // Did the user close the drawer by more than 50%?
        if (Math.abs(this.newPosition_ / this.drawerWidth_) >= 0.5) {
          this.close();
        } else {
          // Triggering an open here means we'll get a nice animation back to the fully open state.
          this.open();
        }
      }
    }, {
      key: 'prepareForTouchEnd_',
      value: function prepareForTouchEnd_() {
        cancelAnimationFrame(this.updateRaf_);
        this.adapter_.setTranslateX(null);
      }
    }, {
      key: 'updateDrawer_',
      value: function updateDrawer_() {
        this.updateRaf_ = requestAnimationFrame(this.updateDrawer_.bind(this));
        this.adapter_.setTranslateX(this.newPosition_);
      }
    }, {
      key: 'isRootTransitioningEventTarget_',
      value: function isRootTransitioningEventTarget_() {
        // Classes extending MDCSlidableDrawerFoundation should implement this method to return true or false
        // if the event target is the root event target currently transitioning.
        return false;
      }
    }, {
      key: 'handleTransitionEnd_',
      value: function handleTransitionEnd_(evt) {
        if (this.isRootTransitioningEventTarget_(evt.target)) {
          this.adapter_.removeClass(this.animatingCssClass_);
          this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);
        }
      }
    }, {
      key: 'newPosition_',
      get: function get$$1() {
        var newPos = null;

        if (this.direction_ === 1) {
          newPos = Math.min(0, this.currentX_ - this.startX_);
        } else {
          newPos = Math.max(0, this.currentX_ - this.startX_);
        }

        return newPos;
      }
    }]);
    return MDCSlidableDrawerFoundation;
  }(MDCFoundation);

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$7 = {
    ROOT: 'mdc-drawer--persistent',
    OPEN: 'mdc-drawer--open',
    ANIMATING: 'mdc-drawer--animating'
  };

  var strings$7 = {
    DRAWER_SELECTOR: '.mdc-drawer--persistent .mdc-drawer__drawer',
    FOCUSABLE_ELEMENTS: FOCUSABLE_ELEMENTS,
    OPEN_EVENT: 'MDCPersistentDrawer:open',
    CLOSE_EVENT: 'MDCPersistentDrawer:close'
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCPersistentDrawerFoundation = function (_MDCSlidableDrawerFou) {
    inherits(MDCPersistentDrawerFoundation, _MDCSlidableDrawerFou);
    createClass(MDCPersistentDrawerFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$7;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$7;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return _extends(MDCSlidableDrawerFoundation.defaultAdapter, {
          isDrawer: function isDrawer() {
            return false;
          }
        });
      }
    }]);

    function MDCPersistentDrawerFoundation(adapter) {
      classCallCheck(this, MDCPersistentDrawerFoundation);
      return possibleConstructorReturn(this, (MDCPersistentDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCPersistentDrawerFoundation)).call(this, _extends(MDCPersistentDrawerFoundation.defaultAdapter, adapter), MDCPersistentDrawerFoundation.cssClasses.ROOT, MDCPersistentDrawerFoundation.cssClasses.ANIMATING, MDCPersistentDrawerFoundation.cssClasses.OPEN));
    }

    createClass(MDCPersistentDrawerFoundation, [{
      key: 'isRootTransitioningEventTarget_',
      value: function isRootTransitioningEventTarget_(el) {
        return this.adapter_.isDrawer(el);
      }
    }]);
    return MDCPersistentDrawerFoundation;
  }(MDCSlidableDrawerFoundation);

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var TAB_DATA = 'data-mdc-tabindex';
  var TAB_DATA_HANDLED = 'data-mdc-tabindex-handled';

  var storedTransformPropertyName_ = void 0;
  var supportsPassive_$3 = void 0;

  // Remap touch events to pointer events, if the browser doesn't support touch events.
  function remapEvent(eventName) {
    var globalObj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;

    if (!('ontouchstart' in globalObj.document)) {
      switch (eventName) {
        case 'touchstart':
          return 'pointerdown';
        case 'touchmove':
          return 'pointermove';
        case 'touchend':
          return 'pointerup';
        default:
          return eventName;
      }
    }

    return eventName;
  }

  // Choose the correct transform property to use on the current browser.
  function getTransformPropertyName() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (storedTransformPropertyName_ === undefined || forceRefresh) {
      var el = globalObj.document.createElement('div');
      var transformPropertyName = 'transform' in el.style ? 'transform' : '-webkit-transform';
      storedTransformPropertyName_ = transformPropertyName;
    }

    return storedTransformPropertyName_;
  }

  // Determine whether the current browser supports CSS properties.
  function supportsCssCustomProperties() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;

    if ('CSS' in globalObj) {
      return globalObj.CSS.supports('(--color: red)');
    }
    return false;
  }

  // Determine whether the current browser supports passive event listeners, and if so, use them.
  function applyPassive$3() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (supportsPassive_$3 === undefined || forceRefresh) {
      var isSupported = false;
      try {
        globalObj.document.addEventListener('test', null, { get passive() {
            isSupported = true;
          } });
      } catch (e) {}

      supportsPassive_$3 = isSupported;
    }

    return supportsPassive_$3 ? { passive: true } : false;
  }

  // Save the tab state for an element.
  function saveElementTabState(el) {
    if (el.hasAttribute('tabindex')) {
      el.setAttribute(TAB_DATA, el.getAttribute('tabindex'));
    }
    el.setAttribute(TAB_DATA_HANDLED, true);
  }

  // Restore the tab state for an element, if it was saved.
  function restoreElementTabState(el) {
    // Only modify elements we've already handled, in case anything was dynamically added since we saved state.
    if (el.hasAttribute(TAB_DATA_HANDLED)) {
      if (el.hasAttribute(TAB_DATA)) {
        el.setAttribute('tabindex', el.getAttribute(TAB_DATA));
        el.removeAttribute(TAB_DATA);
      } else {
        el.removeAttribute('tabindex');
      }
      el.removeAttribute(TAB_DATA_HANDLED);
    }
  }

  //

  var script$k = {
    name: 'mdc-persistent-drawer',
    model: {
      prop: 'open',
      event: 'change'
    },
    props: {
      'toolbar-spacer': Boolean,
      open: Boolean
    },
    data: function data() {
      return {
        classes: {}
      };
    },

    watch: {
      open: '_refresh'
    },
    mounted: function mounted() {
      var _this = this;

      var FOCUSABLE_ELEMENTS = MDCPersistentDrawerFoundation.strings.FOCUSABLE_ELEMENTS;


      this.foundation = new MDCPersistentDrawerFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.classes, className);
        },
        hasClass: function hasClass(className) {
          return _this.$el.classList.contains(className);
        },
        hasNecessaryDom: function hasNecessaryDom() {
          return !!_this.$refs.drawer;
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          _this.$el.addEventListener(remapEvent(evt), handler, applyPassive$3());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          _this.$el.removeEventListener(remapEvent(evt), handler, applyPassive$3());
        },
        registerDrawerInteractionHandler: function registerDrawerInteractionHandler(evt, handler) {
          _this.$refs.drawer.addEventListener(remapEvent(evt), handler, applyPassive$3());
        },
        deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler(evt, handler) {
          _this.$refs.drawer.removeEventListener(remapEvent(evt), handler, applyPassive$3());
        },
        registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
          _this.$refs.drawer.addEventListener('transitionend', handler);
        },
        deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
          _this.$refs.drawer.removeEventListener('transitionend', handler);
        },
        registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
          document.addEventListener('keydown', handler);
        },
        deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
          document.removeEventListener('keydown', handler);
        },
        getDrawerWidth: function getDrawerWidth() {
          return _this.$refs.drawer.offsetWidth;
        },
        setTranslateX: function setTranslateX(value) {
          _this.$refs.drawer.style.setProperty(getTransformPropertyName(), value === null ? null : 'translateX(' + value + 'px)');
        },
        getFocusableElements: function getFocusableElements() {
          return _this.$refs.drawer.querySelectorAll(FOCUSABLE_ELEMENTS);
        },
        saveElementTabState: function saveElementTabState$$1(el) {
          saveElementTabState(el);
        },
        restoreElementTabState: function restoreElementTabState$$1(el) {
          restoreElementTabState(el);
        },
        makeElementUntabbable: function makeElementUntabbable(el) {
          el.setAttribute('tabindex', -1);
        },
        notifyOpen: function notifyOpen() {
          _this.$emit('change', true);
          _this.$emit('open');
        },
        notifyClose: function notifyClose() {
          _this.$emit('change', false);
          _this.$emit('close');
        },
        isRtl: function isRtl() {
          /* global getComputedStyle */
          return getComputedStyle(_this.$el).getPropertyValue('direction') === 'rtl';
        },
        isDrawer: function isDrawer(el) {
          return el === _this.$refs.drawer;
        }
      });
      this.foundation && this.foundation.init();
      this._refresh();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation && this.foundation.destroy();
      this.foundation = null;
    },

    methods: {
      _refresh: function _refresh() {
        if (this.open) {
          this.foundation && this.foundation.open();
        } else {
          this.foundation && this.foundation.close();
        }
      }
    }
  };

  /* script */
  var __vue_script__$k = script$k;

  /* template */
  var __vue_render__$h = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("aside", {
      staticClass: "mdc-persistent-drawer mdc-drawer--persistent mdc-typography",
      class: _vm.classes
    }, [_c("nav", { ref: "drawer", staticClass: "mdc-drawer__drawer" }, [_vm.toolbarSpacer ? _c("div", { staticClass: "mdc-drawer__toolbar-spacer" }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2)]);
  };
  var __vue_staticRenderFns__$h = [];
  __vue_render__$h._withStripped = true;

  /* style */
  var __vue_inject_styles__$k = undefined;
  /* scoped */
  var __vue_scope_id__$k = undefined;
  /* module identifier */
  var __vue_module_identifier__$k = undefined;
  /* functional template */
  var __vue_is_functional_template__$k = false;
  /* component normalizer */
  function __vue_normalize__$k(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/drawer/mdc-persistent-drawer.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$k() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$k.styles || (__vue_create_injector__$k.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcPersistentDrawer = __vue_normalize__$k({ render: __vue_render__$h, staticRenderFns: __vue_staticRenderFns__$h }, __vue_inject_styles__$k, __vue_script__$k, __vue_scope_id__$k, __vue_is_functional_template__$k, __vue_module_identifier__$k, __vue_create_injector__$k, undefined);

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$8 = {
    ROOT: 'mdc-drawer--temporary',
    OPEN: 'mdc-drawer--open',
    ANIMATING: 'mdc-drawer--animating',
    SCROLL_LOCK: 'mdc-drawer-scroll-lock'
  };

  var strings$8 = {
    DRAWER_SELECTOR: '.mdc-drawer--temporary .mdc-drawer__drawer',
    OPACITY_VAR_NAME: '--mdc-temporary-drawer-opacity',
    FOCUSABLE_ELEMENTS: FOCUSABLE_ELEMENTS,
    OPEN_EVENT: 'MDCTemporaryDrawer:open',
    CLOSE_EVENT: 'MDCTemporaryDrawer:close'
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCTemporaryDrawerFoundation = function (_MDCSlidableDrawerFou) {
    inherits(MDCTemporaryDrawerFoundation, _MDCSlidableDrawerFou);
    createClass(MDCTemporaryDrawerFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$8;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$8;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return _extends(MDCSlidableDrawerFoundation.defaultAdapter, {
          addBodyClass: function addBodyClass() /* className: string */{},
          removeBodyClass: function removeBodyClass() /* className: string */{},
          isDrawer: function isDrawer() {
            return false;
          },
          updateCssVariable: function updateCssVariable() /* value: string */{},
          eventTargetHasClass: function eventTargetHasClass() {
            return (/* target: EventTarget, className: string */ /* boolean */false
            );
          }
        });
      }
    }]);

    function MDCTemporaryDrawerFoundation(adapter) {
      classCallCheck(this, MDCTemporaryDrawerFoundation);

      var _this = possibleConstructorReturn(this, (MDCTemporaryDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation)).call(this, _extends(MDCTemporaryDrawerFoundation.defaultAdapter, adapter), MDCTemporaryDrawerFoundation.cssClasses.ROOT, MDCTemporaryDrawerFoundation.cssClasses.ANIMATING, MDCTemporaryDrawerFoundation.cssClasses.OPEN));

      _this.componentClickHandler_ = function (evt) {
        if (_this.adapter_.eventTargetHasClass(evt.target, cssClasses$8.ROOT)) {
          _this.close(true);
        }
      };
      return _this;
    }

    createClass(MDCTemporaryDrawerFoundation, [{
      key: 'init',
      value: function init() {
        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'init', this).call(this);

        // Make browser aware of custom property being used in this element.
        // Workaround for certain types of hard-to-reproduce heisenbugs.
        this.adapter_.updateCssVariable(0);
        this.adapter_.registerInteractionHandler('click', this.componentClickHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'destroy', this).call(this);

        this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
        this.enableScroll_();
      }
    }, {
      key: 'open',
      value: function open() {
        this.disableScroll_();
        // Make sure custom property values are cleared before starting.
        this.adapter_.updateCssVariable('');

        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'open', this).call(this);
      }
    }, {
      key: 'close',
      value: function close() {
        // Make sure custom property values are cleared before making any changes.
        this.adapter_.updateCssVariable('');

        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'close', this).call(this);
      }
    }, {
      key: 'prepareForTouchEnd_',
      value: function prepareForTouchEnd_() {
        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'prepareForTouchEnd_', this).call(this);

        this.adapter_.updateCssVariable('');
      }
    }, {
      key: 'updateDrawer_',
      value: function updateDrawer_() {
        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'updateDrawer_', this).call(this);

        var newOpacity = Math.max(0, 1 + this.direction_ * (this.newPosition_ / this.drawerWidth_));
        this.adapter_.updateCssVariable(newOpacity);
      }
    }, {
      key: 'isRootTransitioningEventTarget_',
      value: function isRootTransitioningEventTarget_(el) {
        return this.adapter_.isDrawer(el);
      }
    }, {
      key: 'handleTransitionEnd_',
      value: function handleTransitionEnd_(evt) {
        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'handleTransitionEnd_', this).call(this, evt);
        if (!this.isOpen_) {
          this.enableScroll_();
        }
      }
    }, {
      key: 'disableScroll_',
      value: function disableScroll_() {
        this.adapter_.addBodyClass(cssClasses$8.SCROLL_LOCK);
      }
    }, {
      key: 'enableScroll_',
      value: function enableScroll_() {
        this.adapter_.removeBodyClass(cssClasses$8.SCROLL_LOCK);
      }
    }]);
    return MDCTemporaryDrawerFoundation;
  }(MDCSlidableDrawerFoundation);

  //

  var script$l = {
    name: 'mdc-temporary-drawer',
    model: {
      prop: 'open',
      event: 'change'
    },
    props: {
      open: Boolean,
      'toolbar-spacer': Boolean
    },
    data: function data() {
      return {
        classes: {}
      };
    },

    watch: {
      open: '_refresh'
    },
    mounted: function mounted() {
      var _this = this;

      var _MDCTemporaryDrawerFo = MDCTemporaryDrawerFoundation.strings,
          FOCUSABLE_ELEMENTS = _MDCTemporaryDrawerFo.FOCUSABLE_ELEMENTS,
          OPACITY_VAR_NAME = _MDCTemporaryDrawerFo.OPACITY_VAR_NAME;


      this.foundation = new MDCTemporaryDrawerFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.classes, className);
        },
        hasClass: function hasClass(className) {
          return _this.$el.classList.contains(className);
        },
        addBodyClass: function addBodyClass(className) {
          return document.body.classList.add(className);
        },
        removeBodyClass: function removeBodyClass(className) {
          return document.body.classList.remove(className);
        },
        eventTargetHasClass: function eventTargetHasClass(target, className) {
          return target.classList.contains(className);
        },
        hasNecessaryDom: function hasNecessaryDom() {
          return !!_this.$refs.drawer;
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          _this.$el.addEventListener(remapEvent(evt), handler, applyPassive$3());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          _this.$el.removeEventListener(remapEvent(evt), handler, applyPassive$3());
        },
        registerDrawerInteractionHandler: function registerDrawerInteractionHandler(evt, handler) {
          _this.$refs.drawer.addEventListener(remapEvent(evt), handler, applyPassive$3());
        },
        deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler(evt, handler) {
          _this.$refs.drawer.removeEventListener(remapEvent(evt), handler, applyPassive$3());
        },
        registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
          _this.$refs.drawer.addEventListener('transitionend', handler);
        },
        deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
          _this.$refs.drawer.removeEventListener('transitionend', handler);
        },
        registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
          document.addEventListener('keydown', handler);
        },
        deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
          document.removeEventListener('keydown', handler);
        },
        getDrawerWidth: function getDrawerWidth() {
          return _this.$refs.drawer.offsetWidth;
        },
        setTranslateX: function setTranslateX(value) {
          _this.$refs.drawer.style.setProperty(getTransformPropertyName(), value === null ? null : 'translateX(' + value + 'px)');
        },
        updateCssVariable: function updateCssVariable(value) {
          if (supportsCssCustomProperties()) {
            _this.$el.style.setProperty(OPACITY_VAR_NAME, value);
          }
        },
        getFocusableElements: function getFocusableElements() {
          return _this.$refs.drawer.querySelectorAll(FOCUSABLE_ELEMENTS);
        },
        saveElementTabState: function saveElementTabState$$1(el) {
          saveElementTabState(el);
        },
        restoreElementTabState: function restoreElementTabState$$1(el) {
          restoreElementTabState(el);
        },
        makeElementUntabbable: function makeElementUntabbable(el) {
          el.setAttribute('tabindex', -1);
        },
        notifyOpen: function notifyOpen() {
          _this.$emit('change', true);
          _this.$emit('open');
        },
        notifyClose: function notifyClose() {
          _this.$emit('change', false);
          _this.$emit('close');
        },
        isRtl: function isRtl() {
          /* global getComputedStyle */
          return getComputedStyle(_this.$el).getPropertyValue('direction') === 'rtl';
        },
        isDrawer: function isDrawer(el) {
          return el === _this.$refs.drawer;
        }
      });
      this.foundation && this.foundation.init();
      this._refresh();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation && this.foundation.destroy();
      this.foundation = null;
    },

    methods: {
      _refresh: function _refresh() {
        if (this.open) {
          this.foundation && this.foundation.open();
        } else {
          this.foundation && this.foundation.close();
        }
      }
    }
  };

  /* script */
  var __vue_script__$l = script$l;

  /* template */
  var __vue_render__$i = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("aside", {
      staticClass: "mdc-temporary-drawer mdc-drawer--temporary mdc-typography",
      class: _vm.classes
    }, [_c("nav", { ref: "drawer", staticClass: "mdc-drawer__drawer" }, [_vm.toolbarSpacer ? _c("div", { staticClass: "mdc-drawer__toolbar-spacer" }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2)]);
  };
  var __vue_staticRenderFns__$i = [];
  __vue_render__$i._withStripped = true;

  /* style */
  var __vue_inject_styles__$l = undefined;
  /* scoped */
  var __vue_scope_id__$l = undefined;
  /* module identifier */
  var __vue_module_identifier__$l = undefined;
  /* functional template */
  var __vue_is_functional_template__$l = false;
  /* component normalizer */
  function __vue_normalize__$l(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/drawer/mdc-temporary-drawer.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$l() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$l.styles || (__vue_create_injector__$l.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcTemporaryDrawer = __vue_normalize__$l({ render: __vue_render__$i, staticRenderFns: __vue_staticRenderFns__$i }, __vue_inject_styles__$l, __vue_script__$l, __vue_scope_id__$l, __vue_is_functional_template__$l, __vue_module_identifier__$l, __vue_create_injector__$l, undefined);

  //

  var media = new (function () {
    function _class() {
      classCallCheck(this, _class);
    }

    createClass(_class, [{
      key: 'small',
      get: function get$$1() {
        return this._small || (this._small = window.matchMedia('(max-width: 839px)'));
      }
    }, {
      key: 'large',
      get: function get$$1() {
        return this._large || (this._large = window.matchMedia('(min-width: 1200px)'));
      }
    }]);
    return _class;
  }())();

  var script$m = {
    name: 'mdc-drawer',
    components: {
      'mdc-permanent-drawer': mdcPermanentDrawer,
      'mdc-persistent-drawer': mdcPersistentDrawer,
      'mdc-temporary-drawer': mdcTemporaryDrawer
    },
    model: {
      prop: 'open',
      event: 'change'
    },
    props: {
      open: Boolean,
      permanent: Boolean,
      persistent: Boolean,
      temporary: Boolean,
      drawerType: {
        type: String,
        validator: function validator(val) {
          return val in ['temporary', 'persistent', 'permanent'];
        }
      },
      toolbarSpacer: Boolean,
      toggleOn: String,
      toggleOnSource: { type: Object, required: false },
      openOn: String,
      openOnSource: { type: Object, required: false },
      closeOn: String,
      closeOnSource: { type: Object, required: false }
    },
    provide: function provide() {
      return { mdcDrawer: this };
    },
    data: function data() {
      return {
        small: false,
        large: false,
        open_: false
      };
    },

    computed: {
      type: function type() {
        if (this.permanent) {
          return 'mdc-permanent-drawer';
        } else if (this.persistent) {
          return 'mdc-persistent-drawer';
        } else if (this.temporary) {
          return 'mdc-temporary-drawer';
        } else {
          switch (this.drawerType) {
            case 'permanent':
              return 'mdc-permanent-drawer';
            case 'persistent':
              return 'mdc-persistent-drawer';
            case 'temporary':
              return 'mdc-temporary-drawer';
            default:
              return this.small ? 'mdc-temporary-drawer' : 'mdc-persistent-drawer';
          }
        }
      },
      isPermanent: function isPermanent() {
        return this.permanent || this.type === 'mdc-permanent-drawer';
      },
      isPersistent: function isPersistent() {
        return this.persistent || this.type === 'mdc-persistent-drawer';
      },
      isTemporary: function isTemporary() {
        return this.temporary || this.type === 'mdc-temporary-drawer';
      },
      isResponsive: function isResponsive() {
        return !(this.permanent || this.persistent || this.temporary || this.drawerType);
      }
    },
    watch: {
      open: 'onOpen_'
    },
    created: function created() {
      if (typeof window !== 'undefined' && window.matchMedia) {
        this.small = media.small.matches;
        this.large = media.large.matches;
      }
    },
    mounted: function mounted() {
      var _this = this;

      if (this.toggleOn) {
        this.toggleOnEventSource = this.toggleOnSource || this.$root;
        this.toggleOnEventSource.$on(this.toggleOn, this.toggle);
      }
      if (this.openOn) {
        this.openOnEventSource = this.openOnSource || this.$root;
        this.openOnEventSource.$on(this.openOn, this.show);
      }
      if (this.closeOn) {
        this.closeOnEventSource = this.closeOnSource || this.$root;
        this.closeOnEventSource.$on(this.closeOn, this.close);
      }
      media.small.addListener(this.refreshMedia);
      media.large.addListener(this.refreshMedia);
      this.$nextTick(function () {
        return _this.refreshMedia();
      });
    },
    beforeDestroy: function beforeDestroy() {
      media.small.removeListener(this.refreshMedia);
      media.large.removeListener(this.refreshMedia);

      if (this.toggleOnEventSource) {
        this.toggleOnEventSource.$off(this.toggleOn, this.toggle);
      }
      if (this.openOnEventSource) {
        this.openOnEventSource.$off(this.openOn, this.show);
      }
      if (this.closeOnEventSource) {
        this.closeOnEventSource.$off(this.closeOn, this.close);
      }
    },

    methods: {
      onOpen_: function onOpen_(value) {
        this.isPermanent || (this.open_ = value);
      },
      onChange: function onChange(event) {
        this.$emit('change', event);
        this.$root.$emit('vma:layout');
      },
      show: function show() {
        this.open_ = true;
      },
      close: function close() {
        this.isPermanent || (this.open_ = false);
      },
      toggle: function toggle() {
        this.isPermanent || (this.isOpen() ? this.close() : this.show());
      },
      isOpen: function isOpen() {
        return this.isPermanent || this.open_;
      },
      refreshMedia: function refreshMedia() {
        this.small = media.small.matches;
        this.large = media.large.matches;
        if (this.isResponsive) {
          if (this.large) {
            this.show();
          } else {
            this.close();
          }
        }
      }
    }
  };

  /* script */
  var __vue_script__$m = script$m;

  /* template */
  var __vue_render__$j = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(_vm.type, {
      ref: "drawer",
      tag: "component",
      staticClass: "mdc-drawer",
      attrs: { "toolbar-spacer": _vm.toolbarSpacer },
      on: {
        change: _vm.onChange,
        open: function open($event) {
          _vm.$emit("open");
        },
        close: function close($event) {
          _vm.$emit("close");
        }
      },
      model: {
        value: _vm.open_,
        callback: function callback($$v) {
          _vm.open_ = $$v;
        },
        expression: "open_"
      }
    }, [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$j = [];
  __vue_render__$j._withStripped = true;

  /* style */
  var __vue_inject_styles__$m = undefined;
  /* scoped */
  var __vue_scope_id__$m = undefined;
  /* module identifier */
  var __vue_module_identifier__$m = undefined;
  /* functional template */
  var __vue_is_functional_template__$m = false;
  /* component normalizer */
  function __vue_normalize__$m(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/drawer/mdc-drawer.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$m() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$m.styles || (__vue_create_injector__$m.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcDrawer = __vue_normalize__$m({ render: __vue_render__$j, staticRenderFns: __vue_staticRenderFns__$j }, __vue_inject_styles__$m, __vue_script__$m, __vue_scope_id__$m, __vue_is_functional_template__$m, __vue_module_identifier__$m, __vue_create_injector__$m, undefined);

  //
  //
  //
  //
  //
  //

  var script$n = {
    name: 'mdc-drawer-layout'
  };

  /* script */
  var __vue_script__$n = script$n;

  /* template */
  var __vue_render__$k = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { staticClass: "mdc-drawer-layout" }, [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$k = [];
  __vue_render__$k._withStripped = true;

  /* style */
  var __vue_inject_styles__$n = undefined;
  /* scoped */
  var __vue_scope_id__$n = undefined;
  /* module identifier */
  var __vue_module_identifier__$n = undefined;
  /* functional template */
  var __vue_is_functional_template__$n = false;
  /* component normalizer */
  function __vue_normalize__$n(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/drawer/mdc-drawer-layout.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$n() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$n.styles || (__vue_create_injector__$n.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcDrawerLayout = __vue_normalize__$n({ render: __vue_render__$k, staticRenderFns: __vue_staticRenderFns__$k }, __vue_inject_styles__$n, __vue_script__$n, __vue_scope_id__$n, __vue_is_functional_template__$n, __vue_module_identifier__$n, __vue_create_injector__$n, undefined);

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //

  var script$o = {
    name: 'mdc-drawer-header',
    props: {
      permanent: Boolean,
      persistent: Boolean,
      temporary: Boolean
    },
    inject: ['mdcDrawer'],
    computed: {
      show: function show() {
        if (this.temporary || this.persistent || this.permanent) {
          return this.temporary && this.mdcDrawer.isTemporary || this.persistent && this.mdcDrawer.isPersistent || this.permanent && this.mdcDrawer.isPermanent;
        } else {
          return true;
        }
      }
    }
  };

  /* script */
  var __vue_script__$o = script$o;

  /* template */
  var __vue_render__$l = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _vm.show ? _c("header", { staticClass: "mdc-drawer-header mdc-drawer__header" }, [_c("div", { staticClass: "mdc-drawer__header-content" }, [_vm._t("default")], 2)]) : _vm._e();
  };
  var __vue_staticRenderFns__$l = [];
  __vue_render__$l._withStripped = true;

  /* style */
  var __vue_inject_styles__$o = undefined;
  /* scoped */
  var __vue_scope_id__$o = undefined;
  /* module identifier */
  var __vue_module_identifier__$o = undefined;
  /* functional template */
  var __vue_is_functional_template__$o = false;
  /* component normalizer */
  function __vue_normalize__$o(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/drawer/mdc-drawer-header.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$o() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$o.styles || (__vue_create_injector__$o.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcDrawerHeader = __vue_normalize__$o({ render: __vue_render__$l, staticRenderFns: __vue_staticRenderFns__$l }, __vue_inject_styles__$o, __vue_script__$o, __vue_scope_id__$o, __vue_is_functional_template__$o, __vue_module_identifier__$o, __vue_create_injector__$o, undefined);

  //
  //
  //
  //
  //
  //
  //
  //

  var script$p = {
    name: 'mdc-drawer-list',
    props: {
      dense: Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-list--dense': this.dense
        }
      };
    }
  };

  /* script */
  var __vue_script__$p = script$p;

  /* template */
  var __vue_render__$m = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("nav", { staticClass: "mdc-drawer-list mdc-list", class: _vm.classes }, [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$m = [];
  __vue_render__$m._withStripped = true;

  /* style */
  var __vue_inject_styles__$p = undefined;
  /* scoped */
  var __vue_scope_id__$p = undefined;
  /* module identifier */
  var __vue_module_identifier__$p = undefined;
  /* functional template */
  var __vue_is_functional_template__$p = false;
  /* component normalizer */
  function __vue_normalize__$p(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/drawer/mdc-drawer-list.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$p() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$p.styles || (__vue_create_injector__$p.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcDrawerList = __vue_normalize__$p({ render: __vue_render__$m, staticRenderFns: __vue_staticRenderFns__$m }, __vue_inject_styles__$p, __vue_script__$p, __vue_scope_id__$p, __vue_is_functional_template__$p, __vue_module_identifier__$p, __vue_create_injector__$p, undefined);

  //

  var script$q = {
    name: 'mdc-drawer-item',
    inject: ['mdcDrawer'],
    mixins: [DispatchEventMixin, CustomLinkMixin],
    props: {
      startIcon: String,
      temporaryClose: {
        type: Boolean,
        default: true
      },
      activated: Boolean,
      exactActiveClass: {
        type: String,
        default: 'mdc-list-item--activated'
      }
    },
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },

    computed: {
      mylisteners: function mylisteners() {
        var _this = this;

        return _extends({}, this.$listeners, {
          click: function click(e) {
            _this.mdcDrawer.isTemporary && _this.temporaryClose && _this.mdcDrawer.close();
            _this.dispatchEvent(e);
          }
        });
      },
      itemClasses: function itemClasses() {
        return {
          'mdc-list-item--activated': this.activated
        };
      },
      hasStartDetail: function hasStartDetail() {
        return this.startIcon || this.$slots['start-detail'];
      }
    },
    mounted: function mounted() {
      this.ripple = new RippleBase(this);
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.ripple && this.ripple.destroy();
      this.ripple = null;
    }
  };

  /* script */
  var __vue_script__$q = script$q;

  /* template */
  var __vue_render__$n = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("custom-link", _vm._g({
      staticClass: "mdc-drawer-item mdc-list-item",
      class: [_vm.classes, _vm.itemClasses],
      style: _vm.styles,
      attrs: { link: _vm.link }
    }, _vm.mylisteners), [_vm.hasStartDetail ? _c("span", { staticClass: "mdc-list-item__graphic" }, [_vm._t("start-detail", [_c("i", {
      staticClass: "material-icons",
      attrs: { "aria-hidden": "true" }
    }, [_vm._v(_vm._s(_vm.startIcon))])])], 2) : _vm._e(), _vm._v(" "), _vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$n = [];
  __vue_render__$n._withStripped = true;

  /* style */
  var __vue_inject_styles__$q = undefined;
  /* scoped */
  var __vue_scope_id__$q = undefined;
  /* module identifier */
  var __vue_module_identifier__$q = undefined;
  /* functional template */
  var __vue_is_functional_template__$q = false;
  /* component normalizer */
  function __vue_normalize__$q(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/drawer/mdc-drawer-item.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$q() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$q.styles || (__vue_create_injector__$q.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcDrawerItem = __vue_normalize__$q({ render: __vue_render__$n, staticRenderFns: __vue_staticRenderFns__$n }, __vue_inject_styles__$q, __vue_script__$q, __vue_scope_id__$q, __vue_is_functional_template__$q, __vue_module_identifier__$q, __vue_create_injector__$q, undefined);

  //
  //
  //
  //

  var script$r = {
    name: 'mdc-drawer-divider'
  };

  /* script */
  var __vue_script__$r = script$r;

  /* template */
  var __vue_render__$o = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("hr", { staticClass: "mdc-list-divider" });
  };
  var __vue_staticRenderFns__$o = [];
  __vue_render__$o._withStripped = true;

  /* style */
  var __vue_inject_styles__$r = undefined;
  /* scoped */
  var __vue_scope_id__$r = undefined;
  /* module identifier */
  var __vue_module_identifier__$r = undefined;
  /* functional template */
  var __vue_is_functional_template__$r = false;
  /* component normalizer */
  function __vue_normalize__$r(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/drawer/mdc-drawer-divider.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$r() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$r.styles || (__vue_create_injector__$r.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcDrawerDivider = __vue_normalize__$r({ render: __vue_render__$o, staticRenderFns: __vue_staticRenderFns__$o }, __vue_inject_styles__$r, __vue_script__$r, __vue_scope_id__$r, __vue_is_functional_template__$r, __vue_module_identifier__$r, __vue_create_injector__$r, undefined);

  var VueMDCDrawer = BasePlugin({
    mdcDrawer: mdcDrawer,
    mdcDrawerLayout: mdcDrawerLayout,
    mdcDrawerHeader: mdcDrawerHeader,
    mdcDrawerList: mdcDrawerList,
    mdcDrawerItem: mdcDrawerItem,
    mdcDrawerDivider: mdcDrawerDivider
  });

  //
  //
  //
  //
  //
  //
  //
  //

  var script$s = {
    name: 'mdc-elevation',
    props: {
      z: {
        type: [Number, String],
        default: function _default() {
          return 1;
        }
      }
    },
    data: function data() {
      var elevationClasses = {};
      elevationClasses['mdc-elevation--z' + this.z] = true;

      return {
        classes: elevationClasses
      };
    }
  };

  /* script */
  var __vue_script__$s = script$s;

  /* template */
  var __vue_render__$p = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { staticClass: "mdc-elevation", class: _vm.classes }, [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$p = [];
  __vue_render__$p._withStripped = true;

  /* style */
  var __vue_inject_styles__$s = undefined;
  /* scoped */
  var __vue_scope_id__$s = undefined;
  /* module identifier */
  var __vue_module_identifier__$s = undefined;
  /* functional template */
  var __vue_is_functional_template__$s = false;
  /* component normalizer */
  function __vue_normalize__$s(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/elevation/mdc-elevation.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$s() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$s.styles || (__vue_create_injector__$s.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcElevation = __vue_normalize__$s({ render: __vue_render__$p, staticRenderFns: __vue_staticRenderFns__$p }, __vue_inject_styles__$s, __vue_script__$s, __vue_scope_id__$s, __vue_is_functional_template__$s, __vue_module_identifier__$s, __vue_create_injector__$s, undefined);

  var VueMDCElevation = BasePlugin({
    mdcElevation: mdcElevation
  });

  //

  var script$t = {
    name: 'mdc-fab',
    mixins: [DispatchEventMixin, CustomButtonMixin, RippleMixin],
    props: {
      icon: String,
      mini: Boolean,
      absolute: Boolean,
      fixed: Boolean
    },
    data: function data() {
      return {
        classes: {
          'material-icons': this.icon,
          'mdc-fab--mini': this.mini,
          'mdc-fab--absolute': this.absolute,
          'mdc-fab--fixed': this.fixed
        },
        styles: {}
      };
    },

    watch: {
      icon: function icon() {
        this.$set(this.classes, 'material-icons', this.icon);
      },
      mini: function mini() {
        this.$set(this.classes, 'mdc-fab--mini', this.mini);
      }
    }
  };

  /* script */
  var __vue_script__$t = script$t;

  /* template */
  var __vue_render__$q = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("custom-button", _vm._g({
      staticClass: "mdc-fab",
      class: _vm.classes,
      style: _vm.styles,
      attrs: { href: _vm.href, link: _vm.link }
    }, _vm.listeners), [_c("span", { staticClass: "mdc-fab__icon" }, [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2)]);
  };
  var __vue_staticRenderFns__$q = [];
  __vue_render__$q._withStripped = true;

  /* style */
  var __vue_inject_styles__$t = undefined;
  /* scoped */
  var __vue_scope_id__$t = undefined;
  /* module identifier */
  var __vue_module_identifier__$t = undefined;
  /* functional template */
  var __vue_is_functional_template__$t = false;
  /* component normalizer */
  function __vue_normalize__$t(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/fab/mdc-fab.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$t() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$t.styles || (__vue_create_injector__$t.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcFAB = __vue_normalize__$t({ render: __vue_render__$q, staticRenderFns: __vue_staticRenderFns__$q }, __vue_inject_styles__$t, __vue_script__$t, __vue_scope_id__$t, __vue_is_functional_template__$t, __vue_module_identifier__$t, __vue_create_injector__$t, undefined);

  var VueMDCFab = BasePlugin({
    mdcFAB: mdcFAB
  });

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var strings$9 = {
    TILES_SELECTOR: '.mdc-grid-list__tiles',
    TILE_SELECTOR: '.mdc-grid-tile'
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCGridListFoundation = function (_MDCFoundation) {
    inherits(MDCGridListFoundation, _MDCFoundation);
    createClass(MDCGridListFoundation, null, [{
      key: 'strings',
      get: function get$$1() {
        return strings$9;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          getOffsetWidth: function getOffsetWidth() {
            return (/* number */0
            );
          },
          getNumberOfTiles: function getNumberOfTiles() {
            return (/* number */0
            );
          },
          getOffsetWidthForTileAtIndex: function getOffsetWidthForTileAtIndex() {
            return (/* index: number */ /* number */0
            );
          },
          setStyleForTilesElement: function setStyleForTilesElement() /* property: string, value: string */{},
          registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
          deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{}
        };
      }
    }]);

    function MDCGridListFoundation(adapter) {
      classCallCheck(this, MDCGridListFoundation);

      var _this = possibleConstructorReturn(this, (MDCGridListFoundation.__proto__ || Object.getPrototypeOf(MDCGridListFoundation)).call(this, _extends(MDCGridListFoundation.defaultAdapter, adapter)));

      _this.resizeHandler_ = function () {
        return _this.alignCenter();
      };
      _this.resizeFrame_ = 0;
      return _this;
    }

    createClass(MDCGridListFoundation, [{
      key: 'init',
      value: function init() {
        this.alignCenter();
        this.adapter_.registerResizeHandler(this.resizeHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterResizeHandler(this.resizeHandler_);
      }
    }, {
      key: 'alignCenter',
      value: function alignCenter() {
        var _this2 = this;

        if (this.resizeFrame_ !== 0) {
          cancelAnimationFrame(this.resizeFrame_);
        }
        this.resizeFrame_ = requestAnimationFrame(function () {
          _this2.alignCenter_();
          _this2.resizeFrame_ = 0;
        });
      }
    }, {
      key: 'alignCenter_',
      value: function alignCenter_() {
        if (this.adapter_.getNumberOfTiles() == 0) {
          return;
        }
        var gridWidth = this.adapter_.getOffsetWidth();
        var itemWidth = this.adapter_.getOffsetWidthForTileAtIndex(0);
        var tilesWidth = itemWidth * Math.floor(gridWidth / itemWidth);
        this.adapter_.setStyleForTilesElement('width', tilesWidth + 'px');
      }
    }]);
    return MDCGridListFoundation;
  }(MDCFoundation);

  //

  var script$u = {
    name: 'mdc-grid-list',
    props: {
      width: [String, Number],
      ratio: String,
      'narrow-gutter': Boolean,
      'header-caption': Boolean,
      'icon-align-start': Boolean,
      'icon-align-end': Boolean,
      'with-support-text': Boolean,
      interactive: Boolean
    },
    provide: function provide() {
      return { mdcGrid: this };
    },

    computed: {
      classes: function classes() {
        var classes = {};

        classes['mdc-grid-list--tile-gutter-1'] = this.narrowGutter;
        classes['mdc-grid-list--header-caption'] = this.headerCaption;
        classes['mdc-grid-list--tile-aspect-' + this.ratio] = this.ratio;
        classes['mdc-grid-list--with-icon-align-start'] = this.iconAlignStart;
        classes['mdc-grid-list--with-icon-align-end'] = this.iconAlignEnd;
        classes['mdc-grid-list--twoline-caption'] = this.withSupportText;
        classes['mdc-grid-list--non-interactive'] = !this.interactive;

        return classes;
      },
      styles: function styles() {
        var defaultWidth = 200;
        return {
          '--mdc-grid-list-tile-width': (this.width || defaultWidth) + 'px'
        };
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCGridListFoundation({
        getOffsetWidth: function getOffsetWidth() {
          return _this.$el.offsetWidth;
        },
        getNumberOfTiles: function getNumberOfTiles() {
          return _this.$el.querySelectorAll(MDCGridListFoundation.strings.TILE_SELECTOR).length;
        },
        getOffsetWidthForTileAtIndex: function getOffsetWidthForTileAtIndex(index) {
          return _this.$el.querySelectorAll(MDCGridListFoundation.strings.TILE_SELECTOR)[index].offsetWidth;
        },
        setStyleForTilesElement: function setStyleForTilesElement(property, value) {
          _this.$el.querySelector(MDCGridListFoundation.strings.TILES_SELECTOR).style[property] = value;
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          window.removeEventListener('resize', handler);
        }
      });
      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    }
  };

  /* script */
  var __vue_script__$u = script$u;

  /* template */
  var __vue_render__$r = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { staticClass: "mdc-grid-list" }, [_c("ul", {
      staticClass: "mdc-grid-list__tiles",
      class: _vm.classes,
      style: _vm.styles
    }, [_vm._t("default")], 2)]);
  };
  var __vue_staticRenderFns__$r = [];
  __vue_render__$r._withStripped = true;

  /* style */
  var __vue_inject_styles__$u = undefined;
  /* scoped */
  var __vue_scope_id__$u = undefined;
  /* module identifier */
  var __vue_module_identifier__$u = undefined;
  /* functional template */
  var __vue_is_functional_template__$u = false;
  /* component normalizer */
  function __vue_normalize__$u(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/grid-list/mdc-grid-list.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$u() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$u.styles || (__vue_create_injector__$u.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcGridList = __vue_normalize__$u({ render: __vue_render__$r, staticRenderFns: __vue_staticRenderFns__$r }, __vue_inject_styles__$u, __vue_script__$u, __vue_scope_id__$u, __vue_is_functional_template__$u, __vue_module_identifier__$u, __vue_create_injector__$u, undefined);

  //

  var script$v = {
    name: 'mdc-grid-tile',
    inject: ['mdcGrid'],
    mixins: [DispatchEventMixin],
    props: {
      src: String,
      cover: Boolean,
      icon: String,
      title: String,
      'support-text': String,
      selected: Boolean,
      activated: Boolean
    },
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },

    computed: {
      clickListener: function clickListener() {
        var _this = this;

        return { click: function click(e) {
            return _this.dispatchEvent(e);
          } };
      },
      itemClasses: function itemClasses() {
        return {
          'mdc-grid-tile--selected': this.selected,
          'mdc-grid-tile--activated': this.activated
        };
      },
      isInteractive: function isInteractive() {
        return this.mdcGrid && this.mdcGrid.interactive;
      },
      hasStartDetail: function hasStartDetail() {
        return this.startIcon || this.$slots['start-detail'];
      },
      hasEndDetail: function hasEndDetail() {
        return this.endIcon || this.$slots['end-detail'];
      }
    },
    watch: {
      isInteractive: function isInteractive(value) {
        if (value) {
          this.addRipple();
        } else {
          this.removeRipple();
        }
      }
    },
    mounted: function mounted() {
      this.isInteractive && this.addRipple();
    },
    beforeDestroy: function beforeDestroy() {
      this.removeRipple();
    },

    methods: {
      addRipple: function addRipple() {
        if (!this.ripple) {
          var ripple = new RippleBase(this);
          ripple.init();
          this.ripple = ripple;
        }
      },
      removeRipple: function removeRipple() {
        if (this.ripple) {
          var ripple = this.ripple;
          this.ripple = null;
          ripple.destroy();
        }
      }
    }
  };

  /* script */
  var __vue_script__$v = script$v;

  /* template */
  var __vue_render__$s = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("li", _vm._g({
      staticClass: "mdc-grid-tile",
      class: [_vm.classes, _vm.itemClasses],
      style: _vm.styles,
      attrs: { tabindex: _vm.isInteractive ? "0" : undefined }
    }, _vm.isInteractive ? _vm.listeners : _vm.clickListener), [_vm.cover ? _c("div", { staticClass: "mdc-grid-tile__primary" }, [_c("div", {
      staticClass: "mdc-grid-tile__primary-content",
      style: { backgroundImage: "url(" + _vm.src + ")" }
    })]) : _c("div", { staticClass: "mdc-grid-tile__primary" }, [_c("img", {
      staticClass: "mdc-grid-tile__primary-content",
      attrs: { src: _vm.src }
    })]), _vm._v(" "), _vm.title || _vm.supportText ? _c("span", { staticClass: "mdc-grid-tile__secondary" }, [_vm.icon ? _c("i", { staticClass: "mdc-grid-tile__icon material-icons" }, [_vm._v(_vm._s(_vm.icon))]) : _vm._e(), _vm._v(" "), _vm.title ? _c("span", { staticClass: "mdc-grid-tile__title" }, [_vm._v(_vm._s(_vm.title))]) : _vm._e(), _vm._v(" "), _vm.supportText ? _c("span", { staticClass: "mdc-grid-tile__support-text" }, [_vm._v(_vm._s(_vm.supportText))]) : _vm._e()]) : _vm._e()]);
  };
  var __vue_staticRenderFns__$s = [];
  __vue_render__$s._withStripped = true;

  /* style */
  var __vue_inject_styles__$v = undefined;
  /* scoped */
  var __vue_scope_id__$v = undefined;
  /* module identifier */
  var __vue_module_identifier__$v = undefined;
  /* functional template */
  var __vue_is_functional_template__$v = false;
  /* component normalizer */
  function __vue_normalize__$v(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/grid-list/mdc-grid-tile.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$v() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$v.styles || (__vue_create_injector__$v.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcGridTile = __vue_normalize__$v({ render: __vue_render__$s, staticRenderFns: __vue_staticRenderFns__$s }, __vue_inject_styles__$v, __vue_script__$v, __vue_scope_id__$v, __vue_is_functional_template__$v, __vue_module_identifier__$v, __vue_create_injector__$v, undefined);

  var VueMDCGridList = BasePlugin({
    mdcGridList: mdcGridList,
    mdcGridTile: mdcGridTile
  });

  //
  //
  //
  //
  //
  //
  //
  //

  var script$w = {
    name: 'mdc-icon',
    props: {
      icon: String
    }
  };

  /* script */
  var __vue_script__$w = script$w;

  /* template */
  var __vue_render__$t = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("span", {
      staticClass: "mdc-icon mdc-icon--material",
      class: { "material-icons": !!_vm.icon }
    }, [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2);
  };
  var __vue_staticRenderFns__$t = [];
  __vue_render__$t._withStripped = true;

  /* style */
  var __vue_inject_styles__$w = undefined;
  /* scoped */
  var __vue_scope_id__$w = undefined;
  /* module identifier */
  var __vue_module_identifier__$w = undefined;
  /* functional template */
  var __vue_is_functional_template__$w = false;
  /* component normalizer */
  function __vue_normalize__$w(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/icon/mdc-icon.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$w() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$w.styles || (__vue_create_injector__$w.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcIcon = __vue_normalize__$w({ render: __vue_render__$t, staticRenderFns: __vue_staticRenderFns__$t }, __vue_inject_styles__$w, __vue_script__$w, __vue_scope_id__$w, __vue_is_functional_template__$w, __vue_module_identifier__$w, __vue_create_injector__$w, undefined);

  var VueMDCIcon = BasePlugin({
    mdcIcon: mdcIcon
  });

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Icon Toggle. Provides an interface for managing
   * - classes
   * - dom
   * - inner text
   * - event handlers
   * - event dispatch
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */

  var MDCIconToggleAdapter = function () {
    function MDCIconToggleAdapter() {
      classCallCheck(this, MDCIconToggleAdapter);
    }

    createClass(MDCIconToggleAdapter, [{
      key: "addClass",

      /** @param {string} className */
      value: function addClass(className) {}

      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * @param {string} type
       * @param {!EventListener} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(type, handler) {}

      /**
       * @param {string} type
       * @param {!EventListener} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(type, handler) {}

      /** @param {string} text */

    }, {
      key: "setText",
      value: function setText(text) {}

      /** @return {number} */

    }, {
      key: "getTabIndex",
      value: function getTabIndex() {}

      /** @param {number} tabIndex */

    }, {
      key: "setTabIndex",
      value: function setTabIndex(tabIndex) {}

      /**
       * @param {string} name
       * @return {string}
       */

    }, {
      key: "getAttr",
      value: function getAttr(name) {}

      /**
       * @param {string} name
       * @param {string} value
       */

    }, {
      key: "setAttr",
      value: function setAttr(name, value) {}

      /** @param {string} name */

    }, {
      key: "rmAttr",
      value: function rmAttr(name) {}

      /** @param {!IconToggleEvent} evtData */

    }, {
      key: "notifyChange",
      value: function notifyChange(evtData) {}
    }]);
    return MDCIconToggleAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$9 = {
    ROOT: 'mdc-icon-toggle',
    DISABLED: 'mdc-icon-toggle--disabled'
  };

  /** @enum {string} */
  var strings$a = {
    DATA_TOGGLE_ON: 'data-toggle-on',
    DATA_TOGGLE_OFF: 'data-toggle-off',
    ARIA_PRESSED: 'aria-pressed',
    ARIA_DISABLED: 'aria-disabled',
    ARIA_LABEL: 'aria-label',
    CHANGE_EVENT: 'MDCIconToggle:change'
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCIconToggleAdapter>}
   */

  var MDCIconToggleFoundation = function (_MDCFoundation) {
    inherits(MDCIconToggleFoundation, _MDCFoundation);
    createClass(MDCIconToggleFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$9;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$a;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
          setText: function setText() /* text: string */{},
          getTabIndex: function getTabIndex() {
            return (/* number */0
            );
          },
          setTabIndex: function setTabIndex() /* tabIndex: number */{},
          getAttr: function getAttr() {
            return (/* name: string */ /* string */''
            );
          },
          setAttr: function setAttr() /* name: string, value: string */{},
          rmAttr: function rmAttr() /* name: string */{},
          notifyChange: function notifyChange() /* evtData: IconToggleEvent */{}
        };
      }
    }]);

    function MDCIconToggleFoundation(adapter) {
      classCallCheck(this, MDCIconToggleFoundation);

      /** @private {boolean} */
      var _this = possibleConstructorReturn(this, (MDCIconToggleFoundation.__proto__ || Object.getPrototypeOf(MDCIconToggleFoundation)).call(this, _extends(MDCIconToggleFoundation.defaultAdapter, adapter)));

      _this.on_ = false;

      /** @private {boolean} */
      _this.disabled_ = false;

      /** @private {number} */
      _this.savedTabIndex_ = -1;

      /** @private {?IconToggleState} */
      _this.toggleOnData_ = null;

      /** @private {?IconToggleState} */
      _this.toggleOffData_ = null;

      _this.clickHandler_ = /** @private {!EventListener} */function () {
        return _this.toggleFromEvt_();
      };

      /** @private {boolean} */
      _this.isHandlingKeydown_ = false;

      _this.keydownHandler_ = /** @private {!EventListener} */function ( /** @type {!KeyboardKey} */evt) {
        if (isSpace(evt)) {
          _this.isHandlingKeydown_ = true;
          return evt.preventDefault();
        }
      };

      _this.keyupHandler_ = /** @private {!EventListener} */function ( /** @type {!KeyboardKey} */evt) {
        if (isSpace(evt)) {
          _this.isHandlingKeydown_ = false;
          _this.toggleFromEvt_();
        }
      };
      return _this;
    }

    createClass(MDCIconToggleFoundation, [{
      key: 'init',
      value: function init() {
        this.refreshToggleData();
        this.savedTabIndex_ = this.adapter_.getTabIndex();
        this.adapter_.registerInteractionHandler('click', this.clickHandler_);
        this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.registerInteractionHandler('keyup', this.keyupHandler_);
      }
    }, {
      key: 'refreshToggleData',
      value: function refreshToggleData() {
        var _MDCIconToggleFoundat = MDCIconToggleFoundation.strings,
            DATA_TOGGLE_ON = _MDCIconToggleFoundat.DATA_TOGGLE_ON,
            DATA_TOGGLE_OFF = _MDCIconToggleFoundat.DATA_TOGGLE_OFF;

        this.toggleOnData_ = this.parseJsonDataAttr_(DATA_TOGGLE_ON);
        this.toggleOffData_ = this.parseJsonDataAttr_(DATA_TOGGLE_OFF);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
        this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.deregisterInteractionHandler('keyup', this.keyupHandler_);
      }

      /** @private */

    }, {
      key: 'toggleFromEvt_',
      value: function toggleFromEvt_() {
        this.toggle();
        var isOn = this.on_;

        this.adapter_.notifyChange( /** @type {!IconToggleEvent} */{ isOn: isOn });
      }

      /** @return {boolean} */

    }, {
      key: 'isOn',
      value: function isOn() {
        return this.on_;
      }

      /** @param {boolean=} isOn */

    }, {
      key: 'toggle',
      value: function toggle() {
        var isOn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !this.on_;

        this.on_ = isOn;

        var _MDCIconToggleFoundat2 = MDCIconToggleFoundation.strings,
            ARIA_LABEL = _MDCIconToggleFoundat2.ARIA_LABEL,
            ARIA_PRESSED = _MDCIconToggleFoundat2.ARIA_PRESSED;


        if (this.on_) {
          this.adapter_.setAttr(ARIA_PRESSED, 'true');
        } else {
          this.adapter_.setAttr(ARIA_PRESSED, 'false');
        }

        var _ref = this.on_ ? this.toggleOffData_ : this.toggleOnData_,
            classToRemove = _ref.cssClass;

        if (classToRemove) {
          this.adapter_.removeClass(classToRemove);
        }

        var _ref2 = this.on_ ? this.toggleOnData_ : this.toggleOffData_,
            content = _ref2.content,
            label = _ref2.label,
            cssClass = _ref2.cssClass;

        if (cssClass) {
          this.adapter_.addClass(cssClass);
        }
        if (content) {
          this.adapter_.setText(content);
        }
        if (label) {
          this.adapter_.setAttr(ARIA_LABEL, label);
        }
      }

      /**
       * @param {string} dataAttr
       * @return {!IconToggleState}
       */

    }, {
      key: 'parseJsonDataAttr_',
      value: function parseJsonDataAttr_(dataAttr) {
        var val = this.adapter_.getAttr(dataAttr);
        if (!val) {
          return {};
        }
        return (/** @type {!IconToggleState} */JSON.parse(val)
        );
      }

      /** @return {boolean} */

    }, {
      key: 'isDisabled',
      value: function isDisabled() {
        return this.disabled_;
      }

      /** @param {boolean} isDisabled */

    }, {
      key: 'setDisabled',
      value: function setDisabled(isDisabled) {
        this.disabled_ = isDisabled;

        var DISABLED = MDCIconToggleFoundation.cssClasses.DISABLED;
        var ARIA_DISABLED = MDCIconToggleFoundation.strings.ARIA_DISABLED;


        if (this.disabled_) {
          this.savedTabIndex_ = this.adapter_.getTabIndex();
          this.adapter_.setTabIndex(-1);
          this.adapter_.setAttr(ARIA_DISABLED, 'true');
          this.adapter_.addClass(DISABLED);
        } else {
          this.adapter_.setTabIndex(this.savedTabIndex_);
          this.adapter_.rmAttr(ARIA_DISABLED);
          this.adapter_.removeClass(DISABLED);
        }
      }

      /** @return {boolean} */

    }, {
      key: 'isKeyboardActivated',
      value: function isKeyboardActivated() {
        return this.isHandlingKeydown_;
      }
    }]);
    return MDCIconToggleFoundation;
  }(MDCFoundation);

  /**
   * @param {!KeyboardKey} keyboardKey
   * @return {boolean}
   */
  function isSpace(keyboardKey) {
    return keyboardKey.key === 'Space' || keyboardKey.keyCode === 32;
  }

  /** @record */

  var IconToggleState = function IconToggleState() {
    classCallCheck(this, IconToggleState);
  };

  /**
   * The aria-label value of the icon toggle, or undefined if there is no aria-label.
   * @export {string|undefined}
   */


  IconToggleState.prototype.label;

  /**
   * The text for the icon toggle, or undefined if there is no text.
   * @export {string|undefined}
   */
  IconToggleState.prototype.content;

  /**
   * The CSS class to add to the icon toggle, or undefined if there is no CSS class.
   * @export {string|undefined}
   */
  IconToggleState.prototype.cssClass;

  //

  var script$x = {
    name: 'mdc-icon-toggle',
    props: {
      toggleOn: [String, Object],
      toggleOff: [String, Object],
      value: Boolean,
      disabled: Boolean,
      accent: Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-icon-toggle--accent': this.accent
        },
        styles: {},
        iconClasses: {},
        tabIndex: 0,
        text: ''
      };
    },

    computed: {
      toggleOnData: function toggleOnData() {
        var toggle = this.toggleOn;
        return toggle && JSON.stringify(typeof toggle === 'string' ? {
          content: toggle,
          cssClass: 'material-icons'
        } : {
          content: toggle.icon || toggle.content,
          label: toggle.label,
          cssClass: toggle.icon ? 'material-icons' : toggle.cssClass
        });
      },
      toggleOffData: function toggleOffData() {
        var toggle = this.toggleOff;
        return toggle && JSON.stringify(typeof toggle === 'string' ? {
          content: toggle,
          cssClass: 'material-icons'
        } : {
          content: toggle.icon || toggle.content,
          label: toggle.label,
          cssClass: toggle.icon ? 'material-icons' : toggle.cssClass
        });
      }
    },
    watch: {
      value: function value(_value) {
        this.foundation && this.foundation.toggle(_value);
      },
      disabled: function disabled(_disabled) {
        this.foundation && this.foundation.setDisabled(_disabled);
      },
      toggleOnData: function toggleOnData() {
        this.foundation && this.foundation.refreshToggleData();
      },
      toggleOffData: function toggleOffData() {
        this.foundation && this.foundation.refreshToggleData();
      },
      accent: function accent(value) {
        this.$set(this.classes, 'mdc-icon-toggle--secondary', value);
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCIconToggleFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.iconClasses, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.iconClasses, className);
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          return _this.$el.addEventListener(evt, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          return _this.$el.removeEventListener(evt, handler);
        },
        setText: function setText(text) {
          _this.text = text;
        },
        getTabIndex: function getTabIndex() {
          return _this.tabIndex;
        },
        setTabIndex: function setTabIndex(tabIndex) {
          _this.tabIndex = tabIndex;
        },
        getAttr: function getAttr(name, value) {
          return _this.$el.getAttribute(name, value);
        },
        setAttr: function setAttr(name, value) {
          _this.$el.setAttribute(name, value);
        },
        rmAttr: function rmAttr(name) {
          _this.$el.removeAttribute(name);
        },
        notifyChange: function notifyChange(evtData) {
          _this.$emit('input', evtData.isOn);
        }
      });
      this.foundation.init();
      this.foundation.toggle(this.value);
      this.foundation.setDisabled(this.disabled);

      this.ripple = new RippleBase(this, {
        isUnbounded: function isUnbounded() {
          return true;
        },
        isSurfaceActive: function isSurfaceActive() {
          return _this.foundation.isKeyboardActivated();
        }
      });
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
      this.ripple.destroy();
    }
  };

  /* script */
  var __vue_script__$x = script$x;

  /* template */
  var __vue_render__$u = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("span", {
      staticClass: "mdc-icon-toggle",
      class: _vm.classes,
      style: _vm.styles,
      attrs: {
        tabindex: _vm.tabIndex,
        "data-toggle-on": _vm.toggleOnData,
        "data-toggle-off": _vm.toggleOffData,
        role: "button",
        "aria-pressed": "false"
      }
    }, [_c("i", { class: _vm.iconClasses, attrs: { "aria-hidden": "true" } }, [_vm._v(_vm._s(_vm.text))])]);
  };
  var __vue_staticRenderFns__$u = [];
  __vue_render__$u._withStripped = true;

  /* style */
  var __vue_inject_styles__$x = undefined;
  /* scoped */
  var __vue_scope_id__$x = undefined;
  /* module identifier */
  var __vue_module_identifier__$x = undefined;
  /* functional template */
  var __vue_is_functional_template__$x = false;
  /* component normalizer */
  function __vue_normalize__$x(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/icon-toggle/mdc-icon-toggle.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$x() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$x.styles || (__vue_create_injector__$x.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcIConToggle = __vue_normalize__$x({ render: __vue_render__$u, staticRenderFns: __vue_staticRenderFns__$u }, __vue_inject_styles__$x, __vue_script__$x, __vue_scope_id__$x, __vue_is_functional_template__$x, __vue_module_identifier__$x, __vue_create_injector__$x, undefined);

  var VueMDCIconToggle = BasePlugin({
    mdcIConToggle: mdcIConToggle
  });

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //

  var script$y = {
    name: 'mdc-layout-app'
  };

  /* script */
  var __vue_script__$y = script$y;

  /* template */
  var __vue_render__$v = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { staticClass: "mdc-layout-app" }, [_c("div", { staticClass: "mdc-layout-app--toolbar-wrapper" }, [_vm._t("toolbar")], 2), _vm._v(" "), _c("div", { staticClass: "mdc-layout-app--main-container" }, [_c("div", { staticClass: "mdc-layout-app--drawer-wrapper" }, [_vm._t("drawer")], 2), _vm._v(" "), _c("div", { staticClass: "mdc-layout-app--content-wrapper" }, [_vm._t("default")], 2)])]);
  };
  var __vue_staticRenderFns__$v = [];
  __vue_render__$v._withStripped = true;

  /* style */
  var __vue_inject_styles__$y = undefined;
  /* scoped */
  var __vue_scope_id__$y = undefined;
  /* module identifier */
  var __vue_module_identifier__$y = undefined;
  /* functional template */
  var __vue_is_functional_template__$y = false;
  /* component normalizer */
  function __vue_normalize__$y(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/layout-app/mdc-layout-app.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$y() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$y.styles || (__vue_create_injector__$y.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcLayoutApp = __vue_normalize__$y({ render: __vue_render__$v, staticRenderFns: __vue_staticRenderFns__$v }, __vue_inject_styles__$y, __vue_script__$y, __vue_scope_id__$y, __vue_is_functional_template__$y, __vue_module_identifier__$y, __vue_create_injector__$y, undefined);

  var VueMDCLayoutApp = BasePlugin({
    mdcLayoutApp: mdcLayoutApp
  });

  //
  //
  //
  //
  //
  //
  //
  //

  var script$z = {
    name: 'mdc-layout-grid',
    props: {
      'fixed-column-width': Boolean,
      'align-left': Boolean,
      'align-right': Boolean
    },
    computed: {
      classes: function classes() {
        return {
          'mdc-layout-grid': true,
          'mdc-layout-grid--fixed-column-width': this.fixedColumnWidth,
          'mdc-layout-grid--align-left': this.alignLeft,
          'mdc-layout-grid--align-right': this.alignRight
        };
      }
    }
  };

  /* script */
  var __vue_script__$z = script$z;

  /* template */
  var __vue_render__$w = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { class: _vm.classes }, [_c("div", { staticClass: "mdc-layout-grid__inner" }, [_vm._t("default")], 2)]);
  };
  var __vue_staticRenderFns__$w = [];
  __vue_render__$w._withStripped = true;

  /* style */
  var __vue_inject_styles__$z = undefined;
  /* scoped */
  var __vue_scope_id__$z = undefined;
  /* module identifier */
  var __vue_module_identifier__$z = undefined;
  /* functional template */
  var __vue_is_functional_template__$z = false;
  /* component normalizer */
  function __vue_normalize__$z(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/layout-grid/mdc-layout-grid.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$z() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$z.styles || (__vue_create_injector__$z.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcLayoutGrid = __vue_normalize__$z({ render: __vue_render__$w, staticRenderFns: __vue_staticRenderFns__$w }, __vue_inject_styles__$z, __vue_script__$z, __vue_scope_id__$z, __vue_is_functional_template__$z, __vue_module_identifier__$z, __vue_create_injector__$z, undefined);

  //
  //
  //
  //
  //
  //
  //
  //

  var spanOptions = {
    type: [String, Number],
    default: null,
    validator: function validator(value) {
      var num = Number(value);
      return isFinite(num) && num <= 12 && num > 0;
    }
  };

  var script$A = {
    name: 'mdc-layout-cell',
    props: {
      span: spanOptions,
      order: spanOptions,
      phone: spanOptions,
      tablet: spanOptions,
      desktop: spanOptions,
      align: {
        type: String,
        validator: function validator(value) {
          return ['top', 'bottom', 'middle'].indexOf(value) !== -1;
        }
      }
    },
    computed: {
      classes: function classes() {
        var classes = [];

        if (this.span) {
          classes.push('mdc-layout-grid__cell--span-' + this.span);
        }

        if (this.order) {
          classes.push('mdc-layout-grid__cell--order-' + this.order);
        }

        if (this.phone) {
          classes.push('mdc-layout-grid__cell--span-' + this.phone + '-phone');
        }

        if (this.tablet) {
          classes.push('mdc-layout-grid__cell--span-' + this.tablet + '-tablet');
        }

        if (this.desktop) {
          classes.push('mdc-layout-grid__cell--span-' + this.desktop + '-desktop');
        }

        if (this.align) {
          classes.push('mdc-layout-grid__cell--align-' + this.align);
        }

        return classes;
      }
    }
  };

  /* script */
  var __vue_script__$A = script$A;

  /* template */
  var __vue_render__$x = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", {
      staticClass: "mdc-layout-cell mdc-layout-grid__cell",
      class: _vm.classes
    }, [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$x = [];
  __vue_render__$x._withStripped = true;

  /* style */
  var __vue_inject_styles__$A = undefined;
  /* scoped */
  var __vue_scope_id__$A = undefined;
  /* module identifier */
  var __vue_module_identifier__$A = undefined;
  /* functional template */
  var __vue_is_functional_template__$A = false;
  /* component normalizer */
  function __vue_normalize__$A(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/layout-grid/mdc-layout-cell.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$A() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$A.styles || (__vue_create_injector__$A.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcLayoutCell = __vue_normalize__$A({ render: __vue_render__$x, staticRenderFns: __vue_staticRenderFns__$x }, __vue_inject_styles__$A, __vue_script__$A, __vue_scope_id__$A, __vue_is_functional_template__$A, __vue_module_identifier__$A, __vue_create_injector__$A, undefined);

  //
  //
  //
  //
  //
  //

  var script$B = {
    name: 'mdc-layout-inner-grid'
  };

  /* script */
  var __vue_script__$B = script$B;

  /* template */
  var __vue_render__$y = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { staticClass: "mdc-layout-inner-grid mdc-layout-grid__inner" }, [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$y = [];
  __vue_render__$y._withStripped = true;

  /* style */
  var __vue_inject_styles__$B = undefined;
  /* scoped */
  var __vue_scope_id__$B = undefined;
  /* module identifier */
  var __vue_module_identifier__$B = undefined;
  /* functional template */
  var __vue_is_functional_template__$B = false;
  /* component normalizer */
  function __vue_normalize__$B(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/layout-grid/mdc-layout-inner-grid.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$B() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$B.styles || (__vue_create_injector__$B.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcLayoutInnerGrid = __vue_normalize__$B({ render: __vue_render__$y, staticRenderFns: __vue_staticRenderFns__$y }, __vue_inject_styles__$B, __vue_script__$B, __vue_scope_id__$B, __vue_is_functional_template__$B, __vue_module_identifier__$B, __vue_create_injector__$B, undefined);

  var VueMDCLayoutGrid = BasePlugin({
    mdcLayoutGrid: mdcLayoutGrid,
    mdcLayoutCell: mdcLayoutCell,
    mdcLayoutInnerGrid: mdcLayoutInnerGrid
  });

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$a = {
    CLOSED_CLASS: 'mdc-linear-progress--closed',
    INDETERMINATE_CLASS: 'mdc-linear-progress--indeterminate',
    REVERSED_CLASS: 'mdc-linear-progress--reversed'
  };

  var strings$b = {
    PRIMARY_BAR_SELECTOR: '.mdc-linear-progress__primary-bar',
    BUFFER_SELECTOR: '.mdc-linear-progress__buffer'
  };

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCLinearProgressFoundation = function (_MDCFoundation) {
    inherits(MDCLinearProgressFoundation, _MDCFoundation);
    createClass(MDCLinearProgressFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$a;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$b;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          getPrimaryBar: function getPrimaryBar() /* el: Element */{},
          getBuffer: function getBuffer() /* el: Element */{},
          hasClass: function hasClass() {
            return (/* className: string */false
            );
          },
          removeClass: function removeClass() /* className: string */{},
          setStyle: function setStyle() /* el: Element, styleProperty: string, value: string */{}
        };
      }
    }]);

    function MDCLinearProgressFoundation(adapter) {
      classCallCheck(this, MDCLinearProgressFoundation);
      return possibleConstructorReturn(this, (MDCLinearProgressFoundation.__proto__ || Object.getPrototypeOf(MDCLinearProgressFoundation)).call(this, _extends(MDCLinearProgressFoundation.defaultAdapter, adapter)));
    }

    createClass(MDCLinearProgressFoundation, [{
      key: 'init',
      value: function init() {
        this.determinate_ = !this.adapter_.hasClass(cssClasses$a.INDETERMINATE_CLASS);
        this.reverse_ = this.adapter_.hasClass(cssClasses$a.REVERSED_CLASS);
        this.progress_ = 0;
      }
    }, {
      key: 'setDeterminate',
      value: function setDeterminate(isDeterminate) {
        this.determinate_ = isDeterminate;
        if (this.determinate_) {
          this.adapter_.removeClass(cssClasses$a.INDETERMINATE_CLASS);
          this.setScale_(this.adapter_.getPrimaryBar(), this.progress_);
        } else {
          this.adapter_.addClass(cssClasses$a.INDETERMINATE_CLASS);
          this.setScale_(this.adapter_.getPrimaryBar(), 1);
          this.setScale_(this.adapter_.getBuffer(), 1);
        }
      }
    }, {
      key: 'setProgress',
      value: function setProgress(value) {
        this.progress_ = value;
        if (this.determinate_) {
          this.setScale_(this.adapter_.getPrimaryBar(), value);
        }
      }
    }, {
      key: 'setBuffer',
      value: function setBuffer(value) {
        if (this.determinate_) {
          this.setScale_(this.adapter_.getBuffer(), value);
        }
      }
    }, {
      key: 'setReverse',
      value: function setReverse(isReversed) {
        this.reverse_ = isReversed;
        if (this.reverse_) {
          this.adapter_.addClass(cssClasses$a.REVERSED_CLASS);
        } else {
          this.adapter_.removeClass(cssClasses$a.REVERSED_CLASS);
        }
      }
    }, {
      key: 'open',
      value: function open() {
        this.adapter_.removeClass(cssClasses$a.CLOSED_CLASS);
      }
    }, {
      key: 'close',
      value: function close() {
        this.adapter_.addClass(cssClasses$a.CLOSED_CLASS);
      }
    }, {
      key: 'setScale_',
      value: function setScale_(el, scaleValue) {
        var _this2 = this;

        var value = 'scaleX(' + scaleValue + ')';
        transformStyleProperties.forEach(function (transformStyleProperty) {
          _this2.adapter_.setStyle(el, transformStyleProperty, value);
        });
      }
    }]);
    return MDCLinearProgressFoundation;
  }(MDCFoundation);

  //

  var ProgressPropType = {
    type: [Number, String],
    validator: function validator(value) {
      return Number(value) >= 0 && Number(value) <= 1;
    }
  };

  var script$C = {
    name: 'mdc-linear-progress',
    props: {
      open: { type: Boolean, default: true },
      indeterminate: Boolean,
      reverse: Boolean,
      accent: Boolean,
      progress: ProgressPropType,
      buffer: ProgressPropType
    },
    data: function data() {
      return {
        classes: { 'mdc-linear-progress--accent': this.accent },
        styles: {}
      };
    },

    watch: {
      open: function open() {
        if (this.open) {
          this.foundation.open();
        } else {
          this.foundation.close();
        }
      },
      progress: function progress() {
        this.foundation.setProgress(Number(this.progress));
      },
      buffer: function buffer() {
        this.foundation.setBuffer(Number(this.buffer));
      },
      indeterminate: function indeterminate() {
        this.foundation.setDeterminate(!this.indeterminate);
      },
      reverse: function reverse() {
        this.foundation.setReverse(this.reverse);
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCLinearProgressFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.classes, className, true);
        },
        getPrimaryBar: function getPrimaryBar() /* el: Element */{
          return _this.$refs.primary;
        },
        getBuffer: function getBuffer() /* el: Element */{
          return _this.$refs.buffer;
        },
        hasClass: function hasClass(className) {
          _this.$el.classList.contains(className);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.classes, className);
        },
        setStyle: function setStyle(el, styleProperty, value) {
          el.style[styleProperty] = value;
        }
      });
      this.foundation.init();

      this.foundation.setReverse(this.reverse);
      this.foundation.setProgress(Number(this.progress));
      this.foundation.setBuffer(Number(this.buffer));
      this.foundation.setDeterminate(!this.indeterminate);
      if (this.open) {
        this.foundation.open();
      } else {
        this.foundation.close();
      }
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    }
  };

  /* script */
  var __vue_script__$C = script$C;

  /* template */
  var __vue_render__$z = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", {
      staticClass: "mdc-linear-progress",
      class: _vm.classes,
      style: _vm.styles,
      attrs: { role: "progressbar" }
    }, [_c("div", { staticClass: "mdc-linear-progress__buffering-dots" }), _vm._v(" "), _c("div", { ref: "buffer", staticClass: "mdc-linear-progress__buffer" }), _vm._v(" "), _c("div", {
      ref: "primary",
      staticClass: "mdc-linear-progress__bar mdc-linear-progress__primary-bar"
    }, [_c("span", { staticClass: "mdc-linear-progress__bar-inner" })]), _vm._v(" "), _vm._m(0)]);
  };
  var __vue_staticRenderFns__$z = [function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", {
      staticClass: "mdc-linear-progress__bar mdc-linear-progress__secondary-bar"
    }, [_c("span", { staticClass: "mdc-linear-progress__bar-inner" })]);
  }];
  __vue_render__$z._withStripped = true;

  /* style */
  var __vue_inject_styles__$C = undefined;
  /* scoped */
  var __vue_scope_id__$C = undefined;
  /* module identifier */
  var __vue_module_identifier__$C = undefined;
  /* functional template */
  var __vue_is_functional_template__$C = false;
  /* component normalizer */
  function __vue_normalize__$C(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/linear-progress/mdc-linear-progress.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$C() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$C.styles || (__vue_create_injector__$C.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcLinearProgress = __vue_normalize__$C({ render: __vue_render__$z, staticRenderFns: __vue_staticRenderFns__$z }, __vue_inject_styles__$C, __vue_script__$C, __vue_scope_id__$C, __vue_is_functional_template__$C, __vue_module_identifier__$C, __vue_create_injector__$C, undefined);

  var VueMDCLinearProgress = BasePlugin({
    mdcLinearProgress: mdcLinearProgress
  });

  //
  //
  //
  //
  //
  //
  //
  //

  var script$D = {
    name: 'mdc-list',
    props: {
      dense: Boolean,
      avatarList: Boolean,
      twoLine: Boolean,
      bordered: Boolean,
      interactive: Boolean
    },
    provide: function provide() {
      return { mdcList: this };
    },

    computed: {
      classes: function classes() {
        return {
          'mdc-list--dense': this.dense,
          'mdc-list--avatar-list': this.avatarList,
          'mdc-list--two-line': this.twoLine,
          'mdc-list--bordered': this.bordered,
          'mdc-list--non-interactive': !this.interactive
        };
      }
    }
  };

  /* script */
  var __vue_script__$D = script$D;

  /* template */
  var __vue_render__$A = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("ul", { staticClass: "mdc-list", class: _vm.classes }, [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$A = [];
  __vue_render__$A._withStripped = true;

  /* style */
  var __vue_inject_styles__$D = undefined;
  /* scoped */
  var __vue_scope_id__$D = undefined;
  /* module identifier */
  var __vue_module_identifier__$D = undefined;
  /* functional template */
  var __vue_is_functional_template__$D = false;
  /* component normalizer */
  function __vue_normalize__$D(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/list/mdc-list.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$D() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$D.styles || (__vue_create_injector__$D.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcList = __vue_normalize__$D({ render: __vue_render__$A, staticRenderFns: __vue_staticRenderFns__$A }, __vue_inject_styles__$D, __vue_script__$D, __vue_scope_id__$D, __vue_is_functional_template__$D, __vue_module_identifier__$D, __vue_create_injector__$D, undefined);

  //

  var script$E = {
    name: 'mdc-list-item',
    inject: ['mdcList'],
    props: {
      selected: Boolean,
      activated: Boolean
    },
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },

    computed: {
      itemClasses: function itemClasses() {
        return {
          'mdc-list-item--selected': this.selected,
          'mdc-list-item--activated': this.activated
        };
      },
      isInteractive: function isInteractive() {
        return this.mdcList && this.mdcList.interactive;
      },
      hasSecondary: function hasSecondary() {
        return this.$slots['secondary'] && this.mdcList && this.mdcList.twoLine;
      },
      hasEndDetail: function hasEndDetail() {
        return !!this.$slots['end-detail'];
      },
      hasStartDetail: function hasStartDetail() {
        return !!this.$slots['start-detail'];
      }
    },
    watch: {
      isInteractive: function isInteractive(value) {
        if (value) {
          this.addRipple();
        } else {
          this.removeRipple();
        }
      }
    },
    mounted: function mounted() {
      this.isInteractive && this.addRipple();
    },
    beforeDestroy: function beforeDestroy() {
      this.removeRipple();
    },

    methods: {
      addRipple: function addRipple() {
        if (!this.ripple) {
          var ripple = new RippleBase(this);
          ripple.init();
          this.ripple = ripple;
        }
      },
      removeRipple: function removeRipple() {
        if (this.ripple) {
          var ripple = this.ripple;
          this.ripple = null;
          ripple.destroy();
        }
      }
    }
  };

  /* script */
  var __vue_script__$E = script$E;

  /* template */
  var __vue_render__$B = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("li", _vm._g({
      staticClass: "mdc-list-item",
      class: [_vm.classes, _vm.itemClasses],
      style: _vm.styles,
      attrs: { tabindex: _vm.isInteractive ? "0" : undefined }
    }, _vm.isInteractive ? _vm.$listeners : {}), [_vm.hasStartDetail ? _c("span", { staticClass: "mdc-list-item__graphic" }, [_vm._t("start-detail")], 2) : _vm._e(), _vm._v(" "), _vm.hasSecondary ? _c("span", { staticClass: "mdc-list-item__text" }, [_vm._t("default"), _vm._v(" "), _c("span", { staticClass: "mdc-list-item__secondary-text" }, [_vm._t("secondary")], 2)], 2) : _vm._t("default"), _vm._v(" "), _vm.hasEndDetail ? _c("span", { staticClass: "mdc-list-item__meta" }, [_vm._t("end-detail")], 2) : _vm._e()], 2);
  };
  var __vue_staticRenderFns__$B = [];
  __vue_render__$B._withStripped = true;

  /* style */
  var __vue_inject_styles__$E = undefined;
  /* scoped */
  var __vue_scope_id__$E = undefined;
  /* module identifier */
  var __vue_module_identifier__$E = undefined;
  /* functional template */
  var __vue_is_functional_template__$E = false;
  /* component normalizer */
  function __vue_normalize__$E(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/list/mdc-list-item.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$E() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$E.styles || (__vue_create_injector__$E.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcListItem = __vue_normalize__$E({ render: __vue_render__$B, staticRenderFns: __vue_staticRenderFns__$B }, __vue_inject_styles__$E, __vue_script__$E, __vue_scope_id__$E, __vue_is_functional_template__$E, __vue_module_identifier__$E, __vue_create_injector__$E, undefined);

  //
  //
  //
  //
  //
  //
  //

  var script$F = {
    name: 'mdc-list-divider',
    props: {
      inset: Boolean,
      padded: Boolean
    },
    computed: {
      classes: function classes() {
        return {
          'mdc-list-divider--inset': this.inset,
          'mdc-list-divider--padded': this.padded
        };
      }
    }
  };

  /* script */
  var __vue_script__$F = script$F;

  /* template */
  var __vue_render__$C = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("li", {
      staticClass: "mdc-list-divider",
      class: _vm.classes,
      attrs: { role: "separator" }
    });
  };
  var __vue_staticRenderFns__$C = [];
  __vue_render__$C._withStripped = true;

  /* style */
  var __vue_inject_styles__$F = undefined;
  /* scoped */
  var __vue_scope_id__$F = undefined;
  /* module identifier */
  var __vue_module_identifier__$F = undefined;
  /* functional template */
  var __vue_is_functional_template__$F = false;
  /* component normalizer */
  function __vue_normalize__$F(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/list/mdc-list-divider.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$F() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$F.styles || (__vue_create_injector__$F.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcListDivider = __vue_normalize__$F({ render: __vue_render__$C, staticRenderFns: __vue_staticRenderFns__$C }, __vue_inject_styles__$F, __vue_script__$F, __vue_scope_id__$F, __vue_is_functional_template__$F, __vue_module_identifier__$F, __vue_create_injector__$F, undefined);

  //
  //
  //
  //

  var script$G = {
    name: 'mdc-list-group'
  };

  /* script */
  var __vue_script__$G = script$G;

  /* template */
  var __vue_render__$D = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { staticClass: "mdc-list-group" }, [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$D = [];
  __vue_render__$D._withStripped = true;

  /* style */
  var __vue_inject_styles__$G = undefined;
  /* scoped */
  var __vue_scope_id__$G = undefined;
  /* module identifier */
  var __vue_module_identifier__$G = undefined;
  /* functional template */
  var __vue_is_functional_template__$G = false;
  /* component normalizer */
  function __vue_normalize__$G(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/list/mdc-list-group.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$G() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$G.styles || (__vue_create_injector__$G.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcListGroup = __vue_normalize__$G({ render: __vue_render__$D, staticRenderFns: __vue_staticRenderFns__$D }, __vue_inject_styles__$G, __vue_script__$G, __vue_scope_id__$G, __vue_is_functional_template__$G, __vue_module_identifier__$G, __vue_create_injector__$G, undefined);

  //
  //
  //
  //

  var script$H = {
    name: 'mdc-list-group-header'
  };

  /* script */
  var __vue_script__$H = script$H;

  /* template */
  var __vue_render__$E = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("h3", { staticClass: "mdc-list-group-header mdc-list-group__subheader" }, [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$E = [];
  __vue_render__$E._withStripped = true;

  /* style */
  var __vue_inject_styles__$H = undefined;
  /* scoped */
  var __vue_scope_id__$H = undefined;
  /* module identifier */
  var __vue_module_identifier__$H = undefined;
  /* functional template */
  var __vue_is_functional_template__$H = false;
  /* component normalizer */
  function __vue_normalize__$H(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/list/mdc-list-group-header.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$H() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$H.styles || (__vue_create_injector__$H.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcListGroupHeader = __vue_normalize__$H({ render: __vue_render__$E, staticRenderFns: __vue_staticRenderFns__$E }, __vue_inject_styles__$H, __vue_script__$H, __vue_scope_id__$H, __vue_is_functional_template__$H, __vue_module_identifier__$H, __vue_create_injector__$H, undefined);

  //
  //
  //
  //

  var script$I = {
    name: 'mdc-list-group-divider'
  };

  /* script */
  var __vue_script__$I = script$I;

  /* template */
  var __vue_render__$F = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("hr", { staticClass: "mdc-list-group-divider mdc-list-divider" });
  };
  var __vue_staticRenderFns__$F = [];
  __vue_render__$F._withStripped = true;

  /* style */
  var __vue_inject_styles__$I = undefined;
  /* scoped */
  var __vue_scope_id__$I = undefined;
  /* module identifier */
  var __vue_module_identifier__$I = undefined;
  /* functional template */
  var __vue_is_functional_template__$I = false;
  /* component normalizer */
  function __vue_normalize__$I(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/list/mdc-list-group-divider.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$I() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$I.styles || (__vue_create_injector__$I.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcListGroupDivider = __vue_normalize__$I({ render: __vue_render__$F, staticRenderFns: __vue_staticRenderFns__$F }, __vue_inject_styles__$I, __vue_script__$I, __vue_scope_id__$I, __vue_is_functional_template__$I, __vue_module_identifier__$I, __vue_create_injector__$I, undefined);

  var VueMDCList = BasePlugin({
    mdcList: mdcList,
    mdcListItem: mdcListItem,
    mdcListDivider: mdcListDivider,
    mdcListGroup: mdcListGroup,
    mdcListGroupHeader: mdcListGroupHeader,
    mdcListGroupDivider: mdcListGroupDivider
  });

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Menu. Provides an interface for managing
   * - classes
   * - dom
   * - focus
   * - position
   * - dimensions
   * - event handlers
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCMenuAdapter = function () {
    function MDCMenuAdapter() {
      classCallCheck(this, MDCMenuAdapter);
    }

    createClass(MDCMenuAdapter, [{
      key: "addClass",

      /** @param {string} className */
      value: function addClass(className) {}

      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}

      /** @return {boolean} */

    }, {
      key: "hasNecessaryDom",
      value: function hasNecessaryDom() {}

      /**
       * @param {EventTarget} target
       * @param {string} attributeName
       * @return {string}
       */

    }, {
      key: "getAttributeForEventTarget",
      value: function getAttributeForEventTarget(target, attributeName) {}

      /** @return {{ width: number, height: number }} */

    }, {
      key: "getInnerDimensions",
      value: function getInnerDimensions() {}

      /** @return {boolean} */

    }, {
      key: "hasAnchor",
      value: function hasAnchor() {}

      /** @return {{width: number, height: number, top: number, right: number, bottom: number, left: number}} */

    }, {
      key: "getAnchorDimensions",
      value: function getAnchorDimensions() {}

      /** @return {{ width: number, height: number }} */

    }, {
      key: "getWindowDimensions",
      value: function getWindowDimensions() {}

      /** @return {number} */

    }, {
      key: "getNumberOfItems",
      value: function getNumberOfItems() {}

      /**
       * @param {string} type
       * @param {function(!Event)} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(type, handler) {}

      /**
       * @param {string} type
       * @param {function(!Event)} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(type, handler) {}

      /** @param {function(!Event)} handler */

    }, {
      key: "registerBodyClickHandler",
      value: function registerBodyClickHandler(handler) {}

      /** @param {function(!Event)} handler */

    }, {
      key: "deregisterBodyClickHandler",
      value: function deregisterBodyClickHandler(handler) {}

      /**
       * @param {EventTarget} target
       * @return {number}
       */

    }, {
      key: "getIndexForEventTarget",
      value: function getIndexForEventTarget(target) {}

      /** @param {{index: number}} evtData */

    }, {
      key: "notifySelected",
      value: function notifySelected(evtData) {}
    }, {
      key: "notifyCancel",
      value: function notifyCancel() {}
    }, {
      key: "saveFocus",
      value: function saveFocus() {}
    }, {
      key: "restoreFocus",
      value: function restoreFocus() {}

      /** @return {boolean} */

    }, {
      key: "isFocused",
      value: function isFocused() {}
    }, {
      key: "focus",
      value: function focus() {}

      /** @return {number} */

    }, {
      key: "getFocusedItemIndex",
      value: function getFocusedItemIndex() /* number */{}

      /** @param {number} index */

    }, {
      key: "focusItemAtIndex",
      value: function focusItemAtIndex(index) {}

      /** @return {boolean} */

    }, {
      key: "isRtl",
      value: function isRtl() {}

      /** @param {string} origin */

    }, {
      key: "setTransformOrigin",
      value: function setTransformOrigin(origin) {}

      /** @param {{
      *   top: (string|undefined),
      *   right: (string|undefined),
      *   bottom: (string|undefined),
      *   left: (string|undefined)
      * }} position */

    }, {
      key: "setPosition",
      value: function setPosition(position) {}

      /** @param {string} height */

    }, {
      key: "setMaxHeight",
      value: function setMaxHeight(height) {}

      /**
       * @param {number} index
       * @param {string} attr
       * @param {string} value
       */

    }, {
      key: "setAttrForOptionAtIndex",
      value: function setAttrForOptionAtIndex(index, attr, value) {}

      /**
       * @param {number} index
       * @param {string} attr
       */

    }, {
      key: "rmAttrForOptionAtIndex",
      value: function rmAttrForOptionAtIndex(index, attr) {}

      /**
       * @param {number} index
       * @param {string} className
       */

    }, {
      key: "addClassForOptionAtIndex",
      value: function addClassForOptionAtIndex(index, className) {}

      /**
       * @param {number} index
       * @param {string} className
       */

    }, {
      key: "rmClassForOptionAtIndex",
      value: function rmClassForOptionAtIndex(index, className) {}
    }]);
    return MDCMenuAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$b = {
    ROOT: 'mdc-menu',
    OPEN: 'mdc-menu--open',
    ANIMATING_OPEN: 'mdc-menu--animating-open',
    ANIMATING_CLOSED: 'mdc-menu--animating-closed',
    SELECTED_LIST_ITEM: 'mdc-list-item--selected'
  };

  /** @enum {string} */
  var strings$c = {
    ITEMS_SELECTOR: '.mdc-menu__items',
    SELECTED_EVENT: 'MDCMenu:selected',
    CANCEL_EVENT: 'MDCMenu:cancel',
    ARIA_DISABLED_ATTR: 'aria-disabled'
  };

  /** @enum {number} */
  var numbers$4 = {
    // Amount of time to wait before triggering a selected event on the menu. Note that this time
    // will most likely be bumped up once interactive lists are supported to allow for the ripple to
    // animate before closing the menu
    SELECTED_TRIGGER_DELAY: 50,
    // Total duration of menu open animation.
    TRANSITION_OPEN_DURATION: 120,
    // Total duration of menu close animation.
    TRANSITION_CLOSE_DURATION: 75,
    // Margin left to the edge of the viewport when menu is at maximum possible height.
    MARGIN_TO_EDGE: 32,
    // Ratio of anchor width to menu width for switching from corner positioning to center positioning.
    ANCHOR_TO_MENU_WIDTH_RATIO: 0.67,
    // Ratio of vertical offset to menu height for switching from corner to mid-way origin positioning.
    OFFSET_TO_MENU_HEIGHT_RATIO: 0.1
  };

  /**
   * Enum for bits in the {@see Corner) bitmap.
   * @enum {number}
   */
  var CornerBit = {
    BOTTOM: 1,
    CENTER: 2,
    RIGHT: 4,
    FLIP_RTL: 8
  };

  /**
   * Enum for representing an element corner for positioning the menu.
   *
   * The START constants map to LEFT if element directionality is left
   * to right and RIGHT if the directionality is right to left.
   * Likewise END maps to RIGHT or LEFT depending on the directionality.
   *
   * @enum {number}
   */
  var Corner = {
    TOP_LEFT: 0,
    TOP_RIGHT: CornerBit.RIGHT,
    BOTTOM_LEFT: CornerBit.BOTTOM,
    BOTTOM_RIGHT: CornerBit.BOTTOM | CornerBit.RIGHT,
    TOP_START: CornerBit.FLIP_RTL,
    TOP_END: CornerBit.FLIP_RTL | CornerBit.RIGHT,
    BOTTOM_START: CornerBit.BOTTOM | CornerBit.FLIP_RTL,
    BOTTOM_END: CornerBit.BOTTOM | CornerBit.RIGHT | CornerBit.FLIP_RTL
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCMenuAdapter>}
   */

  var MDCMenuFoundation = function (_MDCFoundation) {
    inherits(MDCMenuFoundation, _MDCFoundation);
    createClass(MDCMenuFoundation, null, [{
      key: 'cssClasses',

      /** @return enum{cssClasses} */
      get: function get$$1() {
        return cssClasses$b;
      }

      /** @return enum{strings} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$c;
      }

      /** @return enum{numbers} */

    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers$4;
      }

      /** @return enum{number} */

    }, {
      key: 'Corner',
      get: function get$$1() {
        return Corner;
      }

      /**
       * {@see MDCMenuAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCMenuAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCMenuAdapter} */{
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {
              return false;
            },
            hasNecessaryDom: function hasNecessaryDom() {
              return false;
            },
            getAttributeForEventTarget: function getAttributeForEventTarget() {},
            getInnerDimensions: function getInnerDimensions() {
              return {};
            },
            hasAnchor: function hasAnchor() {
              return false;
            },
            getAnchorDimensions: function getAnchorDimensions() {
              return {};
            },
            getWindowDimensions: function getWindowDimensions() {
              return {};
            },
            getNumberOfItems: function getNumberOfItems() {
              return 0;
            },
            registerInteractionHandler: function registerInteractionHandler() {},
            deregisterInteractionHandler: function deregisterInteractionHandler() {},
            registerBodyClickHandler: function registerBodyClickHandler() {},
            deregisterBodyClickHandler: function deregisterBodyClickHandler() {},
            getIndexForEventTarget: function getIndexForEventTarget() {
              return 0;
            },
            notifySelected: function notifySelected() {},
            notifyCancel: function notifyCancel() {},
            saveFocus: function saveFocus() {},
            restoreFocus: function restoreFocus() {},
            isFocused: function isFocused() {
              return false;
            },
            focus: function focus() {},
            getFocusedItemIndex: function getFocusedItemIndex() {
              return -1;
            },
            focusItemAtIndex: function focusItemAtIndex() {},
            isRtl: function isRtl() {
              return false;
            },
            setTransformOrigin: function setTransformOrigin() {},
            setPosition: function setPosition() {},
            setMaxHeight: function setMaxHeight() {},
            setAttrForOptionAtIndex: function setAttrForOptionAtIndex() {},
            rmAttrForOptionAtIndex: function rmAttrForOptionAtIndex() {},
            addClassForOptionAtIndex: function addClassForOptionAtIndex() {},
            rmClassForOptionAtIndex: function rmClassForOptionAtIndex() {}
          }
        );
      }

      /** @param {!MDCMenuAdapter} adapter */

    }]);

    function MDCMenuFoundation(adapter) {
      classCallCheck(this, MDCMenuFoundation);

      /** @private {function(!Event)} */
      var _this = possibleConstructorReturn(this, (MDCMenuFoundation.__proto__ || Object.getPrototypeOf(MDCMenuFoundation)).call(this, _extends(MDCMenuFoundation.defaultAdapter, adapter)));

      _this.clickHandler_ = function (evt) {
        return _this.handlePossibleSelected_(evt);
      };
      /** @private {function(!Event)} */
      _this.keydownHandler_ = function (evt) {
        return _this.handleKeyboardDown_(evt);
      };
      /** @private {function(!Event)} */
      _this.keyupHandler_ = function (evt) {
        return _this.handleKeyboardUp_(evt);
      };
      /** @private {function(!Event)} */
      _this.documentClickHandler_ = function (evt) {
        return _this.handleDocumentClick_(evt);
      };
      /** @private {boolean} */
      _this.isOpen_ = false;
      /** @private {number} */
      _this.openAnimationEndTimerId_ = 0;
      /** @private {number} */
      _this.closeAnimationEndTimerId_ = 0;
      /** @private {number} */
      _this.selectedTriggerTimerId_ = 0;
      /** @private {number} */
      _this.animationRequestId_ = 0;
      /** @private {!{ width: number, height: number }} */
      _this.dimensions_;
      /** @private {number} */
      _this.itemHeight_;
      /** @private {Corner} */
      _this.anchorCorner_ = Corner.TOP_START;
      /** @private {AnchorMargin} */
      _this.anchorMargin_ = { top: 0, right: 0, bottom: 0, left: 0 };
      /** @private {?AutoLayoutMeasurements} */
      _this.measures_ = null;
      /** @private {number} */
      _this.selectedIndex_ = -1;
      /** @private {boolean} */
      _this.rememberSelection_ = false;
      /** @private {boolean} */
      _this.quickOpen_ = false;

      // A keyup event on the menu needs to have a corresponding keydown
      // event on the menu. If the user opens the menu with a keydown event on a
      // button, the menu will only get the key up event causing buggy behavior with selected elements.
      /** @private {boolean} */
      _this.keyDownWithinMenu_ = false;
      return _this;
    }

    createClass(MDCMenuFoundation, [{
      key: 'init',
      value: function init() {
        var _MDCMenuFoundation$cs = MDCMenuFoundation.cssClasses,
            ROOT = _MDCMenuFoundation$cs.ROOT,
            OPEN = _MDCMenuFoundation$cs.OPEN;


        if (!this.adapter_.hasClass(ROOT)) {
          throw new Error(ROOT + ' class required in root element.');
        }

        if (!this.adapter_.hasNecessaryDom()) {
          throw new Error('Required DOM nodes missing in ' + ROOT + ' component.');
        }

        if (this.adapter_.hasClass(OPEN)) {
          this.isOpen_ = true;
        }

        this.adapter_.registerInteractionHandler('click', this.clickHandler_);
        this.adapter_.registerInteractionHandler('keyup', this.keyupHandler_);
        this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        clearTimeout(this.selectedTriggerTimerId_);
        clearTimeout(this.openAnimationEndTimerId_);
        clearTimeout(this.closeAnimationEndTimerId_);
        // Cancel any currently running animations.
        cancelAnimationFrame(this.animationRequestId_);
        this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
        this.adapter_.deregisterInteractionHandler('keyup', this.keyupHandler_);
        this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.deregisterBodyClickHandler(this.documentClickHandler_);
      }

      /**
       * @param {!Corner} corner Default anchor corner alignment of top-left menu corner.
       */

    }, {
      key: 'setAnchorCorner',
      value: function setAnchorCorner(corner) {
        this.anchorCorner_ = corner;
      }

      /**
       * @param {!AnchorMargin} margin 4-plet of margins from anchor.
       */

    }, {
      key: 'setAnchorMargin',
      value: function setAnchorMargin(margin) {
        this.anchorMargin_.top = typeof margin.top === 'number' ? margin.top : 0;
        this.anchorMargin_.right = typeof margin.right === 'number' ? margin.right : 0;
        this.anchorMargin_.bottom = typeof margin.bottom === 'number' ? margin.bottom : 0;
        this.anchorMargin_.left = typeof margin.left === 'number' ? margin.left : 0;
      }

      /** @param {boolean} rememberSelection */

    }, {
      key: 'setRememberSelection',
      value: function setRememberSelection(rememberSelection) {
        this.rememberSelection_ = rememberSelection;
        this.setSelectedIndex(-1);
      }

      /** @param {boolean} quickOpen */

    }, {
      key: 'setQuickOpen',
      value: function setQuickOpen(quickOpen) {
        this.quickOpen_ = quickOpen;
      }

      /**
       * @param {?number} focusIndex
       * @private
       */

    }, {
      key: 'focusOnOpen_',
      value: function focusOnOpen_(focusIndex) {
        if (focusIndex === null) {
          // If this instance of MDCMenu remembers selections, and the user has
          // made a selection, then focus the last selected item
          if (this.rememberSelection_ && this.selectedIndex_ >= 0) {
            this.adapter_.focusItemAtIndex(this.selectedIndex_);
            return;
          }

          this.adapter_.focus();
          // If that doesn't work, focus first item instead.
          if (!this.adapter_.isFocused()) {
            this.adapter_.focusItemAtIndex(0);
          }
        } else {
          this.adapter_.focusItemAtIndex(focusIndex);
        }
      }

      /**
       * Handle clicks and cancel the menu if not a child list-item
       * @param {!Event} evt
       * @private
       */

    }, {
      key: 'handleDocumentClick_',
      value: function handleDocumentClick_(evt) {
        var el = evt.target;

        while (el && el !== document.documentElement) {
          if (this.adapter_.getIndexForEventTarget(el) !== -1) {
            return;
          }
          el = el.parentNode;
        }

        this.adapter_.notifyCancel();
        this.close(evt);
      }
    }, {
      key: 'handleKeyboardDown_',


      /**
       * Handle keys that we want to repeat on hold (tab and arrows).
       * @param {!Event} evt
       * @return {boolean}
       * @private
       */
      value: function handleKeyboardDown_(evt) {
        // Do nothing if Alt, Ctrl or Meta are pressed.
        if (evt.altKey || evt.ctrlKey || evt.metaKey) {
          return true;
        }

        var keyCode = evt.keyCode,
            key = evt.key,
            shiftKey = evt.shiftKey;

        var isTab = key === 'Tab' || keyCode === 9;
        var isArrowUp = key === 'ArrowUp' || keyCode === 38;
        var isArrowDown = key === 'ArrowDown' || keyCode === 40;
        var isSpace = key === 'Space' || keyCode === 32;
        var isEnter = key === 'Enter' || keyCode === 13;
        // The menu needs to know if the keydown event was triggered on the menu
        this.keyDownWithinMenu_ = isEnter || isSpace;

        var focusedItemIndex = this.adapter_.getFocusedItemIndex();
        var lastItemIndex = this.adapter_.getNumberOfItems() - 1;

        if (shiftKey && isTab && focusedItemIndex === 0) {
          this.adapter_.focusItemAtIndex(lastItemIndex);
          evt.preventDefault();
          return false;
        }

        if (!shiftKey && isTab && focusedItemIndex === lastItemIndex) {
          this.adapter_.focusItemAtIndex(0);
          evt.preventDefault();
          return false;
        }

        // Ensure Arrow{Up,Down} and space do not cause inadvertent scrolling
        if (isArrowUp || isArrowDown || isSpace) {
          evt.preventDefault();
        }

        if (isArrowUp) {
          if (focusedItemIndex === 0 || this.adapter_.isFocused()) {
            this.adapter_.focusItemAtIndex(lastItemIndex);
          } else {
            this.adapter_.focusItemAtIndex(focusedItemIndex - 1);
          }
        } else if (isArrowDown) {
          if (focusedItemIndex === lastItemIndex || this.adapter_.isFocused()) {
            this.adapter_.focusItemAtIndex(0);
          } else {
            this.adapter_.focusItemAtIndex(focusedItemIndex + 1);
          }
        }

        return true;
      }

      /**
       * Handle keys that we don't want to repeat on hold (Enter, Space, Escape).
       * @param {!Event} evt
       * @return {boolean}
       * @private
       */

    }, {
      key: 'handleKeyboardUp_',
      value: function handleKeyboardUp_(evt) {
        // Do nothing if Alt, Ctrl or Meta are pressed.
        if (evt.altKey || evt.ctrlKey || evt.metaKey) {
          return true;
        }

        var keyCode = evt.keyCode,
            key = evt.key;

        var isEnter = key === 'Enter' || keyCode === 13;
        var isSpace = key === 'Space' || keyCode === 32;
        var isEscape = key === 'Escape' || keyCode === 27;

        if (isEnter || isSpace) {
          // If the keydown event didn't occur on the menu, then it should
          // disregard the possible selected event.
          if (this.keyDownWithinMenu_) {
            this.handlePossibleSelected_(evt);
          }
          this.keyDownWithinMenu_ = false;
        }

        if (isEscape) {
          this.adapter_.notifyCancel();
          this.close();
        }

        return true;
      }

      /**
       * @param {!Event} evt
       * @private
       */

    }, {
      key: 'handlePossibleSelected_',
      value: function handlePossibleSelected_(evt) {
        var _this2 = this;

        if (this.adapter_.getAttributeForEventTarget(evt.target, strings$c.ARIA_DISABLED_ATTR) === 'true') {
          return;
        }
        var targetIndex = this.adapter_.getIndexForEventTarget(evt.target);
        if (targetIndex < 0) {
          return;
        }
        // Debounce multiple selections
        if (this.selectedTriggerTimerId_) {
          return;
        }
        this.selectedTriggerTimerId_ = setTimeout(function () {
          _this2.selectedTriggerTimerId_ = 0;
          _this2.close();
          if (_this2.rememberSelection_) {
            _this2.setSelectedIndex(targetIndex);
          }
          _this2.adapter_.notifySelected({ index: targetIndex });
        }, numbers$4.SELECTED_TRIGGER_DELAY);
      }

      /**
       * @return {AutoLayoutMeasurements} Measurements used to position menu popup.
       */

    }, {
      key: 'getAutoLayoutMeasurements_',
      value: function getAutoLayoutMeasurements_() {
        var anchorRect = this.adapter_.getAnchorDimensions();
        var viewport = this.adapter_.getWindowDimensions();

        return {
          viewport: viewport,
          viewportDistance: {
            top: anchorRect.top,
            right: viewport.width - anchorRect.right,
            left: anchorRect.left,
            bottom: viewport.height - anchorRect.bottom
          },
          anchorHeight: anchorRect.height,
          anchorWidth: anchorRect.width,
          menuHeight: this.dimensions_.height,
          menuWidth: this.dimensions_.width
        };
      }

      /**
       * Computes the corner of the anchor from which to animate and position the menu.
       * @return {Corner}
       * @private
       */

    }, {
      key: 'getOriginCorner_',
      value: function getOriginCorner_() {
        // Defaults: open from the top left.
        var corner = Corner.TOP_LEFT;

        var _measures_ = this.measures_,
            viewportDistance = _measures_.viewportDistance,
            anchorHeight = _measures_.anchorHeight,
            anchorWidth = _measures_.anchorWidth,
            menuHeight = _measures_.menuHeight,
            menuWidth = _measures_.menuWidth;

        var isBottomAligned = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);
        var availableTop = isBottomAligned ? viewportDistance.top + anchorHeight + this.anchorMargin_.bottom : viewportDistance.top + this.anchorMargin_.top;
        var availableBottom = isBottomAligned ? viewportDistance.bottom - this.anchorMargin_.bottom : viewportDistance.bottom + anchorHeight - this.anchorMargin_.top;

        var topOverflow = menuHeight - availableTop;
        var bottomOverflow = menuHeight - availableBottom;
        if (bottomOverflow > 0 && topOverflow < bottomOverflow) {
          corner |= CornerBit.BOTTOM;
        }

        var isRtl = this.adapter_.isRtl();
        var isFlipRtl = Boolean(this.anchorCorner_ & CornerBit.FLIP_RTL);
        var avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);
        var isAlignedRight = avoidHorizontalOverlap && !isRtl || !avoidHorizontalOverlap && isFlipRtl && isRtl;
        var availableLeft = isAlignedRight ? viewportDistance.left + anchorWidth + this.anchorMargin_.right : viewportDistance.left + this.anchorMargin_.left;
        var availableRight = isAlignedRight ? viewportDistance.right - this.anchorMargin_.right : viewportDistance.right + anchorWidth - this.anchorMargin_.left;

        var leftOverflow = menuWidth - availableLeft;
        var rightOverflow = menuWidth - availableRight;

        if (leftOverflow < 0 && isAlignedRight && isRtl || avoidHorizontalOverlap && !isAlignedRight && leftOverflow < 0 || rightOverflow > 0 && leftOverflow < rightOverflow) {
          corner |= CornerBit.RIGHT;
        }

        return corner;
      }

      /**
       * @param {Corner} corner Origin corner of the menu.
       * @return {number} Horizontal offset of menu origin corner from corresponding anchor corner.
       * @private
       */

    }, {
      key: 'getHorizontalOriginOffset_',
      value: function getHorizontalOriginOffset_(corner) {
        var anchorWidth = this.measures_.anchorWidth;

        var isRightAligned = Boolean(corner & CornerBit.RIGHT);
        var avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);
        var x = 0;
        if (isRightAligned) {
          var rightOffset = avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.left : this.anchorMargin_.right;
          x = rightOffset;
        } else {
          var leftOffset = avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.right : this.anchorMargin_.left;
          x = leftOffset;
        }
        return x;
      }

      /**
       * @param {Corner} corner Origin corner of the menu.
       * @return {number} Vertical offset of menu origin corner from corresponding anchor corner.
       * @private
       */

    }, {
      key: 'getVerticalOriginOffset_',
      value: function getVerticalOriginOffset_(corner) {
        var _measures_2 = this.measures_,
            viewport = _measures_2.viewport,
            viewportDistance = _measures_2.viewportDistance,
            anchorHeight = _measures_2.anchorHeight,
            menuHeight = _measures_2.menuHeight;

        var isBottomAligned = Boolean(corner & CornerBit.BOTTOM);
        var MARGIN_TO_EDGE = MDCMenuFoundation.numbers.MARGIN_TO_EDGE;

        var avoidVerticalOverlap = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);
        var canOverlapVertically = !avoidVerticalOverlap;
        var y = 0;

        if (isBottomAligned) {
          y = avoidVerticalOverlap ? anchorHeight - this.anchorMargin_.top : -this.anchorMargin_.bottom;
          // adjust for when menu can overlap anchor, but too tall to be aligned to bottom
          // anchor corner. Bottom margin is ignored in such cases.
          if (canOverlapVertically && menuHeight > viewportDistance.top + anchorHeight) {
            y = -(Math.min(menuHeight, viewport.height - MARGIN_TO_EDGE) - (viewportDistance.top + anchorHeight));
          }
        } else {
          y = avoidVerticalOverlap ? anchorHeight + this.anchorMargin_.bottom : this.anchorMargin_.top;
          // adjust for when menu can overlap anchor, but too tall to be aligned to top
          // anchor corners. Top margin is ignored in that case.
          if (canOverlapVertically && menuHeight > viewportDistance.bottom + anchorHeight) {
            y = -(Math.min(menuHeight, viewport.height - MARGIN_TO_EDGE) - (viewportDistance.bottom + anchorHeight));
          }
        }
        return y;
      }

      /**
       * @param {Corner} corner Origin corner of the menu.
       * @return {number} Maximum height of the menu, based on available space. 0 indicates should not be set.
       * @private
       */

    }, {
      key: 'getMenuMaxHeight_',
      value: function getMenuMaxHeight_(corner) {
        var maxHeight = 0;
        var viewportDistance = this.measures_.viewportDistance;

        var isBottomAligned = Boolean(corner & CornerBit.BOTTOM);

        // When maximum height is not specified, it is handled from css.
        if (this.anchorCorner_ & CornerBit.BOTTOM) {
          if (isBottomAligned) {
            maxHeight = viewportDistance.top + this.anchorMargin_.top;
          } else {
            maxHeight = viewportDistance.bottom - this.anchorMargin_.bottom;
          }
        }

        return maxHeight;
      }

      /** @private */

    }, {
      key: 'autoPosition_',
      value: function autoPosition_() {
        var _position;

        if (!this.adapter_.hasAnchor()) {
          return;
        }

        // Compute measurements for autoposition methods reuse.
        this.measures_ = this.getAutoLayoutMeasurements_();

        var corner = this.getOriginCorner_();
        var maxMenuHeight = this.getMenuMaxHeight_(corner);
        var verticalAlignment = corner & CornerBit.BOTTOM ? 'bottom' : 'top';
        var horizontalAlignment = corner & CornerBit.RIGHT ? 'right' : 'left';
        var horizontalOffset = this.getHorizontalOriginOffset_(corner);
        var verticalOffset = this.getVerticalOriginOffset_(corner);
        var position = (_position = {}, defineProperty(_position, horizontalAlignment, horizontalOffset ? horizontalOffset + 'px' : '0'), defineProperty(_position, verticalAlignment, verticalOffset ? verticalOffset + 'px' : '0'), _position);
        var _measures_3 = this.measures_,
            anchorWidth = _measures_3.anchorWidth,
            menuHeight = _measures_3.menuHeight,
            menuWidth = _measures_3.menuWidth;
        // Center align when anchor width is comparable or greater than menu, otherwise keep corner.

        if (anchorWidth / menuWidth > numbers$4.ANCHOR_TO_MENU_WIDTH_RATIO) {
          horizontalAlignment = 'center';
        }

        // Adjust vertical origin when menu is positioned with significant offset from anchor. This is done so that
        // scale animation is "anchored" on the anchor.
        if (!(this.anchorCorner_ & CornerBit.BOTTOM) && Math.abs(verticalOffset / menuHeight) > numbers$4.OFFSET_TO_MENU_HEIGHT_RATIO) {
          var verticalOffsetPercent = Math.abs(verticalOffset / menuHeight) * 100;
          var originPercent = corner & CornerBit.BOTTOM ? 100 - verticalOffsetPercent : verticalOffsetPercent;
          verticalAlignment = Math.round(originPercent * 100) / 100 + '%';
        }

        this.adapter_.setTransformOrigin(horizontalAlignment + ' ' + verticalAlignment);
        this.adapter_.setPosition(position);
        this.adapter_.setMaxHeight(maxMenuHeight ? maxMenuHeight + 'px' : '');

        // Clear measures after positioning is complete.
        this.measures_ = null;
      }

      /**
       * Open the menu.
       * @param {{focusIndex: ?number}=} options
       */

    }, {
      key: 'open',
      value: function open() {
        var _this3 = this;

        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref$focusIndex = _ref.focusIndex,
            focusIndex = _ref$focusIndex === undefined ? null : _ref$focusIndex;

        this.adapter_.saveFocus();

        if (!this.quickOpen_) {
          this.adapter_.addClass(MDCMenuFoundation.cssClasses.ANIMATING_OPEN);
        }

        this.animationRequestId_ = requestAnimationFrame(function () {
          _this3.dimensions_ = _this3.adapter_.getInnerDimensions();
          _this3.autoPosition_();
          _this3.adapter_.addClass(MDCMenuFoundation.cssClasses.OPEN);
          _this3.focusOnOpen_(focusIndex);
          _this3.adapter_.registerBodyClickHandler(_this3.documentClickHandler_);
          if (!_this3.quickOpen_) {
            _this3.openAnimationEndTimerId_ = setTimeout(function () {
              _this3.openAnimationEndTimerId_ = 0;
              _this3.adapter_.removeClass(MDCMenuFoundation.cssClasses.ANIMATING_OPEN);
            }, numbers$4.TRANSITION_OPEN_DURATION);
          }
        });
        this.isOpen_ = true;
      }

      /**
       * Closes the menu.
       * @param {Event=} evt
       */

    }, {
      key: 'close',
      value: function close() {
        var _this4 = this;

        var evt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        var targetIsDisabled = evt ? this.adapter_.getAttributeForEventTarget(evt.target, strings$c.ARIA_DISABLED_ATTR) === 'true' : false;

        if (targetIsDisabled) {
          return;
        }

        this.adapter_.deregisterBodyClickHandler(this.documentClickHandler_);

        if (!this.quickOpen_) {
          this.adapter_.addClass(MDCMenuFoundation.cssClasses.ANIMATING_CLOSED);
        }

        requestAnimationFrame(function () {
          _this4.adapter_.removeClass(MDCMenuFoundation.cssClasses.OPEN);
          if (!_this4.quickOpen_) {
            _this4.closeAnimationEndTimerId_ = setTimeout(function () {
              _this4.closeAnimationEndTimerId_ = 0;
              _this4.adapter_.removeClass(MDCMenuFoundation.cssClasses.ANIMATING_CLOSED);
            }, numbers$4.TRANSITION_CLOSE_DURATION);
          }
        });
        this.isOpen_ = false;
        this.adapter_.restoreFocus();
      }

      /** @return {boolean} */

    }, {
      key: 'isOpen',
      value: function isOpen() {
        return this.isOpen_;
      }

      /** @return {number} */

    }, {
      key: 'getSelectedIndex',
      value: function getSelectedIndex() {
        return this.selectedIndex_;
      }

      /**
       * @param {number} index Index of the item to set as selected.
       */

    }, {
      key: 'setSelectedIndex',
      value: function setSelectedIndex(index) {
        if (index === this.selectedIndex_) {
          return;
        }

        var prevSelectedIndex = this.selectedIndex_;
        if (prevSelectedIndex >= 0) {
          this.adapter_.rmAttrForOptionAtIndex(prevSelectedIndex, 'aria-selected');
          this.adapter_.rmClassForOptionAtIndex(prevSelectedIndex, cssClasses$b.SELECTED_LIST_ITEM);
        }

        this.selectedIndex_ = index >= 0 && index < this.adapter_.getNumberOfItems() ? index : -1;
        if (this.selectedIndex_ >= 0) {
          this.adapter_.setAttrForOptionAtIndex(this.selectedIndex_, 'aria-selected', 'true');
          this.adapter_.addClassForOptionAtIndex(this.selectedIndex_, cssClasses$b.SELECTED_LIST_ITEM);
        }
      }
    }]);
    return MDCMenuFoundation;
  }(MDCFoundation);

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @type {string|undefined} */
  var storedTransformPropertyName_$1 = void 0;

  /**
   * Returns the name of the correct transform property to use on the current browser.
   * @param {!Window} globalObj
   * @param {boolean=} forceRefresh
   * @return {string}
   */
  function getTransformPropertyName$1(globalObj) {
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (storedTransformPropertyName_$1 === undefined || forceRefresh) {
      var el = globalObj.document.createElement('div');
      var transformPropertyName = 'transform' in el.style ? 'transform' : 'webkitTransform';
      storedTransformPropertyName_$1 = transformPropertyName;
    }

    return storedTransformPropertyName_$1;
  }

  //

  var script$J = {
    name: 'mdc-menu',
    model: {
      prop: 'open',
      event: 'change'
    },
    props: {
      open: [Boolean, Object],
      'quick-open': Boolean,
      'anchor-corner': [String, Number],
      'anchor-margin': Object
    },
    data: function data() {
      return {
        classes: {},
        styles: {},
        items: []
      };
    },

    watch: {
      open: 'onOpen_',
      quickOpen: function quickOpen(nv) {
        this.foundation.setQuickOpen(nv);
      },
      anchorCorner: function anchorCorner(nv) {
        this.foundation.setAnchorCorner(Number(nv));
      },
      anchorMargin: function anchorMargin(nv) {
        this.foundation.setAnchorMargin(nv);
      }
    },
    mounted: function mounted() {
      var _this = this;

      var refreshItems = function refreshItems() {
        _this.items = [].slice.call(_this.$refs.items.querySelectorAll('.mdc-list-item[role]'));
        _this.$emit('update');
      };
      this.slotObserver = new MutationObserver(function () {
        return refreshItems();
      });
      this.slotObserver.observe(this.$el, {
        childList: true,
        subtree: true
      });

      this._previousFocus = undefined;

      this.foundation = new MDCMenuFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        hasClass: function hasClass(className) {
          return _this.$refs.root.classList.contains(className);
        },
        hasNecessaryDom: function hasNecessaryDom() {
          return Boolean(_this.$refs.items);
        },
        getAttributeForEventTarget: function getAttributeForEventTarget(target, attributeName) {
          return target.getAttribute(attributeName);
        },
        getInnerDimensions: function getInnerDimensions() {
          return {
            width: _this.$refs.items.offsetWidth,
            height: _this.$refs.items.offsetHeight
          };
        },
        hasAnchor: function hasAnchor() {
          return _this.$refs.root.parentElement && _this.$refs.root.parentElement.classList.contains('mdc-menu-anchor');
        },
        getAnchorDimensions: function getAnchorDimensions() {
          return _this.$refs.root.parentElement.getBoundingClientRect();
        },
        getWindowDimensions: function getWindowDimensions() {
          return {
            width: window.innerWidth,
            height: window.innerHeight
          };
        },
        getNumberOfItems: function getNumberOfItems() {
          return _this.items.length;
        },
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          return _this.$refs.root.addEventListener(type, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          return _this.$refs.root.removeEventListener(type, handler);
        },
        registerBodyClickHandler: function registerBodyClickHandler(handler) {
          return document.body.addEventListener('click', handler);
        },
        deregisterBodyClickHandler: function deregisterBodyClickHandler(handler) {
          return document.body.removeEventListener('click', handler);
        },
        getIndexForEventTarget: function getIndexForEventTarget(target) {
          return _this.items.indexOf(target);
        },
        notifySelected: function notifySelected(evtData) {
          var evt = {
            index: evtData.index,
            item: _this.items[evtData.index]
          };
          _this.$emit('change', false);
          _this.$emit('select', evt);
          emitCustomEvent(_this.$el, MDCMenuFoundation.strings.SELECTED_EVENT, evt);
        },
        notifyCancel: function notifyCancel() {
          _this.$emit('change', false);
          _this.$emit('cancel');
          emitCustomEvent(_this.$el, MDCMenuFoundation.strings.CANCEL_EVENT, {});
        },
        saveFocus: function saveFocus() {
          _this._previousFocus = document.activeElement;
        },
        restoreFocus: function restoreFocus() {
          if (_this._previousFocus) {
            _this._previousFocus.focus();
          }
        },
        isFocused: function isFocused() {
          return document.activeElement === _this.$refs.root;
        },
        focus: function focus() {
          return _this.$refs.root.focus();
        },
        getFocusedItemIndex: function getFocusedItemIndex() {
          return _this.items.indexOf(document.activeElement);
        },
        focusItemAtIndex: function focusItemAtIndex(index) {
          return _this.items[index].focus();
        },
        isRtl: function isRtl() {
          return getComputedStyle(_this.$refs.root).getPropertyValue('direction') === 'rtl';
        },
        setTransformOrigin: function setTransformOrigin(origin) {
          _this.$set(_this.styles, getTransformPropertyName$1(window) + '-origin', origin);
        },
        setPosition: function setPosition(position) {
          _this.$set(_this.styles, 'left', position.left);
          _this.$set(_this.styles, 'right', position.right);
          _this.$set(_this.styles, 'top', position.top);
          _this.$set(_this.styles, 'bottom', position.bottom);
        },
        setMaxHeight: function setMaxHeight(height) {
          _this.$set(_this.styles, 'max-height', height);
        },
        setAttrForOptionAtIndex: function setAttrForOptionAtIndex(index, attr, value) {
          _this.items[index].setAttribute(attr, value);
        },
        rmAttrForOptionAtIndex: function rmAttrForOptionAtIndex(index, attr) {
          _this.items[index].removeAttribute(attr);
        },
        addClassForOptionAtIndex: function addClassForOptionAtIndex(index, className) {
          _this.items[index].classList.add(className);
        },
        rmClassForOptionAtIndex: function rmClassForOptionAtIndex(index, className) {
          _this.items[index].classList.remove(className);
        }
      });

      refreshItems();
      this.foundation.init();
      if (this.anchorCorner !== void 0) {
        this.foundation.setAnchorCorner(Number(this.anchorCorner));
      }
      if (this.anchorMargin !== void 0) {
        this.foundation.setAnchorMargin(this.anchorMargin);
      }
    },
    beforeDestroy: function beforeDestroy() {
      this._previousFocus = null;
      this.slotObserver.disconnect();
      this.foundation.destroy();
    },


    methods: {
      onOpen_: function onOpen_(value) {
        if (value) {
          this.foundation.open((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' ? value : void 0);
        } else {
          this.foundation.close();
        }
      },
      show: function show(options) {
        this.foundation.open(options);
      },
      hide: function hide() {
        this.foundation.close();
      },
      isOpen: function isOpen() {
        return this.foundation ? this.foundation.isOpen() : false;
      }
    }
  };

  /* script */
  var __vue_script__$J = script$J;

  /* template */
  var __vue_render__$G = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", {
      ref: "root",
      staticClass: "mdc-menu mdc-simple-menu",
      class: _vm.classes,
      style: _vm.styles,
      attrs: { tabindex: "-1" }
    }, [_c("ul", {
      ref: "items",
      staticClass: "mdc-simple-menu__items mdc-list",
      attrs: { role: "menu", "aria-hidden": "true" }
    }, [_vm._t("default")], 2)]);
  };
  var __vue_staticRenderFns__$G = [];
  __vue_render__$G._withStripped = true;

  /* style */
  var __vue_inject_styles__$J = undefined;
  /* scoped */
  var __vue_scope_id__$J = undefined;
  /* module identifier */
  var __vue_module_identifier__$J = undefined;
  /* functional template */
  var __vue_is_functional_template__$J = false;
  /* component normalizer */
  function __vue_normalize__$J(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/menu/mdc-menu.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$J() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$J.styles || (__vue_create_injector__$J.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcMenu = __vue_normalize__$J({ render: __vue_render__$G, staticRenderFns: __vue_staticRenderFns__$G }, __vue_inject_styles__$J, __vue_script__$J, __vue_scope_id__$J, __vue_is_functional_template__$J, __vue_module_identifier__$J, __vue_create_injector__$J, undefined);

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //

  var script$K = {
    name: 'mdc-menu-item',
    props: {
      disabled: Boolean
    }
  };

  /* script */
  var __vue_script__$K = script$K;

  /* template */
  var __vue_render__$H = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("li", {
      staticClass: "mdc-menu-item mdc-list-item",
      attrs: {
        tabindex: _vm.disabled ? "-1" : "0",
        "aria-disabled": _vm.disabled,
        role: "menuitem"
      }
    }, [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$H = [];
  __vue_render__$H._withStripped = true;

  /* style */
  var __vue_inject_styles__$K = undefined;
  /* scoped */
  var __vue_scope_id__$K = undefined;
  /* module identifier */
  var __vue_module_identifier__$K = undefined;
  /* functional template */
  var __vue_is_functional_template__$K = false;
  /* component normalizer */
  function __vue_normalize__$K(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/menu/mdc-menu-item.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$K() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$K.styles || (__vue_create_injector__$K.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcMenuItem = __vue_normalize__$K({ render: __vue_render__$H, staticRenderFns: __vue_staticRenderFns__$H }, __vue_inject_styles__$K, __vue_script__$K, __vue_scope_id__$K, __vue_is_functional_template__$K, __vue_module_identifier__$K, __vue_create_injector__$K, undefined);

  //
  //
  //
  //
  //
  //

  var script$L = {
    name: 'mdc-menu-divider'
  };

  /* script */
  var __vue_script__$L = script$L;

  /* template */
  var __vue_render__$I = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("li", {
      staticClass: "mdc-menu-divider mdc-list-divider",
      attrs: { role: "separator" }
    });
  };
  var __vue_staticRenderFns__$I = [];
  __vue_render__$I._withStripped = true;

  /* style */
  var __vue_inject_styles__$L = undefined;
  /* scoped */
  var __vue_scope_id__$L = undefined;
  /* module identifier */
  var __vue_module_identifier__$L = undefined;
  /* functional template */
  var __vue_is_functional_template__$L = false;
  /* component normalizer */
  function __vue_normalize__$L(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/menu/mdc-menu-divider.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$L() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$L.styles || (__vue_create_injector__$L.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcMenuDivider = __vue_normalize__$L({ render: __vue_render__$I, staticRenderFns: __vue_staticRenderFns__$I }, __vue_inject_styles__$L, __vue_script__$L, __vue_scope_id__$L, __vue_is_functional_template__$L, __vue_module_identifier__$L, __vue_create_injector__$L, undefined);

  //
  //
  //
  //
  //
  //

  var script$M = {
    name: 'mdc-menu-anchor'
  };

  /* script */
  var __vue_script__$M = script$M;

  /* template */
  var __vue_render__$J = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { staticClass: "mdc-menu-anchor" }, [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$J = [];
  __vue_render__$J._withStripped = true;

  /* style */
  var __vue_inject_styles__$M = undefined;
  /* scoped */
  var __vue_scope_id__$M = undefined;
  /* module identifier */
  var __vue_module_identifier__$M = undefined;
  /* functional template */
  var __vue_is_functional_template__$M = false;
  /* component normalizer */
  function __vue_normalize__$M(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/menu/mdc-menu-anchor.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$M() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$M.styles || (__vue_create_injector__$M.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcMenuAnchor = __vue_normalize__$M({ render: __vue_render__$J, staticRenderFns: __vue_staticRenderFns__$J }, __vue_inject_styles__$M, __vue_script__$M, __vue_scope_id__$M, __vue_is_functional_template__$M, __vue_module_identifier__$M, __vue_create_injector__$M, undefined);

  var VueMDCMenu = BasePlugin({
    mdcMenu: mdcMenu,
    mdcMenuItem: mdcMenuItem,
    mdcMenuDivider: mdcMenuDivider,
    mdcMenuAnchor: mdcMenuAnchor
  });

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Radio. Provides an interface for managing
   * - classes
   * - dom
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */

  var MDCRadioAdapter = function () {
    function MDCRadioAdapter() {
      classCallCheck(this, MDCRadioAdapter);
    }

    createClass(MDCRadioAdapter, [{
      key: 'addClass',

      /** @param {string} className */
      value: function addClass(className) {}

      /** @param {string} className */

    }, {
      key: 'removeClass',
      value: function removeClass(className) {}

      /** @return {!MDCSelectionControlState} */

    }, {
      key: 'getNativeControl',
      value: function getNativeControl() {}
    }]);
    return MDCRadioAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$d = {
    NATIVE_CONTROL_SELECTOR: '.mdc-radio__native-control'
  };

  /** @enum {string} */
  var cssClasses$c = {
    ROOT: 'mdc-radio',
    DISABLED: 'mdc-radio--disabled'
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCRadioAdapter>}
   */

  var MDCRadioFoundation = function (_MDCFoundation) {
    inherits(MDCRadioFoundation, _MDCFoundation);

    function MDCRadioFoundation() {
      classCallCheck(this, MDCRadioFoundation);
      return possibleConstructorReturn(this, (MDCRadioFoundation.__proto__ || Object.getPrototypeOf(MDCRadioFoundation)).apply(this, arguments));
    }

    createClass(MDCRadioFoundation, [{
      key: 'isChecked',


      /** @return {boolean} */
      value: function isChecked() {
        return this.getNativeControl_().checked;
      }

      /** @param {boolean} checked */

    }, {
      key: 'setChecked',
      value: function setChecked(checked) {
        this.getNativeControl_().checked = checked;
      }

      /** @return {boolean} */

    }, {
      key: 'isDisabled',
      value: function isDisabled() {
        return this.getNativeControl_().disabled;
      }

      /** @param {boolean} disabled */

    }, {
      key: 'setDisabled',
      value: function setDisabled(disabled) {
        var DISABLED = MDCRadioFoundation.cssClasses.DISABLED;

        this.getNativeControl_().disabled = disabled;
        if (disabled) {
          this.adapter_.addClass(DISABLED);
        } else {
          this.adapter_.removeClass(DISABLED);
        }
      }

      /** @return {?string} */

    }, {
      key: 'getValue',
      value: function getValue() {
        return this.getNativeControl_().value;
      }

      /** @param {?string} value */

    }, {
      key: 'setValue',
      value: function setValue(value) {
        this.getNativeControl_().value = value;
      }

      /**
       * @return {!MDCSelectionControlState}
       * @private
       */

    }, {
      key: 'getNativeControl_',
      value: function getNativeControl_() {
        return this.adapter_.getNativeControl() || {
          checked: false,
          disabled: false,
          value: null
        };
      }
    }], [{
      key: 'cssClasses',

      /** @return enum {cssClasses} */
      get: function get$$1() {
        return cssClasses$c;
      }

      /** @return enum {strings} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$d;
      }

      /** @return {!MDCRadioAdapter} */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCRadioAdapter} */{
            addClass: function addClass() /* className: string */{},
            removeClass: function removeClass() /* className: string */{},
            getNativeControl: function getNativeControl() /* !MDCSelectionControlState */{}
          }
        );
      }
    }]);
    return MDCRadioFoundation;
  }(MDCFoundation);

  //

  var script$N = {
    name: 'mdc-radio',
    mixins: [DispatchFocusMixin, VMAUniqueIdMixin],
    model: {
      prop: 'picked',
      event: 'change'
    },
    props: {
      name: { type: String, required: true },
      value: String,
      picked: String,
      checked: Boolean,
      label: String,
      'align-end': Boolean,
      disabled: Boolean
    },
    data: function data() {
      return {
        classes: {},
        styles: {},
        formFieldClasses: {
          'mdc-form-field': this.label,
          'mdc-form-field--align-end': this.label && this.alignEnd
        }
      };
    },

    watch: {
      checked: 'setChecked',
      disabled: function disabled(value) {
        this.foundation.setDisabled(value);
      }
    },
    mounted: function mounted() {
      var _this = this;

      // add foundation
      this.foundation = new MDCRadioFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        getNativeControl: function getNativeControl() {
          return _this.$refs.control;
        }
      });

      // add ripple
      this.ripple = new RippleBase(this, {
        isUnbounded: function isUnbounded() {
          return true;
        },
        isSurfaceActive: function isSurfaceActive() {
          return false;
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          _this.$refs.control.addEventListener(evt, handler, applyPassive());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          _this.$refs.control.removeEventListener(evt, handler, applyPassive());
        },
        computeBoundingRect: function computeBoundingRect() {
          return _this.$refs.root.getBoundingClientRect();
        }
      });

      this.formField = new MDCFormFieldFoundation({
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          _this.$refs.label.addEventListener(type, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          _this.$refs.label.removeEventListener(type, handler);
        },
        activateInputRipple: function activateInputRipple() {
          _this.ripple && _this.ripple.activate();
        },
        deactivateInputRipple: function deactivateInputRipple() {
          _this.ripple && _this.ripple.deactivate();
        }
      });

      this.foundation.init();
      this.ripple.init();
      this.formField.init();

      this.foundation.setValue(this.value || this.label);
      this.foundation.setDisabled(this.disabled);
      this.foundation.setChecked(this.checked || this.picked == this.foundation.getValue());

      // refresh model
      this.checked && this.sync();
    },
    beforeDestroy: function beforeDestroy() {
      this.formField.destroy();
      this.ripple.destroy();
      this.foundation.destroy();
    },

    methods: {
      setChecked: function setChecked(checked) {
        this.foundation.setChecked(checked);
      },
      isChecked: function isChecked() {
        return this.foundation.isChecked();
      },
      sync: function sync() {
        this.$emit('change', this.foundation.getValue());
      }
    }
  };

  /* script */
  var __vue_script__$N = script$N;

  /* template */
  var __vue_render__$K = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { staticClass: "mdc-radio-wrapper", class: _vm.formFieldClasses }, [_c("div", {
      ref: "root",
      staticClass: "mdc-radio",
      class: _vm.classes,
      style: _vm.styles
    }, [_c("input", {
      ref: "control",
      staticClass: "mdc-radio__native-control",
      attrs: { id: _vm.vma_uid_, name: _vm.name, type: "radio" },
      on: { change: _vm.sync }
    }), _vm._v(" "), _vm._m(0)]), _vm._v(" "), _c("label", { ref: "label", attrs: { for: _vm.vma_uid_ } }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2)]);
  };
  var __vue_staticRenderFns__$K = [function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { staticClass: "mdc-radio__background" }, [_c("div", { staticClass: "mdc-radio__outer-circle" }), _vm._v(" "), _c("div", { staticClass: "mdc-radio__inner-circle" })]);
  }];
  __vue_render__$K._withStripped = true;

  /* style */
  var __vue_inject_styles__$N = undefined;
  /* scoped */
  var __vue_scope_id__$N = undefined;
  /* module identifier */
  var __vue_module_identifier__$N = undefined;
  /* functional template */
  var __vue_is_functional_template__$N = false;
  /* component normalizer */
  function __vue_normalize__$N(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/radio/mdc-radio.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$N() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$N.styles || (__vue_create_injector__$N.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcRadio = __vue_normalize__$N({ render: __vue_render__$K, staticRenderFns: __vue_staticRenderFns__$K }, __vue_inject_styles__$N, __vue_script__$N, __vue_scope_id__$N, __vue_is_functional_template__$N, __vue_module_identifier__$N, __vue_create_injector__$N, undefined);

  var VueMDCRadio = BasePlugin({
    mdcRadio: mdcRadio
  });

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Select. Provides an interface for managing
   * - classes
   * - dom
   * - event handlers
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */

  var MDCSelectAdapter = function () {
    function MDCSelectAdapter() {
      classCallCheck(this, MDCSelectAdapter);
    }

    createClass(MDCSelectAdapter, [{
      key: "addClass",

      /**
       * Adds class to root element.
       * @param {string} className
       */
      value: function addClass(className) {}

      /**
       * Removes a class from the root element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * Returns true if the root element contains the given class name.
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}

      /**
       * Activates the bottom line, showing a focused state.
       */

    }, {
      key: "activateBottomLine",
      value: function activateBottomLine() {}

      /**
       * Deactivates the bottom line.
       */

    }, {
      key: "deactivateBottomLine",
      value: function deactivateBottomLine() {}

      /**
       * Returns the selected value of the select element.
       * @return {string}
       */

    }, {
      key: "getValue",
      value: function getValue() {}

      /**
       * Returns true if the direction of the root element is set to RTL.
       * @return {boolean}
       */

    }, {
      key: "isRtl",
      value: function isRtl() {}

      /**
       * Returns true if label element exists, false if it doesn't.
       * @return {boolean}
       */

    }, {
      key: "hasLabel",
      value: function hasLabel() {}

      /**
       * Floats label determined based off of the shouldFloat argument.
       * @param {boolean} shouldFloat
       */

    }, {
      key: "floatLabel",
      value: function floatLabel(shouldFloat) {}

      /**
       * Returns width of label in pixels, if the label exists.
       * @return {number}
       */

    }, {
      key: "getLabelWidth",
      value: function getLabelWidth() {}

      /**
       * Returns true if outline element exists, false if it doesn't.
       * @return {boolean}
       */

    }, {
      key: "hasOutline",
      value: function hasOutline() {}

      /**
       * Updates SVG Path and outline element based on the
       * label element width and RTL context, if the outline exists.
       * @param {number} labelWidth
       * @param {boolean=} isRtl
       */

    }, {
      key: "notchOutline",
      value: function notchOutline(labelWidth, isRtl) {}

      /**
       * Closes notch in outline element, if the outline exists.
       */

    }, {
      key: "closeOutline",
      value: function closeOutline() {}
    }]);
    return MDCSelectAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$d = {
    BOX: 'mdc-select--box',
    DISABLED: 'mdc-select--disabled',
    ROOT: 'mdc-select',
    OUTLINED: 'mdc-select--outlined'
  };

  /** @enum {string} */
  var strings$e = {
    CHANGE_EVENT: 'MDCSelect:change',
    LINE_RIPPLE_SELECTOR: '.mdc-line-ripple',
    LABEL_SELECTOR: '.mdc-floating-label',
    NATIVE_CONTROL_SELECTOR: '.mdc-select__native-control',
    OUTLINE_SELECTOR: '.mdc-notched-outline'
  };

  /** @enum {number} */
  var numbers$5 = {
    LABEL_SCALE: 0.75
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCSelectAdapter>}
   * @final
   */

  var MDCSelectFoundation = function (_MDCFoundation) {
    inherits(MDCSelectFoundation, _MDCFoundation);
    createClass(MDCSelectFoundation, null, [{
      key: 'cssClasses',

      /** @return enum {string} */
      get: function get$$1() {
        return cssClasses$d;
      }

      /** @return enum {number} */

    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers$5;
      }

      /** @return enum {string} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$e;
      }

      /**
       * {@see MDCSelectAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCSelectAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCSelectAdapter} */{
            addClass: function addClass() /* className: string */{},
            removeClass: function removeClass() /* className: string */{},
            hasClass: function hasClass() {
              return (/* className: string */false
              );
            },
            activateBottomLine: function activateBottomLine() {},
            deactivateBottomLine: function deactivateBottomLine() {},
            getValue: function getValue() {},
            isRtl: function isRtl() {
              return false;
            },
            hasLabel: function hasLabel() {
              return false;
            },
            floatLabel: function floatLabel() /* value: boolean */{},
            getLabelWidth: function getLabelWidth() {},
            hasOutline: function hasOutline() {
              return false;
            },
            notchOutline: function notchOutline() /* labelWidth: number, isRtl: boolean */{},
            closeOutline: function closeOutline() {}
          }
        );
      }

      /**
       * @param {!MDCSelectAdapter} adapter
       */

    }]);

    function MDCSelectFoundation(adapter) {
      classCallCheck(this, MDCSelectFoundation);
      return possibleConstructorReturn(this, (MDCSelectFoundation.__proto__ || Object.getPrototypeOf(MDCSelectFoundation)).call(this, _extends(MDCSelectFoundation.defaultAdapter, adapter)));
    }

    /**
     * Updates the styles of the select to show the disasbled state.
     * @param {boolean} disabled
     */


    createClass(MDCSelectFoundation, [{
      key: 'updateDisabledStyle',
      value: function updateDisabledStyle(disabled) {
        var DISABLED = MDCSelectFoundation.cssClasses.DISABLED;

        if (disabled) {
          this.adapter_.addClass(DISABLED);
        } else {
          this.adapter_.removeClass(DISABLED);
        }
      }

      /**
       * Handles value changes, via change event or programmatic updates.
       */

    }, {
      key: 'handleChange',
      value: function handleChange() {
        var optionHasValue = this.adapter_.getValue().length > 0;
        this.adapter_.floatLabel(optionHasValue);
        this.notchOutline(optionHasValue);
      }

      /**
       * Handles focus events from root element.
       */

    }, {
      key: 'handleFocus',
      value: function handleFocus() {
        this.adapter_.floatLabel(true);
        this.notchOutline(true);
        this.adapter_.activateBottomLine();
      }

      /**
       * Handles blur events from root element.
       */

    }, {
      key: 'handleBlur',
      value: function handleBlur() {
        this.handleChange();
        this.adapter_.deactivateBottomLine();
      }

      /**
       * Opens/closes the notched outline.
       * @param {boolean} openNotch
       */

    }, {
      key: 'notchOutline',
      value: function notchOutline(openNotch) {
        if (!this.adapter_.hasOutline() || !this.adapter_.hasLabel()) {
          return;
        }

        if (openNotch) {
          var labelScale = numbers$5.LABEL_SCALE;
          var labelWidth = this.adapter_.getLabelWidth() * labelScale;
          var isRtl = this.adapter_.isRtl();
          this.adapter_.notchOutline(labelWidth, isRtl);
        } else {
          this.adapter_.closeOutline();
        }
      }
    }]);
    return MDCSelectFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Floating Label.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the floating label into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCFloatingLabelAdapter = function () {
    function MDCFloatingLabelAdapter() {
      classCallCheck(this, MDCFloatingLabelAdapter);
    }

    createClass(MDCFloatingLabelAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the label element.
       * @param {string} className
       */
      value: function addClass(className) {}

      /**
       * Removes a class from the label element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * Returns the width of the label element.
       * @return {number}
       */

    }, {
      key: "getWidth",
      value: function getWidth() {}

      /**
       * Registers an event listener on the root element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(evtType, handler) {}

      /**
       * Deregisters an event listener on the root element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(evtType, handler) {}
    }]);
    return MDCFloatingLabelAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$e = {
    LABEL_FLOAT_ABOVE: 'mdc-floating-label--float-above',
    LABEL_SHAKE: 'mdc-floating-label--shake'
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCFloatingLabelAdapter>}
   * @final
   */

  var MDCFloatingLabelFoundation = function (_MDCFoundation) {
    inherits(MDCFloatingLabelFoundation, _MDCFoundation);
    createClass(MDCFloatingLabelFoundation, null, [{
      key: 'cssClasses',

      /** @return enum {string} */
      get: function get$$1() {
        return cssClasses$e;
      }

      /**
       * {@see MDCFloatingLabelAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCFloatingLabelAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCFloatingLabelAdapter} */{
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            getWidth: function getWidth() {},
            registerInteractionHandler: function registerInteractionHandler() {},
            deregisterInteractionHandler: function deregisterInteractionHandler() {}
          }
        );
      }

      /**
       * @param {!MDCFloatingLabelAdapter} adapter
       */

    }]);

    function MDCFloatingLabelFoundation(adapter) {
      classCallCheck(this, MDCFloatingLabelFoundation);

      /** @private {function(!Event): undefined} */
      var _this = possibleConstructorReturn(this, (MDCFloatingLabelFoundation.__proto__ || Object.getPrototypeOf(MDCFloatingLabelFoundation)).call(this, _extends(MDCFloatingLabelFoundation.defaultAdapter, adapter)));

      _this.shakeAnimationEndHandler_ = function () {
        return _this.handleShakeAnimationEnd_();
      };
      return _this;
    }

    createClass(MDCFloatingLabelFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerInteractionHandler('animationend', this.shakeAnimationEndHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterInteractionHandler('animationend', this.shakeAnimationEndHandler_);
      }

      /**
       * Returns the width of the label element.
       * @return {number}
       */

    }, {
      key: 'getWidth',
      value: function getWidth() {
        return this.adapter_.getWidth();
      }

      /**
       * Styles the label to produce the label shake for errors.
       * @param {boolean} shouldShake adds shake class if true,
       * otherwise removes shake class.
       */

    }, {
      key: 'shake',
      value: function shake(shouldShake) {
        var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;

        if (shouldShake) {
          this.adapter_.addClass(LABEL_SHAKE);
        } else {
          this.adapter_.removeClass(LABEL_SHAKE);
        }
      }

      /**
       * Styles the label to float or dock.
       * @param {boolean} shouldFloat adds float class if true, otherwise remove
       * float and shake class to dock label.
       */

    }, {
      key: 'float',
      value: function float(shouldFloat) {
        var _MDCFloatingLabelFoun = MDCFloatingLabelFoundation.cssClasses,
            LABEL_FLOAT_ABOVE = _MDCFloatingLabelFoun.LABEL_FLOAT_ABOVE,
            LABEL_SHAKE = _MDCFloatingLabelFoun.LABEL_SHAKE;

        if (shouldFloat) {
          this.adapter_.addClass(LABEL_FLOAT_ABOVE);
        } else {
          this.adapter_.removeClass(LABEL_FLOAT_ABOVE);
          this.adapter_.removeClass(LABEL_SHAKE);
        }
      }

      /**
       * Handles an interaction event on the root element.
       */

    }, {
      key: 'handleShakeAnimationEnd_',
      value: function handleShakeAnimationEnd_() {
        var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;

        this.adapter_.removeClass(LABEL_SHAKE);
      }
    }]);
    return MDCFloatingLabelFoundation;
  }(MDCFoundation);

  //

  var script$O = {
    name: 'mdc-select-label',
    data: function data() {
      return {
        labelClasses: {}
      };
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCFloatingLabelFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.labelClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.labelClasses, className);
        },
        getWidth: function getWidth() {
          return _this.$el.offsetWidth;
        },
        registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
          _this.$el.addEventListener(evtType, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
          _this.$el.removeEventListener(evtType, handler);
        }
      });
      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      var foundation = this.foundation;
      this.foundation = null;
      foundation.destroy();
    }
  };

  /* script */
  var __vue_script__$O = script$O;

  /* template */
  var __vue_render__$L = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("label", { staticClass: "mdc-floating-label", class: _vm.labelClasses }, [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$L = [];
  __vue_render__$L._withStripped = true;

  /* style */
  var __vue_inject_styles__$O = undefined;
  /* scoped */
  var __vue_scope_id__$O = undefined;
  /* module identifier */
  var __vue_module_identifier__$O = undefined;
  /* functional template */
  var __vue_is_functional_template__$O = false;
  /* component normalizer */
  function __vue_normalize__$O(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/select/mdc-select-label.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$O() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$O.styles || (__vue_create_injector__$O.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var SelectLabel = __vue_normalize__$O({ render: __vue_render__$L, staticRenderFns: __vue_staticRenderFns__$L }, __vue_inject_styles__$O, __vue_script__$O, __vue_scope_id__$O, __vue_is_functional_template__$O, __vue_module_identifier__$O, __vue_create_injector__$O, undefined);

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC TextField Line Ripple.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the line ripple into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCLineRippleAdapter = function () {
    function MDCLineRippleAdapter() {
      classCallCheck(this, MDCLineRippleAdapter);
    }

    createClass(MDCLineRippleAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the line ripple element.
       * @param {string} className
       */
      value: function addClass(className) {}

      /**
       * Removes a class from the line ripple element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}

      /**
       * Sets the style property with propertyName to value on the root element.
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setStyle",
      value: function setStyle(propertyName, value) {}

      /**
       * Registers an event listener on the line ripple element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerEventHandler",
      value: function registerEventHandler(evtType, handler) {}

      /**
       * Deregisters an event listener on the line ripple element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterEventHandler",
      value: function deregisterEventHandler(evtType, handler) {}
    }]);
    return MDCLineRippleAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$f = {
    LINE_RIPPLE_ACTIVE: 'mdc-line-ripple--active',
    LINE_RIPPLE_DEACTIVATING: 'mdc-line-ripple--deactivating'
  };

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCLineRippleAdapter>}
   * @final
   */

  var MDCLineRippleFoundation = function (_MDCFoundation) {
    inherits(MDCLineRippleFoundation, _MDCFoundation);
    createClass(MDCLineRippleFoundation, null, [{
      key: 'cssClasses',

      /** @return enum {string} */
      get: function get$$1() {
        return cssClasses$f;
      }

      /**
       * {@see MDCLineRippleAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCLineRippleAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCLineRippleAdapter} */{
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {},
            setStyle: function setStyle() {},
            registerEventHandler: function registerEventHandler() {},
            deregisterEventHandler: function deregisterEventHandler() {}
          }
        );
      }

      /**
       * @param {!MDCLineRippleAdapter=} adapter
       */

    }]);

    function MDCLineRippleFoundation() {
      var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : /** @type {!MDCLineRippleAdapter} */{};
      classCallCheck(this, MDCLineRippleFoundation);

      /** @private {function(!Event): undefined} */
      var _this = possibleConstructorReturn(this, (MDCLineRippleFoundation.__proto__ || Object.getPrototypeOf(MDCLineRippleFoundation)).call(this, _extends(MDCLineRippleFoundation.defaultAdapter, adapter)));

      _this.transitionEndHandler_ = function (evt) {
        return _this.handleTransitionEnd(evt);
      };
      return _this;
    }

    createClass(MDCLineRippleFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerEventHandler('transitionend', this.transitionEndHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterEventHandler('transitionend', this.transitionEndHandler_);
      }

      /**
       * Activates the line ripple
       */

    }, {
      key: 'activate',
      value: function activate() {
        this.adapter_.removeClass(cssClasses$f.LINE_RIPPLE_DEACTIVATING);
        this.adapter_.addClass(cssClasses$f.LINE_RIPPLE_ACTIVE);
      }

      /**
       * Sets the center of the ripple animation to the given X coordinate.
       * @param {number} xCoordinate
       */

    }, {
      key: 'setRippleCenter',
      value: function setRippleCenter(xCoordinate) {
        this.adapter_.setStyle('transform-origin', xCoordinate + 'px center');
      }

      /**
       * Deactivates the line ripple
       */

    }, {
      key: 'deactivate',
      value: function deactivate() {
        this.adapter_.addClass(cssClasses$f.LINE_RIPPLE_DEACTIVATING);
      }

      /**
       * Handles a transition end event
       * @param {!Event} evt
       */

    }, {
      key: 'handleTransitionEnd',
      value: function handleTransitionEnd(evt) {
        // Wait for the line ripple to be either transparent or opaque
        // before emitting the animation end event
        var isDeactivating = this.adapter_.hasClass(cssClasses$f.LINE_RIPPLE_DEACTIVATING);

        if (evt.propertyName === 'opacity') {
          if (isDeactivating) {
            this.adapter_.removeClass(cssClasses$f.LINE_RIPPLE_ACTIVE);
            this.adapter_.removeClass(cssClasses$f.LINE_RIPPLE_DEACTIVATING);
          }
        }
      }
    }]);
    return MDCLineRippleFoundation;
  }(MDCFoundation);

  //

  var script$P = {
    name: 'mdc-select-line-ripple',
    data: function data() {
      return {
        lineClasses: {},
        lineStyles: {}
      };
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCLineRippleFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.lineClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.lineClasses, className);
        },
        hasClass: function hasClass(className) {
          _this.$el.classList.contains(className);
        },
        setStyle: function setStyle(name, value) {
          _this.$set(_this.lineStyles, name, value);
        },
        registerEventHandler: function registerEventHandler(evtType, handler) {
          _this.$el.addEventListener(evtType, handler);
        },
        deregisterEventHandler: function deregisterEventHandler(evtType, handler) {
          _this.$el.removeEventListener(evtType, handler);
        }
      });
      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      var foundation = this.foundation;
      this.foundation = null;
      foundation.destroy();
    }
  };

  /* script */
  var __vue_script__$P = script$P;

  /* template */
  var __vue_render__$M = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", {
      staticClass: "mdc-line-ripple",
      class: _vm.lineClasses,
      style: _vm.lineStyles
    });
  };
  var __vue_staticRenderFns__$M = [];
  __vue_render__$M._withStripped = true;

  /* style */
  var __vue_inject_styles__$P = undefined;
  /* scoped */
  var __vue_scope_id__$P = undefined;
  /* module identifier */
  var __vue_module_identifier__$P = undefined;
  /* functional template */
  var __vue_is_functional_template__$P = false;
  /* component normalizer */
  function __vue_normalize__$P(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/select/mdc-select-line-ripple.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$P() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$P.styles || (__vue_create_injector__$P.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var SelectLineRiple = __vue_normalize__$P({ render: __vue_render__$M, staticRenderFns: __vue_staticRenderFns__$M }, __vue_inject_styles__$P, __vue_script__$P, __vue_scope_id__$P, __vue_is_functional_template__$P, __vue_module_identifier__$P, __vue_create_injector__$P, undefined);

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Notched Outline.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Notched Outline into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCNotchedOutlineAdapter = function () {
    function MDCNotchedOutlineAdapter() {
      classCallCheck(this, MDCNotchedOutlineAdapter);
    }

    createClass(MDCNotchedOutlineAdapter, [{
      key: "getWidth",

      /**
       * Returns the width of the root element.
       * @return {number}
       */
      value: function getWidth() {}

      /**
       * Returns the height of the root element.
       * @return {number}
       */

    }, {
      key: "getHeight",
      value: function getHeight() {}

      /**
       * Adds a class to the root element.
       * @param {string} className
       */

    }, {
      key: "addClass",
      value: function addClass(className) {}

      /**
       * Removes a class from the root element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * Sets the "d" attribute of the outline element's SVG path.
       * @param {string} value
       */

    }, {
      key: "setOutlinePathAttr",
      value: function setOutlinePathAttr(value) {}

      /**
       * Returns the idle outline element's computed style value of the given css property `propertyName`.
       * We achieve this via `getComputedStyle(...).getPropertyValue(propertyName)`.
       * @param {string} propertyName
       * @return {string}
       */

    }, {
      key: "getIdleOutlineStyleValue",
      value: function getIdleOutlineStyleValue(propertyName) {}
    }]);
    return MDCNotchedOutlineAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$f = {
    PATH_SELECTOR: '.mdc-notched-outline__path',
    IDLE_OUTLINE_SELECTOR: '.mdc-notched-outline__idle'
  };

  /** @enum {string} */
  var cssClasses$g = {
    OUTLINE_NOTCHED: 'mdc-notched-outline--notched'
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCNotchedOutlineAdapter>}
   * @final
   */

  var MDCNotchedOutlineFoundation = function (_MDCFoundation) {
    inherits(MDCNotchedOutlineFoundation, _MDCFoundation);
    createClass(MDCNotchedOutlineFoundation, null, [{
      key: 'strings',

      /** @return enum {string} */
      get: function get$$1() {
        return strings$f;
      }

      /** @return enum {string} */

    }, {
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$g;
      }

      /**
       * {@see MDCNotchedOutlineAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCNotchedOutlineAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCNotchedOutlineAdapter} */{
            getWidth: function getWidth() {},
            getHeight: function getHeight() {},
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            setOutlinePathAttr: function setOutlinePathAttr() {},
            getIdleOutlineStyleValue: function getIdleOutlineStyleValue() {}
          }
        );
      }

      /**
       * @param {!MDCNotchedOutlineAdapter} adapter
       */

    }]);

    function MDCNotchedOutlineFoundation(adapter) {
      classCallCheck(this, MDCNotchedOutlineFoundation);
      return possibleConstructorReturn(this, (MDCNotchedOutlineFoundation.__proto__ || Object.getPrototypeOf(MDCNotchedOutlineFoundation)).call(this, _extends(MDCNotchedOutlineFoundation.defaultAdapter, adapter)));
    }

    /**
     * Adds the outline notched selector and updates the notch width
     * calculated based off of notchWidth and isRtl.
     * @param {number} notchWidth
     * @param {boolean=} isRtl
     */


    createClass(MDCNotchedOutlineFoundation, [{
      key: 'notch',
      value: function notch(notchWidth) {
        var isRtl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;

        this.adapter_.addClass(OUTLINE_NOTCHED);
        this.updateSvgPath_(notchWidth, isRtl);
      }

      /**
       * Removes notched outline selector to close the notch in the outline.
       */

    }, {
      key: 'closeNotch',
      value: function closeNotch() {
        var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;

        this.adapter_.removeClass(OUTLINE_NOTCHED);
      }

      /**
       * Updates the SVG path of the focus outline element based on the notchWidth
       * and the RTL context.
       * @param {number} notchWidth
       * @param {boolean=} isRtl
       * @private
       */

    }, {
      key: 'updateSvgPath_',
      value: function updateSvgPath_(notchWidth, isRtl) {
        // Fall back to reading a specific corner's style because Firefox doesn't report the style on border-radius.
        var radiusStyleValue = this.adapter_.getIdleOutlineStyleValue('border-radius') || this.adapter_.getIdleOutlineStyleValue('border-top-left-radius');
        var radius = parseFloat(radiusStyleValue);
        var width = this.adapter_.getWidth();
        var height = this.adapter_.getHeight();
        var cornerWidth = radius + 1.2;
        var leadingStrokeLength = Math.abs(11 - cornerWidth);
        var paddedNotchWidth = notchWidth + 8;

        // The right, bottom, and left sides of the outline follow the same SVG path.
        var pathMiddle = 'a' + radius + ',' + radius + ' 0 0 1 ' + radius + ',' + radius + 'v' + (height - 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + -radius + ',' + radius + 'h' + (-width + 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + -radius + ',' + -radius + 'v' + (-height + 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + radius + ',' + -radius;

        var path = void 0;
        if (!isRtl) {
          path = 'M' + (cornerWidth + leadingStrokeLength + paddedNotchWidth) + ',' + 1 + 'h' + (width - 2 * cornerWidth - paddedNotchWidth - leadingStrokeLength) + pathMiddle + 'h' + leadingStrokeLength;
        } else {
          path = 'M' + (width - cornerWidth - leadingStrokeLength) + ',' + 1 + 'h' + leadingStrokeLength + pathMiddle + 'h' + (width - 2 * cornerWidth - paddedNotchWidth - leadingStrokeLength);
        }

        this.adapter_.setOutlinePathAttr(path);
      }
    }]);
    return MDCNotchedOutlineFoundation;
  }(MDCFoundation);

  //

  var script$Q = {
    name: 'mdc-select-notched-outline',
    data: function data() {
      return {
        outlinedClasses: {}
      };
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCNotchedOutlineFoundation({
        getWidth: function getWidth() {
          return _this.$refs.outlined.offsetWidth;
        },
        getHeight: function getHeight() {
          return _this.$refs.outlined.offsetHeight;
        },
        addClass: function addClass(className) {
          _this.$set(_this.outlinedClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.outlinedClasses, className);
        },
        setOutlinePathAttr: function setOutlinePathAttr(value) {
          var path = _this.$refs.outlinedPath;
          path.setAttribute('d', value);
        },
        getIdleOutlineStyleValue: function getIdleOutlineStyleValue(propertyName) {
          return window.getComputedStyle(_this.$refs.outlinedIdle).getPropertyValue(propertyName);
        }
      });
      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      var foundation = this.foundation;
      this.foundation = null;
      foundation.destroy();
    }
  };

  /* script */
  var __vue_script__$Q = script$Q;

  /* template */
  var __vue_render__$N = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", [_c("div", {
      ref: "outlined",
      staticClass: "mdc-notched-outline",
      class: _vm.outlinedClasses
    }, [_c("svg", [_c("path", {
      ref: "outlinedPath",
      staticClass: "mdc-notched-outline__path"
    })])]), _vm._v(" "), _c("div", { ref: "outlinedIdle", staticClass: "mdc-notched-outline__idle" })]);
  };
  var __vue_staticRenderFns__$N = [];
  __vue_render__$N._withStripped = true;

  /* style */
  var __vue_inject_styles__$Q = undefined;
  /* scoped */
  var __vue_scope_id__$Q = undefined;
  /* module identifier */
  var __vue_module_identifier__$Q = undefined;
  /* functional template */
  var __vue_is_functional_template__$Q = false;
  /* component normalizer */
  function __vue_normalize__$Q(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/select/mdc-select-notched-outline.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$Q() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$Q.styles || (__vue_create_injector__$Q.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var SelectNotchedOutline = __vue_normalize__$Q({ render: __vue_render__$N, staticRenderFns: __vue_staticRenderFns__$N }, __vue_inject_styles__$Q, __vue_script__$Q, __vue_scope_id__$Q, __vue_is_functional_template__$Q, __vue_module_identifier__$Q, __vue_create_injector__$Q, undefined);

  //

  var script$R = {
    name: 'mdc-select',
    components: {
      SelectLabel: SelectLabel,
      SelectLineRiple: SelectLineRiple,
      SelectNotchedOutline: SelectNotchedOutline
    },
    inheritAttrs: false,
    model: {
      prop: 'value',
      event: 'change'
    },
    props: {
      value: String,
      disabled: Boolean,
      label: String,
      outlined: Boolean,
      id: { type: String }
    },
    data: function data() {
      return {
        styles: {},
        classes: {}
      };
    },

    computed: {
      rootClasses: function rootClasses() {
        return _extends({
          'mdc-select--box': !this.outlined,
          'mdc-select--outlined': this.outlined
        }, this.classes);
      },
      listeners: function listeners() {
        var _this = this;

        return _extends({}, this.$listeners, {
          change: function change(event) {
            return _this.onChange(event);
          }
        });
      }
    },
    watch: {
      disabled: function disabled(value) {
        this.foundation && this.foundation.updateDisabledStyle(value);
      },

      value: 'refreshIndex'
    },
    mounted: function mounted() {
      var _this2 = this;

      this.foundation = new MDCSelectFoundation({
        addClass: function addClass(className) {
          return _this2.$set(_this2.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this2.$delete(_this2.classes, className);
        },
        hasClass: function hasClass(className) {
          return _this2.$el.classList.contains(className);
        },
        activateBottomLine: function activateBottomLine() {
          if (_this2.$refs.line) {
            _this2.$refs.line.foundation.activate();
          }
        },
        deactivateBottomLine: function deactivateBottomLine() {
          if (_this2.$refs.line) {
            _this2.$refs.line.foundation.deactivate();
          }
        },
        getValue: function getValue() {
          return _this2.$refs.native_control.value;
        },
        isRtl: function isRtl() {
          return window.getComputedStyle(_this2.$el).getPropertyValue('direction') === 'rtl';
        },
        notchOutline: function notchOutline(labelWidth, isRtl) {
          if (_this2.$refs.outline) {
            _this2.$refs.outline.foundation.notch(labelWidth, isRtl);
          }
        },
        closeOutline: function closeOutline() {
          if (_this2.$refs.outline) {
            _this2.$refs.outline.foundation.closeNotch();
          }
        },
        hasOutline: function hasOutline() {
          return !!_this2.$refs.outline;
        },
        floatLabel: function floatLabel(value) {
          if (_this2.$refs.label) {
            _this2.$refs.label.foundation.float(value);
          }
        },
        hasLabel: function hasLabel() {
          return !!_this2.$refs.label;
        },
        getLabelWidth: function getLabelWidth() {
          if (_this2.$refs.label) {
            return _this2.$refs.label.foundation.getWidth();
          }
        }
      });

      this.foundation.init();
      this.foundation.handleChange();

      // initial sync with DOM
      this.refreshIndex();
      this.slotObserver = new MutationObserver(function () {
        return _this2.refreshIndex();
      });
      this.slotObserver.observe(this.$refs.native_control, {
        childList: true,
        subtree: true
      });

      this.ripple = new RippleBase(this);
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.slotObserver.disconnect();

      var foundation = this.foundation;
      this.foundation = null;
      foundation.destroy();

      this.ripple && this.ripple.destroy();
    },

    methods: {
      refreshIndex: function refreshIndex() {
        var _this3 = this;

        var options = [].concat(toConsumableArray(this.$refs.native_control.querySelectorAll('option')));

        var idx = options.findIndex(function (_ref) {
          var value = _ref.value;

          return _this3.value === value;
        });

        if (this.$refs.native_control.selectedIndex !== idx) {
          this.$refs.native_control.selectedIndex = idx;
          this.foundation.handleChange();
        }
      },
      onChange: function onChange(event) {
        this.foundation.handleChange();
        this.$emit('change', event.target.value);
      }
    }
  };

  /* script */
  var __vue_script__$R = script$R;

  /* template */
  var __vue_render__$O = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", {
      staticClass: "mdc-select",
      class: _vm.rootClasses,
      style: _vm.styles,
      attrs: { id: _vm.id }
    }, [_c("select", _vm._g(_vm._b({
      ref: "native_control",
      staticClass: "mdc-select__native-control",
      attrs: { disabled: _vm.disabled }
    }, "select", _vm.$attrs, false), _vm.listeners), [!!_vm.label ? _c("option", {
      staticClass: "mdc-option",
      attrs: { value: "", disabled: "", selected: "" }
    }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2), _vm._v(" "), _vm.label ? _c("select-label", { ref: "label" }, [_vm._v(_vm._s(_vm.label))]) : _vm._e(), _vm._v(" "), !_vm.outlined ? _c("select-line-riple", { ref: "line" }) : _vm._e(), _vm._v(" "), _vm.outlined ? _c("select-notched-outline", { ref: "outline" }) : _vm._e()], 1);
  };
  var __vue_staticRenderFns__$O = [];
  __vue_render__$O._withStripped = true;

  /* style */
  var __vue_inject_styles__$R = undefined;
  /* scoped */
  var __vue_scope_id__$R = undefined;
  /* module identifier */
  var __vue_module_identifier__$R = undefined;
  /* functional template */
  var __vue_is_functional_template__$R = false;
  /* component normalizer */
  function __vue_normalize__$R(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/select/mdc-select.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$R() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$R.styles || (__vue_create_injector__$R.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcSelect = __vue_normalize__$R({ render: __vue_render__$O, staticRenderFns: __vue_staticRenderFns__$O }, __vue_inject_styles__$R, __vue_script__$R, __vue_scope_id__$R, __vue_is_functional_template__$R, __vue_module_identifier__$R, __vue_create_injector__$R, undefined);

  var VueMDCSelect = BasePlugin({
    mdcSelect: mdcSelect
  });

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$h = {
    ACTIVE: 'mdc-slider--active',
    DISABLED: 'mdc-slider--disabled',
    DISCRETE: 'mdc-slider--discrete',
    FOCUS: 'mdc-slider--focus',
    IN_TRANSIT: 'mdc-slider--in-transit',
    IS_DISCRETE: 'mdc-slider--discrete',
    HAS_TRACK_MARKER: 'mdc-slider--display-markers'
  };

  /** @enum {string} */
  var strings$g = {
    TRACK_SELECTOR: '.mdc-slider__track',
    TRACK_MARKER_CONTAINER_SELECTOR: '.mdc-slider__track-marker-container',
    LAST_TRACK_MARKER_SELECTOR: '.mdc-slider__track-marker:last-child',
    THUMB_CONTAINER_SELECTOR: '.mdc-slider__thumb-container',
    PIN_VALUE_MARKER_SELECTOR: '.mdc-slider__pin-value-marker',
    ARIA_VALUEMIN: 'aria-valuemin',
    ARIA_VALUEMAX: 'aria-valuemax',
    ARIA_VALUENOW: 'aria-valuenow',
    ARIA_DISABLED: 'aria-disabled',
    STEP_DATA_ATTR: 'data-step',
    CHANGE_EVENT: 'MDCSlider:change',
    INPUT_EVENT: 'MDCSlider:input'
  };

  /** @enum {number} */
  var numbers$6 = {
    PAGE_FACTOR: 4
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint-disable no-unused-vars */

  /**
   * Adapter for MDC Slider.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Slider into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCSliderAdapter = function () {
    function MDCSliderAdapter() {
      classCallCheck(this, MDCSliderAdapter);
    }

    createClass(MDCSliderAdapter, [{
      key: "hasClass",

      /**
       * Returns true if className exists for the slider Element
       * @param {string} className
       * @return {boolean}
       */
      value: function hasClass(className) {}

      /**
       * Adds a class to the slider Element
       * @param {string} className
       */

    }, {
      key: "addClass",
      value: function addClass(className) {}

      /**
       * Removes a class from the slider Element
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * Returns a string if attribute name exists on the slider Element,
       * otherwise returns null
       * @param {string} name
       * @return {?string}
       */

    }, {
      key: "getAttribute",
      value: function getAttribute(name) {}

      /**
       * Sets attribute name on slider Element to value
       * @param {string} name
       * @param {string} value
       */

    }, {
      key: "setAttribute",
      value: function setAttribute(name, value) {}

      /**
       * Removes attribute name from slider Element
       * @param {string} name
       */

    }, {
      key: "removeAttribute",
      value: function removeAttribute(name) {}

      /**
       * Returns the bounding client rect for the slider Element
       * @return {?ClientRect}
       */

    }, {
      key: "computeBoundingRect",
      value: function computeBoundingRect() {}

      /**
       * Returns the tab index of the slider Element
       * @return {number}
       */

    }, {
      key: "getTabIndex",
      value: function getTabIndex() {}

      /**
       * Registers an event handler on the root element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(type, handler) {}

      /**
       * Deregisters an event handler on the root element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(type, handler) {}

      /**
       * Registers an event handler on the thumb container element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerThumbContainerInteractionHandler",
      value: function registerThumbContainerInteractionHandler(type, handler) {}

      /**
       * Deregisters an event handler on the thumb container element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterThumbContainerInteractionHandler",
      value: function deregisterThumbContainerInteractionHandler(type, handler) {}

      /**
       * Registers an event handler on the body for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerBodyInteractionHandler",
      value: function registerBodyInteractionHandler(type, handler) {}

      /**
       * Deregisters an event handler on the body for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterBodyInteractionHandler",
      value: function deregisterBodyInteractionHandler(type, handler) {}

      /**
       * Registers an event handler for the window resize event
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerResizeHandler",
      value: function registerResizeHandler(handler) {}

      /**
       * Deregisters an event handler for the window resize event
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterResizeHandler",
      value: function deregisterResizeHandler(handler) {}

      /**
       * Emits a custom event MDCSlider:input from the root
       */

    }, {
      key: "notifyInput",
      value: function notifyInput() {}

      /**
       * Emits a custom event MDCSlider:change from the root
       */

    }, {
      key: "notifyChange",
      value: function notifyChange() {}

      /**
       * Sets a style property of the thumb container element to the passed value
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setThumbContainerStyleProperty",
      value: function setThumbContainerStyleProperty(propertyName, value) {}

      /**
       * Sets a style property of the track element to the passed value
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setTrackStyleProperty",
      value: function setTrackStyleProperty(propertyName, value) {}

      /**
       * Sets the inner text of the pin marker to the passed value
       * @param {number} value
       */

    }, {
      key: "setMarkerValue",
      value: function setMarkerValue(value) {}

      /**
       * Appends the passed number of track markers to the track mark container element
       * @param {number} numMarkers
       */

    }, {
      key: "appendTrackMarkers",
      value: function appendTrackMarkers(numMarkers) {}

      /**
       * Removes all track markers fromt he track mark container element
       */

    }, {
      key: "removeTrackMarkers",
      value: function removeTrackMarkers() {}

      /**
       * Sets a style property of the last track marker to the passed value
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setLastTrackMarkersStyleProperty",
      value: function setLastTrackMarkersStyleProperty(propertyName, value) {}

      /**
       * Returns true if the root element is RTL, otherwise false
       * @return {boolean}
       */

    }, {
      key: "isRTL",
      value: function isRTL() {}
    }]);
    return MDCSliderAdapter;
  }();

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   *you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var KEY_IDS = {
    ARROW_LEFT: 'ArrowLeft',
    ARROW_RIGHT: 'ArrowRight',
    ARROW_UP: 'ArrowUp',
    ARROW_DOWN: 'ArrowDown',
    HOME: 'Home',
    END: 'End',
    PAGE_UP: 'PageUp',
    PAGE_DOWN: 'PageDown'
  };

  /** @enum {string} */
  var MOVE_EVENT_MAP = {
    'mousedown': 'mousemove',
    'touchstart': 'touchmove',
    'pointerdown': 'pointermove'
  };

  var DOWN_EVENTS = ['mousedown', 'pointerdown', 'touchstart'];
  var UP_EVENTS = ['mouseup', 'pointerup', 'touchend'];

  /**
   * @extends {MDCFoundation<!MDCSliderAdapter>}
   */

  var MDCSliderFoundation = function (_MDCFoundation) {
    inherits(MDCSliderFoundation, _MDCFoundation);
    createClass(MDCSliderFoundation, null, [{
      key: 'cssClasses',

      /** @return enum {cssClasses} */
      get: function get$$1() {
        return cssClasses$h;
      }

      /** @return enum {strings} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$g;
      }

      /** @return enum {numbers} */

    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers$6;
      }

      /** @return {!MDCSliderAdapter} */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCSliderAdapter} */{
            hasClass: function hasClass() {
              return (/* className: string */ /* boolean */false
              );
            },
            addClass: function addClass() /* className: string */{},
            removeClass: function removeClass() /* className: string */{},
            getAttribute: function getAttribute() {
              return (/* name: string */ /* string|null */null
              );
            },
            setAttribute: function setAttribute() /* name: string, value: string */{},
            removeAttribute: function removeAttribute() /* name: string */{},
            computeBoundingRect: function computeBoundingRect() {
              return (/* ClientRect */{
                  top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0
                }
              );
            },
            getTabIndex: function getTabIndex() {
              return (/* number */0
              );
            },
            registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
            deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
            registerThumbContainerInteractionHandler: function registerThumbContainerInteractionHandler() /* type: string, handler: EventListener */{},
            deregisterThumbContainerInteractionHandler: function deregisterThumbContainerInteractionHandler() /* type: string, handler: EventListener */{},
            registerBodyInteractionHandler: function registerBodyInteractionHandler() /* type: string, handler: EventListener */{},
            deregisterBodyInteractionHandler: function deregisterBodyInteractionHandler() /* type: string, handler: EventListener */{},
            registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
            deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
            notifyInput: function notifyInput() {},
            notifyChange: function notifyChange() {},
            setThumbContainerStyleProperty: function setThumbContainerStyleProperty() /* propertyName: string, value: string */{},
            setTrackStyleProperty: function setTrackStyleProperty() /* propertyName: string, value: string */{},
            setMarkerValue: function setMarkerValue() /* value: number */{},
            appendTrackMarkers: function appendTrackMarkers() /* numMarkers: number */{},
            removeTrackMarkers: function removeTrackMarkers() {},
            setLastTrackMarkersStyleProperty: function setLastTrackMarkersStyleProperty() /* propertyName: string, value: string */{},
            isRTL: function isRTL() {
              return (/* boolean */false
              );
            }
          }
        );
      }

      /**
       * Creates a new instance of MDCSliderFoundation
       * @param {?MDCSliderAdapter} adapter
       */

    }]);

    function MDCSliderFoundation(adapter) {
      classCallCheck(this, MDCSliderFoundation);

      /** @private {?ClientRect} */
      var _this = possibleConstructorReturn(this, (MDCSliderFoundation.__proto__ || Object.getPrototypeOf(MDCSliderFoundation)).call(this, _extends(MDCSliderFoundation.defaultAdapter, adapter)));

      _this.rect_ = null;
      // We set this to NaN since we want it to be a number, but we can't use '0' or '-1'
      // because those could be valid tabindices set by the client code.
      _this.savedTabIndex_ = NaN;
      _this.active_ = false;
      _this.inTransit_ = false;
      _this.isDiscrete_ = false;
      _this.hasTrackMarker_ = false;
      _this.handlingThumbTargetEvt_ = false;
      _this.min_ = 0;
      _this.max_ = 100;
      _this.step_ = 0;
      _this.value_ = 0;
      _this.disabled_ = false;
      _this.preventFocusState_ = false;
      _this.updateUIFrame_ = 0;
      _this.thumbContainerPointerHandler_ = function () {
        _this.handlingThumbTargetEvt_ = true;
      };
      _this.interactionStartHandler_ = function (evt) {
        return _this.handleDown_(evt);
      };
      _this.keydownHandler_ = function (evt) {
        return _this.handleKeydown_(evt);
      };
      _this.focusHandler_ = function () {
        return _this.handleFocus_();
      };
      _this.blurHandler_ = function () {
        return _this.handleBlur_();
      };
      _this.resizeHandler_ = function () {
        return _this.layout();
      };
      return _this;
    }

    createClass(MDCSliderFoundation, [{
      key: 'init',
      value: function init() {
        var _this2 = this;

        this.isDiscrete_ = this.adapter_.hasClass(cssClasses$h.IS_DISCRETE);
        this.hasTrackMarker_ = this.adapter_.hasClass(cssClasses$h.HAS_TRACK_MARKER);
        DOWN_EVENTS.forEach(function (evtName) {
          return _this2.adapter_.registerInteractionHandler(evtName, _this2.interactionStartHandler_);
        });
        this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
        this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
        DOWN_EVENTS.forEach(function (evtName) {
          _this2.adapter_.registerThumbContainerInteractionHandler(evtName, _this2.thumbContainerPointerHandler_);
        });
        this.adapter_.registerResizeHandler(this.resizeHandler_);
        this.layout();
        // At last step, provide a reasonable default value to discrete slider
        if (this.isDiscrete_ && this.getStep() == 0) {
          this.step_ = 1;
        }
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this3 = this;

        DOWN_EVENTS.forEach(function (evtName) {
          _this3.adapter_.deregisterInteractionHandler(evtName, _this3.interactionStartHandler_);
        });
        this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
        this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);
        DOWN_EVENTS.forEach(function (evtName) {
          _this3.adapter_.deregisterThumbContainerInteractionHandler(evtName, _this3.thumbContainerPointerHandler_);
        });
        this.adapter_.deregisterResizeHandler(this.resizeHandler_);
      }
    }, {
      key: 'setupTrackMarker',
      value: function setupTrackMarker() {
        if (this.isDiscrete_ && this.hasTrackMarker_ && this.getStep() != 0) {
          var min = this.getMin();
          var max = this.getMax();
          var step = this.getStep();
          var numMarkers = (max - min) / step;

          // In case distance between max & min is indivisible to step,
          // we place the secondary to last marker proportionally at where thumb
          // could reach and place the last marker at max value
          var indivisible = Math.ceil(numMarkers) !== numMarkers;
          if (indivisible) {
            numMarkers = Math.ceil(numMarkers);
          }

          this.adapter_.removeTrackMarkers();
          this.adapter_.appendTrackMarkers(numMarkers);

          if (indivisible) {
            var lastStepRatio = (max - numMarkers * step) / step + 1;
            var flex = getCorrectPropertyName(window, 'flex');
            this.adapter_.setLastTrackMarkersStyleProperty(flex, String(lastStepRatio));
          }
        }
      }
    }, {
      key: 'layout',
      value: function layout() {
        this.rect_ = this.adapter_.computeBoundingRect();
        this.updateUIForCurrentValue_();
      }

      /** @return {number} */

    }, {
      key: 'getValue',
      value: function getValue() {
        return this.value_;
      }

      /** @param {number} value */

    }, {
      key: 'setValue',
      value: function setValue(value) {
        this.setValue_(value, false);
      }

      /** @return {number} */

    }, {
      key: 'getMax',
      value: function getMax() {
        return this.max_;
      }

      /** @param {number} max */

    }, {
      key: 'setMax',
      value: function setMax(max) {
        if (max < this.min_) {
          throw new Error('Cannot set max to be less than the slider\'s minimum value');
        }
        this.max_ = max;
        this.setValue_(this.value_, false, true);
        this.adapter_.setAttribute(strings$g.ARIA_VALUEMAX, String(this.max_));
        this.setupTrackMarker();
      }

      /** @return {number} */

    }, {
      key: 'getMin',
      value: function getMin() {
        return this.min_;
      }

      /** @param {number} min */

    }, {
      key: 'setMin',
      value: function setMin(min) {
        if (min > this.max_) {
          throw new Error('Cannot set min to be greater than the slider\'s maximum value');
        }
        this.min_ = min;
        this.setValue_(this.value_, false, true);
        this.adapter_.setAttribute(strings$g.ARIA_VALUEMIN, String(this.min_));
        this.setupTrackMarker();
      }

      /** @return {number} */

    }, {
      key: 'getStep',
      value: function getStep() {
        return this.step_;
      }

      /** @param {number} step */

    }, {
      key: 'setStep',
      value: function setStep(step) {
        if (step < 0) {
          throw new Error('Step cannot be set to a negative number');
        }
        if (this.isDiscrete_ && (typeof step !== 'number' || step < 1)) {
          step = 1;
        }
        this.step_ = step;
        this.setValue_(this.value_, false, true);
        this.setupTrackMarker();
      }

      /** @return {boolean} */

    }, {
      key: 'isDisabled',
      value: function isDisabled() {
        return this.disabled_;
      }

      /** @param {boolean} disabled */

    }, {
      key: 'setDisabled',
      value: function setDisabled(disabled) {
        this.disabled_ = disabled;
        this.toggleClass_(cssClasses$h.DISABLED, this.disabled_);
        if (this.disabled_) {
          this.savedTabIndex_ = this.adapter_.getTabIndex();
          this.adapter_.setAttribute(strings$g.ARIA_DISABLED, 'true');
          this.adapter_.removeAttribute('tabindex');
        } else {
          this.adapter_.removeAttribute(strings$g.ARIA_DISABLED);
          if (!isNaN(this.savedTabIndex_)) {
            this.adapter_.setAttribute('tabindex', String(this.savedTabIndex_));
          }
        }
      }

      /**
       * Called when the user starts interacting with the slider
       * @param {!Event} evt
       * @private
       */

    }, {
      key: 'handleDown_',
      value: function handleDown_(evt) {
        var _this4 = this;

        if (this.disabled_) {
          return;
        }

        this.preventFocusState_ = true;
        this.setInTransit_(!this.handlingThumbTargetEvt_);
        this.handlingThumbTargetEvt_ = false;
        this.setActive_(true);

        var moveHandler = function moveHandler(evt) {
          _this4.handleMove_(evt);
        };

        // Note: upHandler is [de]registered on ALL potential pointer-related release event types, since some browsers
        // do not always fire these consistently in pairs.
        // (See https://github.com/material-components/material-components-web/issues/1192)
        var upHandler = function upHandler() {
          _this4.handleUp_();
          _this4.adapter_.deregisterBodyInteractionHandler(MOVE_EVENT_MAP[evt.type], moveHandler);
          UP_EVENTS.forEach(function (evtName) {
            return _this4.adapter_.deregisterBodyInteractionHandler(evtName, upHandler);
          });
        };

        this.adapter_.registerBodyInteractionHandler(MOVE_EVENT_MAP[evt.type], moveHandler);
        UP_EVENTS.forEach(function (evtName) {
          return _this4.adapter_.registerBodyInteractionHandler(evtName, upHandler);
        });
        this.setValueFromEvt_(evt);
      }

      /**
       * Called when the user moves the slider
       * @param {!Event} evt
       * @private
       */

    }, {
      key: 'handleMove_',
      value: function handleMove_(evt) {
        evt.preventDefault();
        this.setValueFromEvt_(evt);
      }

      /**
       * Called when the user's interaction with the slider ends
       * @private
       */

    }, {
      key: 'handleUp_',
      value: function handleUp_() {
        this.setActive_(false);
        this.adapter_.notifyChange();
      }

      /**
       * Returns the pageX of the event
       * @param {!Event} evt
       * @return {number}
       * @private
       */

    }, {
      key: 'getPageX_',
      value: function getPageX_(evt) {
        if (evt.targetTouches && evt.targetTouches.length > 0) {
          return evt.targetTouches[0].pageX;
        }
        return evt.pageX;
      }

      /**
       * Sets the slider value from an event
       * @param {!Event} evt
       * @private
       */

    }, {
      key: 'setValueFromEvt_',
      value: function setValueFromEvt_(evt) {
        var pageX = this.getPageX_(evt);
        var value = this.computeValueFromPageX_(pageX);
        this.setValue_(value, true);
      }

      /**
       * Computes the new value from the pageX position
       * @param {number} pageX
       * @return {number}
       */

    }, {
      key: 'computeValueFromPageX_',
      value: function computeValueFromPageX_(pageX) {
        var max = this.max_,
            min = this.min_;

        var xPos = pageX - this.rect_.left;
        var pctComplete = xPos / this.rect_.width;
        if (this.adapter_.isRTL()) {
          pctComplete = 1 - pctComplete;
        }
        // Fit the percentage complete between the range [min,max]
        // by remapping from [0, 1] to [min, min+(max-min)].
        return min + pctComplete * (max - min);
      }

      /**
       * Handles keydown events
       * @param {!Event} evt
       */

    }, {
      key: 'handleKeydown_',
      value: function handleKeydown_(evt) {
        var keyId = this.getKeyId_(evt);
        var value = this.getValueForKeyId_(keyId);
        if (isNaN(value)) {
          return;
        }

        // Prevent page from scrolling due to key presses that would normally scroll the page
        evt.preventDefault();
        this.adapter_.addClass(cssClasses$h.FOCUS);
        this.setValue_(value, true);
        this.adapter_.notifyChange();
      }

      /**
       * Returns the computed name of the event
       * @param {!Event} kbdEvt
       * @return {string}
       */

    }, {
      key: 'getKeyId_',
      value: function getKeyId_(kbdEvt) {
        if (kbdEvt.key === KEY_IDS.ARROW_LEFT || kbdEvt.keyCode === 37) {
          return KEY_IDS.ARROW_LEFT;
        }
        if (kbdEvt.key === KEY_IDS.ARROW_RIGHT || kbdEvt.keyCode === 39) {
          return KEY_IDS.ARROW_RIGHT;
        }
        if (kbdEvt.key === KEY_IDS.ARROW_UP || kbdEvt.keyCode === 38) {
          return KEY_IDS.ARROW_UP;
        }
        if (kbdEvt.key === KEY_IDS.ARROW_DOWN || kbdEvt.keyCode === 40) {
          return KEY_IDS.ARROW_DOWN;
        }
        if (kbdEvt.key === KEY_IDS.HOME || kbdEvt.keyCode === 36) {
          return KEY_IDS.HOME;
        }
        if (kbdEvt.key === KEY_IDS.END || kbdEvt.keyCode === 35) {
          return KEY_IDS.END;
        }
        if (kbdEvt.key === KEY_IDS.PAGE_UP || kbdEvt.keyCode === 33) {
          return KEY_IDS.PAGE_UP;
        }
        if (kbdEvt.key === KEY_IDS.PAGE_DOWN || kbdEvt.keyCode === 34) {
          return KEY_IDS.PAGE_DOWN;
        }

        return '';
      }

      /**
       * Computes the value given a keyboard key ID
       * @param {string} keyId
       * @return {number}
       */

    }, {
      key: 'getValueForKeyId_',
      value: function getValueForKeyId_(keyId) {
        var max = this.max_,
            min = this.min_,
            step = this.step_;

        var delta = step || (max - min) / 100;
        var valueNeedsToBeFlipped = this.adapter_.isRTL() && (keyId === KEY_IDS.ARROW_LEFT || keyId === KEY_IDS.ARROW_RIGHT);
        if (valueNeedsToBeFlipped) {
          delta = -delta;
        }

        switch (keyId) {
          case KEY_IDS.ARROW_LEFT:
          case KEY_IDS.ARROW_DOWN:
            return this.value_ - delta;
          case KEY_IDS.ARROW_RIGHT:
          case KEY_IDS.ARROW_UP:
            return this.value_ + delta;
          case KEY_IDS.HOME:
            return this.min_;
          case KEY_IDS.END:
            return this.max_;
          case KEY_IDS.PAGE_UP:
            return this.value_ + delta * numbers$6.PAGE_FACTOR;
          case KEY_IDS.PAGE_DOWN:
            return this.value_ - delta * numbers$6.PAGE_FACTOR;
          default:
            return NaN;
        }
      }
    }, {
      key: 'handleFocus_',
      value: function handleFocus_() {
        if (this.preventFocusState_) {
          return;
        }
        this.adapter_.addClass(cssClasses$h.FOCUS);
      }
    }, {
      key: 'handleBlur_',
      value: function handleBlur_() {
        this.preventFocusState_ = false;
        this.adapter_.removeClass(cssClasses$h.FOCUS);
      }

      /**
       * Sets the value of the slider
       * @param {number} value
       * @param {boolean} shouldFireInput
       * @param {boolean=} force
       */

    }, {
      key: 'setValue_',
      value: function setValue_(value, shouldFireInput) {
        var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (value === this.value_ && !force) {
          return;
        }

        var min = this.min_,
            max = this.max_;

        var valueSetToBoundary = value === min || value === max;
        if (this.step_ && !valueSetToBoundary) {
          value = this.quantize_(value);
        }
        if (value < min) {
          value = min;
        } else if (value > max) {
          value = max;
        }
        this.value_ = value;
        this.adapter_.setAttribute(strings$g.ARIA_VALUENOW, String(this.value_));
        this.updateUIForCurrentValue_();

        if (shouldFireInput) {
          this.adapter_.notifyInput();
          if (this.isDiscrete_) {
            this.adapter_.setMarkerValue(value);
          }
        }
      }

      /**
       * Calculates the quantized value
       * @param {number} value
       * @return {number}
       */

    }, {
      key: 'quantize_',
      value: function quantize_(value) {
        var numSteps = Math.round(value / this.step_);
        var quantizedVal = numSteps * this.step_;
        return quantizedVal;
      }
    }, {
      key: 'updateUIForCurrentValue_',
      value: function updateUIForCurrentValue_() {
        var _this5 = this;

        var max = this.max_,
            min = this.min_,
            value = this.value_;

        var pctComplete = (value - min) / (max - min);
        var translatePx = pctComplete * this.rect_.width;
        if (this.adapter_.isRTL()) {
          translatePx = this.rect_.width - translatePx;
        }

        var transformProp = getCorrectPropertyName(window, 'transform');
        var transitionendEvtName = getCorrectEventName(window, 'transitionend');

        if (this.inTransit_) {
          var onTransitionEnd = function onTransitionEnd() {
            _this5.setInTransit_(false);
            _this5.adapter_.deregisterThumbContainerInteractionHandler(transitionendEvtName, onTransitionEnd);
          };
          this.adapter_.registerThumbContainerInteractionHandler(transitionendEvtName, onTransitionEnd);
        }

        this.updateUIFrame_ = requestAnimationFrame(function () {
          // NOTE(traviskaufman): It would be nice to use calc() here,
          // but IE cannot handle calcs in transforms correctly.
          // See: https://goo.gl/NC2itk
          // Also note that the -50% offset is used to center the slider thumb.
          _this5.adapter_.setThumbContainerStyleProperty(transformProp, 'translateX(' + translatePx + 'px) translateX(-50%)');
          _this5.adapter_.setTrackStyleProperty(transformProp, 'scaleX(' + pctComplete + ')');
        });
      }

      /**
       * Toggles the active state of the slider
       * @param {boolean} active
       */

    }, {
      key: 'setActive_',
      value: function setActive_(active) {
        this.active_ = active;
        this.toggleClass_(cssClasses$h.ACTIVE, this.active_);
      }

      /**
       * Toggles the inTransit state of the slider
       * @param {boolean} inTransit
       */

    }, {
      key: 'setInTransit_',
      value: function setInTransit_(inTransit) {
        this.inTransit_ = inTransit;
        this.toggleClass_(cssClasses$h.IN_TRANSIT, this.inTransit_);
      }

      /**
       * Conditionally adds or removes a class based on shouldBePresent
       * @param {string} className
       * @param {boolean} shouldBePresent
       */

    }, {
      key: 'toggleClass_',
      value: function toggleClass_(className, shouldBePresent) {
        if (shouldBePresent) {
          this.adapter_.addClass(className);
        } else {
          this.adapter_.removeClass(className);
        }
      }
    }]);
    return MDCSliderFoundation;
  }(MDCFoundation);

  //

  var script$S = {
    name: 'mdc-slider',
    mixins: [DispatchFocusMixin],
    model: {
      prop: 'value',
      event: 'change'
    },
    props: {
      value: [Number, String],
      min: { type: [Number, String], default: 0 },
      max: { type: [Number, String], default: 100 },
      step: { type: [Number, String], default: 0 },
      displayMarkers: Boolean,
      disabled: Boolean,
      layoutOn: String,
      layoutOnSource: { type: Object, required: false }
    },
    data: function data() {
      return {
        classes: {
          'mdc-slider--discrete': !!this.step,
          'mdc-slider--display-markers': this.displayMarkers
        },
        trackStyles: {},
        lastTrackMarkersStyles: {},
        thumbStyles: {},
        markerValue: '',
        numMarkers: 0
      };
    },

    computed: {
      isDiscrete: function isDiscrete() {
        return !!this.step;
      },
      hasMarkers: function hasMarkers() {
        return !!this.step && this.displayMarkers && this.numMarkers;
      }
    },
    watch: {
      value: function value() {
        if (this.foundation.getValue() !== Number(this.value)) {
          this.foundation.setValue(this.value);
        }
      },
      min: function min() {
        this.foundation.setMin(Number(this.min));
      },
      max: function max() {
        this.foundation.setMax(Number(this.max));
      },
      step: function step() {
        this.foundation.setStep(Number(this.step));
      },
      disabled: function disabled() {
        this.foundation.setDisabled(this.disabled);
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCSliderFoundation({
        hasClass: function hasClass(className) {
          return _this.$el.classList.contains(className);
        },
        addClass: function addClass(className) {
          _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.classes, className, true);
        },
        getAttribute: function getAttribute(name) {
          return _this.$el.getAttribute(name);
        },
        setAttribute: function setAttribute(name, value) {
          return _this.$el.setAttribute(name, value);
        },
        removeAttribute: function removeAttribute(name) {
          return _this.$el.removeAttribute(name);
        },
        computeBoundingRect: function computeBoundingRect() {
          return _this.$el.getBoundingClientRect();
        },
        getTabIndex: function getTabIndex() {
          return _this.$el.tabIndex;
        },
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          _this.$el.addEventListener(type, handler, applyPassive());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          _this.$el.removeEventListener(type, handler, applyPassive());
        },
        registerThumbContainerInteractionHandler: function registerThumbContainerInteractionHandler(type, handler) {
          _this.$refs.thumbContainer.addEventListener(type, handler, applyPassive());
        },
        deregisterThumbContainerInteractionHandler: function deregisterThumbContainerInteractionHandler(type, handler) {
          _this.$refs.thumbContainer.removeEventListener(type, handler, applyPassive());
        },
        registerBodyInteractionHandler: function registerBodyInteractionHandler(type, handler) {
          document.body.addEventListener(type, handler);
        },
        deregisterBodyInteractionHandler: function deregisterBodyInteractionHandler(type, handler) {
          document.body.removeEventListener(type, handler);
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          window.removeEventListener('resize', handler);
        },
        notifyInput: function notifyInput() {
          _this.$emit('input', _this.foundation.getValue());
        },
        notifyChange: function notifyChange() {
          _this.$emit('change', _this.foundation.getValue());
        },
        setThumbContainerStyleProperty: function setThumbContainerStyleProperty(propertyName, value) {
          _this.$set(_this.thumbStyles, propertyName, value);
        },
        setTrackStyleProperty: function setTrackStyleProperty(propertyName, value) {
          _this.$set(_this.trackStyles, propertyName, value);
        },
        setMarkerValue: function setMarkerValue(value) {
          _this.markerValue = value;
        },
        appendTrackMarkers: function appendTrackMarkers(numMarkers) {
          _this.numMarkers = numMarkers;
        },
        removeTrackMarkers: function removeTrackMarkers() {
          _this.numMarkers = 0;
        },
        setLastTrackMarkersStyleProperty: function setLastTrackMarkersStyleProperty(propertyName, value) {
          _this.$set(_this.lastTrackMarkersStyles, propertyName, value);
        },
        isRTL: function isRTL() {
          return false;
        }
      });

      this.foundation.init();
      this.foundation.setDisabled(this.disabled);
      if (Number(this.min) <= this.foundation.getMax()) {
        this.foundation.setMin(Number(this.min));
        this.foundation.setMax(Number(this.max));
      } else {
        this.foundation.setMax(Number(this.max));
        this.foundation.setMin(Number(this.min));
      }
      this.foundation.setStep(Number(this.step));
      this.foundation.setValue(Number(this.value));
      if (this.hasMarkers) {
        this.foundation.setupTrackMarker();
      }

      this.$root.$on('vma:layout', this.layout);

      if (this.layoutOn) {
        this.layoutOnEventSource = this.layoutOnSource || this.$root;
        this.layoutOnEventSource.$on(this.layoutOn, this.layout);
      }
    },
    beforeDestroy: function beforeDestroy() {
      this.$root.$off('vma:layout', this.layout);
      if (this.layoutOnEventSource) {
        this.layoutOnEventSource.$off(this.layoutOn, this.layout);
      }
      this.foundation.destroy();
    },

    methods: {
      layout: function layout() {
        var _this2 = this;

        this.$nextTick(function () {
          _this2.foundation && _this2.foundation.layout();
        });
      }
    }
  };

  /* script */
  var __vue_script__$S = script$S;

  /* template */
  var __vue_render__$P = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", {
      staticClass: "mdc-slider",
      class: _vm.classes,
      attrs: { tabindex: "0", role: "slider" }
    }, [_c("div", { staticClass: "mdc-slider__track-container" }, [_c("div", { staticClass: "mdc-slider__track", style: _vm.trackStyles }), _vm._v(" "), _vm.hasMarkers ? _c("div", { staticClass: "mdc-slider__track-marker-container" }, _vm._l(_vm.numMarkers, function (markerNum) {
      return _c("div", {
        key: markerNum,
        staticClass: "mdc-slider__track-marker",
        style: markerNum == _vm.numMarkers ? _vm.lastTrackMarkersStyles : {}
      });
    })) : _vm._e()]), _vm._v(" "), _c("div", {
      ref: "thumbContainer",
      staticClass: "mdc-slider__thumb-container",
      style: _vm.thumbStyles
    }, [_vm.isDiscrete ? _c("div", { staticClass: "mdc-slider__pin" }, [_c("span", { staticClass: "mdc-slider__pin-value-marker" }, [_vm._v(_vm._s(_vm.markerValue))])]) : _vm._e(), _vm._v(" "), _c("svg", {
      staticClass: "mdc-slider__thumb",
      attrs: { width: "21", height: "21" }
    }, [_c("circle", { attrs: { cx: "10.5", cy: "10.5", r: "7.875" } })]), _vm._v(" "), _c("div", { staticClass: "mdc-slider__focus-ring" })])]);
  };
  var __vue_staticRenderFns__$P = [];
  __vue_render__$P._withStripped = true;

  /* style */
  var __vue_inject_styles__$S = undefined;
  /* scoped */
  var __vue_scope_id__$S = undefined;
  /* module identifier */
  var __vue_module_identifier__$S = undefined;
  /* functional template */
  var __vue_is_functional_template__$S = false;
  /* component normalizer */
  function __vue_normalize__$S(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/slider/mdc-slider.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$S() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$S.styles || (__vue_create_injector__$S.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcSlider = __vue_normalize__$S({ render: __vue_render__$P, staticRenderFns: __vue_staticRenderFns__$P }, __vue_inject_styles__$S, __vue_script__$S, __vue_scope_id__$S, __vue_is_functional_template__$S, __vue_module_identifier__$S, __vue_create_injector__$S, undefined);

  var VueMDCSlider = BasePlugin({
    mdcSlider: mdcSlider
  });

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var cssClasses$i = {
    ROOT: 'mdc-snackbar',
    TEXT: 'mdc-snackbar__text',
    ACTION_WRAPPER: 'mdc-snackbar__action-wrapper',
    ACTION_BUTTON: 'mdc-snackbar__action-button',
    ACTIVE: 'mdc-snackbar--active',
    MULTILINE: 'mdc-snackbar--multiline',
    ACTION_ON_BOTTOM: 'mdc-snackbar--action-on-bottom'
  };

  var strings$h = {
    TEXT_SELECTOR: '.mdc-snackbar__text',
    ACTION_WRAPPER_SELECTOR: '.mdc-snackbar__action-wrapper',
    ACTION_BUTTON_SELECTOR: '.mdc-snackbar__action-button',
    SHOW_EVENT: 'MDCSnackbar:show',
    HIDE_EVENT: 'MDCSnackbar:hide'
  };

  var numbers$7 = {
    MESSAGE_TIMEOUT: 2750
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCSnackbarFoundation = function (_MDCFoundation) {
    inherits(MDCSnackbarFoundation, _MDCFoundation);
    createClass(MDCSnackbarFoundation, [{
      key: 'active',
      get: function get$$1() {
        return this.active_;
      }
    }], [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$i;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$h;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          setAriaHidden: function setAriaHidden() {},
          unsetAriaHidden: function unsetAriaHidden() {},
          setActionAriaHidden: function setActionAriaHidden() {},
          unsetActionAriaHidden: function unsetActionAriaHidden() {},
          setActionText: function setActionText() /* actionText: string */{},
          setMessageText: function setMessageText() /* message: string */{},
          setFocus: function setFocus() {},
          visibilityIsHidden: function visibilityIsHidden() {
            return (/* boolean */false
            );
          },
          registerCapturedBlurHandler: function registerCapturedBlurHandler() /* handler: EventListener */{},
          deregisterCapturedBlurHandler: function deregisterCapturedBlurHandler() /* handler: EventListener */{},
          registerVisibilityChangeHandler: function registerVisibilityChangeHandler() /* handler: EventListener */{},
          deregisterVisibilityChangeHandler: function deregisterVisibilityChangeHandler() /* handler: EventListener */{},
          registerCapturedInteractionHandler: function registerCapturedInteractionHandler() /* evtType: string, handler: EventListener */{},
          deregisterCapturedInteractionHandler: function deregisterCapturedInteractionHandler() /* evtType: string, handler: EventListener */{},
          registerActionClickHandler: function registerActionClickHandler() /* handler: EventListener */{},
          deregisterActionClickHandler: function deregisterActionClickHandler() /* handler: EventListener */{},
          registerTransitionEndHandler: function registerTransitionEndHandler() /* handler: EventListener */{},
          deregisterTransitionEndHandler: function deregisterTransitionEndHandler() /* handler: EventListener */{},
          notifyShow: function notifyShow() {},
          notifyHide: function notifyHide() {}
        };
      }
    }]);

    function MDCSnackbarFoundation(adapter) {
      classCallCheck(this, MDCSnackbarFoundation);

      var _this = possibleConstructorReturn(this, (MDCSnackbarFoundation.__proto__ || Object.getPrototypeOf(MDCSnackbarFoundation)).call(this, _extends(MDCSnackbarFoundation.defaultAdapter, adapter)));

      _this.active_ = false;
      _this.actionWasClicked_ = false;
      _this.dismissOnAction_ = true;
      _this.firstFocus_ = true;
      _this.pointerDownRecognized_ = false;
      _this.snackbarHasFocus_ = false;
      _this.snackbarData_ = null;
      _this.queue_ = [];
      _this.actionClickHandler_ = function () {
        _this.actionWasClicked_ = true;
        _this.invokeAction_();
      };
      _this.visibilitychangeHandler_ = function () {
        clearTimeout(_this.timeoutId_);
        _this.snackbarHasFocus_ = true;

        if (!_this.adapter_.visibilityIsHidden()) {
          setTimeout(_this.cleanup_.bind(_this), _this.snackbarData_.timeout || numbers$7.MESSAGE_TIMEOUT);
        }
      };
      _this.interactionHandler_ = function (evt) {
        if (evt.type == 'touchstart' || evt.type == 'mousedown') {
          _this.pointerDownRecognized_ = true;
        }
        _this.handlePossibleTabKeyboardFocus_(evt);

        if (evt.type == 'focus') {
          _this.pointerDownRecognized_ = false;
        }
      };
      _this.blurHandler_ = function () {
        clearTimeout(_this.timeoutId_);
        _this.snackbarHasFocus_ = false;
        _this.timeoutId_ = setTimeout(_this.cleanup_.bind(_this), _this.snackbarData_.timeout || numbers$7.MESSAGE_TIMEOUT);
      };
      return _this;
    }

    createClass(MDCSnackbarFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerActionClickHandler(this.actionClickHandler_);
        this.adapter_.setAriaHidden();
        this.adapter_.setActionAriaHidden();
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this2 = this;

        this.adapter_.deregisterActionClickHandler(this.actionClickHandler_);
        this.adapter_.deregisterCapturedBlurHandler(this.blurHandler_);
        this.adapter_.deregisterVisibilityChangeHandler(this.visibilitychangeHandler_);
        ['touchstart', 'mousedown', 'focus'].forEach(function (evtType) {
          _this2.adapter_.deregisterCapturedInteractionHandler(evtType, _this2.interactionHandler_);
        });
      }
    }, {
      key: 'dismissesOnAction',
      value: function dismissesOnAction() {
        return this.dismissOnAction_;
      }
    }, {
      key: 'setDismissOnAction',
      value: function setDismissOnAction(dismissOnAction) {
        this.dismissOnAction_ = !!dismissOnAction;
      }
    }, {
      key: 'show',
      value: function show(data) {
        var _this3 = this;

        if (!data) {
          throw new Error('Please provide a data object with at least a message to display.');
        }
        if (!data.message) {
          throw new Error('Please provide a message to be displayed.');
        }
        if (data.actionHandler && !data.actionText) {
          throw new Error('Please provide action text with the handler.');
        }
        if (this.active) {
          this.queue_.push(data);
          return;
        }
        clearTimeout(this.timeoutId_);
        this.snackbarData_ = data;
        this.firstFocus_ = true;
        this.adapter_.registerVisibilityChangeHandler(this.visibilitychangeHandler_);
        this.adapter_.registerCapturedBlurHandler(this.blurHandler_);
        ['touchstart', 'mousedown', 'focus'].forEach(function (evtType) {
          _this3.adapter_.registerCapturedInteractionHandler(evtType, _this3.interactionHandler_);
        });

        var ACTIVE = cssClasses$i.ACTIVE,
            MULTILINE = cssClasses$i.MULTILINE,
            ACTION_ON_BOTTOM = cssClasses$i.ACTION_ON_BOTTOM;


        this.adapter_.setMessageText(this.snackbarData_.message);

        if (this.snackbarData_.multiline) {
          this.adapter_.addClass(MULTILINE);
          if (this.snackbarData_.actionOnBottom) {
            this.adapter_.addClass(ACTION_ON_BOTTOM);
          }
        }

        if (this.snackbarData_.actionHandler) {
          this.adapter_.setActionText(this.snackbarData_.actionText);
          this.actionHandler_ = this.snackbarData_.actionHandler;
          this.setActionHidden_(false);
        } else {
          this.setActionHidden_(true);
          this.actionHandler_ = null;
          this.adapter_.setActionText(null);
        }

        this.active_ = true;
        this.adapter_.addClass(ACTIVE);
        this.adapter_.unsetAriaHidden();
        this.adapter_.notifyShow();

        this.timeoutId_ = setTimeout(this.cleanup_.bind(this), this.snackbarData_.timeout || numbers$7.MESSAGE_TIMEOUT);
      }
    }, {
      key: 'handlePossibleTabKeyboardFocus_',
      value: function handlePossibleTabKeyboardFocus_() {
        var hijackFocus = this.firstFocus_ && !this.pointerDownRecognized_;

        if (hijackFocus) {
          this.setFocusOnAction_();
        }

        this.firstFocus_ = false;
      }
    }, {
      key: 'setFocusOnAction_',
      value: function setFocusOnAction_() {
        this.adapter_.setFocus();
        this.snackbarHasFocus_ = true;
        this.firstFocus_ = false;
      }
    }, {
      key: 'invokeAction_',
      value: function invokeAction_() {
        try {
          if (!this.actionHandler_) {
            return;
          }

          this.actionHandler_();
        } finally {
          if (this.dismissOnAction_) {
            this.cleanup_();
          }
        }
      }
    }, {
      key: 'cleanup_',
      value: function cleanup_() {
        var _this4 = this;

        var allowDismissal = !this.snackbarHasFocus_ || this.actionWasClicked_;

        if (allowDismissal) {
          var ACTIVE = cssClasses$i.ACTIVE,
              MULTILINE = cssClasses$i.MULTILINE,
              ACTION_ON_BOTTOM = cssClasses$i.ACTION_ON_BOTTOM;


          this.adapter_.removeClass(ACTIVE);

          var handler = function handler() {
            clearTimeout(_this4.timeoutId_);
            _this4.adapter_.deregisterTransitionEndHandler(handler);
            _this4.adapter_.removeClass(MULTILINE);
            _this4.adapter_.removeClass(ACTION_ON_BOTTOM);
            _this4.setActionHidden_(true);
            _this4.adapter_.setAriaHidden();
            _this4.active_ = false;
            _this4.snackbarHasFocus_ = false;
            _this4.adapter_.notifyHide();
            _this4.showNext_();
          };

          this.adapter_.registerTransitionEndHandler(handler);
        }
      }
    }, {
      key: 'showNext_',
      value: function showNext_() {
        if (!this.queue_.length) {
          return;
        }
        this.show(this.queue_.shift());
      }
    }, {
      key: 'setActionHidden_',
      value: function setActionHidden_(isHidden) {
        if (isHidden) {
          this.adapter_.setActionAriaHidden();
        } else {
          this.adapter_.unsetActionAriaHidden();
        }
      }
    }]);
    return MDCSnackbarFoundation;
  }(MDCFoundation);

  //

  var script$T = {
    name: 'mdc-snackbar',
    model: {
      prop: 'snack',
      event: 'queued'
    },
    props: {
      'align-start': Boolean,
      snack: Object,
      event: String,
      'event-source': {
        type: Object,
        required: false,
        default: function _default() {
          return this.$root;
        }
      },
      'dismisses-on-action': {
        type: Boolean,
        default: true
      }
    },
    data: function data() {
      return {
        classes: {
          'mdc-snackbar--align-start': this.alignStart
        },
        message: '',
        actionText: '',
        hidden: false,
        actionHidden: false
      };
    },

    watch: {
      snack: 'onSnack'
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCSnackbarFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        setAriaHidden: function setAriaHidden() {
          return _this.hidden = true;
        },
        unsetAriaHidden: function unsetAriaHidden() {
          return _this.hidden = false;
        },
        setActionAriaHidden: function setActionAriaHidden() {
          return _this.actionHidden = true;
        },
        unsetActionAriaHidden: function unsetActionAriaHidden() {
          return _this.actionHidden = false;
        },
        setActionText: function setActionText(text) {
          _this.actionText = text;
        },
        setMessageText: function setMessageText(text) {
          _this.message = text;
        },
        setFocus: function setFocus() {
          return _this.$refs.button.focus();
        },
        visibilityIsHidden: function visibilityIsHidden() {
          return document.hidden;
        },
        registerCapturedBlurHandler: function registerCapturedBlurHandler(handler) {
          return _this.$refs.button.addEventListener('blur', handler, true);
        },
        deregisterCapturedBlurHandler: function deregisterCapturedBlurHandler(handler) {
          return _this.$refs.button.removeEventListener('blur', handler, true);
        },
        registerVisibilityChangeHandler: function registerVisibilityChangeHandler(handler) {
          return document.addEventListener('visibilitychange', handler);
        },
        deregisterVisibilityChangeHandler: function deregisterVisibilityChangeHandler(handler) {
          return document.removeEventListener('visibilitychange', handler);
        },
        registerCapturedInteractionHandler: function registerCapturedInteractionHandler(evt, handler) {
          return document.body.addEventListener(evt, handler, true);
        },
        deregisterCapturedInteractionHandler: function deregisterCapturedInteractionHandler(evt, handler) {
          return document.body.removeEventListener(evt, handler, true);
        },
        registerActionClickHandler: function registerActionClickHandler(handler) {
          return _this.$refs.button.addEventListener('click', handler);
        },
        deregisterActionClickHandler: function deregisterActionClickHandler(handler) {
          return _this.$refs.button.removeEventListener('click', handler);
        },
        registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
          var root = _this.$refs.root;
          root && root.addEventListener(getCorrectEventName(window, 'transitionend'), handler);
        },
        deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
          var root = _this.$refs.root;
          root && root.removeEventListener(getCorrectEventName(window, 'transitionend'), handler);
        },
        notifyShow: function notifyShow() {
          return _this.$emit('show');
        },
        notifyHide: function notifyHide() {
          return _this.$emit('hide');
        }
      });
      this.foundation.init();

      // if event specified use it, else if no snack prop then use default.
      this.eventName = this.event || (this.snack === void 0 ? 'show-snackbar' : null);
      if (this.eventName) {
        this.eventSource.$on(this.eventName, this.show);
      }
      this.foundation.setDismissOnAction(this.dismissesOnAction);
    },
    beforeDestroy: function beforeDestroy() {
      if (this.eventSource) {
        this.eventSource.$off(this.eventName, this.show);
      }
      this.foundation.destroy();
    },

    methods: {
      onSnack: function onSnack(snack) {
        if (snack && snack.message) {
          this.foundation.show(snack);
          this.$emit('queued', snack);
        }
      },
      show: function show(data) {
        this.foundation.show(data);
      }
    }
  };

  /* script */
  var __vue_script__$T = script$T;

  /* template */
  var __vue_render__$Q = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", {
      ref: "root",
      staticClass: "mdc-snackbar",
      class: _vm.classes,
      attrs: {
        "aria-hidden": _vm.hidden,
        "aria-live": "assertive",
        "aria-atomic": "true"
      }
    }, [_c("div", { staticClass: "mdc-snackbar__text" }, [_vm._v(_vm._s(_vm.message))]), _vm._v(" "), _c("div", { staticClass: "mdc-snackbar__action-wrapper" }, [_c("button", {
      ref: "button",
      staticClass: "mdc-snackbar__action-button",
      attrs: { "aria-hidden": _vm.actionHidden, type: "button" }
    }, [_vm._v(_vm._s(_vm.actionText))])])]);
  };
  var __vue_staticRenderFns__$Q = [];
  __vue_render__$Q._withStripped = true;

  /* style */
  var __vue_inject_styles__$T = undefined;
  /* scoped */
  var __vue_scope_id__$T = undefined;
  /* module identifier */
  var __vue_module_identifier__$T = undefined;
  /* functional template */
  var __vue_is_functional_template__$T = false;
  /* component normalizer */
  function __vue_normalize__$T(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/snackbar/mdc-snackbar.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$T() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$T.styles || (__vue_create_injector__$T.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcSnackbar = __vue_normalize__$T({ render: __vue_render__$Q, staticRenderFns: __vue_staticRenderFns__$Q }, __vue_inject_styles__$T, __vue_script__$T, __vue_scope_id__$T, __vue_is_functional_template__$T, __vue_module_identifier__$T, __vue_create_injector__$T, undefined);

  var VueMDCSnackbar = BasePlugin({
    mdcSnackbar: mdcSnackbar
  });

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Switch. Provides an interface for managing
   * - classes
   * - dom
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCSwitchAdapter = function () {
    function MDCSwitchAdapter() {
      classCallCheck(this, MDCSwitchAdapter);
    }

    createClass(MDCSwitchAdapter, [{
      key: "addClass",

      /** @param {string} className */
      value: function addClass(className) {}

      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /** @param {boolean} checked */

    }, {
      key: "setNativeControlChecked",
      value: function setNativeControlChecked(checked) {}

      /** @return {boolean} checked */

    }, {
      key: "isNativeControlChecked",
      value: function isNativeControlChecked() {}

      /** @param {boolean} disabled */

    }, {
      key: "setNativeControlDisabled",
      value: function setNativeControlDisabled(disabled) {}

      /** @return {boolean} disabled */

    }, {
      key: "isNativeControlDisabled",
      value: function isNativeControlDisabled() {}
    }]);
    return MDCSwitchAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$j = {
    CHECKED: 'mdc-switch--checked',
    DISABLED: 'mdc-switch--disabled'
  };

  /** @enum {string} */
  var strings$i = {
    NATIVE_CONTROL_SELECTOR: '.mdc-switch__native-control',
    RIPPLE_SURFACE_SELECTOR: '.mdc-switch__thumb-underlay'
  };

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCSwitchAdapter>}
   */

  var MDCSwitchFoundation = function (_MDCFoundation) {
    inherits(MDCSwitchFoundation, _MDCFoundation);
    createClass(MDCSwitchFoundation, null, [{
      key: 'strings',

      /** @return enum {string} */
      get: function get$$1() {
        return strings$i;
      }

      /** @return enum {string} */

    }, {
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$j;
      }

      /** @return {!MDCSwitchAdapter} */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCSwitchAdapter} */{
            addClass: function addClass() /* className: string */{},
            removeClass: function removeClass() /* className: string */{},
            setNativeControlChecked: function setNativeControlChecked() /* checked: boolean */{},
            isNativeControlChecked: function isNativeControlChecked() /* boolean */{},
            setNativeControlDisabled: function setNativeControlDisabled() /* disabled: boolean */{},
            isNativeControlDisabled: function isNativeControlDisabled() /* boolean */{}
          }
        );
      }
    }]);

    function MDCSwitchFoundation(adapter) {
      classCallCheck(this, MDCSwitchFoundation);
      return possibleConstructorReturn(this, (MDCSwitchFoundation.__proto__ || Object.getPrototypeOf(MDCSwitchFoundation)).call(this, _extends(MDCSwitchFoundation.defaultAdapter, adapter)));
    }

    /** @override */


    createClass(MDCSwitchFoundation, [{
      key: 'init',
      value: function init() {
        // Do an initial state update based on the state of the native control.
        this.handleChange();
      }

      /** @return {boolean} */

    }, {
      key: 'isChecked',
      value: function isChecked() {
        return this.adapter_.isNativeControlChecked();
      }

      /** @param {boolean} checked */

    }, {
      key: 'setChecked',
      value: function setChecked(checked) {
        this.adapter_.setNativeControlChecked(checked);
        this.updateCheckedStyling_(checked);
      }

      /** @return {boolean} */

    }, {
      key: 'isDisabled',
      value: function isDisabled() {
        return this.adapter_.isNativeControlDisabled();
      }

      /** @param {boolean} disabled */

    }, {
      key: 'setDisabled',
      value: function setDisabled(disabled) {
        this.adapter_.setNativeControlDisabled(disabled);
        if (disabled) {
          this.adapter_.addClass(cssClasses$j.DISABLED);
        } else {
          this.adapter_.removeClass(cssClasses$j.DISABLED);
        }
      }

      /**
       * Handles the change event for the switch native control.
       */

    }, {
      key: 'handleChange',
      value: function handleChange() {
        this.updateCheckedStyling_(this.isChecked());
      }

      /**
       * Updates the styling of the switch based on its checked state.
       * @param {boolean} checked
       * @private
       */

    }, {
      key: 'updateCheckedStyling_',
      value: function updateCheckedStyling_(checked) {
        if (checked) {
          this.adapter_.addClass(cssClasses$j.CHECKED);
        } else {
          this.adapter_.removeClass(cssClasses$j.CHECKED);
        }
      }
    }]);
    return MDCSwitchFoundation;
  }(MDCFoundation);

  //

  var script$U = {
    name: 'mdc-switch',
    mixins: [DispatchFocusMixin, VMAUniqueIdMixin],
    model: {
      prop: 'checked',
      event: 'change'
    },
    props: {
      checked: Boolean,
      disabled: Boolean,
      value: String,
      label: String,
      alignEnd: Boolean,
      name: String
    },
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },

    computed: {
      hasLabel: function hasLabel() {
        return this.label || this.$slots.default;
      }
    },
    watch: {
      checked: function checked(value) {
        this.foundation && this.foundation.setChecked(value);
      },
      disabled: function disabled(value) {
        this.foundation && this.foundation.setDisabled(value);
      }
    },

    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCSwitchFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        setNativeControlChecked: function setNativeControlChecked(checked) {
          return _this.$refs.control.checked = checked;
        },
        isNativeControlChecked: function isNativeControlChecked() {
          return _this.$refs.control.checked;
        },
        setNativeControlDisabled: function setNativeControlDisabled(disabled) {
          return _this.$refs.control.disabled = disabled;
        },
        isNativeControlDisabled: function isNativeControlDisabled() {
          return _this.nativeControl_.disabled;
        }
      });
      this.foundation.init();
      this.foundation.setChecked(this.checked);
      this.foundation.setDisabled(this.disabled);

      this.ripple = new RippleBase(this);
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation && this.foundation.destroy();
      this.ripple && this.ripple.destroy();
    },

    methods: {
      onChanged: function onChanged(event) {
        this.foundation && this.foundation.handleChange();
        this.$emit('change', event.target.checked);
      }
    }
  };

  /* script */
  var __vue_script__$U = script$U;

  /* template */
  var __vue_render__$R = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", {
      staticClass: "mdc-switch-wrapper",
      class: {
        "mdc-form-field": _vm.hasLabel,
        "mdc-form-field--align-end": _vm.hasLabel && _vm.alignEnd
      }
    }, [_c("div", {
      staticClass: "mdc-switch",
      class: _vm.classes,
      attrs: { styles: _vm.styles }
    }, [_c("div", { staticClass: "mdc-switch__track" }), _vm._v(" "), _c("div", { staticClass: "mdc-switch__thumb-underlay" }, [_c("div", { staticClass: "mdc-switch__thumb" }, [_c("input", {
      ref: "control",
      staticClass: "mdc-switch__native-control",
      attrs: {
        name: _vm.name,
        id: _vm.vma_uid_,
        type: "checkbox",
        role: "switch"
      },
      domProps: { value: _vm.value },
      on: { change: _vm.onChanged }
    })])])]), _vm._v(" "), _vm.hasLabel ? _c("label", { staticClass: "mdc-switch-label", attrs: { for: _vm.vma_uid_ } }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e()]);
  };
  var __vue_staticRenderFns__$R = [];
  __vue_render__$R._withStripped = true;

  /* style */
  var __vue_inject_styles__$U = undefined;
  /* scoped */
  var __vue_scope_id__$U = undefined;
  /* module identifier */
  var __vue_module_identifier__$U = undefined;
  /* functional template */
  var __vue_is_functional_template__$U = false;
  /* component normalizer */
  function __vue_normalize__$U(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/switch/mdc-switch.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$U() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$U.styles || (__vue_create_injector__$U.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcSwitch = __vue_normalize__$U({ render: __vue_render__$R, staticRenderFns: __vue_staticRenderFns__$R }, __vue_inject_styles__$U, __vue_script__$U, __vue_scope_id__$U, __vue_is_functional_template__$U, __vue_module_identifier__$U, __vue_create_injector__$U, undefined);

  var VueMDCSwitch = BasePlugin({
    mdcSwitch: mdcSwitch
  });

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$k = {
    ACTIVE: 'mdc-tab--active'
  };

  var strings$j = {
    SELECTED_EVENT: 'MDCTab:selected'
  };

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCTabFoundation = function (_MDCFoundation) {
    inherits(MDCTabFoundation, _MDCFoundation);
    createClass(MDCTabFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$k;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$j;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
          getOffsetWidth: function getOffsetWidth() {
            return (/* number */0
            );
          },
          getOffsetLeft: function getOffsetLeft() {
            return (/* number */0
            );
          },
          notifySelected: function notifySelected() {}
        };
      }
    }]);

    function MDCTabFoundation() {
      var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      classCallCheck(this, MDCTabFoundation);

      var _this = possibleConstructorReturn(this, (MDCTabFoundation.__proto__ || Object.getPrototypeOf(MDCTabFoundation)).call(this, _extends(MDCTabFoundation.defaultAdapter, adapter)));

      _this.computedWidth_ = 0;
      _this.computedLeft_ = 0;
      _this.isActive_ = false;
      _this.preventDefaultOnClick_ = false;

      _this.clickHandler_ = function (evt) {
        if (_this.preventDefaultOnClick_) {
          evt.preventDefault();
        }
        _this.adapter_.notifySelected();
      };

      _this.keydownHandler_ = function (evt) {
        if (evt.key && evt.key === 'Enter' || evt.keyCode === 13) {
          _this.adapter_.notifySelected();
        }
      };
      return _this;
    }

    createClass(MDCTabFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerInteractionHandler('click', this.clickHandler_);
        this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
        this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
      }
    }, {
      key: 'getComputedWidth',
      value: function getComputedWidth() {
        return this.computedWidth_;
      }
    }, {
      key: 'getComputedLeft',
      value: function getComputedLeft() {
        return this.computedLeft_;
      }
    }, {
      key: 'isActive',
      value: function isActive() {
        return this.isActive_;
      }
    }, {
      key: 'setActive',
      value: function setActive(isActive) {
        this.isActive_ = isActive;
        if (this.isActive_) {
          this.adapter_.addClass(cssClasses$k.ACTIVE);
        } else {
          this.adapter_.removeClass(cssClasses$k.ACTIVE);
        }
      }
    }, {
      key: 'preventsDefaultOnClick',
      value: function preventsDefaultOnClick() {
        return this.preventDefaultOnClick_;
      }
    }, {
      key: 'setPreventDefaultOnClick',
      value: function setPreventDefaultOnClick(preventDefaultOnClick) {
        this.preventDefaultOnClick_ = preventDefaultOnClick;
      }
    }, {
      key: 'measureSelf',
      value: function measureSelf() {
        this.computedWidth_ = this.adapter_.getOffsetWidth();
        this.computedLeft_ = this.adapter_.getOffsetLeft();
      }
    }]);
    return MDCTabFoundation;
  }(MDCFoundation);

  //

  var script$V = {
    name: 'mdc-tab',
    mixins: [CustomLinkMixin, DispatchEventMixin],
    props: {
      active: Boolean,
      icon: [String, Array, Object]
    },
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },

    computed: {
      hasIcon: function hasIcon() {
        if (this.icon || this.$slots.icon) {
          return this.icon ? extractIconProp(this.icon) : {};
        }
        return false;
      },
      hasText: function hasText() {
        return !!this.$slots.default;
      }
    },
    watch: {
      active: function active(value) {
        if (value) {
          this.foundation.adapter_.notifySelected();
        }
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCTabFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          return _this.$el.addEventListener(type, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          return _this.$el.removeEventListener(type, handler);
        },
        getOffsetWidth: function getOffsetWidth() {
          return _this.$el.offsetWidth;
        },
        getOffsetLeft: function getOffsetLeft() {
          return _this.$el.offsetLeft;
        },
        notifySelected: function notifySelected() {
          emitCustomEvent(_this.$el, MDCTabFoundation.strings.SELECTED_EVENT, { tab: _this }, true);
        }
      });
      this.foundation.init();
      this.setActive(this.active);
      this.ripple = new RippleBase(this);
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
      this.ripple.destroy();
    },

    methods: {
      getComputedWidth: function getComputedWidth() {
        return this.foundation.getComputedWidth();
      },
      getComputedLeft: function getComputedLeft() {
        return this.foundation.getComputedLeft();
      },
      isActive: function isActive() {
        return this.foundation.isActive();
      },
      setActive: function setActive(isActive) {
        this.foundation.setActive(isActive);
      },
      isDefaultPreventedOnClick: function isDefaultPreventedOnClick() {
        return this.foundation.preventsDefaultOnClick();
      },
      setPreventDefaultOnClick: function setPreventDefaultOnClick(preventDefaultOnClick) {
        this.foundation.setPreventDefaultOnClick(preventDefaultOnClick);
      },
      measureSelf: function measureSelf() {
        this.foundation.measureSelf();
      }
    }
  };

  /* script */
  var __vue_script__$V = script$V;

  /* template */
  var __vue_render__$S = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("custom-link", _vm._g({
      staticClass: "mdc-tab",
      class: _vm.classes,
      style: _vm.styles,
      attrs: { link: _vm.link }
    }, _vm.listeners), [!!_vm.hasIcon ? _c("i", {
      ref: "icon",
      staticClass: "mdc-tab__icon",
      class: _vm.hasIcon.classes,
      attrs: { tabindex: "0" }
    }, [_vm._t("icon", [_vm._v(_vm._s(_vm.hasIcon.content))])], 2) : _vm._e(), _vm._v(" "), _vm.hasText ? _c("span", { class: { "mdc-tab__icon-text": !!_vm.hasIcon } }, [_vm._t("default")], 2) : _vm._e()]);
  };
  var __vue_staticRenderFns__$S = [];
  __vue_render__$S._withStripped = true;

  /* style */
  var __vue_inject_styles__$V = undefined;
  /* scoped */
  var __vue_scope_id__$V = undefined;
  /* module identifier */
  var __vue_module_identifier__$V = undefined;
  /* functional template */
  var __vue_is_functional_template__$V = false;
  /* component normalizer */
  function __vue_normalize__$V(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/tabs/mdc-tab.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$V() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$V.styles || (__vue_create_injector__$V.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcTab = __vue_normalize__$V({ render: __vue_render__$S, staticRenderFns: __vue_staticRenderFns__$S }, __vue_inject_styles__$V, __vue_script__$V, __vue_scope_id__$V, __vue_is_functional_template__$V, __vue_module_identifier__$V, __vue_create_injector__$V, undefined);

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$l = {
    UPGRADED: 'mdc-tab-bar-upgraded'
  };

  var strings$k = {
    TAB_SELECTOR: '.mdc-tab',
    INDICATOR_SELECTOR: '.mdc-tab-bar__indicator',
    CHANGE_EVENT: 'MDCTabBar:change'
  };

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCTabBarFoundation = function (_MDCFoundation) {
    inherits(MDCTabBarFoundation, _MDCFoundation);
    createClass(MDCTabBarFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$l;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$k;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          bindOnMDCTabSelectedEvent: function bindOnMDCTabSelectedEvent() {},
          unbindOnMDCTabSelectedEvent: function unbindOnMDCTabSelectedEvent() {},
          registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
          deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
          getOffsetWidth: function getOffsetWidth() {
            return (/* number */0
            );
          },
          setStyleForIndicator: function setStyleForIndicator() /* propertyName: string, value: string */{},
          getOffsetWidthForIndicator: function getOffsetWidthForIndicator() {
            return (/* number */0
            );
          },
          notifyChange: function notifyChange() /* evtData: {activeTabIndex: number} */{},
          getNumberOfTabs: function getNumberOfTabs() {
            return (/* number */0
            );
          },
          isTabActiveAtIndex: function isTabActiveAtIndex() {
            return (/* index: number */ /* boolean */false
            );
          },
          setTabActiveAtIndex: function setTabActiveAtIndex() /* index: number, isActive: true */{},
          isDefaultPreventedOnClickForTabAtIndex: function isDefaultPreventedOnClickForTabAtIndex() {
            return (/* index: number */ /* boolean */false
            );
          },
          setPreventDefaultOnClickForTabAtIndex: function setPreventDefaultOnClickForTabAtIndex() /* index: number, preventDefaultOnClick: boolean */{},
          measureTabAtIndex: function measureTabAtIndex() /* index: number */{},
          getComputedWidthForTabAtIndex: function getComputedWidthForTabAtIndex() {
            return (/* index: number */ /* number */0
            );
          },
          getComputedLeftForTabAtIndex: function getComputedLeftForTabAtIndex() {
            return (/* index: number */ /* number */0
            );
          }
        };
      }
    }]);

    function MDCTabBarFoundation(adapter) {
      classCallCheck(this, MDCTabBarFoundation);

      var _this = possibleConstructorReturn(this, (MDCTabBarFoundation.__proto__ || Object.getPrototypeOf(MDCTabBarFoundation)).call(this, _extends(MDCTabBarFoundation.defaultAdapter, adapter)));

      _this.isIndicatorShown_ = false;
      _this.computedWidth_ = 0;
      _this.computedLeft_ = 0;
      _this.activeTabIndex_ = 0;
      _this.layoutFrame_ = 0;
      _this.resizeHandler_ = function () {
        return _this.layout();
      };
      return _this;
    }

    createClass(MDCTabBarFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.addClass(cssClasses$l.UPGRADED);
        this.adapter_.bindOnMDCTabSelectedEvent();
        this.adapter_.registerResizeHandler(this.resizeHandler_);
        var activeTabIndex = this.findActiveTabIndex_();
        if (activeTabIndex >= 0) {
          this.activeTabIndex_ = activeTabIndex;
        }
        this.layout();
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.removeClass(cssClasses$l.UPGRADED);
        this.adapter_.unbindOnMDCTabSelectedEvent();
        this.adapter_.deregisterResizeHandler(this.resizeHandler_);
      }
    }, {
      key: 'layoutInternal_',
      value: function layoutInternal_() {
        var _this2 = this;

        this.forEachTabIndex_(function (index) {
          return _this2.adapter_.measureTabAtIndex(index);
        });
        this.computedWidth_ = this.adapter_.getOffsetWidth();
        this.layoutIndicator_();
      }
    }, {
      key: 'layoutIndicator_',
      value: function layoutIndicator_() {
        var isIndicatorFirstRender = !this.isIndicatorShown_;

        // Ensure that indicator appears in the right position immediately for correct first render.
        if (isIndicatorFirstRender) {
          this.adapter_.setStyleForIndicator('transition', 'none');
        }

        var translateAmtForActiveTabLeft = this.adapter_.getComputedLeftForTabAtIndex(this.activeTabIndex_);
        var scaleAmtForActiveTabWidth = this.adapter_.getComputedWidthForTabAtIndex(this.activeTabIndex_) / this.adapter_.getOffsetWidth();

        var transformValue = 'translateX(' + translateAmtForActiveTabLeft + 'px) scale(' + scaleAmtForActiveTabWidth + ', 1)';
        this.adapter_.setStyleForIndicator(getCorrectPropertyName(window, 'transform'), transformValue);

        if (isIndicatorFirstRender) {
          // Force layout so that transform styles to take effect.
          this.adapter_.getOffsetWidthForIndicator();
          this.adapter_.setStyleForIndicator('transition', '');
          this.adapter_.setStyleForIndicator('visibility', 'visible');
          this.isIndicatorShown_ = true;
        }
      }
    }, {
      key: 'findActiveTabIndex_',
      value: function findActiveTabIndex_() {
        var _this3 = this;

        var activeTabIndex = -1;
        this.forEachTabIndex_(function (index) {
          if (_this3.adapter_.isTabActiveAtIndex(index)) {
            activeTabIndex = index;
            return true;
          }
        });
        return activeTabIndex;
      }
    }, {
      key: 'forEachTabIndex_',
      value: function forEachTabIndex_(iterator) {
        var numTabs = this.adapter_.getNumberOfTabs();
        for (var index = 0; index < numTabs; index++) {
          var shouldBreak = iterator(index);
          if (shouldBreak) {
            break;
          }
        }
      }
    }, {
      key: 'layout',
      value: function layout() {
        var _this4 = this;

        if (this.layoutFrame_) {
          cancelAnimationFrame(this.layoutFrame_);
        }

        this.layoutFrame_ = requestAnimationFrame(function () {
          _this4.layoutInternal_();
          _this4.layoutFrame_ = 0;
        });
      }
    }, {
      key: 'switchToTabAtIndex',
      value: function switchToTabAtIndex(index, shouldNotify) {
        var _this5 = this;

        if (index === this.activeTabIndex_) {
          return;
        }

        if (index < 0 || index >= this.adapter_.getNumberOfTabs()) {
          throw new Error('Out of bounds index specified for tab: ' + index);
        }

        var prevActiveTabIndex = this.activeTabIndex_;
        this.activeTabIndex_ = index;
        requestAnimationFrame(function () {
          if (prevActiveTabIndex >= 0) {
            _this5.adapter_.setTabActiveAtIndex(prevActiveTabIndex, false);
          }
          _this5.adapter_.setTabActiveAtIndex(_this5.activeTabIndex_, true);
          _this5.layoutIndicator_();
          if (shouldNotify) {
            _this5.adapter_.notifyChange({ activeTabIndex: _this5.activeTabIndex_ });
          }
        });
      }
    }, {
      key: 'getActiveTabIndex',
      value: function getActiveTabIndex() {
        return this.findActiveTabIndex_();
      }
    }]);
    return MDCTabBarFoundation;
  }(MDCFoundation);

  //

  var script$W = {
    name: 'mdc-tab-bar',
    data: function data() {
      return {
        classes: {},
        indicatorStyles: {},
        tabs: []
      };
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCTabBarFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        bindOnMDCTabSelectedEvent: function bindOnMDCTabSelectedEvent() {
          _this.$el.addEventListener(MDCTabFoundation.strings.SELECTED_EVENT, _this.onSelect);
        },
        unbindOnMDCTabSelectedEvent: function unbindOnMDCTabSelectedEvent() {
          return _this.$el.removeEventListener(MDCTabFoundation.strings.SELECTED_EVENT, _this.onSelect);
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          return window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          return window.removeEventListener('resize', handler);
        },
        getOffsetWidth: function getOffsetWidth() {
          return _this.$el.offsetWidth;
        },
        setStyleForIndicator: function setStyleForIndicator(propertyName, value) {
          return _this.$set(_this.indicatorStyles, propertyName, value);
        },
        getOffsetWidthForIndicator: function getOffsetWidthForIndicator() {
          return _this.$refs.indicator.offsetWidth;
        },
        notifyChange: function notifyChange(evtData) {
          _this.$emit('change', evtData.activeTabIndex);
        },
        getNumberOfTabs: function getNumberOfTabs() {
          return _this.tabs.length;
        },
        isTabActiveAtIndex: function isTabActiveAtIndex(index) {
          return _this.tabs[index].isActive();
        },
        setTabActiveAtIndex: function setTabActiveAtIndex(index, isActive) {
          // pgbr: 2018-04-07
          // since it is possible to change the number of tabs programatically
          // we need to detect the foundation deactivating a tab
          // that no longer exists but was previously active.
          if (!isActive && index >= _this.tabs.length) {
            return;
          }
          _this.tabs[index].setActive(isActive);
        },
        isDefaultPreventedOnClickForTabAtIndex: function isDefaultPreventedOnClickForTabAtIndex(index) {
          return _this.tabs[index].isDefaultPreventedOnClick();
        },
        setPreventDefaultOnClickForTabAtIndex: function setPreventDefaultOnClickForTabAtIndex(index, preventDefaultOnClick) {
          _this.tabs[index].setPreventDefaultOnClick(preventDefaultOnClick);
        },
        measureTabAtIndex: function measureTabAtIndex(index) {
          return _this.tabs[index].measureSelf();
        },
        getComputedWidthForTabAtIndex: function getComputedWidthForTabAtIndex(index) {
          return _this.tabs[index].getComputedWidth();
        },
        getComputedLeftForTabAtIndex: function getComputedLeftForTabAtIndex(index) {
          return _this.tabs[index].getComputedLeft();
        }
      });

      var resetTabs = function resetTabs() {
        var tabElements = [].slice.call(_this.$el.querySelectorAll(MDCTabBarFoundation.strings.TAB_SELECTOR));
        _this.tabs = tabElements.map(function (el) {
          return el.__vue__;
        });

        var hasText = void 0,
            hasIcon = void 0;
        var tabs = _this.tabs;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = tabs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var tab = _step.value;

            if (tab.hasText) {
              hasText = true;
              break;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = tabs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _tab = _step2.value;

            if (_tab.hasIcon) {
              hasIcon = true;
              break;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        if (hasText && hasIcon) {
          _this.$set(_this.classes, 'mdc-tab-bar--icons-with-text', true);
        } else if (hasIcon) {
          _this.$set(_this.classes, 'mdc-tab-bar--icon-tab-bar', true);
        }

        if (_this.foundation) {
          var activeTabIndex = _this.foundation.getActiveTabIndex();
          if (activeTabIndex >= 0) {
            _this.foundation.switchToTabAtIndex(activeTabIndex, true);
          } else {
            _this.foundation.switchToTabAtIndex(0, true);
          }
          _this.foundation.layout();
        }
      };

      resetTabs();

      this.slotObserver = new MutationObserver(function () {
        return resetTabs();
      });
      this.slotObserver.observe(this.$el, { childList: true, subtree: true });

      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.slotObserver.disconnect();
      this.foundation.destroy();
    },

    methods: {
      onSelect: function onSelect(_ref) {
        var detail = _ref.detail;
        var tab = detail.tab;

        var index = this.tabs.indexOf(tab);
        if (index < 0) {
          throw new Error('mdc-tab-bar internal error: index not found');
        }
        this.foundation.switchToTabAtIndex(index, true);
      }
    }
  };

  /* script */
  var __vue_script__$W = script$W;

  /* template */
  var __vue_render__$T = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("nav", _vm._g({ staticClass: "mdc-tab-bar", class: _vm.classes }, _vm.$listeners), [_vm._t("default"), _vm._v(" "), _c("span", {
      ref: "indicator",
      staticClass: "mdc-tab-bar__indicator",
      style: _vm.indicatorStyles
    })], 2);
  };
  var __vue_staticRenderFns__$T = [];
  __vue_render__$T._withStripped = true;

  /* style */
  var __vue_inject_styles__$W = undefined;
  /* scoped */
  var __vue_scope_id__$W = undefined;
  /* module identifier */
  var __vue_module_identifier__$W = undefined;
  /* functional template */
  var __vue_is_functional_template__$W = false;
  /* component normalizer */
  function __vue_normalize__$W(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/tabs/mdc-tab-bar.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$W() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$W.styles || (__vue_create_injector__$W.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcTabBar = __vue_normalize__$W({ render: __vue_render__$T, staticRenderFns: __vue_staticRenderFns__$T }, __vue_inject_styles__$W, __vue_script__$W, __vue_scope_id__$W, __vue_is_functional_template__$W, __vue_module_identifier__$W, __vue_create_injector__$W, undefined);

  var VueMDCTabs = BasePlugin({
    mdcTab: mdcTab,
    mdcTabBar: mdcTabBar
  });

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Text Field Helper Text.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the TextField helper text into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCTextFieldHelperTextAdapter = function () {
    function MDCTextFieldHelperTextAdapter() {
      classCallCheck(this, MDCTextFieldHelperTextAdapter);
    }

    createClass(MDCTextFieldHelperTextAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the helper text element.
       * @param {string} className
       */
      value: function addClass(className) {}

      /**
       * Removes a class from the helper text element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * Returns whether or not the helper text element contains the given class.
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}

      /**
       * Sets an attribute with a given value on the helper text element.
       * @param {string} attr
       * @param {string} value
       */

    }, {
      key: "setAttr",
      value: function setAttr(attr, value) {}

      /**
       * Removes an attribute from the helper text element.
       * @param {string} attr
       */

    }, {
      key: "removeAttr",
      value: function removeAttr(attr) {}

      /**
       * Sets the text content for the helper text element.
       * @param {string} content
       */

    }, {
      key: "setContent",
      value: function setContent(content) {}
    }]);
    return MDCTextFieldHelperTextAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$l = {
    ARIA_HIDDEN: 'aria-hidden',
    ROLE: 'role'
  };

  /** @enum {string} */
  var cssClasses$m = {
    HELPER_TEXT_PERSISTENT: 'mdc-text-field-helper-text--persistent',
    HELPER_TEXT_VALIDATION_MSG: 'mdc-text-field-helper-text--validation-msg'
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCTextFieldHelperTextAdapter>}
   * @final
   */

  var MDCTextFieldHelperTextFoundation = function (_MDCFoundation) {
    inherits(MDCTextFieldHelperTextFoundation, _MDCFoundation);
    createClass(MDCTextFieldHelperTextFoundation, null, [{
      key: 'cssClasses',

      /** @return enum {string} */
      get: function get$$1() {
        return cssClasses$m;
      }

      /** @return enum {string} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$l;
      }

      /**
       * {@see MDCTextFieldHelperTextAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCTextFieldHelperTextAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCTextFieldHelperTextAdapter} */{
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {},
            setAttr: function setAttr() {},
            removeAttr: function removeAttr() {},
            setContent: function setContent() {}
          }
        );
      }

      /**
       * @param {!MDCTextFieldHelperTextAdapter} adapter
       */

    }]);

    function MDCTextFieldHelperTextFoundation(adapter) {
      classCallCheck(this, MDCTextFieldHelperTextFoundation);
      return possibleConstructorReturn(this, (MDCTextFieldHelperTextFoundation.__proto__ || Object.getPrototypeOf(MDCTextFieldHelperTextFoundation)).call(this, _extends(MDCTextFieldHelperTextFoundation.defaultAdapter, adapter)));
    }

    /**
     * Sets the content of the helper text field.
     * @param {string} content
     */


    createClass(MDCTextFieldHelperTextFoundation, [{
      key: 'setContent',
      value: function setContent(content) {
        this.adapter_.setContent(content);
      }

      /** @param {boolean} isPersistent Sets the persistency of the helper text. */

    }, {
      key: 'setPersistent',
      value: function setPersistent(isPersistent) {
        if (isPersistent) {
          this.adapter_.addClass(cssClasses$m.HELPER_TEXT_PERSISTENT);
        } else {
          this.adapter_.removeClass(cssClasses$m.HELPER_TEXT_PERSISTENT);
        }
      }

      /**
       * @param {boolean} isValidation True to make the helper text act as an
       *   error validation message.
       */

    }, {
      key: 'setValidation',
      value: function setValidation(isValidation) {
        if (isValidation) {
          this.adapter_.addClass(cssClasses$m.HELPER_TEXT_VALIDATION_MSG);
        } else {
          this.adapter_.removeClass(cssClasses$m.HELPER_TEXT_VALIDATION_MSG);
        }
      }

      /** Makes the helper text visible to the screen reader. */

    }, {
      key: 'showToScreenReader',
      value: function showToScreenReader() {
        this.adapter_.removeAttr(strings$l.ARIA_HIDDEN);
      }

      /**
       * Sets the validity of the helper text based on the input validity.
       * @param {boolean} inputIsValid
       */

    }, {
      key: 'setValidity',
      value: function setValidity(inputIsValid) {
        var helperTextIsPersistent = this.adapter_.hasClass(cssClasses$m.HELPER_TEXT_PERSISTENT);
        var helperTextIsValidationMsg = this.adapter_.hasClass(cssClasses$m.HELPER_TEXT_VALIDATION_MSG);
        var validationMsgNeedsDisplay = helperTextIsValidationMsg && !inputIsValid;

        if (validationMsgNeedsDisplay) {
          this.adapter_.setAttr(strings$l.ROLE, 'alert');
        } else {
          this.adapter_.removeAttr(strings$l.ROLE);
        }

        if (!helperTextIsPersistent && !validationMsgNeedsDisplay) {
          this.hide_();
        }
      }

      /**
       * Hides the help text from screen readers.
       * @private
       */

    }, {
      key: 'hide_',
      value: function hide_() {
        this.adapter_.setAttr(strings$l.ARIA_HIDDEN, 'true');
      }
    }]);
    return MDCTextFieldHelperTextFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Text Field Icon.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the text field icon into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCTextFieldIconAdapter = function () {
    function MDCTextFieldIconAdapter() {
      classCallCheck(this, MDCTextFieldIconAdapter);
    }

    createClass(MDCTextFieldIconAdapter, [{
      key: "getAttr",

      /**
       * Gets the value of an attribute on the icon element.
       * @param {string} attr
       * @return {string}
       */
      value: function getAttr(attr) {}

      /**
       * Sets an attribute on the icon element.
       * @param {string} attr
       * @param {string} value
       */

    }, {
      key: "setAttr",
      value: function setAttr(attr, value) {}

      /**
       * Removes an attribute from the icon element.
       * @param {string} attr
       */

    }, {
      key: "removeAttr",
      value: function removeAttr(attr) {}

      /**
       * Sets the text content of the icon element.
       * @param {string} content
       */

    }, {
      key: "setContent",
      value: function setContent(content) {}

      /**
       * Registers an event listener on the icon element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(evtType, handler) {}

      /**
       * Deregisters an event listener on the icon element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(evtType, handler) {}

      /**
       * Emits a custom event "MDCTextField:icon" denoting a user has clicked the icon.
       */

    }, {
      key: "notifyIconAction",
      value: function notifyIconAction() {}
    }]);
    return MDCTextFieldIconAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$m = {
    ICON_EVENT: 'MDCTextField:icon',
    ICON_ROLE: 'button'
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCTextFieldIconAdapter>}
   * @final
   */

  var MDCTextFieldIconFoundation = function (_MDCFoundation) {
    inherits(MDCTextFieldIconFoundation, _MDCFoundation);
    createClass(MDCTextFieldIconFoundation, null, [{
      key: 'strings',

      /** @return enum {string} */
      get: function get$$1() {
        return strings$m;
      }

      /**
       * {@see MDCTextFieldIconAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCTextFieldIconAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCTextFieldIconAdapter} */{
            getAttr: function getAttr() {},
            setAttr: function setAttr() {},
            removeAttr: function removeAttr() {},
            setContent: function setContent() {},
            registerInteractionHandler: function registerInteractionHandler() {},
            deregisterInteractionHandler: function deregisterInteractionHandler() {},
            notifyIconAction: function notifyIconAction() {}
          }
        );
      }

      /**
       * @param {!MDCTextFieldIconAdapter} adapter
       */

    }]);

    function MDCTextFieldIconFoundation(adapter) {
      classCallCheck(this, MDCTextFieldIconFoundation);

      /** @private {string?} */
      var _this = possibleConstructorReturn(this, (MDCTextFieldIconFoundation.__proto__ || Object.getPrototypeOf(MDCTextFieldIconFoundation)).call(this, _extends(MDCTextFieldIconFoundation.defaultAdapter, adapter)));

      _this.savedTabIndex_ = null;

      /** @private {function(!Event): undefined} */
      _this.interactionHandler_ = function (evt) {
        return _this.handleInteraction(evt);
      };
      return _this;
    }

    createClass(MDCTextFieldIconFoundation, [{
      key: 'init',
      value: function init() {
        var _this2 = this;

        this.savedTabIndex_ = this.adapter_.getAttr('tabindex');

        ['click', 'keydown'].forEach(function (evtType) {
          _this2.adapter_.registerInteractionHandler(evtType, _this2.interactionHandler_);
        });
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this3 = this;

        ['click', 'keydown'].forEach(function (evtType) {
          _this3.adapter_.deregisterInteractionHandler(evtType, _this3.interactionHandler_);
        });
      }

      /** @param {boolean} disabled */

    }, {
      key: 'setDisabled',
      value: function setDisabled(disabled) {
        if (!this.savedTabIndex_) {
          return;
        }

        if (disabled) {
          this.adapter_.setAttr('tabindex', '-1');
          this.adapter_.removeAttr('role');
        } else {
          this.adapter_.setAttr('tabindex', this.savedTabIndex_);
          this.adapter_.setAttr('role', strings$m.ICON_ROLE);
        }
      }

      /** @param {string} label */

    }, {
      key: 'setAriaLabel',
      value: function setAriaLabel(label) {
        this.adapter_.setAttr('aria-label', label);
      }

      /** @param {string} content */

    }, {
      key: 'setContent',
      value: function setContent(content) {
        this.adapter_.setContent(content);
      }

      /**
       * Handles an interaction event
       * @param {!Event} evt
       */

    }, {
      key: 'handleInteraction',
      value: function handleInteraction(evt) {
        if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
          this.adapter_.notifyIconAction();
        }
      }
    }]);
    return MDCTextFieldIconFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Adapter for MDC Text Field.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Text Field into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */

  var MDCTextFieldAdapter = function () {
    function MDCTextFieldAdapter() {
      classCallCheck(this, MDCTextFieldAdapter);
    }

    createClass(MDCTextFieldAdapter, [{
      key: 'addClass',

      /**
       * Adds a class to the root Element.
       * @param {string} className
       */
      value: function addClass(className) {}

      /**
       * Removes a class from the root Element.
       * @param {string} className
       */

    }, {
      key: 'removeClass',
      value: function removeClass(className) {}

      /**
       * Returns true if the root element contains the given class name.
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: 'hasClass',
      value: function hasClass(className) {}

      /**
       * Registers an event handler on the root element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: 'registerTextFieldInteractionHandler',
      value: function registerTextFieldInteractionHandler(type, handler) {}

      /**
       * Deregisters an event handler on the root element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: 'deregisterTextFieldInteractionHandler',
      value: function deregisterTextFieldInteractionHandler(type, handler) {}

      /**
       * Registers an event listener on the native input element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: 'registerInputInteractionHandler',
      value: function registerInputInteractionHandler(evtType, handler) {}

      /**
       * Deregisters an event listener on the native input element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: 'deregisterInputInteractionHandler',
      value: function deregisterInputInteractionHandler(evtType, handler) {}

      /**
       * Registers a validation attribute change listener on the input element.
       * Handler accepts list of attribute names.
       * @param {function(!Array<string>): undefined} handler
       * @return {!MutationObserver}
       */

    }, {
      key: 'registerValidationAttributeChangeHandler',
      value: function registerValidationAttributeChangeHandler(handler) {}

      /**
       * Disconnects a validation attribute observer on the input element.
       * @param {!MutationObserver} observer
       */

    }, {
      key: 'deregisterValidationAttributeChangeHandler',
      value: function deregisterValidationAttributeChangeHandler(observer) {}

      /**
       * Returns an object representing the native text input element, with a
       * similar API shape. The object returned should include the value, disabled
       * and badInput properties, as well as the checkValidity() function. We never
       * alter the value within our code, however we do update the disabled
       * property, so if you choose to duck-type the return value for this method
       * in your implementation it's important to keep this in mind. Also note that
       * this method can return null, which the foundation will handle gracefully.
       * @return {?Element|?NativeInputType}
       */

    }, {
      key: 'getNativeInput',
      value: function getNativeInput() {}

      /**
       * Returns true if the textfield is focused.
       * We achieve this via `document.activeElement === this.root_`.
       * @return {boolean}
       */

    }, {
      key: 'isFocused',
      value: function isFocused() {}

      /**
       * Returns true if the direction of the root element is set to RTL.
       * @return {boolean}
       */

    }, {
      key: 'isRtl',
      value: function isRtl() {}

      /**
       * Activates the line ripple.
       */

    }, {
      key: 'activateLineRipple',
      value: function activateLineRipple() {}

      /**
       * Deactivates the line ripple.
       */

    }, {
      key: 'deactivateLineRipple',
      value: function deactivateLineRipple() {}

      /**
       * Sets the transform origin of the line ripple.
       * @param {number} normalizedX
       */

    }, {
      key: 'setLineRippleTransformOrigin',
      value: function setLineRippleTransformOrigin(normalizedX) {}

      /**
       * Only implement if label exists.
       * Shakes label if shouldShake is true.
       * @param {boolean} shouldShake
       */

    }, {
      key: 'shakeLabel',
      value: function shakeLabel(shouldShake) {}

      /**
       * Only implement if label exists.
       * Floats the label above the input element if shouldFloat is true.
       * @param {boolean} shouldFloat
       */

    }, {
      key: 'floatLabel',
      value: function floatLabel(shouldFloat) {}

      /**
       * Returns true if label element exists, false if it doesn't.
       * @return {boolean}
       */

    }, {
      key: 'hasLabel',
      value: function hasLabel() {}

      /**
       * Only implement if label exists.
       * Returns width of label in pixels.
       * @return {number}
       */

    }, {
      key: 'getLabelWidth',
      value: function getLabelWidth() {}

      /**
       * Returns true if outline element exists, false if it doesn't.
       * @return {boolean}
       */

    }, {
      key: 'hasOutline',
      value: function hasOutline() {}

      /**
       * Only implement if outline element exists.
       * Updates SVG Path and outline element based on the
       * label element width and RTL context.
       * @param {number} labelWidth
       * @param {boolean=} isRtl
       */

    }, {
      key: 'notchOutline',
      value: function notchOutline(labelWidth, isRtl) {}

      /**
       * Only implement if outline element exists.
       * Closes notch in outline element.
       */

    }, {
      key: 'closeOutline',
      value: function closeOutline() {}
    }]);
    return MDCTextFieldAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$n = {
    ARIA_CONTROLS: 'aria-controls',
    INPUT_SELECTOR: '.mdc-text-field__input',
    LABEL_SELECTOR: '.mdc-floating-label',
    ICON_SELECTOR: '.mdc-text-field__icon',
    OUTLINE_SELECTOR: '.mdc-notched-outline',
    LINE_RIPPLE_SELECTOR: '.mdc-line-ripple'
  };

  /** @enum {string} */
  var cssClasses$n = {
    ROOT: 'mdc-text-field',
    UPGRADED: 'mdc-text-field--upgraded',
    DISABLED: 'mdc-text-field--disabled',
    DENSE: 'mdc-text-field--dense',
    FOCUSED: 'mdc-text-field--focused',
    INVALID: 'mdc-text-field--invalid',
    BOX: 'mdc-text-field--box',
    OUTLINED: 'mdc-text-field--outlined'
  };

  /** @enum {number} */
  var numbers$8 = {
    LABEL_SCALE: 0.75,
    DENSE_LABEL_SCALE: 0.923
  };

  // whitelist based off of https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation
  // under section: `Validation-related attributes`
  var VALIDATION_ATTR_WHITELIST = ['pattern', 'min', 'max', 'required', 'step', 'minlength', 'maxlength'];

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCTextFieldAdapter>}
   * @final
   */

  var MDCTextFieldFoundation = function (_MDCFoundation) {
    inherits(MDCTextFieldFoundation, _MDCFoundation);
    createClass(MDCTextFieldFoundation, [{
      key: 'shouldShake',


      /** @return {boolean} */
      get: function get$$1() {
        return !this.isValid() && !this.isFocused_;
      }

      /** @return {boolean} */

    }, {
      key: 'shouldFloat',
      get: function get$$1() {
        return this.isFocused_ || !!this.getValue() || this.isBadInput_();
      }

      /**
       * {@see MDCTextFieldAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCTextFieldAdapter}
       */

    }], [{
      key: 'cssClasses',

      /** @return enum {string} */
      get: function get$$1() {
        return cssClasses$n;
      }

      /** @return enum {string} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$n;
      }

      /** @return enum {string} */

    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers$8;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCTextFieldAdapter} */{
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {},
            registerTextFieldInteractionHandler: function registerTextFieldInteractionHandler() {},
            deregisterTextFieldInteractionHandler: function deregisterTextFieldInteractionHandler() {},
            registerInputInteractionHandler: function registerInputInteractionHandler() {},
            deregisterInputInteractionHandler: function deregisterInputInteractionHandler() {},
            registerValidationAttributeChangeHandler: function registerValidationAttributeChangeHandler() {},
            deregisterValidationAttributeChangeHandler: function deregisterValidationAttributeChangeHandler() {},
            getNativeInput: function getNativeInput() {},
            isFocused: function isFocused() {},
            isRtl: function isRtl() {},
            activateLineRipple: function activateLineRipple() {},
            deactivateLineRipple: function deactivateLineRipple() {},
            setLineRippleTransformOrigin: function setLineRippleTransformOrigin() {},
            shakeLabel: function shakeLabel() {},
            floatLabel: function floatLabel() {},
            hasLabel: function hasLabel() {},
            getLabelWidth: function getLabelWidth() {},
            hasOutline: function hasOutline() {},
            notchOutline: function notchOutline() {},
            closeOutline: function closeOutline() {}
          }
        );
      }

      /**
       * @param {!MDCTextFieldAdapter} adapter
       * @param {!FoundationMapType=} foundationMap Map from subcomponent names to their subfoundations.
       */

    }]);

    function MDCTextFieldFoundation(adapter) {
      var foundationMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /** @type {!FoundationMapType} */{};
      classCallCheck(this, MDCTextFieldFoundation);

      /** @type {!MDCTextFieldHelperTextFoundation|undefined} */
      var _this = possibleConstructorReturn(this, (MDCTextFieldFoundation.__proto__ || Object.getPrototypeOf(MDCTextFieldFoundation)).call(this, _extends(MDCTextFieldFoundation.defaultAdapter, adapter)));

      _this.helperText_ = foundationMap.helperText;
      /** @type {!MDCTextFieldIconFoundation|undefined} */
      _this.icon_ = foundationMap.icon;

      /** @private {boolean} */
      _this.isFocused_ = false;
      /** @private {boolean} */
      _this.receivedUserInput_ = false;
      /** @private {boolean} */
      _this.useCustomValidityChecking_ = false;
      /** @private {boolean} */
      _this.isValid_ = true;
      /** @private {function(): undefined} */
      _this.inputFocusHandler_ = function () {
        return _this.activateFocus();
      };
      /** @private {function(): undefined} */
      _this.inputBlurHandler_ = function () {
        return _this.deactivateFocus();
      };
      /** @private {function(): undefined} */
      _this.inputInputHandler_ = function () {
        return _this.autoCompleteFocus();
      };
      /** @private {function(!Event): undefined} */
      _this.setPointerXOffset_ = function (evt) {
        return _this.setTransformOrigin(evt);
      };
      /** @private {function(!Event): undefined} */
      _this.textFieldInteractionHandler_ = function () {
        return _this.handleTextFieldInteraction();
      };
      /** @private {function(!Array): undefined} */
      _this.validationAttributeChangeHandler_ = function (attributesList) {
        return _this.handleValidationAttributeChange(attributesList);
      };

      /** @private {!MutationObserver} */
      _this.validationObserver_;
      return _this;
    }

    createClass(MDCTextFieldFoundation, [{
      key: 'init',
      value: function init() {
        var _this2 = this;

        this.adapter_.addClass(MDCTextFieldFoundation.cssClasses.UPGRADED);
        // Ensure label does not collide with any pre-filled value.
        if (this.adapter_.hasLabel() && (this.getValue() || this.isBadInput_())) {
          this.adapter_.floatLabel(this.shouldFloat);
          this.notchOutline(this.shouldFloat);
        }

        if (this.adapter_.isFocused()) {
          this.inputFocusHandler_();
        }

        this.adapter_.registerInputInteractionHandler('focus', this.inputFocusHandler_);
        this.adapter_.registerInputInteractionHandler('blur', this.inputBlurHandler_);
        this.adapter_.registerInputInteractionHandler('input', this.inputInputHandler_);
        ['mousedown', 'touchstart'].forEach(function (evtType) {
          _this2.adapter_.registerInputInteractionHandler(evtType, _this2.setPointerXOffset_);
        });
        ['click', 'keydown'].forEach(function (evtType) {
          _this2.adapter_.registerTextFieldInteractionHandler(evtType, _this2.textFieldInteractionHandler_);
        });
        this.validationObserver_ = this.adapter_.registerValidationAttributeChangeHandler(this.validationAttributeChangeHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this3 = this;

        this.adapter_.removeClass(MDCTextFieldFoundation.cssClasses.UPGRADED);
        this.adapter_.deregisterInputInteractionHandler('focus', this.inputFocusHandler_);
        this.adapter_.deregisterInputInteractionHandler('blur', this.inputBlurHandler_);
        this.adapter_.deregisterInputInteractionHandler('input', this.inputInputHandler_);
        ['mousedown', 'touchstart'].forEach(function (evtType) {
          _this3.adapter_.deregisterInputInteractionHandler(evtType, _this3.setPointerXOffset_);
        });
        ['click', 'keydown'].forEach(function (evtType) {
          _this3.adapter_.deregisterTextFieldInteractionHandler(evtType, _this3.textFieldInteractionHandler_);
        });
        this.adapter_.deregisterValidationAttributeChangeHandler(this.validationObserver_);
      }

      /**
       * Handles user interactions with the Text Field.
       */

    }, {
      key: 'handleTextFieldInteraction',
      value: function handleTextFieldInteraction() {
        if (this.adapter_.getNativeInput().disabled) {
          return;
        }
        this.receivedUserInput_ = true;
      }

      /**
       * Handles validation attribute changes
       * @param {!Array<string>} attributesList
       */

    }, {
      key: 'handleValidationAttributeChange',
      value: function handleValidationAttributeChange(attributesList) {
        var _this4 = this;

        attributesList.some(function (attributeName) {
          if (VALIDATION_ATTR_WHITELIST.indexOf(attributeName) > -1) {
            _this4.styleValidity_(true);
            return true;
          }
        });
      }

      /**
       * Opens/closes the notched outline.
       * @param {boolean} openNotch
       */

    }, {
      key: 'notchOutline',
      value: function notchOutline(openNotch) {
        if (!this.adapter_.hasOutline() || !this.adapter_.hasLabel()) {
          return;
        }

        if (openNotch) {
          var isDense = this.adapter_.hasClass(cssClasses$n.DENSE);
          var labelScale = isDense ? numbers$8.DENSE_LABEL_SCALE : numbers$8.LABEL_SCALE;
          var labelWidth = this.adapter_.getLabelWidth() * labelScale;
          var isRtl = this.adapter_.isRtl();
          this.adapter_.notchOutline(labelWidth, isRtl);
        } else {
          this.adapter_.closeOutline();
        }
      }

      /**
       * Activates the text field focus state.
       */

    }, {
      key: 'activateFocus',
      value: function activateFocus() {
        this.isFocused_ = true;
        this.styleFocused_(this.isFocused_);
        this.adapter_.activateLineRipple();
        this.notchOutline(this.shouldFloat);
        if (this.adapter_.hasLabel()) {
          this.adapter_.shakeLabel(this.shouldShake);
          this.adapter_.floatLabel(this.shouldFloat);
        }
        if (this.helperText_) {
          this.helperText_.showToScreenReader();
        }
      }

      /**
       * Sets the line ripple's transform origin, so that the line ripple activate
       * animation will animate out from the user's click location.
       * @param {!Event} evt
       */

    }, {
      key: 'setTransformOrigin',
      value: function setTransformOrigin(evt) {
        var targetClientRect = evt.target.getBoundingClientRect();
        var evtCoords = { x: evt.clientX, y: evt.clientY };
        var normalizedX = evtCoords.x - targetClientRect.left;
        this.adapter_.setLineRippleTransformOrigin(normalizedX);
      }

      /**
       * Activates the Text Field's focus state in cases when the input value
       * changes without user input (e.g. programatically).
       */

    }, {
      key: 'autoCompleteFocus',
      value: function autoCompleteFocus() {
        if (!this.receivedUserInput_) {
          this.activateFocus();
        }
      }

      /**
       * Deactivates the Text Field's focus state.
       */

    }, {
      key: 'deactivateFocus',
      value: function deactivateFocus() {
        this.isFocused_ = false;
        this.adapter_.deactivateLineRipple();
        var input = this.getNativeInput_();
        var shouldRemoveLabelFloat = !input.value && !this.isBadInput_();
        var isValid = this.isValid();
        this.styleValidity_(isValid);
        this.styleFocused_(this.isFocused_);
        if (this.adapter_.hasLabel()) {
          this.adapter_.shakeLabel(this.shouldShake);
          this.adapter_.floatLabel(this.shouldFloat);
          this.notchOutline(this.shouldFloat);
        }
        if (shouldRemoveLabelFloat) {
          this.receivedUserInput_ = false;
        }
      }

      /**
       * @return {string} The value of the input Element.
       */

    }, {
      key: 'getValue',
      value: function getValue() {
        return this.getNativeInput_().value;
      }

      /**
       * @param {string} value The value to set on the input Element.
       */

    }, {
      key: 'setValue',
      value: function setValue(value) {
        this.getNativeInput_().value = value;
        var isValid = this.isValid();
        this.styleValidity_(isValid);
        if (this.adapter_.hasLabel()) {
          this.adapter_.shakeLabel(this.shouldShake);
          this.adapter_.floatLabel(this.shouldFloat);
          this.notchOutline(this.shouldFloat);
        }
      }

      /**
       * @return {boolean} If a custom validity is set, returns that value.
       *     Otherwise, returns the result of native validity checks.
       */

    }, {
      key: 'isValid',
      value: function isValid() {
        return this.useCustomValidityChecking_ ? this.isValid_ : this.isNativeInputValid_();
      }

      /**
       * @param {boolean} isValid Sets the validity state of the Text Field.
       */

    }, {
      key: 'setValid',
      value: function setValid(isValid) {
        this.useCustomValidityChecking_ = true;
        this.isValid_ = isValid;
        // Retrieve from the getter to ensure correct logic is applied.
        isValid = this.isValid();
        this.styleValidity_(isValid);
        if (this.adapter_.hasLabel()) {
          this.adapter_.shakeLabel(this.shouldShake);
        }
      }

      /**
       * @return {boolean} True if the Text Field is disabled.
       */

    }, {
      key: 'isDisabled',
      value: function isDisabled() {
        return this.getNativeInput_().disabled;
      }

      /**
       * @param {boolean} disabled Sets the text-field disabled or enabled.
       */

    }, {
      key: 'setDisabled',
      value: function setDisabled(disabled) {
        this.getNativeInput_().disabled = disabled;
        this.styleDisabled_(disabled);
      }

      /**
       * @param {string} content Sets the content of the helper text.
       */

    }, {
      key: 'setHelperTextContent',
      value: function setHelperTextContent(content) {
        if (this.helperText_) {
          this.helperText_.setContent(content);
        }
      }

      /**
       * Sets the aria label of the icon.
       * @param {string} label
       */

    }, {
      key: 'setIconAriaLabel',
      value: function setIconAriaLabel(label) {
        if (this.icon_) {
          this.icon_.setAriaLabel(label);
        }
      }

      /**
       * Sets the text content of the icon.
       * @param {string} content
       */

    }, {
      key: 'setIconContent',
      value: function setIconContent(content) {
        if (this.icon_) {
          this.icon_.setContent(content);
        }
      }

      /**
       * @return {boolean} True if the Text Field input fails in converting the
       *     user-supplied value.
       * @private
       */

    }, {
      key: 'isBadInput_',
      value: function isBadInput_() {
        return this.getNativeInput_().validity.badInput;
      }

      /**
       * @return {boolean} The result of native validity checking
       *     (ValidityState.valid).
       */

    }, {
      key: 'isNativeInputValid_',
      value: function isNativeInputValid_() {
        return this.getNativeInput_().validity.valid;
      }

      /**
       * Styles the component based on the validity state.
       * @param {boolean} isValid
       * @private
       */

    }, {
      key: 'styleValidity_',
      value: function styleValidity_(isValid) {
        var INVALID = MDCTextFieldFoundation.cssClasses.INVALID;

        if (isValid) {
          this.adapter_.removeClass(INVALID);
        } else {
          this.adapter_.addClass(INVALID);
        }
        if (this.helperText_) {
          this.helperText_.setValidity(isValid);
        }
      }

      /**
       * Styles the component based on the focused state.
       * @param {boolean} isFocused
       * @private
       */

    }, {
      key: 'styleFocused_',
      value: function styleFocused_(isFocused) {
        var FOCUSED = MDCTextFieldFoundation.cssClasses.FOCUSED;

        if (isFocused) {
          this.adapter_.addClass(FOCUSED);
        } else {
          this.adapter_.removeClass(FOCUSED);
        }
      }

      /**
       * Styles the component based on the disabled state.
       * @param {boolean} isDisabled
       * @private
       */

    }, {
      key: 'styleDisabled_',
      value: function styleDisabled_(isDisabled) {
        var _MDCTextFieldFoundati = MDCTextFieldFoundation.cssClasses,
            DISABLED = _MDCTextFieldFoundati.DISABLED,
            INVALID = _MDCTextFieldFoundati.INVALID;

        if (isDisabled) {
          this.adapter_.addClass(DISABLED);
          this.adapter_.removeClass(INVALID);
        } else {
          this.adapter_.removeClass(DISABLED);
        }
        if (this.icon_) {
          this.icon_.setDisabled(isDisabled);
        }
      }

      /**
       * @return {!Element|!NativeInputType} The native text input from the
       * host environment, or a dummy if none exists.
       * @private
       */

    }, {
      key: 'getNativeInput_',
      value: function getNativeInput_() {
        return this.adapter_.getNativeInput() ||
        /** @type {!NativeInputType} */{
          value: '',
          disabled: false,
          validity: {
            badInput: false,
            valid: true
          }
        };
      }
    }]);
    return MDCTextFieldFoundation;
  }(MDCFoundation);

  //

  var script$X = {
    name: 'mdc-textfield',
    mixins: [CustomElementMixin, DispatchFocusMixin, VMAUniqueIdMixin],
    inheritAttrs: false,
    model: {
      prop: 'value',
      event: 'model'
    },
    props: {
      value: String,
      type: {
        type: String,
        default: 'text',
        validator: function validator(value) {
          return ['text', 'email', 'search', 'password', 'tel', 'url', 'number'].indexOf(value) !== -1;
        }
      },
      dense: Boolean,
      label: String,
      helptext: String,
      helptextPersistent: Boolean,
      helptextValidation: Boolean,
      box: Boolean,
      outline: Boolean,
      disabled: Boolean,
      required: Boolean,
      valid: { type: Boolean, default: undefined },
      fullwidth: Boolean,
      multiline: Boolean,
      leadingIcon: [String, Array, Object],
      trailingIcon: [String, Array, Object],
      size: { type: [Number, String], default: 20 },
      minlength: { type: [Number, String], default: undefined },
      maxlength: { type: [Number, String], default: undefined },
      rows: { type: [Number, String], default: 8 },
      cols: { type: [Number, String], default: 40 },
      id: { type: String }
    },
    data: function data() {
      return {
        text: this.value,
        rootClasses: {
          'mdc-textfield': true,
          'mdc-text-field': true,
          'mdc-text-field--upgraded': true,
          'mdc-text-field--disabled': this.disabled,
          'mdc-text-field--dense': this.dense,
          'mdc-text-field--fullwidth': this.fullwidth,
          'mdc-text-field--textarea': this.multiline,
          'mdc-text-field--box': !this.fullwidth && this.box,
          'mdc-text-field--outlined': !this.fullwidth && this.outline
        },
        inputClasses: {
          'mdc-text-field__input': true
        },
        labelClasses: {
          'mdc-floating-label': true
        },
        lineRippleClasses: {
          'mdc-line-ripple': true
        },
        lineRippleStyles: {},
        helpClasses: {
          'mdc-text-field-helper-text': true,
          'mdc-text-field-helper-text--persistent': this.helptextPersistent,
          'mdc-text-field-helper-text--validation-msg': this.helptextValidation
        },
        outlineClasses: {},
        outlinePathAttr: undefined
      };
    },
    computed: {
      inputPlaceHolder: function inputPlaceHolder() {
        return this.fullwidth ? this.label : undefined;
      },
      inputAriaControls: function inputAriaControls() {
        return this.help ? 'help-' + this.vma_uid_ : undefined;
      },
      hasLabel: function hasLabel() {
        return !this.fullwidth && this.label;
      },
      hasOutline: function hasOutline() {
        return !this.fullwidth && this.outline;
      },
      hasLineRipple: function hasLineRipple() {
        return !this.hasOutline && !this.multiline;
      },
      hasLeadingIcon: function hasLeadingIcon() {
        if ((this.leadingIcon || this.$slots['leading-icon']) && !(this.trailingIcon || this.$slots['trailing-icon'])) {
          return this.leadingIcon ? extractIconProp(this.leadingIcon) : {};
        }
        return false;
      },
      hasTrailingIcon: function hasTrailingIcon() {
        if (this.trailingIcon || this.$slots['trailing-icon']) {
          return this.trailingIcon ? extractIconProp(this.trailingIcon) : {};
        }
        return false;
      },
      labelClassesUpgraded: function labelClassesUpgraded() {
        return _extends(this.labelClasses, {
          'mdc-floating-label--float-above': this.value
        });
      }
    },
    watch: {
      disabled: function disabled() {
        this.foundation && this.foundation.setDisabled(this.disabled);
      },
      required: function required() {
        this.$refs.input && (this.$refs.input.required = this.required);
      },
      valid: function valid() {
        if (typeof this.valid !== 'undefined') {
          this.foundation && this.foundation.setValid(this.valid);
        }
      },
      dense: function dense() {
        this.$set(this.rootClasses, 'mdc-text-field--dense', this.dense);
      },
      helptextPersistent: function helptextPersistent() {
        this.helperTextFoundation && this.helperTextFoundation.setPersistent(this.helptextPersistent);
      },
      helptextValidation: function helptextValidation() {
        this.helperTextFoundation && this.helperTextFoundation.setValidation(this.helptextValidation);
      },
      value: function value(_value) {
        if (this.foundation) {
          if (_value !== this.foundation.getValue()) {
            this.foundation.setValue(_value);
          }
        }
      }
    },
    mounted: function mounted() {
      var _this = this;

      if (this.$refs.lineRipple) {
        this.lineRippleFoundation = new MDCLineRippleFoundation({
          addClass: function addClass(className) {
            _this.$set(_this.lineRippleClasses, className, true);
          },
          removeClass: function removeClass(className) {
            _this.$delete(_this.lineRippleClasses, className);
          },
          hasClass: function hasClass(className) {
            _this.$refs.lineRipple.classList.contains(className);
          },
          setStyle: function setStyle(name, value) {
            _this.$set(_this.lineRippleStyles, name, value);
          },
          registerEventHandler: function registerEventHandler(evtType, handler) {
            _this.$refs.lineRipple.addEventListener(evtType, handler);
          },
          deregisterEventHandler: function deregisterEventHandler(evtType, handler) {
            _this.$refs.lineRipple.removeEventListener(evtType, handler);
          }
        });
        this.lineRippleFoundation.init();
      }

      if (this.$refs.help) {
        this.helperTextFoundation = new MDCTextFieldHelperTextFoundation({
          addClass: function addClass(className) {
            _this.$set(_this.helpClasses, className, true);
          },
          removeClass: function removeClass(className) {
            _this.$delete(_this.helpClasses, className);
          },
          hasClass: function hasClass(className) {
            return _this.$refs.help.classList.contains(className);
          },
          setAttr: function setAttr(name, value) {
            _this.$refs.help.setAttribute(name, value);
          },
          removeAttr: function removeAttr(name) {
            _this.$refs.help.removeAttribute(name);
          },
          setContent: function setContent() /*content*/{
            // help text get's updated from {{helptext}}
            // this.$refs.help.textContent = content;
          }
        });
        this.helperTextFoundation.init();
      }

      if (this.$refs.icon) {
        if (this.hasLeadingIcon) {
          this.$set(this.rootClasses, 'mdc-text-field--with-leading-icon', true);
        } else if (this.hasTrailingIcon) {
          this.$set(this.rootClasses, 'mdc-text-field--with-trailing-icon', true);
        }

        this.iconFoundation = new MDCTextFieldIconFoundation({
          setAttr: function setAttr(attr, value) {
            return _this.$refs.icon.setAttribute(attr, value);
          },
          getAttr: function getAttr(attr) {
            return _this.$refs.icon.getAttribute(attr);
          },
          removeAttr: function removeAttr(attr) {
            return _this.$refs.icon.removeAttribute(attr);
          },
          setContent: function setContent() /*content*/{
            // icon text get's updated from {{{{ hasTrailingIcon.content }}}}
            // this.$refs.icon.textContent = content;
          },
          registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
            _this.$refs.icon.addEventListener(evtType, handler);
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
            _this.$refs.icon.removeEventListener(evtType, handler);
          },
          notifyIconAction: function notifyIconAction() {
            return _this.$emit('icon-action');
          }
        });
        this.iconFoundation.init();
      }

      if (this.$refs.label) {
        this.labelFoundation = new MDCFloatingLabelFoundation({
          addClass: function addClass(className) {
            _this.$set(_this.labelClasses, className, true);
          },
          removeClass: function removeClass(className) {
            _this.$delete(_this.labelClasses, className);
          },
          getWidth: function getWidth() {
            return _this.$refs.label.offsetWidth;
          },
          registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
            _this.$refs.label.addEventListener(evtType, handler);
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
            _this.$refs.label.removeEventListener(evtType, handler);
          }
        });
        this.labelFoundation.init();
      }

      if (this.$refs.outline) {
        this.outlineFoundation = new MDCNotchedOutlineFoundation({
          getWidth: function getWidth() {
            return _this.$refs.outline.offsetWidth;
          },
          getHeight: function getHeight() {
            return _this.$refs.outline.offsetHeight;
          },
          addClass: function addClass(className) {
            _this.$set(_this.outlineClasses, className, true);
          },
          removeClass: function removeClass(className) {
            _this.$delete(_this.outlineClasses, className);
          },
          setOutlinePathAttr: function setOutlinePathAttr(value) {
            _this.outlinePathAttr = value;
          },
          getIdleOutlineStyleValue: function getIdleOutlineStyleValue(propertyName) {
            var idleOutlineElement = _this.$refs.outlineIdle;
            if (idleOutlineElement) {
              return window.getComputedStyle(idleOutlineElement).getPropertyValue(propertyName);
            }
          }
        });
        this.outlineFoundation.init();
      }

      this.foundation = new MDCTextFieldFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.rootClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.rootClasses, className);
        },
        hasClass: function hasClass(className) {
          _this.$refs.root.classList.contains(className);
        },
        registerTextFieldInteractionHandler: function registerTextFieldInteractionHandler(evtType, handler) {
          _this.$refs.root.addEventListener(evtType, handler);
        },
        deregisterTextFieldInteractionHandler: function deregisterTextFieldInteractionHandler(evtType, handler) {
          _this.$refs.root.removeEventListener(evtType, handler);
        },
        isFocused: function isFocused() {
          return document.activeElement === _this.$refs.input;
        },
        isRtl: function isRtl() {
          return window.getComputedStyle(_this.$refs.root).getPropertyValue('direction') === 'rtl';
        },
        deactivateLineRipple: function deactivateLineRipple() {
          if (_this.lineRippleFoundation) {
            _this.lineRippleFoundation.deactivate();
          }
        },
        activateLineRipple: function activateLineRipple() {
          if (_this.lineRippleFoundation) {
            _this.lineRippleFoundation.activate();
          }
        },
        setLineRippleTransformOrigin: function setLineRippleTransformOrigin(normalizedX) {
          if (_this.lineRippleFoundation) {
            _this.lineRippleFoundation.setRippleCenter(normalizedX);
          }
        },
        registerInputInteractionHandler: function registerInputInteractionHandler(evtType, handler) {
          _this.$refs.input.addEventListener(evtType, handler, applyPassive());
        },
        deregisterInputInteractionHandler: function deregisterInputInteractionHandler(evtType, handler) {
          _this.$refs.input.removeEventListener(evtType, handler, applyPassive());
        },
        registerValidationAttributeChangeHandler: function registerValidationAttributeChangeHandler(handler) {
          var getAttributesList = function getAttributesList(mutationsList) {
            return mutationsList.map(function (mutation) {
              return mutation.attributeName;
            });
          };
          var observer = new MutationObserver(function (mutationsList) {
            return handler(getAttributesList(mutationsList));
          });
          var targetNode = _this.$refs.input;
          var config = { attributes: true };
          observer.observe(targetNode, config);
          return observer;
        },
        deregisterValidationAttributeChangeHandler: function deregisterValidationAttributeChangeHandler(observer) {
          observer.disconnect();
        },
        shakeLabel: function shakeLabel(shouldShake) {
          _this.labelFoundation.shake(shouldShake);
        },
        floatLabel: function floatLabel(shouldFloat) {
          _this.labelFoundation.float(shouldFloat);
        },
        hasLabel: function hasLabel() {
          return !!_this.$refs.label;
        },
        getLabelWidth: function getLabelWidth() {
          return _this.labelFoundation.getWidth();
        },
        getNativeInput: function getNativeInput() {
          return _this.$refs.input;
        },
        hasOutline: function hasOutline() {
          return !!_this.hasOutline;
        },
        notchOutline: function notchOutline(notchWidth, isRtl) {
          return _this.outlineFoundation.notch(notchWidth, isRtl);
        },
        closeOutline: function closeOutline() {
          return _this.outlineFoundation.closeNotch();
        }
      }, {
        helperText: this.helperTextFoundation,
        icon: this.iconFoundation
      });

      this.foundation.init();
      this.foundation.setValue(this.value);
      this.foundation.setDisabled(this.disabled);
      this.$refs.input && (this.$refs.input.required = this.required);
      if (typeof this.valid !== 'undefined') {
        this.foundation.setValid(this.valid);
      }

      if (this.textbox) {
        this.ripple = new RippleBase(this);
        this.ripple.init();
      }
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation && this.foundation.destroy();
      this.lineRippleFoundation && this.lineRippleFoundation.destroy();
      this.helperTextFoundation && this.helperTextFoundation.destroy();
      this.iconFoundation && this.iconFoundation.destroy();
      this.labelFoundation && this.labelFoundation.destroy();
      this.outlineFoundation && this.outlineFoundation.destroy();
      this.ripple && this.ripple.destroy();
    },

    methods: {
      updateValue: function updateValue(value) {
        this.$emit('model', value);
      },
      focus: function focus() {
        this.$refs.input && this.$refs.input.focus();
      },
      blur: function blur() {
        this.$refs.input && this.$refs.input.blur();
      }
    }
  };

  /* script */
  var __vue_script__$X = script$X;

  /* template */
  var __vue_render__$U = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", {
      staticClass: "mdc-textfield-wrapper",
      style: { width: _vm.fullwidth ? "100%" : undefined },
      attrs: { id: _vm.id }
    }, [_c("div", { ref: "root", class: _vm.rootClasses }, [!!_vm.hasLeadingIcon ? _c("i", {
      ref: "icon",
      staticClass: "mdc-text-field__icon",
      class: _vm.hasLeadingIcon.classes,
      attrs: { tabindex: "0" }
    }, [_vm._t("leading-icon", [_vm._v(_vm._s(_vm.hasLeadingIcon.content))])], 2) : _vm._e(), _vm._v(" "), _vm.multiline ? _c("textarea", _vm._g(_vm._b({
      ref: "input",
      class: _vm.inputClasses,
      attrs: {
        id: _vm.vma_uid_,
        minlength: _vm.minlength,
        maxlength: _vm.maxlength,
        placeholder: _vm.inputPlaceHolder,
        "aria-label": _vm.inputPlaceHolder,
        "aria-controls": _vm.inputAriaControls,
        rows: _vm.rows,
        cols: _vm.cols
      },
      on: {
        input: function input($event) {
          _vm.updateValue($event.target.value);
        }
      }
    }, "textarea", _vm.$attrs, false), _vm.$listeners)) : _c("input", _vm._g(_vm._b({
      ref: "input",
      class: _vm.inputClasses,
      attrs: {
        id: _vm.vma_uid_,
        type: _vm.type,
        minlength: _vm.minlength,
        maxlength: _vm.maxlength,
        placeholder: _vm.inputPlaceHolder,
        "aria-label": _vm.inputPlaceHolder,
        "aria-controls": _vm.inputAriaControls
      },
      on: {
        input: function input($event) {
          _vm.updateValue($event.target.value);
        }
      }
    }, "input", _vm.$attrs, false), _vm.$listeners)), _vm._v(" "), _vm.hasLabel ? _c("label", {
      ref: "label",
      class: _vm.labelClassesUpgraded,
      attrs: { for: _vm.vma_uid_ }
    }, [_vm._v("\n      " + _vm._s(_vm.label) + "\n    ")]) : _vm._e(), _vm._v(" "), !!_vm.hasTrailingIcon ? _c("i", {
      ref: "icon",
      staticClass: "mdc-text-field__icon",
      class: _vm.hasTrailingIcon.classes,
      attrs: { tabindex: "0" }
    }, [_vm._t("trailing-icon", [_vm._v(_vm._s(_vm.hasTrailingIcon.content))])], 2) : _vm._e(), _vm._v(" "), _vm.hasOutline ? _c("div", {
      ref: "outline",
      staticClass: "mdc-notched-outline",
      class: _vm.outlineClasses
    }, [_c("svg", [_c("path", {
      staticClass: "mdc-notched-outline__path",
      attrs: { d: _vm.outlinePathAttr }
    })])]) : _vm._e(), _vm._v(" "), _vm.hasOutline ? _c("div", {
      ref: "outlineIdle",
      staticClass: "mdc-notched-outline__idle"
    }) : _vm._e(), _vm._v(" "), _vm.hasLineRipple ? _c("div", {
      ref: "lineRipple",
      class: _vm.lineRippleClasses,
      style: _vm.lineRippleStyles
    }) : _vm._e()]), _vm._v(" "), _vm.helptext ? _c("p", {
      ref: "help",
      class: _vm.helpClasses,
      attrs: { id: "help-" + _vm.vma_uid_, "aria-hidden": "true" }
    }, [_vm._v("\n    " + _vm._s(_vm.helptext) + "\n  ")]) : _vm._e()]);
  };
  var __vue_staticRenderFns__$U = [];
  __vue_render__$U._withStripped = true;

  /* style */
  var __vue_inject_styles__$X = undefined;
  /* scoped */
  var __vue_scope_id__$X = undefined;
  /* module identifier */
  var __vue_module_identifier__$X = undefined;
  /* functional template */
  var __vue_is_functional_template__$X = false;
  /* component normalizer */
  function __vue_normalize__$X(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/textfield/mdc-textfield.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$X() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$X.styles || (__vue_create_injector__$X.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcTextField = __vue_normalize__$X({ render: __vue_render__$U, staticRenderFns: __vue_staticRenderFns__$U }, __vue_inject_styles__$X, __vue_script__$X, __vue_scope_id__$X, __vue_is_functional_template__$X, __vue_module_identifier__$X, __vue_create_injector__$X, undefined);

  var VueMDCTextfield = BasePlugin({
    mdcTextField: mdcTextField
  });

  //

  var THEME_COLORS = ['primary', 'secondary', 'background', 'primary-light', 'secondary-light', 'secondary-dark', 'primary-dark'];

  var THEME_STYLES = ['text-primary', 'text-secondary', 'text-hint', 'text-icon', 'text-disabled'];

  var script$Y = {
    name: 'mdc-theme',
    components: {
      CustomElement: CustomElement
    },
    props: {
      tag: { type: String, default: 'div' },
      color: String,
      background: String
    },
    computed: {
      classes: function classes() {
        var classes = {};

        if (this.color && THEME_COLORS.indexOf(this.color) !== -1) {
          classes['mdc-theme--' + this.color] = true;
        }

        if (this.background && THEME_COLORS.indexOf(this.background) !== -1) {
          classes['mdc-theme--' + this.background + '-bg'] = true;

          if (this.color && THEME_STYLES.indexOf(this.color) !== -1) {
            classes['mdc-theme--' + this.color + '-on-' + this.background] = true;
          }
        }
        return classes;
      }
    }
  };

  /* script */
  var __vue_script__$Y = script$Y;

  /* template */
  var __vue_render__$V = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("custom-element", { staticClass: "mdc-theme", class: _vm.classes, attrs: { tag: _vm.tag } }, [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$V = [];
  __vue_render__$V._withStripped = true;

  /* style */
  var __vue_inject_styles__$Y = undefined;
  /* scoped */
  var __vue_scope_id__$Y = undefined;
  /* module identifier */
  var __vue_module_identifier__$Y = undefined;
  /* functional template */
  var __vue_is_functional_template__$Y = false;
  /* component normalizer */
  function __vue_normalize__$Y(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/theme/mdc-theme.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$Y() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$Y.styles || (__vue_create_injector__$Y.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcTheme = __vue_normalize__$Y({ render: __vue_render__$V, staticRenderFns: __vue_staticRenderFns__$V }, __vue_inject_styles__$Y, __vue_script__$Y, __vue_scope_id__$Y, __vue_is_functional_template__$Y, __vue_module_identifier__$Y, __vue_create_injector__$Y, undefined);

  var VueMDCTheme = BasePlugin({
    mdcTheme: mdcTheme
  });

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$o = {
    FIXED: 'mdc-toolbar--fixed',
    FIXED_LASTROW: 'mdc-toolbar--fixed-lastrow-only',
    FIXED_AT_LAST_ROW: 'mdc-toolbar--fixed-at-last-row',
    TOOLBAR_ROW_FLEXIBLE: 'mdc-toolbar--flexible',
    FLEXIBLE_DEFAULT_BEHAVIOR: 'mdc-toolbar--flexible-default-behavior',
    FLEXIBLE_MAX: 'mdc-toolbar--flexible-space-maximized',
    FLEXIBLE_MIN: 'mdc-toolbar--flexible-space-minimized'
  };

  var strings$o = {
    TITLE_SELECTOR: '.mdc-toolbar__title',
    ICON_SELECTOR: '.mdc-toolbar__icon',
    FIRST_ROW_SELECTOR: '.mdc-toolbar__row:first-child',
    CHANGE_EVENT: 'MDCToolbar:change'
  };

  var numbers$9 = {
    MAX_TITLE_SIZE: 2.125,
    MIN_TITLE_SIZE: 1.25,
    TOOLBAR_ROW_HEIGHT: 64,
    TOOLBAR_ROW_MOBILE_HEIGHT: 56,
    TOOLBAR_MOBILE_BREAKPOINT: 600
  };

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCToolbarFoundation = function (_MDCFoundation) {
    inherits(MDCToolbarFoundation, _MDCFoundation);
    createClass(MDCToolbarFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$o;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$o;
      }
    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers$9;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          hasClass: function hasClass() {
            return (/* className: string */ /* boolean */false
            );
          },
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          registerScrollHandler: function registerScrollHandler() /* handler: EventListener */{},
          deregisterScrollHandler: function deregisterScrollHandler() /* handler: EventListener */{},
          registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
          deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
          getViewportWidth: function getViewportWidth() {
            return (/* number */0
            );
          },
          getViewportScrollY: function getViewportScrollY() {
            return (/* number */0
            );
          },
          getOffsetHeight: function getOffsetHeight() {
            return (/* number */0
            );
          },
          getFirstRowElementOffsetHeight: function getFirstRowElementOffsetHeight() {
            return (/* number */0
            );
          },
          notifyChange: function notifyChange() /* evtData: {flexibleExpansionRatio: number} */{},
          setStyle: function setStyle() /* property: string, value: string */{},
          setStyleForTitleElement: function setStyleForTitleElement() /* property: string, value: string */{},
          setStyleForFlexibleRowElement: function setStyleForFlexibleRowElement() /* property: string, value: string */{},
          setStyleForFixedAdjustElement: function setStyleForFixedAdjustElement() /* property: string, value: string */{}
        };
      }
    }]);

    function MDCToolbarFoundation(adapter) {
      classCallCheck(this, MDCToolbarFoundation);

      var _this = possibleConstructorReturn(this, (MDCToolbarFoundation.__proto__ || Object.getPrototypeOf(MDCToolbarFoundation)).call(this, _extends(MDCToolbarFoundation.defaultAdapter, adapter)));

      _this.resizeHandler_ = function () {
        return _this.checkRowHeight_();
      };
      _this.scrollHandler_ = function () {
        return _this.updateToolbarStyles_();
      };
      _this.checkRowHeightFrame_ = 0;
      _this.scrollFrame_ = 0;
      _this.executedLastChange_ = false;

      _this.calculations_ = {
        toolbarRowHeight: 0,
        // Calculated Height ratio. We use ratio to calculate corresponding heights in resize event.
        toolbarRatio: 0, // The ratio of toolbar height to row height
        flexibleExpansionRatio: 0, // The ratio of flexible space height to row height
        maxTranslateYRatio: 0, // The ratio of max toolbar move up distance to row height
        scrollThresholdRatio: 0, // The ratio of max scrollTop that we should listen to to row height
        // Derived Heights based on the above key ratios.
        toolbarHeight: 0,
        flexibleExpansionHeight: 0, // Flexible row minus toolbar height (derived)
        maxTranslateYDistance: 0, // When toolbar only fix last row (derived)
        scrollThreshold: 0
      };
      // Toolbar fixed behavior
      // If toolbar is fixed
      _this.fixed_ = false;
      // If fixed is targeted only at the last row
      _this.fixedLastrow_ = false;
      // Toolbar flexible behavior
      // If the first row is flexible
      _this.hasFlexibleRow_ = false;
      // If use the default behavior
      _this.useFlexDefaultBehavior_ = false;
      return _this;
    }

    createClass(MDCToolbarFoundation, [{
      key: 'init',
      value: function init() {
        this.fixed_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.FIXED);
        this.fixedLastrow_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.FIXED_LASTROW) & this.fixed_;
        this.hasFlexibleRow_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.TOOLBAR_ROW_FLEXIBLE);
        if (this.hasFlexibleRow_) {
          this.useFlexDefaultBehavior_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_DEFAULT_BEHAVIOR);
        }
        this.initKeyRatio_();
        this.setKeyHeights_();
        this.adapter_.registerResizeHandler(this.resizeHandler_);
        this.adapter_.registerScrollHandler(this.scrollHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterResizeHandler(this.resizeHandler_);
        this.adapter_.deregisterScrollHandler(this.scrollHandler_);
      }
    }, {
      key: 'updateAdjustElementStyles',
      value: function updateAdjustElementStyles() {
        if (this.fixed_) {
          this.adapter_.setStyleForFixedAdjustElement('margin-top', this.calculations_.toolbarHeight + 'px');
        }
      }
    }, {
      key: 'getFlexibleExpansionRatio_',
      value: function getFlexibleExpansionRatio_(scrollTop) {
        // To prevent division by zero when there is no flexibleExpansionHeight
        var delta = 0.0001;
        return Math.max(0, 1 - scrollTop / (this.calculations_.flexibleExpansionHeight + delta));
      }
    }, {
      key: 'checkRowHeight_',
      value: function checkRowHeight_() {
        var _this2 = this;

        cancelAnimationFrame(this.checkRowHeightFrame_);
        this.checkRowHeightFrame_ = requestAnimationFrame(function () {
          return _this2.setKeyHeights_();
        });
      }
    }, {
      key: 'setKeyHeights_',
      value: function setKeyHeights_() {
        var newToolbarRowHeight = this.getRowHeight_();
        if (newToolbarRowHeight !== this.calculations_.toolbarRowHeight) {
          this.calculations_.toolbarRowHeight = newToolbarRowHeight;
          this.calculations_.toolbarHeight = this.calculations_.toolbarRatio * this.calculations_.toolbarRowHeight;
          this.calculations_.flexibleExpansionHeight = this.calculations_.flexibleExpansionRatio * this.calculations_.toolbarRowHeight;
          this.calculations_.maxTranslateYDistance = this.calculations_.maxTranslateYRatio * this.calculations_.toolbarRowHeight;
          this.calculations_.scrollThreshold = this.calculations_.scrollThresholdRatio * this.calculations_.toolbarRowHeight;
          this.updateAdjustElementStyles();
          this.updateToolbarStyles_();
        }
      }
    }, {
      key: 'updateToolbarStyles_',
      value: function updateToolbarStyles_() {
        var _this3 = this;

        cancelAnimationFrame(this.scrollFrame_);
        this.scrollFrame_ = requestAnimationFrame(function () {
          var scrollTop = _this3.adapter_.getViewportScrollY();
          var hasScrolledOutOfThreshold = _this3.scrolledOutOfThreshold_(scrollTop);

          if (hasScrolledOutOfThreshold && _this3.executedLastChange_) {
            return;
          }

          var flexibleExpansionRatio = _this3.getFlexibleExpansionRatio_(scrollTop);

          _this3.updateToolbarFlexibleState_(flexibleExpansionRatio);
          if (_this3.fixedLastrow_) {
            _this3.updateToolbarFixedState_(scrollTop);
          }
          if (_this3.hasFlexibleRow_) {
            _this3.updateFlexibleRowElementStyles_(flexibleExpansionRatio);
          }
          _this3.executedLastChange_ = hasScrolledOutOfThreshold;
          _this3.adapter_.notifyChange({ flexibleExpansionRatio: flexibleExpansionRatio });
        });
      }
    }, {
      key: 'scrolledOutOfThreshold_',
      value: function scrolledOutOfThreshold_(scrollTop) {
        return scrollTop > this.calculations_.scrollThreshold;
      }
    }, {
      key: 'initKeyRatio_',
      value: function initKeyRatio_() {
        var toolbarRowHeight = this.getRowHeight_();
        var firstRowMaxRatio = this.adapter_.getFirstRowElementOffsetHeight() / toolbarRowHeight;
        this.calculations_.toolbarRatio = this.adapter_.getOffsetHeight() / toolbarRowHeight;
        this.calculations_.flexibleExpansionRatio = firstRowMaxRatio - 1;
        this.calculations_.maxTranslateYRatio = this.fixedLastrow_ ? this.calculations_.toolbarRatio - firstRowMaxRatio : 0;
        this.calculations_.scrollThresholdRatio = (this.fixedLastrow_ ? this.calculations_.toolbarRatio : firstRowMaxRatio) - 1;
      }
    }, {
      key: 'getRowHeight_',
      value: function getRowHeight_() {
        var breakpoint = MDCToolbarFoundation.numbers.TOOLBAR_MOBILE_BREAKPOINT;
        return this.adapter_.getViewportWidth() < breakpoint ? MDCToolbarFoundation.numbers.TOOLBAR_ROW_MOBILE_HEIGHT : MDCToolbarFoundation.numbers.TOOLBAR_ROW_HEIGHT;
      }
    }, {
      key: 'updateToolbarFlexibleState_',
      value: function updateToolbarFlexibleState_(flexibleExpansionRatio) {
        this.adapter_.removeClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MAX);
        this.adapter_.removeClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MIN);
        if (flexibleExpansionRatio === 1) {
          this.adapter_.addClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MAX);
        } else if (flexibleExpansionRatio === 0) {
          this.adapter_.addClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MIN);
        }
      }
    }, {
      key: 'updateToolbarFixedState_',
      value: function updateToolbarFixedState_(scrollTop) {
        var translateDistance = Math.max(0, Math.min(scrollTop - this.calculations_.flexibleExpansionHeight, this.calculations_.maxTranslateYDistance));
        this.adapter_.setStyle('transform', 'translateY(' + -translateDistance + 'px)');

        if (translateDistance === this.calculations_.maxTranslateYDistance) {
          this.adapter_.addClass(MDCToolbarFoundation.cssClasses.FIXED_AT_LAST_ROW);
        } else {
          this.adapter_.removeClass(MDCToolbarFoundation.cssClasses.FIXED_AT_LAST_ROW);
        }
      }
    }, {
      key: 'updateFlexibleRowElementStyles_',
      value: function updateFlexibleRowElementStyles_(flexibleExpansionRatio) {
        if (this.fixed_) {
          var height = this.calculations_.flexibleExpansionHeight * flexibleExpansionRatio;
          this.adapter_.setStyleForFlexibleRowElement('height', height + this.calculations_.toolbarRowHeight + 'px');
        }
        if (this.useFlexDefaultBehavior_) {
          this.updateElementStylesDefaultBehavior_(flexibleExpansionRatio);
        }
      }
    }, {
      key: 'updateElementStylesDefaultBehavior_',
      value: function updateElementStylesDefaultBehavior_(flexibleExpansionRatio) {
        var maxTitleSize = MDCToolbarFoundation.numbers.MAX_TITLE_SIZE;
        var minTitleSize = MDCToolbarFoundation.numbers.MIN_TITLE_SIZE;
        var currentTitleSize = (maxTitleSize - minTitleSize) * flexibleExpansionRatio + minTitleSize;

        this.adapter_.setStyleForTitleElement('font-size', currentTitleSize + 'rem');
      }
    }]);
    return MDCToolbarFoundation;
  }(MDCFoundation);

  //

  var script$Z = {
    name: 'mdc-toolbar',
    props: {
      fixed: Boolean,
      waterfall: Boolean,
      'fixed-lastrow': Boolean,
      flexible: Boolean,
      'flexible-default': { type: Boolean, default: true }
    },
    data: function data() {
      return {
        rootClasses: {
          'mdc-toolbar': true,
          'mdc-toolbar--fixed': this.fixed || this.waterfall || this.fixedLastrow,
          'mdc-toolbar--waterfall': this.waterfall,
          'mdc-toolbar--fixed-lastrow-only': this.fixedLastrow,
          'mdc-toolbar--flexible': this.flexible,
          'mdc-toolbar--flexible-default-behavior': this.flexible && this.flexibleDefault
        },
        rootStyles: {},
        adjustStyles: {
          // to avoid top margin collapse with :after el
          // 0.1 px should be rounded to 0px
          // TODO: find a better trick
          // height: '0.1px'
        },
        foundation: null
      };
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCToolbarFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.rootClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.rootClasses, className);
        },
        hasClass: function hasClass(className) {
          return _this.$refs.root.classList.contains(className);
        },
        registerScrollHandler: function registerScrollHandler(handler) {
          window.addEventListener('scroll', handler);
        },
        deregisterScrollHandler: function deregisterScrollHandler(handler) {
          window.removeEventListener('scroll', handler);
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          window.removeEventListener('resize', handler);
        },
        getViewportWidth: function getViewportWidth() {
          return window.innerWidth;
        },
        getViewportScrollY: function getViewportScrollY() {
          return window.pageYOffset;
        },
        getOffsetHeight: function getOffsetHeight() {
          return _this.$refs.root.offsetHeight;
        },
        getFirstRowElementOffsetHeight: function getFirstRowElementOffsetHeight() {
          var el = _this.$refs.root.querySelector(MDCToolbarFoundation.strings.FIRST_ROW_SELECTOR);
          return el ? el.offsetHeight : undefined;
        },
        notifyChange: function notifyChange(evtData) {
          _this.$emit('change', evtData);
        },
        setStyle: function setStyle(property, value) {
          _this.$set(_this.rootStyles, property, value);
        },
        setStyleForTitleElement: function setStyleForTitleElement(property, value) {
          var el = _this.$refs.root.querySelector(MDCToolbarFoundation.strings.TITLE_SELECTOR);
          if (el) el.style.setProperty(property, value);
        },
        setStyleForFlexibleRowElement: function setStyleForFlexibleRowElement(property, value) {
          var el = _this.$refs.root.querySelector(MDCToolbarFoundation.strings.FIRST_ROW_SELECTOR);
          if (el) el.style.setProperty(property, value);
        },
        setStyleForFixedAdjustElement: function setStyleForFixedAdjustElement(property, value) {
          _this.$set(_this.adjustStyles, property, value);
        }
      });
      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    }
  };

  /* script */
  var __vue_script__$Z = script$Z;

  /* template */
  var __vue_render__$W = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("header", { staticClass: "mdc-toolbar-wrapper" }, [_c("div", { ref: "root", class: _vm.rootClasses, style: _vm.rootStyles }, [_vm._t("default")], 2), _vm._v(" "), _vm.fixed || _vm.waterfall || _vm.fixedLastrow ? _c("div", {
      ref: "fixed-adjust",
      staticClass: "mdc-toolbar-fixed-adjust",
      style: _vm.adjustStyles
    }) : _vm._e()]);
  };
  var __vue_staticRenderFns__$W = [];
  __vue_render__$W._withStripped = true;

  /* style */
  var __vue_inject_styles__$Z = undefined;
  /* scoped */
  var __vue_scope_id__$Z = undefined;
  /* module identifier */
  var __vue_module_identifier__$Z = undefined;
  /* functional template */
  var __vue_is_functional_template__$Z = false;
  /* component normalizer */
  function __vue_normalize__$Z(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/toolbar/mdc-toolbar.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$Z() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$Z.styles || (__vue_create_injector__$Z.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcToolbar = __vue_normalize__$Z({ render: __vue_render__$W, staticRenderFns: __vue_staticRenderFns__$W }, __vue_inject_styles__$Z, __vue_script__$Z, __vue_scope_id__$Z, __vue_is_functional_template__$Z, __vue_module_identifier__$Z, __vue_create_injector__$Z, undefined);

  //
  //
  //
  //
  //
  //

  var script$_ = {
    name: 'mdc-toolbar-row'
  };

  /* script */
  var __vue_script__$_ = script$_;

  /* template */
  var __vue_render__$X = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { staticClass: "mdc-toolbar-row mdc-toolbar__row" }, [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$X = [];
  __vue_render__$X._withStripped = true;

  /* style */
  var __vue_inject_styles__$_ = undefined;
  /* scoped */
  var __vue_scope_id__$_ = undefined;
  /* module identifier */
  var __vue_module_identifier__$_ = undefined;
  /* functional template */
  var __vue_is_functional_template__$_ = false;
  /* component normalizer */
  function __vue_normalize__$_(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/toolbar/mdc-toolbar-row.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$_() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$_.styles || (__vue_create_injector__$_.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcToolbarRow = __vue_normalize__$_({ render: __vue_render__$X, staticRenderFns: __vue_staticRenderFns__$X }, __vue_inject_styles__$_, __vue_script__$_, __vue_scope_id__$_, __vue_is_functional_template__$_, __vue_module_identifier__$_, __vue_create_injector__$_, undefined);

  //
  //
  //
  //
  //
  //
  //
  //

  var script$10 = {
    name: 'mdc-toolbar-section',
    props: {
      'align-start': Boolean,
      'align-end': Boolean,
      'shrink-to-fit': Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-toolbar__section--align-start': this.alignStart,
          'mdc-toolbar__section--align-end': this.alignEnd,
          'mdc-toolbar__section--shrink-to-fit': this.shrinkToFit
        }
      };
    }
  };

  /* script */
  var __vue_script__$10 = script$10;

  /* template */
  var __vue_render__$Y = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("section", {
      staticClass: "mdc-toolbar-section mdc-toolbar__section",
      class: _vm.classes
    }, [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$Y = [];
  __vue_render__$Y._withStripped = true;

  /* style */
  var __vue_inject_styles__$10 = undefined;
  /* scoped */
  var __vue_scope_id__$10 = undefined;
  /* module identifier */
  var __vue_module_identifier__$10 = undefined;
  /* functional template */
  var __vue_is_functional_template__$10 = false;
  /* component normalizer */
  function __vue_normalize__$10(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/toolbar/mdc-toolbar-section.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$10() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$10.styles || (__vue_create_injector__$10.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcToolbarSection = __vue_normalize__$10({ render: __vue_render__$Y, staticRenderFns: __vue_staticRenderFns__$Y }, __vue_inject_styles__$10, __vue_script__$10, __vue_scope_id__$10, __vue_is_functional_template__$10, __vue_module_identifier__$10, __vue_create_injector__$10, undefined);

  //

  var script$11 = {
    name: 'mdc-toolbar-menu-icon',
    mixins: [DispatchEventMixin],
    props: {
      icon: { type: String, default: 'menu' }
    }
  };

  /* script */
  var __vue_script__$11 = script$11;

  /* template */
  var __vue_render__$Z = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("a", _vm._g({
      staticClass: "mdc-toolbar-menu-icon mdc-toolbar__menu-icon",
      class: { "material-icons": !!_vm.icon }
    }, _vm.listeners), [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2);
  };
  var __vue_staticRenderFns__$Z = [];
  __vue_render__$Z._withStripped = true;

  /* style */
  var __vue_inject_styles__$11 = undefined;
  /* scoped */
  var __vue_scope_id__$11 = undefined;
  /* module identifier */
  var __vue_module_identifier__$11 = undefined;
  /* functional template */
  var __vue_is_functional_template__$11 = false;
  /* component normalizer */
  function __vue_normalize__$11(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/toolbar/mdc-toolbar-menu-icon.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$11() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$11.styles || (__vue_create_injector__$11.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcToolbarMenuIcon = __vue_normalize__$11({ render: __vue_render__$Z, staticRenderFns: __vue_staticRenderFns__$Z }, __vue_inject_styles__$11, __vue_script__$11, __vue_scope_id__$11, __vue_is_functional_template__$11, __vue_module_identifier__$11, __vue_create_injector__$11, undefined);

  //

  var script$12 = {
    name: 'mdc-toolbar-title',
    mixins: [DispatchEventMixin]
  };

  /* script */
  var __vue_script__$12 = script$12;

  /* template */
  var __vue_render__$_ = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("a", _vm._g({ staticClass: "mdc-toolbar-title mdc-toolbar__title" }, _vm.listeners), [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$_ = [];
  __vue_render__$_._withStripped = true;

  /* style */
  var __vue_inject_styles__$12 = undefined;
  /* scoped */
  var __vue_scope_id__$12 = undefined;
  /* module identifier */
  var __vue_module_identifier__$12 = undefined;
  /* functional template */
  var __vue_is_functional_template__$12 = false;
  /* component normalizer */
  function __vue_normalize__$12(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/toolbar/mdc-toolbar-title.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$12() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$12.styles || (__vue_create_injector__$12.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcToolbarTitle = __vue_normalize__$12({ render: __vue_render__$_, staticRenderFns: __vue_staticRenderFns__$_ }, __vue_inject_styles__$12, __vue_script__$12, __vue_scope_id__$12, __vue_is_functional_template__$12, __vue_module_identifier__$12, __vue_create_injector__$12, undefined);

  //

  var script$13 = {
    name: 'mdc-toolbar-icon',
    mixins: [DispatchEventMixin],
    props: {
      icon: String
    }
  };

  /* script */
  var __vue_script__$13 = script$13;

  /* template */
  var __vue_render__$10 = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("a", _vm._g({
      staticClass: "mdc-toolbar-icon mdc-toolbar__icon",
      class: { "material-icons": !!_vm.icon }
    }, _vm.listeners), [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2);
  };
  var __vue_staticRenderFns__$10 = [];
  __vue_render__$10._withStripped = true;

  /* style */
  var __vue_inject_styles__$13 = undefined;
  /* scoped */
  var __vue_scope_id__$13 = undefined;
  /* module identifier */
  var __vue_module_identifier__$13 = undefined;
  /* functional template */
  var __vue_is_functional_template__$13 = false;
  /* component normalizer */
  function __vue_normalize__$13(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/toolbar/mdc-toolbar-icon.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$13() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$13.styles || (__vue_create_injector__$13.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcToolbarIcon = __vue_normalize__$13({ render: __vue_render__$10, staticRenderFns: __vue_staticRenderFns__$10 }, __vue_inject_styles__$13, __vue_script__$13, __vue_scope_id__$13, __vue_is_functional_template__$13, __vue_module_identifier__$13, __vue_create_injector__$13, undefined);

  var VueMDCToolbar = BasePlugin({
    mdcToolbar: mdcToolbar,
    mdcToolbarRow: mdcToolbarRow,
    mdcToolbarSection: mdcToolbarSection,
    mdcToolbarMenuIcon: mdcToolbarMenuIcon,
    mdcToolbarTitle: mdcToolbarTitle,
    mdcToolbarIcon: mdcToolbarIcon
  });

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$p = {
    FIXED_CLASS: 'mdc-top-app-bar--fixed',
    FIXED_SCROLLED_CLASS: 'mdc-top-app-bar--fixed-scrolled',
    SHORT_CLASS: 'mdc-top-app-bar--short',
    SHORT_HAS_ACTION_ITEM_CLASS: 'mdc-top-app-bar--short-has-action-item',
    SHORT_COLLAPSED_CLASS: 'mdc-top-app-bar--short-collapsed'
  };

  /** @enum {number} */
  var numbers$a = {
    DEBOUNCE_THROTTLE_RESIZE_TIME_MS: 100,
    MAX_TOP_APP_BAR_HEIGHT: 128
  };

  /** @enum {string} */
  var strings$p = {
    ACTION_ITEM_SELECTOR: '.mdc-top-app-bar__action-item',
    NAVIGATION_EVENT: 'MDCTopAppBar:nav',
    NAVIGATION_ICON_SELECTOR: '.mdc-top-app-bar__navigation-icon',
    ROOT_SELECTOR: '.mdc-top-app-bar',
    TITLE_SELECTOR: '.mdc-top-app-bar__title'
  };

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Top App Bar
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Top App Bar into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCTopAppBarAdapter = function () {
    function MDCTopAppBarAdapter() {
      classCallCheck(this, MDCTopAppBarAdapter);
    }

    createClass(MDCTopAppBarAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the root Element.
       * @param {string} className
       */
      value: function addClass(className) {}

      /**
       * Removes a class from the root Element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * Returns true if the root Element contains the given class.
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}

      /**
       * Sets the specified inline style property on the root Element to the given value.
       * @param {string} property
       * @param {string} value
       */

    }, {
      key: "setStyle",
      value: function setStyle(property, value) {}

      /**
       * Gets the height of the top app bar.
       * @return {number}
       */

    }, {
      key: "getTopAppBarHeight",
      value: function getTopAppBarHeight() {}

      /**
       * Registers an event handler on the navigation icon element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerNavigationIconInteractionHandler",
      value: function registerNavigationIconInteractionHandler(type, handler) {}

      /**
       * Deregisters an event handler on the navigation icon element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterNavigationIconInteractionHandler",
      value: function deregisterNavigationIconInteractionHandler(type, handler) {}

      /**
       * Emits an event when the navigation icon is clicked.
       */

    }, {
      key: "notifyNavigationIconClicked",
      value: function notifyNavigationIconClicked() {}

      /** @param {function(!Event)} handler */

    }, {
      key: "registerScrollHandler",
      value: function registerScrollHandler(handler) {}

      /** @param {function(!Event)} handler */

    }, {
      key: "deregisterScrollHandler",
      value: function deregisterScrollHandler(handler) {}

      /** @param {function(!Event)} handler */

    }, {
      key: "registerResizeHandler",
      value: function registerResizeHandler(handler) {}

      /** @param {function(!Event)} handler */

    }, {
      key: "deregisterResizeHandler",
      value: function deregisterResizeHandler(handler) {}

      /** @return {number} */

    }, {
      key: "getViewportScrollY",
      value: function getViewportScrollY() {}

      /** @return {number} */

    }, {
      key: "getTotalActionItems",
      value: function getTotalActionItems() {}
    }]);
    return MDCTopAppBarAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCTopAppBarAdapter>}
   */

  var MDCTopAppBarBaseFoundation = function (_MDCFoundation) {
    inherits(MDCTopAppBarBaseFoundation, _MDCFoundation);
    createClass(MDCTopAppBarBaseFoundation, null, [{
      key: 'strings',

      /** @return enum {string} */
      get: function get$$1() {
        return strings$p;
      }

      /** @return enum {string} */

    }, {
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$p;
      }

      /** @return enum {number} */

    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers$a;
      }

      /**
       * {@see MDCTopAppBarAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCTopAppBarAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCTopAppBarAdapter} */{
            hasClass: function hasClass() /* className: string */{},
            addClass: function addClass() /* className: string */{},
            removeClass: function removeClass() /* className: string */{},
            setStyle: function setStyle() /* property: string, value: string */{},
            getTopAppBarHeight: function getTopAppBarHeight() {},
            registerNavigationIconInteractionHandler: function registerNavigationIconInteractionHandler() /* type: string, handler: EventListener */{},
            deregisterNavigationIconInteractionHandler: function deregisterNavigationIconInteractionHandler() /* type: string, handler: EventListener */{},
            notifyNavigationIconClicked: function notifyNavigationIconClicked() {},
            registerScrollHandler: function registerScrollHandler() /* handler: EventListener */{},
            deregisterScrollHandler: function deregisterScrollHandler() /* handler: EventListener */{},
            registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
            deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
            getViewportScrollY: function getViewportScrollY() {
              return (/* number */0
              );
            },
            getTotalActionItems: function getTotalActionItems() {
              return (/* number */0
              );
            }
          }
        );
      }

      /**
       * @param {!MDCTopAppBarAdapter} adapter
       */

    }]);

    function MDCTopAppBarBaseFoundation( /** @type {!MDCTopAppBarAdapter} */adapter) {
      classCallCheck(this, MDCTopAppBarBaseFoundation);

      var _this = possibleConstructorReturn(this, (MDCTopAppBarBaseFoundation.__proto__ || Object.getPrototypeOf(MDCTopAppBarBaseFoundation)).call(this, _extends(MDCTopAppBarBaseFoundation.defaultAdapter, adapter)));

      _this.navClickHandler_ = function () {
        return _this.adapter_.notifyNavigationIconClicked();
      };
      return _this;
    }

    createClass(MDCTopAppBarBaseFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerNavigationIconInteractionHandler('click', this.navClickHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterNavigationIconInteractionHandler('click', this.navClickHandler_);
      }
    }]);
    return MDCTopAppBarBaseFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCTopAppBarBaseFoundation<!MDCShortTopAppBarFoundation>}
   * @final
   */

  var MDCShortTopAppBarFoundation = function (_MDCTopAppBarBaseFoun) {
    inherits(MDCShortTopAppBarFoundation, _MDCTopAppBarBaseFoun);

    /**
     * @param {!MDCTopAppBarAdapter} adapter
     */
    function MDCShortTopAppBarFoundation(adapter) {
      classCallCheck(this, MDCShortTopAppBarFoundation);

      // State variable for the current top app bar state
      var _this = possibleConstructorReturn(this, (MDCShortTopAppBarFoundation.__proto__ || Object.getPrototypeOf(MDCShortTopAppBarFoundation)).call(this, adapter));

      _this.isCollapsed = false;

      _this.scrollHandler_ = function () {
        return _this.shortAppBarScrollHandler_();
      };
      return _this;
    }

    createClass(MDCShortTopAppBarFoundation, [{
      key: 'init',
      value: function init() {
        get(MDCShortTopAppBarFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCShortTopAppBarFoundation.prototype), 'init', this).call(this);
        var isAlwaysCollapsed = this.adapter_.hasClass(cssClasses$p.SHORT_COLLAPSED_CLASS);

        if (this.adapter_.getTotalActionItems() > 0) {
          this.adapter_.addClass(cssClasses$p.SHORT_HAS_ACTION_ITEM_CLASS);
        }

        if (!isAlwaysCollapsed) {
          this.adapter_.registerScrollHandler(this.scrollHandler_);
          this.shortAppBarScrollHandler_();
        }
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        get(MDCShortTopAppBarFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCShortTopAppBarFoundation.prototype), 'destroy', this).call(this);
        this.adapter_.deregisterScrollHandler(this.scrollHandler_);
      }

      /**
       * Scroll handler for applying/removing the collapsed modifier class
       * on the short top app bar.
       * @private
       */

    }, {
      key: 'shortAppBarScrollHandler_',
      value: function shortAppBarScrollHandler_() {
        var currentScroll = this.adapter_.getViewportScrollY();

        if (currentScroll <= 0) {
          if (this.isCollapsed) {
            this.adapter_.removeClass(cssClasses$p.SHORT_COLLAPSED_CLASS);
            this.isCollapsed = false;
          }
        } else {
          if (!this.isCollapsed) {
            this.adapter_.addClass(cssClasses$p.SHORT_COLLAPSED_CLASS);
            this.isCollapsed = true;
          }
        }
      }
    }]);
    return MDCShortTopAppBarFoundation;
  }(MDCTopAppBarBaseFoundation);

  //

  var script$14 = {
    name: 'mdc-top-app-bar',
    mixins: [DispatchEventMixin],
    props: {
      short: Boolean,
      shortCollapsed: Boolean,
      prominent: Boolean,
      fixed: Boolean,
      title: String,
      icon: {
        type: String,
        default: 'menu'
      },
      iconClasses: Object,
      dense: Boolean
    },
    data: function data() {
      return {
        rootStyles: {},
        rootClasses: {
          'mdc-top-app-bar': true,
          'mdc-top-app-bar--dense': this.dense,
          'mdc-top-app-bar--short': this.short,
          'mdc-top-app-bar--short-collapsed': this.shortCollapsed,
          'mdc-top-app-bar--prominent': this.prominent,
          'mdc-top-app-bar--fixed': this.fixed
        },
        foundation: null
      };
    },

    computed: {
      haveNavigationIcon: function haveNavigationIcon() {
        return !!this.icon || this.iconClasses;
      },
      naviconClasses: function naviconClasses() {
        return _extends({
          'mdc-top-app-bar__navigation-icon': true,
          'material-icons': !!this.icon
        }, this.iconClasses);
      }
    },
    mounted: function mounted() {
      var _this = this;

      var adapter = {
        addClass: function addClass(className) {
          _this.$set(_this.rootClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.rootClasses, className);
        },
        hasClass: function hasClass(className) {
          return _this.$refs.root.classList.contains(className);
        },
        setStyle: function setStyle(property, value) {
          _this.$set(_this.rootStyles, property, value);
        },
        getTopAppBarHeight: function getTopAppBarHeight() {
          return _this.$el.clientHeight;
        },
        registerNavigationIconInteractionHandler: function registerNavigationIconInteractionHandler(type, handler) {
          if (_this.$refs.navigationIcon) {
            _this.$refs.navigationIcon.addEventListener(type, handler);
          }
        },
        deregisterNavigationIconInteractionHandler: function deregisterNavigationIconInteractionHandler(type, handler) {
          if (_this.$refs.navigationIcon) {
            _this.$refs.navigationIcon.removeEventListener(type, handler);
          }
        },
        notifyNavigationIconClicked: function notifyNavigationIconClicked() {
          _this.$emit('nav');
        },
        registerScrollHandler: function registerScrollHandler(handler) {
          window.addEventListener('scroll', handler);
        },
        deregisterScrollHandler: function deregisterScrollHandler(handler) {
          window.removeEventListener('scroll', handler);
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          return window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          return window.removeEventListener('resize', handler);
        },

        getViewportScrollY: function getViewportScrollY() {
          return window.pageYOffset;
        },
        getTotalActionItems: function getTotalActionItems() {
          return _this.$refs.root.querySelectorAll(MDCTopAppBarBaseFoundation.strings.ACTION_ITEM_SELECTOR).length;
        }
      };

      this.foundation = this.short ? new MDCShortTopAppBarFoundation(adapter) : new MDCTopAppBarBaseFoundation(adapter);

      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    }
  };

  /* script */
  var __vue_script__$14 = script$14;

  /* template */
  var __vue_render__$11 = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("header", _vm._g({ ref: "root", class: _vm.rootClasses, style: _vm.rootStyles }, _vm.$listeners), [_c("div", { staticClass: "mdc-top-app-bar__row" }, [_c("section", {
      staticClass: "mdc-top-app-bar__section mdc-top-app-bar__section--align-start"
    }, [_vm.haveNavigationIcon ? _c("a", _vm._g({
      ref: "navigationIcon",
      class: _vm.naviconClasses,
      attrs: { href: "#" }
    }, _vm.listeners), [_vm._v(_vm._s(_vm.icon))]) : _vm._e(), _vm._v(" "), !!_vm.title ? _c("span", { staticClass: "mdc-top-app-bar__title" }, [_vm._v(_vm._s(_vm.title))]) : _vm._e()]), _vm._v(" "), _vm.$slots.default ? _c("section", {
      staticClass: "mdc-top-app-bar__section mdc-top-app-bar__section--align-end"
    }, [_vm._t("default")], 2) : _vm._e()]), _vm._v(" "), _vm._t("tabs")], 2);
  };
  var __vue_staticRenderFns__$11 = [];
  __vue_render__$11._withStripped = true;

  /* style */
  var __vue_inject_styles__$14 = undefined;
  /* scoped */
  var __vue_scope_id__$14 = undefined;
  /* module identifier */
  var __vue_module_identifier__$14 = undefined;
  /* functional template */
  var __vue_is_functional_template__$14 = false;
  /* component normalizer */
  function __vue_normalize__$14(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/top-app-bar/mdc-top-app-bar.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$14() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$14.styles || (__vue_create_injector__$14.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcTopAppBar = __vue_normalize__$14({ render: __vue_render__$11, staticRenderFns: __vue_staticRenderFns__$11 }, __vue_inject_styles__$14, __vue_script__$14, __vue_scope_id__$14, __vue_is_functional_template__$14, __vue_module_identifier__$14, __vue_create_injector__$14, undefined);

  //

  var script$15 = {
    name: 'mdc-top-app-bar-action',
    mixins: [DispatchEventMixin, RippleMixin],
    props: {
      icon: String,
      iconClasses: Object
    },
    computed: {
      actioniconClasses: function actioniconClasses() {
        return _extends({
          'material-icons': !!this.icon
        }, this.iconClasses);
      }
    }
  };

  /* script */
  var __vue_script__$15 = script$15;

  /* template */
  var __vue_render__$12 = function __vue_render__() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("a", _vm._g({
      staticClass: "mdc-top-app-bar-action mdc-top-app-bar--action mdc-top-app-bar__action-item",
      class: _vm.actioniconClasses,
      attrs: { href: "#" }
    }, _vm.listeners), [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2);
  };
  var __vue_staticRenderFns__$12 = [];
  __vue_render__$12._withStripped = true;

  /* style */
  var __vue_inject_styles__$15 = undefined;
  /* scoped */
  var __vue_scope_id__$15 = undefined;
  /* module identifier */
  var __vue_module_identifier__$15 = undefined;
  /* functional template */
  var __vue_is_functional_template__$15 = false;
  /* component normalizer */
  function __vue_normalize__$15(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/home/travis/build/stasson/vue-mdc-adapter/components/top-app-bar/mdc-top-app-bar-action.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */
  function __vue_create_injector__$15() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$15.styles || (__vue_create_injector__$15.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) el.setAttribute('media', css.media);
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */

  var mdcTopAppBarAction = __vue_normalize__$15({ render: __vue_render__$12, staticRenderFns: __vue_staticRenderFns__$12 }, __vue_inject_styles__$15, __vue_script__$15, __vue_scope_id__$15, __vue_is_functional_template__$15, __vue_module_identifier__$15, __vue_create_injector__$15, undefined);

  var VueMDCTopAppBar = BasePlugin({
    mdcTopAppBar: mdcTopAppBar,
    mdcTopAppBarAction: mdcTopAppBarAction
  });

  var typos = ['headline1', 'headline2', 'headline3', 'headline4', 'headline5', 'headline6', 'subtitle1', 'subtitle2', 'body1', 'body2', 'caption', 'button', 'overline'];

  var mdcTypoMixin = function mdcTypoMixin(name) {
    return {
      render: function render(createElement) {
        var _class;

        return createElement(this.tag, {
          class: (_class = {
            'mdc-typo': true
          }, defineProperty(_class, name, true), defineProperty(_class, 'mdc-typography--' + this.typo, true), _class),
          attrs: this.$attrs,
          on: this.$listeners
        }, this.$slots.default);
      }
    };
  };

  function mdcTypoPropMixin(defaultTag, defaultTypo, validTypos) {
    return {
      props: {
        tag: {
          type: String,
          default: defaultTag
        },
        typo: {
          type: String,
          default: defaultTypo,
          validator: function validator(value) {
            return validTypos.indexOf(value) !== -1;
          }
        }
      }
    };
  }

  var mdcTextSection = {
    name: 'mdc-text-section',
    props: {
      tag: {
        type: String,
        default: 'section'
      }
    },
    render: function render(createElement) {
      return createElement(this.tag, {
        class: {
          'mdc-typography': true,
          'mdc-text-section': true
        },
        attrs: this.$attrs,
        on: this.$listeners
      }, this.$slots.default);
    }
  };

  var mdcText = {
    name: 'mdc-text',
    mixins: [mdcTypoMixin('mdc-text'), mdcTypoPropMixin('p', 'body1', typos)]
  };

  var mdcDisplay = {
    name: 'mdc-display',
    mixins: [mdcTypoMixin('mdc-display'), mdcTypoPropMixin('h1', 'headline4', ['headline4', 'headline3', 'headline2', 'headline1'])]
  };

  var mdcHeadline = {
    name: 'mdc-headline',
    mixins: [mdcTypoMixin('mdc-headline'), mdcTypoPropMixin('h2', 'headline5', ['headline5'])]
  };

  var mdcTitle = {
    name: 'mdc-title',
    mixins: [mdcTypoMixin('mdc-title'), mdcTypoPropMixin('h3', 'headline6', ['headline6'])]
  };

  var mdcSubHeading = {
    name: 'mdc-subheading',
    mixins: [mdcTypoMixin('mdc-subheading'), mdcTypoPropMixin('h4', 'subtitle2', ['subtitle1', 'subtitle2'])]
  };

  var mdcBody = {
    name: 'mdc-body',
    mixins: [mdcTypoMixin('mdc-body'), mdcTypoPropMixin('p', 'body1', ['body1', 'body2'])]
  };

  var mdcCaption = {
    name: 'mdc-caption',
    mixins: [mdcTypoMixin('mdc-caption'), mdcTypoPropMixin('span', 'caption', ['caption'])]
  };

  var VueMDCTypography = BasePlugin({
    mdcTextSection: mdcTextSection,
    mdcText: mdcText,
    mdcBody: mdcBody,
    mdcCaption: mdcCaption,
    mdcDisplay: mdcDisplay,
    mdcHeadline: mdcHeadline,
    mdcSubHeading: mdcSubHeading,
    mdcTitle: mdcTitle
  });

  //

  var plugin = {
    version: '0.18.2',
    install: function install(vm) {
      vm.use(VueMDCButton);
      vm.use(VueMDCCard);
      vm.use(VueMDCCheckbox);
      vm.use(VueMDCChipSet);
      vm.use(VueMDCElevation);
      vm.use(VueMDCDialog);
      vm.use(VueMDCDrawer);
      vm.use(VueMDCElevation);
      vm.use(VueMDCFab);
      vm.use(VueMDCGridList);
      vm.use(VueMDCIcon);
      vm.use(VueMDCIconToggle);
      vm.use(VueMDCLayoutApp);
      vm.use(VueMDCLayoutGrid);
      vm.use(VueMDCLinearProgress);
      vm.use(VueMDCList);
      vm.use(VueMDCMenu);
      vm.use(VueMDCRadio);
      vm.use(VueMDCRipple);
      vm.use(VueMDCSelect);
      vm.use(VueMDCSlider);
      vm.use(VueMDCSnackbar);
      vm.use(VueMDCSwitch);
      vm.use(VueMDCTabs);
      vm.use(VueMDCTextfield);
      vm.use(VueMDCTheme);
      vm.use(VueMDCToolbar);
      vm.use(VueMDCTopAppBar);
      vm.use(VueMDCTypography);
    }
  };

  autoInit(plugin);

  return plugin;

})));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidnVlLW1kYy1hZGFwdGVyLmpzIiwic291cmNlcyI6WyIuLi9jb21wb25lbnRzL2Jhc2UvYXBwbHktcGFzc2l2ZS5qcyIsIi4uL2NvbXBvbmVudHMvYmFzZS9hdXRvLWluaXQuanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvYmFzZS1wbHVnaW4uanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvY3VzdG9tLWVsZW1lbnQuanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvY3VzdG9tLWxpbmsuanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvY3VzdG9tLWV2ZW50LmpzIiwiLi4vY29tcG9uZW50cy9iYXNlL2N1c3RvbS1idXR0b24uanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvY3VzdG9tLWljb24uanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvZGlzcGF0Y2gtZXZlbnQtbWl4aW4uanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvZGlzcGF0Y2gtZm9jdXMtbWl4aW4uanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvdW5pcXVlaWQtbWl4aW4uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvcmlwcGxlL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS91dGlsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yaXBwbGUvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvcmlwcGxlL21kYy1yaXBwbGUtYmFzZS5qcyIsIi4uL2NvbXBvbmVudHMvcmlwcGxlL21kYy1yaXBwbGUudnVlIiwiLi4vY29tcG9uZW50cy9yaXBwbGUvaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2J1dHRvbi9tZGMtYnV0dG9uLWJhc2UudnVlIiwiLi4vY29tcG9uZW50cy9idXR0b24vbWRjLWJ1dHRvbi52dWUiLCIuLi9jb21wb25lbnRzL2J1dHRvbi9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvY2FyZC9tZGMtY2FyZC52dWUiLCIuLi9jb21wb25lbnRzL2NhcmQvbWRjLWNhcmQtcHJpbWFyeS1hY3Rpb24udnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLW1lZGlhLnZ1ZSIsIi4uL2NvbXBvbmVudHMvY2FyZC9tZGMtY2FyZC1oZWFkZXIudnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLXRpdGxlLnZ1ZSIsIi4uL2NvbXBvbmVudHMvY2FyZC9tZGMtY2FyZC1zdWJ0aXRsZS52dWUiLCIuLi9jb21wb25lbnRzL2NhcmQvbWRjLWNhcmQtdGV4dC52dWUiLCIuLi9jb21wb25lbnRzL2NhcmQvbWRjLWNhcmQtYWN0aW9ucy52dWUiLCIuLi9jb21wb25lbnRzL2NhcmQvbWRjLWNhcmQtYWN0aW9uLWJ1dHRvbnMudnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLWFjdGlvbi1idXR0b24udnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLWFjdGlvbi1pY29ucy52dWUiLCIuLi9jb21wb25lbnRzL2NhcmQvbWRjLWNhcmQtYWN0aW9uLWljb24udnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9iYXNlL2NvbXBvbmVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc2VsZWN0aW9uLWNvbnRyb2wvbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yaXBwbGUvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc2VsZWN0aW9uLWNvbnRyb2wvbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yaXBwbGUvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9zZWxlY3Rpb24tY29udHJvbC9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS91dGlsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9zZWxlY3Rpb24tY29udHJvbC9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9zZWxlY3Rpb24tY29udHJvbC9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc2VsZWN0aW9uLWNvbnRyb2wvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2NoZWNrYm94L2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2NoZWNrYm94L2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvY2hlY2tib3gvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZm9ybS1maWVsZC9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9mb3JtLWZpZWxkL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZm9ybS1maWVsZC9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9hbmltYXRpb24vaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2NoZWNrYm94L21kYy1jaGVja2JveC52dWUiLCIuLi9jb21wb25lbnRzL2NoZWNrYm94L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9jaGlwcy9jaGlwL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2NoaXBzL2NoaXAvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9jaGlwcy9jaGlwL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL2NoaXBzL21kYy1jaGlwLnZ1ZSIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvY2hpcHMvY2hpcC1zZXQvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvY2hpcHMvY2hpcC1zZXQvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9jaGlwcy9jaGlwLXNldC9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy9jaGlwcy9tZGMtY2hpcC1zZXQudnVlIiwiLi4vY29tcG9uZW50cy9jaGlwcy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvYmFzZS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZGlhbG9nL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZGlhbG9nL2ZvdW5kYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvdGFiYmFibGUvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvZm9jdXMtdHJhcC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZGlhbG9nL3V0aWwuanMiLCIuLi9jb21wb25lbnRzL2RpYWxvZy9tZGMtZGlhbG9nLnZ1ZSIsIi4uL2NvbXBvbmVudHMvZGlhbG9nL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLXBlcm1hbmVudC1kcmF3ZXIudnVlIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kcmF3ZXIvc2xpZGFibGUvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kcmF3ZXIvc2xpZGFibGUvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZHJhd2VyL3NsaWRhYmxlL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kcmF3ZXIvcGVyc2lzdGVudC9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RyYXdlci9wZXJzaXN0ZW50L2ZvdW5kYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RyYXdlci91dGlsLmpzIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLXBlcnNpc3RlbnQtZHJhd2VyLnZ1ZSIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZHJhd2VyL3RlbXBvcmFyeS9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RyYXdlci90ZW1wb3JhcnkvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvZHJhd2VyL21kYy10ZW1wb3JhcnktZHJhd2VyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvZHJhd2VyL21kYy1kcmF3ZXIudnVlIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLWRyYXdlci1sYXlvdXQudnVlIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLWRyYXdlci1oZWFkZXIudnVlIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLWRyYXdlci1saXN0LnZ1ZSIsIi4uL2NvbXBvbmVudHMvZHJhd2VyL21kYy1kcmF3ZXItaXRlbS52dWUiLCIuLi9jb21wb25lbnRzL2RyYXdlci9tZGMtZHJhd2VyLWRpdmlkZXIudnVlIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2VsZXZhdGlvbi9tZGMtZWxldmF0aW9uLnZ1ZSIsIi4uL2NvbXBvbmVudHMvZWxldmF0aW9uL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9mYWIvbWRjLWZhYi52dWUiLCIuLi9jb21wb25lbnRzL2ZhYi9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZ3JpZC1saXN0L2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZ3JpZC1saXN0L2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL2dyaWQtbGlzdC9tZGMtZ3JpZC1saXN0LnZ1ZSIsIi4uL2NvbXBvbmVudHMvZ3JpZC1saXN0L21kYy1ncmlkLXRpbGUudnVlIiwiLi4vY29tcG9uZW50cy9ncmlkLWxpc3QvaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2ljb24vbWRjLWljb24udnVlIiwiLi4vY29tcG9uZW50cy9pY29uL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9pY29uLXRvZ2dsZS9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9pY29uLXRvZ2dsZS9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2ljb24tdG9nZ2xlL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL2ljb24tdG9nZ2xlL21kYy1pY29uLXRvZ2dsZS52dWUiLCIuLi9jb21wb25lbnRzL2ljb24tdG9nZ2xlL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9sYXlvdXQtYXBwL21kYy1sYXlvdXQtYXBwLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGF5b3V0LWFwcC9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvbGF5b3V0LWdyaWQvbWRjLWxheW91dC1ncmlkLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGF5b3V0LWdyaWQvbWRjLWxheW91dC1jZWxsLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGF5b3V0LWdyaWQvbWRjLWxheW91dC1pbm5lci1ncmlkLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGF5b3V0LWdyaWQvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2xpbmVhci1wcm9ncmVzcy9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2xpbmVhci1wcm9ncmVzcy9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy9saW5lYXItcHJvZ3Jlc3MvbWRjLWxpbmVhci1wcm9ncmVzcy52dWUiLCIuLi9jb21wb25lbnRzL2xpbmVhci1wcm9ncmVzcy9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvbGlzdC9tZGMtbGlzdC52dWUiLCIuLi9jb21wb25lbnRzL2xpc3QvbWRjLWxpc3QtaXRlbS52dWUiLCIuLi9jb21wb25lbnRzL2xpc3QvbWRjLWxpc3QtZGl2aWRlci52dWUiLCIuLi9jb21wb25lbnRzL2xpc3QvbWRjLWxpc3QtZ3JvdXAudnVlIiwiLi4vY29tcG9uZW50cy9saXN0L21kYy1saXN0LWdyb3VwLWhlYWRlci52dWUiLCIuLi9jb21wb25lbnRzL2xpc3QvbWRjLWxpc3QtZ3JvdXAtZGl2aWRlci52dWUiLCIuLi9jb21wb25lbnRzL2xpc3QvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL21lbnUvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbWVudS9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL21lbnUvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbWVudS91dGlsLmpzIiwiLi4vY29tcG9uZW50cy9tZW51L21kYy1tZW51LnZ1ZSIsIi4uL2NvbXBvbmVudHMvbWVudS9tZGMtbWVudS1pdGVtLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbWVudS9tZGMtbWVudS1kaXZpZGVyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbWVudS9tZGMtbWVudS1hbmNob3IudnVlIiwiLi4vY29tcG9uZW50cy9tZW51L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yYWRpby9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yYWRpby9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JhZGlvL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL3JhZGlvL21kYy1yYWRpby52dWUiLCIuLi9jb21wb25lbnRzL3JhZGlvL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9zZWxlY3QvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc2VsZWN0L2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc2VsZWN0L2ZvdW5kYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2Zsb2F0aW5nLWxhYmVsL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2Zsb2F0aW5nLWxhYmVsL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZmxvYXRpbmctbGFiZWwvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvc2VsZWN0L21kYy1zZWxlY3QtbGFiZWwudnVlIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9saW5lLXJpcHBsZS9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9saW5lLXJpcHBsZS9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2xpbmUtcmlwcGxlL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL3NlbGVjdC9tZGMtc2VsZWN0LWxpbmUtcmlwcGxlLnZ1ZSIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbm90Y2hlZC1vdXRsaW5lL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL25vdGNoZWQtb3V0bGluZS9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL25vdGNoZWQtb3V0bGluZS9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy9zZWxlY3QvbWRjLXNlbGVjdC1ub3RjaGVkLW91dGxpbmUudnVlIiwiLi4vY29tcG9uZW50cy9zZWxlY3QvbWRjLXNlbGVjdC52dWUiLCIuLi9jb21wb25lbnRzL3NlbGVjdC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc2xpZGVyL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc2xpZGVyL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3NsaWRlci9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy9zbGlkZXIvbWRjLXNsaWRlci52dWUiLCIuLi9jb21wb25lbnRzL3NsaWRlci9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc25hY2tiYXIvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9zbmFja2Jhci9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy9zbmFja2Jhci9tZGMtc25hY2tiYXIudnVlIiwiLi4vY29tcG9uZW50cy9zbmFja2Jhci9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc3dpdGNoL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3N3aXRjaC9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3N3aXRjaC9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy9zd2l0Y2gvbWRjLXN3aXRjaC52dWUiLCIuLi9jb21wb25lbnRzL3N3aXRjaC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFicy90YWIvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWJzL3RhYi9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy90YWJzL21kYy10YWIudnVlIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWJzL3RhYi1iYXIvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWJzL3RhYi1iYXIvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvdGFicy9tZGMtdGFiLWJhci52dWUiLCIuLi9jb21wb25lbnRzL3RhYnMvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RleHRmaWVsZC9oZWxwZXItdGV4dC9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvaGVscGVyLXRleHQvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvaGVscGVyLXRleHQvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGV4dGZpZWxkL2ljb24vYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGV4dGZpZWxkL2ljb24vY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvaWNvbi9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGV4dGZpZWxkL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGV4dGZpZWxkL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL3RleHRmaWVsZC9tZGMtdGV4dGZpZWxkLnZ1ZSIsIi4uL2NvbXBvbmVudHMvdGV4dGZpZWxkL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy90aGVtZS9tZGMtdGhlbWUudnVlIiwiLi4vY29tcG9uZW50cy90aGVtZS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdG9vbGJhci9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3Rvb2xiYXIvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvdG9vbGJhci9tZGMtdG9vbGJhci52dWUiLCIuLi9jb21wb25lbnRzL3Rvb2xiYXIvbWRjLXRvb2xiYXItcm93LnZ1ZSIsIi4uL2NvbXBvbmVudHMvdG9vbGJhci9tZGMtdG9vbGJhci1zZWN0aW9uLnZ1ZSIsIi4uL2NvbXBvbmVudHMvdG9vbGJhci9tZGMtdG9vbGJhci1tZW51LWljb24udnVlIiwiLi4vY29tcG9uZW50cy90b29sYmFyL21kYy10b29sYmFyLXRpdGxlLnZ1ZSIsIi4uL2NvbXBvbmVudHMvdG9vbGJhci9tZGMtdG9vbGJhci1pY29uLnZ1ZSIsIi4uL2NvbXBvbmVudHMvdG9vbGJhci9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdG9wLWFwcC1iYXIvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90b3AtYXBwLWJhci9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90b3AtYXBwLWJhci9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90b3AtYXBwLWJhci9zaG9ydC9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy90b3AtYXBwLWJhci9tZGMtdG9wLWFwcC1iYXIudnVlIiwiLi4vY29tcG9uZW50cy90b3AtYXBwLWJhci9tZGMtdG9wLWFwcC1iYXItYWN0aW9uLnZ1ZSIsIi4uL2NvbXBvbmVudHMvdG9wLWFwcC1iYXIvaW5kZXguanMiLCIuLi9jb21wb25lbnRzL3R5cG9ncmFwaHkvbWRjLXR5cG9ncmFwaHkuanMiLCIuLi9jb21wb25lbnRzL3R5cG9ncmFwaHkvaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9lbnRyeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgc3VwcG9ydHNQYXNzaXZlX1xuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIHRoZSBjdXJyZW50IGJyb3dzZXIgc3VwcG9ydHMgcGFzc2l2ZSBldmVudCBsaXN0ZW5lcnMsIGFuZCBpZiBzbywgdXNlIHRoZW0uXG4gKiBAcGFyYW0geyFXaW5kb3c9fSBnbG9iYWxPYmpcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGZvcmNlUmVmcmVzaFxuICogQHJldHVybiB7Ym9vbGVhbnx7cGFzc2l2ZTogYm9vbGVhbn19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVBhc3NpdmUoZ2xvYmFsT2JqID0gd2luZG93LCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkge1xuICBpZiAoc3VwcG9ydHNQYXNzaXZlXyA9PT0gdW5kZWZpbmVkIHx8IGZvcmNlUmVmcmVzaCkge1xuICAgIGxldCBpc1N1cHBvcnRlZCA9IGZhbHNlXG4gICAgdHJ5IHtcbiAgICAgIGdsb2JhbE9iai5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwge1xuICAgICAgICBnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHsgcGFzc2l2ZTogdHJ1ZSB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy9lbXB0eVxuICAgIH1cblxuICAgIHN1cHBvcnRzUGFzc2l2ZV8gPSBpc1N1cHBvcnRlZFxuICB9XG5cbiAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZV9cbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBhdXRvSW5pdChwbHVnaW4pIHtcbiAgLy8gQXV0by1pbnN0YWxsXG4gIGxldCBfVnVlID0gbnVsbFxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBfVnVlID0gd2luZG93LlZ1ZVxuICB9IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLypnbG9iYWwgZ2xvYmFsKi9cbiAgICBfVnVlID0gZ2xvYmFsLlZ1ZVxuICB9XG4gIGlmIChfVnVlKSB7XG4gICAgX1Z1ZS51c2UocGx1Z2luKVxuICB9XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gQmFzZVBsdWdpbihjb21wb25lbnRzKSB7XG4gIHJldHVybiB7XG4gICAgdmVyc2lvbjogJ19fVkVSU0lPTl9fJyxcbiAgICBpbnN0YWxsOiB2bSA9PiB7XG4gICAgICBmb3IgKGxldCBrZXkgaW4gY29tcG9uZW50cykge1xuICAgICAgICBsZXQgY29tcG9uZW50ID0gY29tcG9uZW50c1trZXldXG4gICAgICAgIHZtLmNvbXBvbmVudChjb21wb25lbnQubmFtZSwgY29tcG9uZW50KVxuICAgICAgfVxuICAgIH0sXG4gICAgY29tcG9uZW50c1xuICB9XG59XG4iLCJleHBvcnQgY29uc3QgQ3VzdG9tRWxlbWVudCA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcmVuZGVyKGNyZWF0ZUVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChcbiAgICAgIGNvbnRleHQucHJvcHMuaXMgfHwgY29udGV4dC5wcm9wcy50YWcgfHwgJ2RpdicsXG4gICAgICBjb250ZXh0LmRhdGEsXG4gICAgICBjb250ZXh0LmNoaWxkcmVuXG4gICAgKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBDdXN0b21FbGVtZW50TWl4aW4gPSB7XG4gIGNvbXBvbmVudHM6IHtcbiAgICBDdXN0b21FbGVtZW50XG4gIH1cbn1cbiIsImV4cG9ydCBjb25zdCBDdXN0b21MaW5rID0ge1xuICBuYW1lOiAnY3VzdG9tLWxpbmsnLFxuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczoge1xuICAgIHRhZzogeyB0eXBlOiBTdHJpbmcsIGRlZmF1bHQ6ICdhJyB9LFxuICAgIGxpbms6IE9iamVjdFxuICB9LFxuICByZW5kZXIoaCwgY29udGV4dCkge1xuICAgIGxldCBlbGVtZW50XG4gICAgbGV0IGRhdGEgPSBPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0LmRhdGEpXG5cbiAgICBpZiAoY29udGV4dC5wcm9wcy5saW5rICYmIGNvbnRleHQucGFyZW50LiRyb3V0ZXIpIHtcbiAgICAgIC8vIHJvdXRlci1saW5rIGNhc2VcbiAgICAgIGVsZW1lbnQgPSBjb250ZXh0LnBhcmVudC4kcm9vdC4kb3B0aW9ucy5jb21wb25lbnRzWydyb3V0ZXItbGluayddXG4gICAgICBkYXRhLnByb3BzID0gT2JqZWN0LmFzc2lnbih7IHRhZzogY29udGV4dC5wcm9wcy50YWcgfSwgY29udGV4dC5wcm9wcy5saW5rKVxuICAgICAgaWYgKGRhdGEub24uY2xpY2spIHtcbiAgICAgICAgZGF0YS5uYXRpdmVPbiA9IHsgY2xpY2s6IGRhdGEub24uY2xpY2sgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbGVtZW50IGZhbGxiYWNrXG4gICAgICBlbGVtZW50ID0gY29udGV4dC5wcm9wcy50YWdcbiAgICB9XG5cbiAgICByZXR1cm4gaChlbGVtZW50LCBkYXRhLCBjb250ZXh0LmNoaWxkcmVuKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBDdXN0b21MaW5rTWl4aW4gPSB7XG4gIHByb3BzOiB7XG4gICAgdG86IFtTdHJpbmcsIE9iamVjdF0sXG4gICAgZXhhY3Q6IEJvb2xlYW4sXG4gICAgYXBwZW5kOiBCb29sZWFuLFxuICAgIHJlcGxhY2U6IEJvb2xlYW4sXG4gICAgYWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBleGFjdEFjdGl2ZUNsYXNzOiBTdHJpbmdcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBsaW5rKCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy50byAmJiB7XG4gICAgICAgICAgdG86IHRoaXMudG8sXG4gICAgICAgICAgZXhhY3Q6IHRoaXMuZXhhY3QsXG4gICAgICAgICAgYXBwZW5kOiB0aGlzLmFwcGVuZCxcbiAgICAgICAgICByZXBsYWNlOiB0aGlzLnJlcGxhY2UsXG4gICAgICAgICAgYWN0aXZlQ2xhc3M6IHRoaXMuYWN0aXZlQ2xhc3MsXG4gICAgICAgICAgZXhhY3RBY3RpdmVDbGFzczogdGhpcy5leGFjdEFjdGl2ZUNsYXNzXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudHM6IHtcbiAgICBDdXN0b21MaW5rXG4gIH1cbn1cbiIsIi8qIGdsb2JhbCBDdXN0b21FdmVudCAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZW1pdEN1c3RvbUV2ZW50KGVsLCBldnRUeXBlLCBldnREYXRhLCBzaG91bGRCdWJibGUgPSBmYWxzZSkge1xuICBsZXQgZXZ0XG4gIGlmICh0eXBlb2YgQ3VzdG9tRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBldnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXZ0VHlwZSwge1xuICAgICAgZGV0YWlsOiBldnREYXRhLFxuICAgICAgYnViYmxlczogc2hvdWxkQnViYmxlXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKVxuICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoZXZ0VHlwZSwgc2hvdWxkQnViYmxlLCBmYWxzZSwgZXZ0RGF0YSlcbiAgfVxuICBlbC5kaXNwYXRjaEV2ZW50KGV2dClcbn1cbiIsImV4cG9ydCBjb25zdCBDdXN0b21CdXR0b24gPSB7XG4gIG5hbWU6ICdjdXN0b20tYnV0dG9uJyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBsaW5rOiBPYmplY3RcbiAgfSxcbiAgcmVuZGVyKGgsIGNvbnRleHQpIHtcbiAgICBsZXQgZWxlbWVudFxuICAgIGxldCBkYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgY29udGV4dC5kYXRhKVxuXG4gICAgaWYgKGNvbnRleHQucHJvcHMubGluayAmJiBjb250ZXh0LnBhcmVudC4kcm91dGVyKSB7XG4gICAgICAvLyByb3V0ZXItbGluayBjYXNlXG4gICAgICBlbGVtZW50ID0gY29udGV4dC5wYXJlbnQuJHJvb3QuJG9wdGlvbnMuY29tcG9uZW50c1sncm91dGVyLWxpbmsnXVxuICAgICAgZGF0YS5wcm9wcyA9IE9iamVjdC5hc3NpZ24oeyB0YWc6IGNvbnRleHQucHJvcHMudGFnIH0sIGNvbnRleHQucHJvcHMubGluaylcbiAgICAgIGRhdGEuYXR0cnMucm9sZSA9ICdidXR0b24nXG4gICAgICBpZiAoZGF0YS5vbi5jbGljaykge1xuICAgICAgICBkYXRhLm5hdGl2ZU9uID0geyBjbGljazogZGF0YS5vbi5jbGljayB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMuaHJlZikge1xuICAgICAgLy8gaHJlZiBjYXNlXG4gICAgICBlbGVtZW50ID0gJ2EnXG4gICAgICBkYXRhLmF0dHJzLnJvbGUgPSAnYnV0dG9uJ1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBidXR0b24gZmFsbGJhY2tcbiAgICAgIGVsZW1lbnQgPSAnYnV0dG9uJ1xuICAgIH1cblxuICAgIHJldHVybiBoKGVsZW1lbnQsIGRhdGEsIGNvbnRleHQuY2hpbGRyZW4pXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEN1c3RvbUJ1dHRvbk1peGluID0ge1xuICBwcm9wczoge1xuICAgIGhyZWY6IFN0cmluZyxcbiAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICB0bzogW1N0cmluZywgT2JqZWN0XSxcbiAgICBleGFjdDogQm9vbGVhbixcbiAgICBhcHBlbmQ6IEJvb2xlYW4sXG4gICAgcmVwbGFjZTogQm9vbGVhbixcbiAgICBhY3RpdmVDbGFzczogU3RyaW5nLFxuICAgIGV4YWN0QWN0aXZlQ2xhc3M6IFN0cmluZ1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGxpbmsoKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLnRvICYmIHtcbiAgICAgICAgICB0bzogdGhpcy50byxcbiAgICAgICAgICBleGFjdDogdGhpcy5leGFjdCxcbiAgICAgICAgICBhcHBlbmQ6IHRoaXMuYXBwZW5kLFxuICAgICAgICAgIHJlcGxhY2U6IHRoaXMucmVwbGFjZSxcbiAgICAgICAgICBhY3RpdmVDbGFzczogdGhpcy5hY3RpdmVDbGFzcyxcbiAgICAgICAgICBleGFjdEFjdGl2ZUNsYXNzOiB0aGlzLmV4YWN0QWN0aXZlQ2xhc3NcbiAgICAgICAgfVxuICAgICAgKVxuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50czoge1xuICAgIEN1c3RvbUJ1dHRvblxuICB9XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gZXh0cmFjdEljb25Qcm9wKGljb25Qcm9wKSB7XG4gIGlmICh0eXBlb2YgaWNvblByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHsgJ21hdGVyaWFsLWljb25zJzogdHJ1ZSB9LFxuICAgICAgY29udGVudDogaWNvblByb3BcbiAgICB9XG4gIH0gZWxzZSBpZiAoaWNvblByb3AgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiBpY29uUHJvcC5yZWR1Y2UoXG4gICAgICAgIChyZXN1bHQsIHZhbHVlKSA9PiBPYmplY3QuYXNzaWduKHJlc3VsdCwgeyBbdmFsdWVdOiB0cnVlIH0pLFxuICAgICAgICB7fVxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgaWNvblByb3AgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IGljb25Qcm9wLmNsYXNzTmFtZVxuICAgICAgICAuc3BsaXQoJyAnKVxuICAgICAgICAucmVkdWNlKFxuICAgICAgICAgIChyZXN1bHQsIHZhbHVlKSA9PiBPYmplY3QuYXNzaWduKHJlc3VsdCwgeyBbdmFsdWVdOiB0cnVlIH0pLFxuICAgICAgICAgIHt9XG4gICAgICAgICksXG4gICAgICBjb250ZW50OiBpY29uUHJvcC50ZXh0Q29udGVudFxuICAgIH1cbiAgfVxufVxuIiwiZXhwb3J0IGNvbnN0IERpc3BhdGNoRXZlbnRNaXhpbiA9IHtcbiAgcHJvcHM6IHtcbiAgICBldmVudDogU3RyaW5nLFxuICAgICdldmVudC10YXJnZXQnOiBPYmplY3QsXG4gICAgJ2V2ZW50LWFyZ3MnOiBBcnJheVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgZGlzcGF0Y2hFdmVudChldnQpIHtcbiAgICAgIGV2dCAmJiB0aGlzLiRlbWl0KGV2dC50eXBlLCBldnQpXG4gICAgICBpZiAodGhpcy5ldmVudCkge1xuICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5ldmVudFRhcmdldCB8fCB0aGlzLiRyb290XG4gICAgICAgIGxldCBhcmdzID0gdGhpcy5ldmVudEFyZ3MgfHwgW11cbiAgICAgICAgdGFyZ2V0LiRlbWl0KHRoaXMuZXZlbnQsIC4uLmFyZ3MpXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGxpc3RlbmVycygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnRoaXMuJGxpc3RlbmVycyxcbiAgICAgICAgY2xpY2s6IGUgPT4gdGhpcy5kaXNwYXRjaEV2ZW50KGUpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCJleHBvcnQgY29uc3QgRGlzcGF0Y2hGb2N1c01peGluID0ge1xuICBkYXRhKCkge1xuICAgIHJldHVybiB7IGhhc0ZvY3VzOiBmYWxzZSB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbk1vdXNlRG93bigpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IHRydWVcbiAgICB9LFxuICAgIG9uTW91c2VVcCgpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlXG4gICAgfSxcbiAgICBvbkZvY3VzRXZlbnQoKSB7XG4gICAgICAvLyBkaXNwYXRjaCBhc3luYyB0byBsZXQgdGltZSB0byBvdGhlciBmb2N1cyBldmVudCB0byBwcm9wYWdhdGVcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5kaXNwYXRjaEZvY3VzRXZlbnQoKSwgMClcbiAgICB9LFxuICAgIG9uQmx1ckV2ZW50KCkge1xuICAgICAgLy8gZGlzcGF0Y2ggYXN5bmMgdG8gbGV0IHRpbWUgdG8gb3RoZXIgZm9jdXMgZXZlbnQgdG8gcHJvcGFnYXRlXG4gICAgICAvLyBhbHNvIGZpbHR1ciBibHVyIGlmIG1vdXNlZG93blxuICAgICAgdGhpcy5fYWN0aXZlIHx8IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5kaXNwYXRjaEZvY3VzRXZlbnQoKSwgMClcbiAgICB9LFxuICAgIGRpc3BhdGNoRm9jdXNFdmVudCgpIHtcbiAgICAgIGxldCBoYXNGb2N1cyA9XG4gICAgICAgIHRoaXMuJGVsID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50IHx8XG4gICAgICAgIHRoaXMuJGVsLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpXG4gICAgICBpZiAoaGFzRm9jdXMgIT0gdGhpcy5oYXNGb2N1cykge1xuICAgICAgICB0aGlzLiRlbWl0KGhhc0ZvY3VzID8gJ2ZvY3VzJyA6ICdibHVyJylcbiAgICAgICAgdGhpcy5oYXNGb2N1cyA9IGhhc0ZvY3VzXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCB0aGlzLm9uRm9jdXNFdmVudClcbiAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIHRoaXMub25CbHVyRXZlbnQpXG4gICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bilcbiAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXApXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIHRoaXMub25Gb2N1c0V2ZW50KVxuICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgdGhpcy5vbkJsdXJFdmVudClcbiAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duKVxuICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcClcbiAgfVxufVxuIiwiY29uc3Qgc2NvcGUgPVxuICBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBNYXRoLmZsb29yKDB4MTAwMDAwMDApKS50b1N0cmluZygpICsgJy0nXG5cbmV4cG9ydCBjb25zdCBWTUFVbmlxdWVJZE1peGluID0ge1xuICBiZWZvcmVDcmVhdGUoKSB7XG4gICAgdGhpcy52bWFfdWlkXyA9IHNjb3BlICsgdGhpcy5fdWlkXG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBBXG4gKi9cbmNsYXNzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVte2Nzc0NsYXNzZXN9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIHNob3VsZCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGFuIG9iamVjdCB3aGljaCBleHBvcnRzIGV2ZXJ5XG4gICAgLy8gQ1NTIGNsYXNzIHRoZSBmb3VuZGF0aW9uIGNsYXNzIG5lZWRzIGFzIGEgcHJvcGVydHkuIGUuZy4ge0FDVElWRTogJ21kYy1jb21wb25lbnQtLWFjdGl2ZSd9XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bXtzdHJpbmdzfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggZXhwb3J0cyBhbGxcbiAgICAvLyBzZW1hbnRpYyBzdHJpbmdzIGFzIGNvbnN0YW50cy4gZS5nLiB7QVJJQV9ST0xFOiAndGFibGlzdCd9XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bXtudW1iZXJzfSAqL1xuICBzdGF0aWMgZ2V0IG51bWJlcnMoKSB7XG4gICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggZXhwb3J0cyBhbGxcbiAgICAvLyBvZiBpdHMgc2VtYW50aWMgbnVtYmVycyBhcyBjb25zdGFudHMuIGUuZy4ge0FOSU1BVElPTl9ERUxBWV9NUzogMzUwfVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshT2JqZWN0fSAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gbWF5IGNob29zZSB0byBpbXBsZW1lbnQgdGhpcyBnZXR0ZXIgaW4gb3JkZXIgdG8gcHJvdmlkZSBhIGNvbnZlbmllbnRcbiAgICAvLyB3YXkgb2Ygdmlld2luZyB0aGUgbmVjZXNzYXJ5IG1ldGhvZHMgb2YgYW4gYWRhcHRlci4gSW4gdGhlIGZ1dHVyZSwgdGhpcyBjb3VsZCBhbHNvIGJlIHVzZWQgZm9yIGFkYXB0ZXJcbiAgICAvLyB2YWxpZGF0aW9uLlxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0E9fSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyID0ge30pIHtcbiAgICAvKiogQHByb3RlY3RlZCB7IUF9ICovXG4gICAgdGhpcy5hZGFwdGVyXyA9IGFkYXB0ZXI7XG4gIH1cblxuICBpbml0KCkge1xuICAgIC8vIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHBlcmZvcm0gaW5pdGlhbGl6YXRpb24gcm91dGluZXMgKHJlZ2lzdGVyaW5nIGV2ZW50cywgZXRjLilcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcGVyZm9ybSBkZS1pbml0aWFsaXphdGlvbiByb3V0aW5lcyAoZGUtcmVnaXN0ZXJpbmcgZXZlbnRzLCBldGMuKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0ZvdW5kYXRpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFJpcHBsZS4gUHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBtYW5hZ2luZ1xuICogLSBjbGFzc2VzXG4gKiAtIGRvbVxuICogLSBDU1MgdmFyaWFibGVzXG4gKiAtIHBvc2l0aW9uXG4gKiAtIGRpbWVuc2lvbnNcbiAqIC0gc2Nyb2xsIHBvc2l0aW9uXG4gKiAtIGV2ZW50IGhhbmRsZXJzXG4gKiAtIHVuYm91bmRlZCwgYWN0aXZlIGFuZCBkaXNhYmxlZCBzdGF0ZXNcbiAqXG4gKiBBZGRpdGlvbmFsbHksIHByb3ZpZGVzIHR5cGUgaW5mb3JtYXRpb24gZm9yIHRoZSBhZGFwdGVyIHRvIHRoZSBDbG9zdXJlXG4gKiBjb21waWxlci5cbiAqXG4gKiBJbXBsZW1lbnQgdGhpcyBhZGFwdGVyIGZvciB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UgdG8gZGVsZWdhdGUgdXBkYXRlcyB0b1xuICogdGhlIGNvbXBvbmVudCBpbiB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UuIFNlZSBhcmNoaXRlY3R1cmUgZG9jdW1lbnRhdGlvblxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvY29kZS9hcmNoaXRlY3R1cmUubWRcbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1JpcHBsZUFkYXB0ZXIge1xuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgYnJvd3NlclN1cHBvcnRzQ3NzVmFycygpIHt9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzVW5ib3VuZGVkKCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNTdXJmYWNlQWN0aXZlKCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNTdXJmYWNlRGlzYWJsZWQoKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqIEBwYXJhbSB7IUV2ZW50VGFyZ2V0fSB0YXJnZXQgKi9cbiAgY29udGFpbnNFdmVudFRhcmdldCh0YXJnZXQpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlclJlc2l6ZUhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YXJOYW1lXG4gICAqIEBwYXJhbSB7P251bWJlcnxzdHJpbmd9IHZhbHVlXG4gICAqL1xuICB1cGRhdGVDc3NWYXJpYWJsZSh2YXJOYW1lLCB2YWx1ZSkge31cblxuICAvKiogQHJldHVybiB7IUNsaWVudFJlY3R9ICovXG4gIGNvbXB1dGVCb3VuZGluZ1JlY3QoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSAqL1xuICBnZXRXaW5kb3dQYWdlT2Zmc2V0KCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDUmlwcGxlQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICAvLyBSaXBwbGUgaXMgYSBzcGVjaWFsIGNhc2Ugd2hlcmUgdGhlIFwicm9vdFwiIGNvbXBvbmVudCBpcyByZWFsbHkgYSBcIm1peGluXCIgb2Ygc29ydHMsXG4gIC8vIGdpdmVuIHRoYXQgaXQncyBhbiAndXBncmFkZScgdG8gYW4gZXhpc3RpbmcgY29tcG9uZW50LiBUaGF0IGJlaW5nIHNhaWQgaXQgaXMgdGhlIHJvb3RcbiAgLy8gQ1NTIGNsYXNzIHRoYXQgYWxsIG90aGVyIENTUyBjbGFzc2VzIGRlcml2ZSBmcm9tLlxuICBST09UOiAnbWRjLXJpcHBsZS11cGdyYWRlZCcsXG4gIFVOQk9VTkRFRDogJ21kYy1yaXBwbGUtdXBncmFkZWQtLXVuYm91bmRlZCcsXG4gIEJHX0ZPQ1VTRUQ6ICdtZGMtcmlwcGxlLXVwZ3JhZGVkLS1iYWNrZ3JvdW5kLWZvY3VzZWQnLFxuICBGR19BQ1RJVkFUSU9OOiAnbWRjLXJpcHBsZS11cGdyYWRlZC0tZm9yZWdyb3VuZC1hY3RpdmF0aW9uJyxcbiAgRkdfREVBQ1RJVkFUSU9OOiAnbWRjLXJpcHBsZS11cGdyYWRlZC0tZm9yZWdyb3VuZC1kZWFjdGl2YXRpb24nLFxufTtcblxuY29uc3Qgc3RyaW5ncyA9IHtcbiAgVkFSX0xFRlQ6ICctLW1kYy1yaXBwbGUtbGVmdCcsXG4gIFZBUl9UT1A6ICctLW1kYy1yaXBwbGUtdG9wJyxcbiAgVkFSX0ZHX1NJWkU6ICctLW1kYy1yaXBwbGUtZmctc2l6ZScsXG4gIFZBUl9GR19TQ0FMRTogJy0tbWRjLXJpcHBsZS1mZy1zY2FsZScsXG4gIFZBUl9GR19UUkFOU0xBVEVfU1RBUlQ6ICctLW1kYy1yaXBwbGUtZmctdHJhbnNsYXRlLXN0YXJ0JyxcbiAgVkFSX0ZHX1RSQU5TTEFURV9FTkQ6ICctLW1kYy1yaXBwbGUtZmctdHJhbnNsYXRlLWVuZCcsXG59O1xuXG5jb25zdCBudW1iZXJzID0ge1xuICBQQURESU5HOiAxMCxcbiAgSU5JVElBTF9PUklHSU5fU0NBTEU6IDAuNixcbiAgREVBQ1RJVkFUSU9OX1RJTUVPVVRfTVM6IDIyNSwgLy8gQ29ycmVzcG9uZHMgdG8gJG1kYy1yaXBwbGUtdHJhbnNsYXRlLWR1cmF0aW9uIChpLmUuIGFjdGl2YXRpb24gYW5pbWF0aW9uIGR1cmF0aW9uKVxuICBGR19ERUFDVElWQVRJT05fTVM6IDE1MCwgLy8gQ29ycmVzcG9uZHMgdG8gJG1kYy1yaXBwbGUtZmFkZS1vdXQtZHVyYXRpb24gKGkuZS4gZGVhY3RpdmF0aW9uIGFuaW1hdGlvbiBkdXJhdGlvbilcbiAgVEFQX0RFTEFZX01TOiAzMDAsIC8vIERlbGF5IGJldHdlZW4gdG91Y2ggYW5kIHNpbXVsYXRlZCBtb3VzZSBldmVudHMgb24gdG91Y2ggZGV2aWNlc1xufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIFN0b3JlcyByZXN1bHQgZnJvbSBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyB0byBhdm9pZCByZWR1bmRhbnQgcHJvY2Vzc2luZyB0byBkZXRlY3QgQ1NTIGN1c3RvbSB2YXJpYWJsZSBzdXBwb3J0LlxuICogQHByaXZhdGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICovXG5sZXQgc3VwcG9ydHNDc3NWYXJpYWJsZXNfO1xuXG4vKipcbiAqIFN0b3JlcyByZXN1bHQgZnJvbSBhcHBseVBhc3NpdmUgdG8gYXZvaWQgcmVkdW5kYW50IHByb2Nlc3NpbmcgdG8gZGV0ZWN0IHBhc3NpdmUgZXZlbnQgbGlzdGVuZXIgc3VwcG9ydC5cbiAqIEBwcml2YXRlIHtib29sZWFufHVuZGVmaW5lZH1cbiAqL1xubGV0IHN1cHBvcnRzUGFzc2l2ZV87XG5cbi8qKlxuICogQHBhcmFtIHshV2luZG93fSB3aW5kb3dPYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGRldGVjdEVkZ2VQc2V1ZG9WYXJCdWcod2luZG93T2JqKSB7XG4gIC8vIERldGVjdCB2ZXJzaW9ucyBvZiBFZGdlIHdpdGggYnVnZ3kgdmFyKCkgc3VwcG9ydFxuICAvLyBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzExNDk1NDQ4L1xuICBjb25zdCBkb2N1bWVudCA9IHdpbmRvd09iai5kb2N1bWVudDtcbiAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBub2RlLmNsYXNzTmFtZSA9ICdtZGMtcmlwcGxlLXN1cmZhY2UtLXRlc3QtZWRnZS12YXItYnVnJztcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChub2RlKTtcblxuICAvLyBUaGUgYnVnIGV4aXN0cyBpZiA6OmJlZm9yZSBzdHlsZSBlbmRzIHVwIHByb3BhZ2F0aW5nIHRvIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgLy8gQWRkaXRpb25hbGx5LCBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgbnVsbCBpbiBpZnJhbWVzIHdpdGggZGlzcGxheTogXCJub25lXCIgaW4gRmlyZWZveCxcbiAgLy8gYnV0IEZpcmVmb3ggaXMga25vd24gdG8gc3VwcG9ydCBDU1MgY3VzdG9tIHByb3BlcnRpZXMgY29ycmVjdGx5LlxuICAvLyBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU0ODM5N1xuICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93T2JqLmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gIGNvbnN0IGhhc1BzZXVkb1ZhckJ1ZyA9IGNvbXB1dGVkU3R5bGUgIT09IG51bGwgJiYgY29tcHV0ZWRTdHlsZS5ib3JkZXJUb3BTdHlsZSA9PT0gJ3NvbGlkJztcbiAgbm9kZS5yZW1vdmUoKTtcbiAgcmV0dXJuIGhhc1BzZXVkb1ZhckJ1Zztcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFXaW5kb3d9IHdpbmRvd09ialxuICogQHBhcmFtIHtib29sZWFuPX0gZm9yY2VSZWZyZXNoXG4gKiBAcmV0dXJuIHtib29sZWFufHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyh3aW5kb3dPYmosIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gIGxldCBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyA9IHN1cHBvcnRzQ3NzVmFyaWFibGVzXztcbiAgaWYgKHR5cGVvZiBzdXBwb3J0c0Nzc1ZhcmlhYmxlc18gPT09ICdib29sZWFuJyAmJiAhZm9yY2VSZWZyZXNoKSB7XG4gICAgcmV0dXJuIHN1cHBvcnRzQ3NzVmFyaWFibGVzO1xuICB9XG5cbiAgY29uc3Qgc3VwcG9ydHNGdW5jdGlvblByZXNlbnQgPSB3aW5kb3dPYmouQ1NTICYmIHR5cGVvZiB3aW5kb3dPYmouQ1NTLnN1cHBvcnRzID09PSAnZnVuY3Rpb24nO1xuICBpZiAoIXN1cHBvcnRzRnVuY3Rpb25QcmVzZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgZXhwbGljaXRseVN1cHBvcnRzQ3NzVmFycyA9IHdpbmRvd09iai5DU1Muc3VwcG9ydHMoJy0tY3NzLXZhcnMnLCAneWVzJyk7XG4gIC8vIFNlZTogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NDY2OVxuICAvLyBTZWU6IFJFQURNRSBzZWN0aW9uIG9uIFNhZmFyaVxuICBjb25zdCB3ZUFyZUZlYXR1cmVEZXRlY3RpbmdTYWZhcmkxMHBsdXMgPSAoXG4gICAgd2luZG93T2JqLkNTUy5zdXBwb3J0cygnKC0tY3NzLXZhcnM6IHllcyknKSAmJlxuICAgIHdpbmRvd09iai5DU1Muc3VwcG9ydHMoJ2NvbG9yJywgJyMwMDAwMDAwMCcpXG4gICk7XG5cbiAgaWYgKGV4cGxpY2l0bHlTdXBwb3J0c0Nzc1ZhcnMgfHwgd2VBcmVGZWF0dXJlRGV0ZWN0aW5nU2FmYXJpMTBwbHVzKSB7XG4gICAgc3VwcG9ydHNDc3NWYXJpYWJsZXMgPSAhZGV0ZWN0RWRnZVBzZXVkb1ZhckJ1Zyh3aW5kb3dPYmopO1xuICB9IGVsc2Uge1xuICAgIHN1cHBvcnRzQ3NzVmFyaWFibGVzID0gZmFsc2U7XG4gIH1cblxuICBpZiAoIWZvcmNlUmVmcmVzaCkge1xuICAgIHN1cHBvcnRzQ3NzVmFyaWFibGVzXyA9IHN1cHBvcnRzQ3NzVmFyaWFibGVzO1xuICB9XG4gIHJldHVybiBzdXBwb3J0c0Nzc1ZhcmlhYmxlcztcbn1cblxuLy9cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGN1cnJlbnQgYnJvd3NlciBzdXBwb3J0cyBwYXNzaXZlIGV2ZW50IGxpc3RlbmVycywgYW5kIGlmIHNvLCB1c2UgdGhlbS5cbiAqIEBwYXJhbSB7IVdpbmRvdz19IGdsb2JhbE9ialxuICogQHBhcmFtIHtib29sZWFuPX0gZm9yY2VSZWZyZXNoXG4gKiBAcmV0dXJuIHtib29sZWFufHtwYXNzaXZlOiBib29sZWFufX1cbiAqL1xuZnVuY3Rpb24gYXBwbHlQYXNzaXZlKGdsb2JhbE9iaiA9IHdpbmRvdywgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgaWYgKHN1cHBvcnRzUGFzc2l2ZV8gPT09IHVuZGVmaW5lZCB8fCBmb3JjZVJlZnJlc2gpIHtcbiAgICBsZXQgaXNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgZ2xvYmFsT2JqLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCB7Z2V0IHBhc3NpdmUoKSB7XG4gICAgICAgIGlzU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgIH19KTtcbiAgICB9IGNhdGNoIChlKSB7IH1cblxuICAgIHN1cHBvcnRzUGFzc2l2ZV8gPSBpc1N1cHBvcnRlZDtcbiAgfVxuXG4gIHJldHVybiBzdXBwb3J0c1Bhc3NpdmVfID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHshT2JqZWN0fSBIVE1MRWxlbWVudFByb3RvdHlwZVxuICogQHJldHVybiB7IUFycmF5PHN0cmluZz59XG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoZXNQcm9wZXJ0eShIVE1MRWxlbWVudFByb3RvdHlwZSkge1xuICByZXR1cm4gW1xuICAgICd3ZWJraXRNYXRjaGVzU2VsZWN0b3InLCAnbXNNYXRjaGVzU2VsZWN0b3InLCAnbWF0Y2hlcycsXG4gIF0uZmlsdGVyKChwKSA9PiBwIGluIEhUTUxFbGVtZW50UHJvdG90eXBlKS5wb3AoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFFdmVudH0gZXZcbiAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcGFnZU9mZnNldFxuICogQHBhcmFtIHshQ2xpZW50UmVjdH0gY2xpZW50UmVjdFxuICogQHJldHVybiB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzKGV2LCBwYWdlT2Zmc2V0LCBjbGllbnRSZWN0KSB7XG4gIGNvbnN0IHt4LCB5fSA9IHBhZ2VPZmZzZXQ7XG4gIGNvbnN0IGRvY3VtZW50WCA9IHggKyBjbGllbnRSZWN0LmxlZnQ7XG4gIGNvbnN0IGRvY3VtZW50WSA9IHkgKyBjbGllbnRSZWN0LnRvcDtcblxuICBsZXQgbm9ybWFsaXplZFg7XG4gIGxldCBub3JtYWxpemVkWTtcbiAgLy8gRGV0ZXJtaW5lIHRvdWNoIHBvaW50IHJlbGF0aXZlIHRvIHRoZSByaXBwbGUgY29udGFpbmVyLlxuICBpZiAoZXYudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgbm9ybWFsaXplZFggPSBldi5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCAtIGRvY3VtZW50WDtcbiAgICBub3JtYWxpemVkWSA9IGV2LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZIC0gZG9jdW1lbnRZO1xuICB9IGVsc2Uge1xuICAgIG5vcm1hbGl6ZWRYID0gZXYucGFnZVggLSBkb2N1bWVudFg7XG4gICAgbm9ybWFsaXplZFkgPSBldi5wYWdlWSAtIGRvY3VtZW50WTtcbiAgfVxuXG4gIHJldHVybiB7eDogbm9ybWFsaXplZFgsIHk6IG5vcm1hbGl6ZWRZfTtcbn1cblxuZXhwb3J0IHtzdXBwb3J0c0Nzc1ZhcmlhYmxlcywgYXBwbHlQYXNzaXZlLCBnZXRNYXRjaGVzUHJvcGVydHksIGdldE5vcm1hbGl6ZWRFdmVudENvb3Jkc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDUmlwcGxlQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQge2dldE5vcm1hbGl6ZWRFdmVudENvb3Jkc30gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBpc0FjdGl2YXRlZDogKGJvb2xlYW58dW5kZWZpbmVkKSxcbiAqICAgaGFzRGVhY3RpdmF0aW9uVVhSdW46IChib29sZWFufHVuZGVmaW5lZCksXG4gKiAgIHdhc0FjdGl2YXRlZEJ5UG9pbnRlcjogKGJvb2xlYW58dW5kZWZpbmVkKSxcbiAqICAgd2FzRWxlbWVudE1hZGVBY3RpdmU6IChib29sZWFufHVuZGVmaW5lZCksXG4gKiAgIGFjdGl2YXRpb25FdmVudDogRXZlbnQsXG4gKiAgIGlzUHJvZ3JhbW1hdGljOiAoYm9vbGVhbnx1bmRlZmluZWQpXG4gKiB9fVxuICovXG5sZXQgQWN0aXZhdGlvblN0YXRlVHlwZTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBhY3RpdmF0ZTogKHN0cmluZ3x1bmRlZmluZWQpLFxuICogICBkZWFjdGl2YXRlOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gKiAgIGZvY3VzOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gKiAgIGJsdXI6IChzdHJpbmd8dW5kZWZpbmVkKVxuICogfX1cbiAqL1xubGV0IExpc3RlbmVySW5mb1R5cGU7XG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgYWN0aXZhdGU6IGZ1bmN0aW9uKCFFdmVudCksXG4gKiAgIGRlYWN0aXZhdGU6IGZ1bmN0aW9uKCFFdmVudCksXG4gKiAgIGZvY3VzOiBmdW5jdGlvbigpLFxuICogICBibHVyOiBmdW5jdGlvbigpXG4gKiB9fVxuICovXG5sZXQgTGlzdGVuZXJzVHlwZTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICB4OiBudW1iZXIsXG4gKiAgIHk6IG51bWJlclxuICogfX1cbiAqL1xubGV0IFBvaW50VHlwZTtcblxuLy8gQWN0aXZhdGlvbiBldmVudHMgcmVnaXN0ZXJlZCBvbiB0aGUgcm9vdCBlbGVtZW50IG9mIGVhY2ggaW5zdGFuY2UgZm9yIGFjdGl2YXRpb25cbmNvbnN0IEFDVElWQVRJT05fRVZFTlRfVFlQRVMgPSBbJ3RvdWNoc3RhcnQnLCAncG9pbnRlcmRvd24nLCAnbW91c2Vkb3duJywgJ2tleWRvd24nXTtcblxuLy8gRGVhY3RpdmF0aW9uIGV2ZW50cyByZWdpc3RlcmVkIG9uIGRvY3VtZW50RWxlbWVudCB3aGVuIGEgcG9pbnRlci1yZWxhdGVkIGRvd24gZXZlbnQgb2NjdXJzXG5jb25zdCBQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFUyA9IFsndG91Y2hlbmQnLCAncG9pbnRlcnVwJywgJ21vdXNldXAnXTtcblxuLy8gVHJhY2tzIGFjdGl2YXRpb25zIHRoYXQgaGF2ZSBvY2N1cnJlZCBvbiB0aGUgY3VycmVudCBmcmFtZSwgdG8gYXZvaWQgc2ltdWx0YW5lb3VzIG5lc3RlZCBhY3RpdmF0aW9uc1xuLyoqIEB0eXBlIHshQXJyYXk8IUV2ZW50VGFyZ2V0Pn0gKi9cbmxldCBhY3RpdmF0ZWRUYXJnZXRzID0gW107XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ1JpcHBsZUFkYXB0ZXI+fVxuICovXG5jbGFzcyBNRENSaXBwbGVGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICByZXR1cm4gbnVtYmVycztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJyb3dzZXJTdXBwb3J0c0Nzc1ZhcnM6ICgpID0+IC8qIGJvb2xlYW4gLSBjYWNoZWQgKi8ge30sXG4gICAgICBpc1VuYm91bmRlZDogKCkgPT4gLyogYm9vbGVhbiAqLyB7fSxcbiAgICAgIGlzU3VyZmFjZUFjdGl2ZTogKCkgPT4gLyogYm9vbGVhbiAqLyB7fSxcbiAgICAgIGlzU3VyZmFjZURpc2FibGVkOiAoKSA9PiAvKiBib29sZWFuICovIHt9LFxuICAgICAgYWRkQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGNvbnRhaW5zRXZlbnRUYXJnZXQ6ICgvKiB0YXJnZXQ6ICFFdmVudFRhcmdldCAqLykgPT4ge30sXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dFR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0VHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnRUeXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0VHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHVwZGF0ZUNzc1ZhcmlhYmxlOiAoLyogdmFyTmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGNvbXB1dGVCb3VuZGluZ1JlY3Q6ICgpID0+IC8qIENsaWVudFJlY3QgKi8ge30sXG4gICAgICBnZXRXaW5kb3dQYWdlT2Zmc2V0OiAoKSA9PiAvKiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9ICovIHt9LFxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENSaXBwbGVGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLmxheW91dEZyYW1lXyA9IDA7XG5cbiAgICAvKiogQHByaXZhdGUgeyFDbGllbnRSZWN0fSAqL1xuICAgIHRoaXMuZnJhbWVfID0gLyoqIEB0eXBlIHshQ2xpZW50UmVjdH0gKi8gKHt3aWR0aDogMCwgaGVpZ2h0OiAwfSk7XG5cbiAgICAvKiogQHByaXZhdGUgeyFBY3RpdmF0aW9uU3RhdGVUeXBlfSAqL1xuICAgIHRoaXMuYWN0aXZhdGlvblN0YXRlXyA9IHRoaXMuZGVmYXVsdEFjdGl2YXRpb25TdGF0ZV8oKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuaW5pdGlhbFNpemVfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMubWF4UmFkaXVzXyA9IDA7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCl9ICovXG4gICAgdGhpcy5hY3RpdmF0ZUhhbmRsZXJfID0gKGUpID0+IHRoaXMuYWN0aXZhdGVfKGUpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpfSAqL1xuICAgIHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXJfID0gKGUpID0+IHRoaXMuZGVhY3RpdmF0ZV8oZSk7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKD9FdmVudD0pfSAqL1xuICAgIHRoaXMuZm9jdXNIYW5kbGVyXyA9ICgpID0+IHRoaXMuaGFuZGxlRm9jdXMoKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oP0V2ZW50PSl9ICovXG4gICAgdGhpcy5ibHVySGFuZGxlcl8gPSAoKSA9PiB0aGlzLmhhbmRsZUJsdXIoKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUZ1bmN0aW9ufSAqL1xuICAgIHRoaXMucmVzaXplSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmxheW91dCgpO1xuXG4gICAgLyoqIEBwcml2YXRlIHt7bGVmdDogbnVtYmVyLCB0b3A6bnVtYmVyfX0gKi9cbiAgICB0aGlzLnVuYm91bmRlZENvb3Jkc18gPSB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgIH07XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLmZnU2NhbGVfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuYWN0aXZhdGlvblRpbWVyXyA9IDA7XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLmZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyXyA9IDA7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5hY3RpdmF0aW9uQW5pbWF0aW9uSGFzRW5kZWRfID0gZmFsc2U7XG5cbiAgICAvKiogQHByaXZhdGUgeyFGdW5jdGlvbn0gKi9cbiAgICB0aGlzLmFjdGl2YXRpb25UaW1lckNhbGxiYWNrXyA9ICgpID0+IHtcbiAgICAgIHRoaXMuYWN0aXZhdGlvbkFuaW1hdGlvbkhhc0VuZGVkXyA9IHRydWU7XG4gICAgICB0aGlzLnJ1bkRlYWN0aXZhdGlvblVYTG9naWNJZlJlYWR5XygpO1xuICAgIH07XG5cbiAgICAvKiogQHByaXZhdGUgez9FdmVudH0gKi9cbiAgICB0aGlzLnByZXZpb3VzQWN0aXZhdGlvbkV2ZW50XyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogV2UgY29tcHV0ZSB0aGlzIHByb3BlcnR5IHNvIHRoYXQgd2UgYXJlIG5vdCBxdWVyeWluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2xpZW50XG4gICAqIHVudGlsIHRoZSBwb2ludCBpbiB0aW1lIHdoZXJlIHRoZSBmb3VuZGF0aW9uIHJlcXVlc3RzIGl0LiBUaGlzIHByZXZlbnRzIHNjZW5hcmlvcyB3aGVyZVxuICAgKiBjbGllbnQtc2lkZSBmZWF0dXJlLWRldGVjdGlvbiBtYXkgaGFwcGVuIHRvbyBlYXJseSwgc3VjaCBhcyB3aGVuIGNvbXBvbmVudHMgYXJlIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXJcbiAgICogYW5kIHRoZW4gaW5pdGlhbGl6ZWQgYXQgbW91bnQgdGltZSBvbiB0aGUgY2xpZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNTdXBwb3J0ZWRfKCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmJyb3dzZXJTdXBwb3J0c0Nzc1ZhcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshQWN0aXZhdGlvblN0YXRlVHlwZX1cbiAgICovXG4gIGRlZmF1bHRBY3RpdmF0aW9uU3RhdGVfKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpc0FjdGl2YXRlZDogZmFsc2UsXG4gICAgICBoYXNEZWFjdGl2YXRpb25VWFJ1bjogZmFsc2UsXG4gICAgICB3YXNBY3RpdmF0ZWRCeVBvaW50ZXI6IGZhbHNlLFxuICAgICAgd2FzRWxlbWVudE1hZGVBY3RpdmU6IGZhbHNlLFxuICAgICAgYWN0aXZhdGlvbkV2ZW50OiBudWxsLFxuICAgICAgaXNQcm9ncmFtbWF0aWM6IGZhbHNlLFxuICAgIH07XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGluaXQoKSB7XG4gICAgaWYgKCF0aGlzLmlzU3VwcG9ydGVkXygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVnaXN0ZXJSb290SGFuZGxlcnNfKCk7XG5cbiAgICBjb25zdCB7Uk9PVCwgVU5CT1VOREVEfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhST09UKTtcbiAgICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzVW5ib3VuZGVkKCkpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhVTkJPVU5ERUQpO1xuICAgICAgICAvLyBVbmJvdW5kZWQgcmlwcGxlcyBuZWVkIGxheW91dCBsb2dpYyBhcHBsaWVkIGltbWVkaWF0ZWx5IHRvIHNldCBjb29yZGluYXRlcyBmb3IgYm90aCBzaGFkZSBhbmQgcmlwcGxlXG4gICAgICAgIHRoaXMubGF5b3V0SW50ZXJuYWxfKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKCF0aGlzLmlzU3VwcG9ydGVkXygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWN0aXZhdGlvblRpbWVyXykge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYWN0aXZhdGlvblRpbWVyXyk7XG4gICAgICB0aGlzLmFjdGl2YXRpb25UaW1lcl8gPSAwO1xuICAgICAgY29uc3Qge0ZHX0FDVElWQVRJT059ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhGR19BQ1RJVkFUSU9OKTtcbiAgICB9XG5cbiAgICB0aGlzLmRlcmVnaXN0ZXJSb290SGFuZGxlcnNfKCk7XG4gICAgdGhpcy5kZXJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfKCk7XG5cbiAgICBjb25zdCB7Uk9PVCwgVU5CT1VOREVEfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhST09UKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoVU5CT1VOREVEKTtcbiAgICAgIHRoaXMucmVtb3ZlQ3NzVmFyc18oKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICByZWdpc3RlclJvb3RIYW5kbGVyc18oKSB7XG4gICAgQUNUSVZBVElPTl9FVkVOVF9UWVBFUy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIHRoaXMuYWN0aXZhdGVIYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignZm9jdXMnLCB0aGlzLmZvY3VzSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyXyk7XG5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc1VuYm91bmRlZCgpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfKGUpIHtcbiAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleXVwJywgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcl8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFUy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcih0eXBlLCB0aGlzLmRlYWN0aXZhdGVIYW5kbGVyXyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgZGVyZWdpc3RlclJvb3RIYW5kbGVyc18oKSB7XG4gICAgQUNUSVZBVElPTl9FVkVOVF9UWVBFUy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgdGhpcy5hY3RpdmF0ZUhhbmRsZXJfKTtcbiAgICB9KTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyXyk7XG5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc1VuYm91bmRlZCgpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBkZXJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5dXAnLCB0aGlzLmRlYWN0aXZhdGVIYW5kbGVyXyk7XG4gICAgUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcl8pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJlbW92ZUNzc1ZhcnNfKCkge1xuICAgIGNvbnN0IHtzdHJpbmdzfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb247XG4gICAgT2JqZWN0LmtleXMoc3RyaW5ncykuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgaWYgKGsuaW5kZXhPZignVkFSXycpID09PSAwKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoc3RyaW5nc1trXSwgbnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHs/RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFjdGl2YXRlXyhlKSB7XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNTdXJmYWNlRGlzYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdGl2YXRpb25TdGF0ZSA9IHRoaXMuYWN0aXZhdGlvblN0YXRlXztcbiAgICBpZiAoYWN0aXZhdGlvblN0YXRlLmlzQWN0aXZhdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQXZvaWQgcmVhY3RpbmcgdG8gZm9sbG93LW9uIGV2ZW50cyBmaXJlZCBieSB0b3VjaCBkZXZpY2UgYWZ0ZXIgYW4gYWxyZWFkeS1wcm9jZXNzZWQgdXNlciBpbnRlcmFjdGlvblxuICAgIGNvbnN0IHByZXZpb3VzQWN0aXZhdGlvbkV2ZW50ID0gdGhpcy5wcmV2aW91c0FjdGl2YXRpb25FdmVudF87XG4gICAgY29uc3QgaXNTYW1lSW50ZXJhY3Rpb24gPSBwcmV2aW91c0FjdGl2YXRpb25FdmVudCAmJiBlICYmIHByZXZpb3VzQWN0aXZhdGlvbkV2ZW50LnR5cGUgIT09IGUudHlwZTtcbiAgICBpZiAoaXNTYW1lSW50ZXJhY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhY3RpdmF0aW9uU3RhdGUuaXNBY3RpdmF0ZWQgPSB0cnVlO1xuICAgIGFjdGl2YXRpb25TdGF0ZS5pc1Byb2dyYW1tYXRpYyA9IGUgPT09IG51bGw7XG4gICAgYWN0aXZhdGlvblN0YXRlLmFjdGl2YXRpb25FdmVudCA9IGU7XG4gICAgYWN0aXZhdGlvblN0YXRlLndhc0FjdGl2YXRlZEJ5UG9pbnRlciA9IGFjdGl2YXRpb25TdGF0ZS5pc1Byb2dyYW1tYXRpYyA/IGZhbHNlIDogKFxuICAgICAgZS50eXBlID09PSAnbW91c2Vkb3duJyB8fCBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyB8fCBlLnR5cGUgPT09ICdwb2ludGVyZG93bidcbiAgICApO1xuXG4gICAgY29uc3QgaGFzQWN0aXZhdGVkQ2hpbGQgPVxuICAgICAgZSAmJiBhY3RpdmF0ZWRUYXJnZXRzLmxlbmd0aCA+IDAgJiYgYWN0aXZhdGVkVGFyZ2V0cy5zb21lKCh0YXJnZXQpID0+IHRoaXMuYWRhcHRlcl8uY29udGFpbnNFdmVudFRhcmdldCh0YXJnZXQpKTtcbiAgICBpZiAoaGFzQWN0aXZhdGVkQ2hpbGQpIHtcbiAgICAgIC8vIEltbWVkaWF0ZWx5IHJlc2V0IGFjdGl2YXRpb24gc3RhdGUsIHdoaWxlIHByZXNlcnZpbmcgbG9naWMgdGhhdCBwcmV2ZW50cyB0b3VjaCBmb2xsb3ctb24gZXZlbnRzXG4gICAgICB0aGlzLnJlc2V0QWN0aXZhdGlvblN0YXRlXygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlKSB7XG4gICAgICBhY3RpdmF0ZWRUYXJnZXRzLnB1c2goLyoqIEB0eXBlIHshRXZlbnRUYXJnZXR9ICovIChlLnRhcmdldCkpO1xuICAgICAgdGhpcy5yZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXyhlKTtcbiAgICB9XG5cbiAgICBhY3RpdmF0aW9uU3RhdGUud2FzRWxlbWVudE1hZGVBY3RpdmUgPSB0aGlzLmNoZWNrRWxlbWVudE1hZGVBY3RpdmVfKGUpO1xuICAgIGlmIChhY3RpdmF0aW9uU3RhdGUud2FzRWxlbWVudE1hZGVBY3RpdmUpIHtcbiAgICAgIHRoaXMuYW5pbWF0ZUFjdGl2YXRpb25fKCk7XG4gICAgfVxuXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIC8vIFJlc2V0IGFycmF5IG9uIG5leHQgZnJhbWUgYWZ0ZXIgdGhlIGN1cnJlbnQgZXZlbnQgaGFzIGhhZCBhIGNoYW5jZSB0byBidWJibGUgdG8gcHJldmVudCBhbmNlc3RvciByaXBwbGVzXG4gICAgICBhY3RpdmF0ZWRUYXJnZXRzID0gW107XG5cbiAgICAgIGlmICghYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlICYmIChlLmtleSA9PT0gJyAnIHx8IGUua2V5Q29kZSA9PT0gMzIpKSB7XG4gICAgICAgIC8vIElmIHNwYWNlIHdhcyBwcmVzc2VkLCB0cnkgYWdhaW4gd2l0aGluIGFuIHJBRiBjYWxsIHRvIGRldGVjdCA6YWN0aXZlLCBiZWNhdXNlIGRpZmZlcmVudCBVQXMgcmVwb3J0XG4gICAgICAgIC8vIGFjdGl2ZSBzdGF0ZXMgaW5jb25zaXN0ZW50bHkgd2hlbiB0aGV5J3JlIGNhbGxlZCB3aXRoaW4gZXZlbnQgaGFuZGxpbmcgY29kZTpcbiAgICAgICAgLy8gLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MzU5NzFcbiAgICAgICAgLy8gLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjkzNzQxXG4gICAgICAgIC8vIFdlIHRyeSBmaXJzdCBvdXRzaWRlIHJBRiB0byBzdXBwb3J0IEVkZ2UsIHdoaWNoIGRvZXMgbm90IGV4aGliaXQgdGhpcyBwcm9ibGVtLCBidXQgd2lsbCBjcmFzaCBpZiBhIENTU1xuICAgICAgICAvLyB2YXJpYWJsZSBpcyBzZXQgd2l0aGluIGEgckFGIGNhbGxiYWNrIGZvciBhIHN1Ym1pdCBidXR0b24gaW50ZXJhY3Rpb24gKCMyMjQxKS5cbiAgICAgICAgYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlID0gdGhpcy5jaGVja0VsZW1lbnRNYWRlQWN0aXZlXyhlKTtcbiAgICAgICAgaWYgKGFjdGl2YXRpb25TdGF0ZS53YXNFbGVtZW50TWFkZUFjdGl2ZSkge1xuICAgICAgICAgIHRoaXMuYW5pbWF0ZUFjdGl2YXRpb25fKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFhY3RpdmF0aW9uU3RhdGUud2FzRWxlbWVudE1hZGVBY3RpdmUpIHtcbiAgICAgICAgLy8gUmVzZXQgYWN0aXZhdGlvbiBzdGF0ZSBpbW1lZGlhdGVseSBpZiBlbGVtZW50IHdhcyBub3QgbWFkZSBhY3RpdmUuXG4gICAgICAgIHRoaXMuYWN0aXZhdGlvblN0YXRlXyA9IHRoaXMuZGVmYXVsdEFjdGl2YXRpb25TdGF0ZV8oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gez9FdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2hlY2tFbGVtZW50TWFkZUFjdGl2ZV8oZSkge1xuICAgIHJldHVybiAoZSAmJiBlLnR5cGUgPT09ICdrZXlkb3duJykgPyB0aGlzLmFkYXB0ZXJfLmlzU3VyZmFjZUFjdGl2ZSgpIDogdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gez9FdmVudD19IGV2ZW50IE9wdGlvbmFsIGV2ZW50IGNvbnRhaW5pbmcgcG9zaXRpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuICBhY3RpdmF0ZShldmVudCA9IG51bGwpIHtcbiAgICB0aGlzLmFjdGl2YXRlXyhldmVudCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgYW5pbWF0ZUFjdGl2YXRpb25fKCkge1xuICAgIGNvbnN0IHtWQVJfRkdfVFJBTlNMQVRFX1NUQVJULCBWQVJfRkdfVFJBTlNMQVRFX0VORH0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLnN0cmluZ3M7XG4gICAgY29uc3Qge0ZHX0RFQUNUSVZBVElPTiwgRkdfQUNUSVZBVElPTn0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgY29uc3Qge0RFQUNUSVZBVElPTl9USU1FT1VUX01TfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24ubnVtYmVycztcblxuICAgIHRoaXMubGF5b3V0SW50ZXJuYWxfKCk7XG5cbiAgICBsZXQgdHJhbnNsYXRlU3RhcnQgPSAnJztcbiAgICBsZXQgdHJhbnNsYXRlRW5kID0gJyc7XG5cbiAgICBpZiAoIXRoaXMuYWRhcHRlcl8uaXNVbmJvdW5kZWQoKSkge1xuICAgICAgY29uc3Qge3N0YXJ0UG9pbnQsIGVuZFBvaW50fSA9IHRoaXMuZ2V0RmdUcmFuc2xhdGlvbkNvb3JkaW5hdGVzXygpO1xuICAgICAgdHJhbnNsYXRlU3RhcnQgPSBgJHtzdGFydFBvaW50Lnh9cHgsICR7c3RhcnRQb2ludC55fXB4YDtcbiAgICAgIHRyYW5zbGF0ZUVuZCA9IGAke2VuZFBvaW50Lnh9cHgsICR7ZW5kUG9pbnQueX1weGA7XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfVFJBTlNMQVRFX1NUQVJULCB0cmFuc2xhdGVTdGFydCk7XG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfVFJBTlNMQVRFX0VORCwgdHJhbnNsYXRlRW5kKTtcbiAgICAvLyBDYW5jZWwgYW55IG9uZ29pbmcgYWN0aXZhdGlvbi9kZWFjdGl2YXRpb24gYW5pbWF0aW9uc1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmFjdGl2YXRpb25UaW1lcl8pO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyXyk7XG4gICAgdGhpcy5ybUJvdW5kZWRBY3RpdmF0aW9uQ2xhc3Nlc18oKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKEZHX0RFQUNUSVZBVElPTik7XG5cbiAgICAvLyBGb3JjZSBsYXlvdXQgaW4gb3JkZXIgdG8gcmUtdHJpZ2dlciB0aGUgYW5pbWF0aW9uLlxuICAgIHRoaXMuYWRhcHRlcl8uY29tcHV0ZUJvdW5kaW5nUmVjdCgpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoRkdfQUNUSVZBVElPTik7XG4gICAgdGhpcy5hY3RpdmF0aW9uVGltZXJfID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmFjdGl2YXRpb25UaW1lckNhbGxiYWNrXygpLCBERUFDVElWQVRJT05fVElNRU9VVF9NUyk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7e3N0YXJ0UG9pbnQ6IFBvaW50VHlwZSwgZW5kUG9pbnQ6IFBvaW50VHlwZX19XG4gICAqL1xuICBnZXRGZ1RyYW5zbGF0aW9uQ29vcmRpbmF0ZXNfKCkge1xuICAgIGNvbnN0IHthY3RpdmF0aW9uRXZlbnQsIHdhc0FjdGl2YXRlZEJ5UG9pbnRlcn0gPSB0aGlzLmFjdGl2YXRpb25TdGF0ZV87XG5cbiAgICBsZXQgc3RhcnRQb2ludDtcbiAgICBpZiAod2FzQWN0aXZhdGVkQnlQb2ludGVyKSB7XG4gICAgICBzdGFydFBvaW50ID0gZ2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzKFxuICAgICAgICAvKiogQHR5cGUgeyFFdmVudH0gKi8gKGFjdGl2YXRpb25FdmVudCksXG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZ2V0V2luZG93UGFnZU9mZnNldCgpLCB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRQb2ludCA9IHtcbiAgICAgICAgeDogdGhpcy5mcmFtZV8ud2lkdGggLyAyLFxuICAgICAgICB5OiB0aGlzLmZyYW1lXy5oZWlnaHQgLyAyLFxuICAgICAgfTtcbiAgICB9XG4gICAgLy8gQ2VudGVyIHRoZSBlbGVtZW50IGFyb3VuZCB0aGUgc3RhcnQgcG9pbnQuXG4gICAgc3RhcnRQb2ludCA9IHtcbiAgICAgIHg6IHN0YXJ0UG9pbnQueCAtICh0aGlzLmluaXRpYWxTaXplXyAvIDIpLFxuICAgICAgeTogc3RhcnRQb2ludC55IC0gKHRoaXMuaW5pdGlhbFNpemVfIC8gMiksXG4gICAgfTtcblxuICAgIGNvbnN0IGVuZFBvaW50ID0ge1xuICAgICAgeDogKHRoaXMuZnJhbWVfLndpZHRoIC8gMikgLSAodGhpcy5pbml0aWFsU2l6ZV8gLyAyKSxcbiAgICAgIHk6ICh0aGlzLmZyYW1lXy5oZWlnaHQgLyAyKSAtICh0aGlzLmluaXRpYWxTaXplXyAvIDIpLFxuICAgIH07XG5cbiAgICByZXR1cm4ge3N0YXJ0UG9pbnQsIGVuZFBvaW50fTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBydW5EZWFjdGl2YXRpb25VWExvZ2ljSWZSZWFkeV8oKSB7XG4gICAgLy8gVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJvdGggd2hlbiBhIHBvaW50aW5nIGRldmljZSBpcyByZWxlYXNlZCwgYW5kIHdoZW4gdGhlIGFjdGl2YXRpb24gYW5pbWF0aW9uIGVuZHMuXG4gICAgLy8gVGhlIGRlYWN0aXZhdGlvbiBhbmltYXRpb24gc2hvdWxkIG9ubHkgcnVuIGFmdGVyIGJvdGggb2YgdGhvc2Ugb2NjdXIuXG4gICAgY29uc3Qge0ZHX0RFQUNUSVZBVElPTn0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgY29uc3Qge2hhc0RlYWN0aXZhdGlvblVYUnVuLCBpc0FjdGl2YXRlZH0gPSB0aGlzLmFjdGl2YXRpb25TdGF0ZV87XG4gICAgY29uc3QgYWN0aXZhdGlvbkhhc0VuZGVkID0gaGFzRGVhY3RpdmF0aW9uVVhSdW4gfHwgIWlzQWN0aXZhdGVkO1xuXG4gICAgaWYgKGFjdGl2YXRpb25IYXNFbmRlZCAmJiB0aGlzLmFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF8pIHtcbiAgICAgIHRoaXMucm1Cb3VuZGVkQWN0aXZhdGlvbkNsYXNzZXNfKCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKEZHX0RFQUNUSVZBVElPTik7XG4gICAgICB0aGlzLmZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyXyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKEZHX0RFQUNUSVZBVElPTik7XG4gICAgICB9LCBudW1iZXJzLkZHX0RFQUNUSVZBVElPTl9NUyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJtQm91bmRlZEFjdGl2YXRpb25DbGFzc2VzXygpIHtcbiAgICBjb25zdCB7RkdfQUNUSVZBVElPTn0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhGR19BQ1RJVkFUSU9OKTtcbiAgICB0aGlzLmFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF8gPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKTtcbiAgfVxuXG4gIHJlc2V0QWN0aXZhdGlvblN0YXRlXygpIHtcbiAgICB0aGlzLnByZXZpb3VzQWN0aXZhdGlvbkV2ZW50XyA9IHRoaXMuYWN0aXZhdGlvblN0YXRlXy5hY3RpdmF0aW9uRXZlbnQ7XG4gICAgdGhpcy5hY3RpdmF0aW9uU3RhdGVfID0gdGhpcy5kZWZhdWx0QWN0aXZhdGlvblN0YXRlXygpO1xuICAgIC8vIFRvdWNoIGRldmljZXMgbWF5IGZpcmUgYWRkaXRpb25hbCBldmVudHMgZm9yIHRoZSBzYW1lIGludGVyYWN0aW9uIHdpdGhpbiBhIHNob3J0IHRpbWUuXG4gICAgLy8gU3RvcmUgdGhlIHByZXZpb3VzIGV2ZW50IHVudGlsIGl0J3Mgc2FmZSB0byBhc3N1bWUgdGhhdCBzdWJzZXF1ZW50IGV2ZW50cyBhcmUgZm9yIG5ldyBpbnRlcmFjdGlvbnMuXG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnByZXZpb3VzQWN0aXZhdGlvbkV2ZW50XyA9IG51bGwsIE1EQ1JpcHBsZUZvdW5kYXRpb24ubnVtYmVycy5UQVBfREVMQVlfTVMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7P0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZWFjdGl2YXRlXyhlKSB7XG4gICAgY29uc3QgYWN0aXZhdGlvblN0YXRlID0gdGhpcy5hY3RpdmF0aW9uU3RhdGVfO1xuICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpbiBzY2VuYXJpb3Mgc3VjaCBhcyB3aGVuIHlvdSBoYXZlIGEga2V5dXAgZXZlbnQgdGhhdCBibHVycyB0aGUgZWxlbWVudC5cbiAgICBpZiAoIWFjdGl2YXRpb25TdGF0ZS5pc0FjdGl2YXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXRlID0gLyoqIEB0eXBlIHshQWN0aXZhdGlvblN0YXRlVHlwZX0gKi8gKE9iamVjdC5hc3NpZ24oe30sIGFjdGl2YXRpb25TdGF0ZSkpO1xuXG4gICAgaWYgKGFjdGl2YXRpb25TdGF0ZS5pc1Byb2dyYW1tYXRpYykge1xuICAgICAgY29uc3QgZXZ0T2JqZWN0ID0gbnVsbDtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmFuaW1hdGVEZWFjdGl2YXRpb25fKGV2dE9iamVjdCwgc3RhdGUpKTtcbiAgICAgIHRoaXMucmVzZXRBY3RpdmF0aW9uU3RhdGVfKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVyZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXygpO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgdGhpcy5hY3RpdmF0aW9uU3RhdGVfLmhhc0RlYWN0aXZhdGlvblVYUnVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hbmltYXRlRGVhY3RpdmF0aW9uXyhlLCBzdGF0ZSk7XG4gICAgICAgIHRoaXMucmVzZXRBY3RpdmF0aW9uU3RhdGVfKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHs/RXZlbnQ9fSBldmVudCBPcHRpb25hbCBldmVudCBjb250YWluaW5nIHBvc2l0aW9uIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgZGVhY3RpdmF0ZShldmVudCA9IG51bGwpIHtcbiAgICB0aGlzLmRlYWN0aXZhdGVfKGV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwYXJhbSB7IUFjdGl2YXRpb25TdGF0ZVR5cGV9IG9wdGlvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFuaW1hdGVEZWFjdGl2YXRpb25fKGUsIHt3YXNBY3RpdmF0ZWRCeVBvaW50ZXIsIHdhc0VsZW1lbnRNYWRlQWN0aXZlfSkge1xuICAgIGlmICh3YXNBY3RpdmF0ZWRCeVBvaW50ZXIgfHwgd2FzRWxlbWVudE1hZGVBY3RpdmUpIHtcbiAgICAgIHRoaXMucnVuRGVhY3RpdmF0aW9uVVhMb2dpY0lmUmVhZHlfKCk7XG4gICAgfVxuICB9XG5cbiAgbGF5b3V0KCkge1xuICAgIGlmICh0aGlzLmxheW91dEZyYW1lXykge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5sYXlvdXRGcmFtZV8pO1xuICAgIH1cbiAgICB0aGlzLmxheW91dEZyYW1lXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmxheW91dEludGVybmFsXygpO1xuICAgICAgdGhpcy5sYXlvdXRGcmFtZV8gPSAwO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGxheW91dEludGVybmFsXygpIHtcbiAgICB0aGlzLmZyYW1lXyA9IHRoaXMuYWRhcHRlcl8uY29tcHV0ZUJvdW5kaW5nUmVjdCgpO1xuICAgIGNvbnN0IG1heERpbSA9IE1hdGgubWF4KHRoaXMuZnJhbWVfLmhlaWdodCwgdGhpcy5mcmFtZV8ud2lkdGgpO1xuXG4gICAgLy8gU3VyZmFjZSBkaWFtZXRlciBpcyB0cmVhdGVkIGRpZmZlcmVudGx5IGZvciB1bmJvdW5kZWQgdnMuIGJvdW5kZWQgcmlwcGxlcy5cbiAgICAvLyBVbmJvdW5kZWQgcmlwcGxlIGRpYW1ldGVyIGlzIGNhbGN1bGF0ZWQgc21hbGxlciBzaW5jZSB0aGUgc3VyZmFjZSBpcyBleHBlY3RlZCB0byBhbHJlYWR5IGJlIHBhZGRlZCBhcHByb3ByaWF0ZWx5XG4gICAgLy8gdG8gZXh0ZW5kIHRoZSBoaXRib3gsIGFuZCB0aGUgcmlwcGxlIGlzIGV4cGVjdGVkIHRvIG1lZXQgdGhlIGVkZ2VzIG9mIHRoZSBwYWRkZWQgaGl0Ym94ICh3aGljaCBpcyB0eXBpY2FsbHlcbiAgICAvLyBzcXVhcmUpLiBCb3VuZGVkIHJpcHBsZXMsIG9uIHRoZSBvdGhlciBoYW5kLCBhcmUgZnVsbHkgZXhwZWN0ZWQgdG8gZXhwYW5kIGJleW9uZCB0aGUgc3VyZmFjZSdzIGxvbmdlc3QgZGlhbWV0ZXJcbiAgICAvLyAoY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgZGlhZ29uYWwgcGx1cyBhIGNvbnN0YW50IHBhZGRpbmcpLCBhbmQgYXJlIGNsaXBwZWQgYXQgdGhlIHN1cmZhY2UncyBib3JkZXIgdmlhXG4gICAgLy8gYG92ZXJmbG93OiBoaWRkZW5gLlxuICAgIGNvbnN0IGdldEJvdW5kZWRSYWRpdXMgPSAoKSA9PiB7XG4gICAgICBjb25zdCBoeXBvdGVudXNlID0gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMuZnJhbWVfLndpZHRoLCAyKSArIE1hdGgucG93KHRoaXMuZnJhbWVfLmhlaWdodCwgMikpO1xuICAgICAgcmV0dXJuIGh5cG90ZW51c2UgKyBNRENSaXBwbGVGb3VuZGF0aW9uLm51bWJlcnMuUEFERElORztcbiAgICB9O1xuXG4gICAgdGhpcy5tYXhSYWRpdXNfID0gdGhpcy5hZGFwdGVyXy5pc1VuYm91bmRlZCgpID8gbWF4RGltIDogZ2V0Qm91bmRlZFJhZGl1cygpO1xuXG4gICAgLy8gUmlwcGxlIGlzIHNpemVkIGFzIGEgZnJhY3Rpb24gb2YgdGhlIGxhcmdlc3QgZGltZW5zaW9uIG9mIHRoZSBzdXJmYWNlLCB0aGVuIHNjYWxlcyB1cCB1c2luZyBhIENTUyBzY2FsZSB0cmFuc2Zvcm1cbiAgICB0aGlzLmluaXRpYWxTaXplXyA9IG1heERpbSAqIE1EQ1JpcHBsZUZvdW5kYXRpb24ubnVtYmVycy5JTklUSUFMX09SSUdJTl9TQ0FMRTtcbiAgICB0aGlzLmZnU2NhbGVfID0gdGhpcy5tYXhSYWRpdXNfIC8gdGhpcy5pbml0aWFsU2l6ZV87XG5cbiAgICB0aGlzLnVwZGF0ZUxheW91dENzc1ZhcnNfKCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgdXBkYXRlTGF5b3V0Q3NzVmFyc18oKSB7XG4gICAgY29uc3Qge1xuICAgICAgVkFSX0ZHX1NJWkUsIFZBUl9MRUZULCBWQVJfVE9QLCBWQVJfRkdfU0NBTEUsXG4gICAgfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uc3RyaW5ncztcblxuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoVkFSX0ZHX1NJWkUsIGAke3RoaXMuaW5pdGlhbFNpemVffXB4YCk7XG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfU0NBTEUsIHRoaXMuZmdTY2FsZV8pO1xuXG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNVbmJvdW5kZWQoKSkge1xuICAgICAgdGhpcy51bmJvdW5kZWRDb29yZHNfID0ge1xuICAgICAgICBsZWZ0OiBNYXRoLnJvdW5kKCh0aGlzLmZyYW1lXy53aWR0aCAvIDIpIC0gKHRoaXMuaW5pdGlhbFNpemVfIC8gMikpLFxuICAgICAgICB0b3A6IE1hdGgucm91bmQoKHRoaXMuZnJhbWVfLmhlaWdodCAvIDIpIC0gKHRoaXMuaW5pdGlhbFNpemVfIC8gMikpLFxuICAgICAgfTtcblxuICAgICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfTEVGVCwgYCR7dGhpcy51bmJvdW5kZWRDb29yZHNfLmxlZnR9cHhgKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoVkFSX1RPUCwgYCR7dGhpcy51bmJvdW5kZWRDb29yZHNfLnRvcH1weGApO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcGFyYW0ge2Jvb2xlYW59IHVuYm91bmRlZCAqL1xuICBzZXRVbmJvdW5kZWQodW5ib3VuZGVkKSB7XG4gICAgY29uc3Qge1VOQk9VTkRFRH0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgaWYgKHVuYm91bmRlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhVTkJPVU5ERUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKFVOQk9VTkRFRCk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlRm9jdXMoKSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5CR19GT0NVU0VEKSk7XG4gIH1cblxuICBoYW5kbGVCbHVyKCkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PlxuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQkdfRk9DVVNFRCkpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1JpcHBsZUZvdW5kYXRpb247XG4iLCJpbXBvcnQgTURDUmlwcGxlRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvcmlwcGxlL2ZvdW5kYXRpb24uanMnXG5pbXBvcnQge1xuICBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyxcbiAgZ2V0TWF0Y2hlc1Byb3BlcnR5LFxuICBhcHBseVBhc3NpdmVcbn0gZnJvbSAnQG1hdGVyaWFsL3JpcHBsZS91dGlsJ1xuXG5leHBvcnQgY2xhc3MgUmlwcGxlQmFzZSBleHRlbmRzIE1EQ1JpcHBsZUZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IE1BVENIRVMoKSB7XG4gICAgLyogZ2xvYmFsIEhUTUxFbGVtZW50ICovXG4gICAgcmV0dXJuIChcbiAgICAgIFJpcHBsZUJhc2UuX21hdGNoZXMgfHxcbiAgICAgIChSaXBwbGVCYXNlLl9tYXRjaGVzID0gZ2V0TWF0Y2hlc1Byb3BlcnR5KEhUTUxFbGVtZW50LnByb3RvdHlwZSkpXG4gICAgKVxuICB9XG5cbiAgc3RhdGljIGlzU3VyZmFjZUFjdGl2ZShyZWYpIHtcbiAgICByZXR1cm4gcmVmW1JpcHBsZUJhc2UuTUFUQ0hFU10oJzphY3RpdmUnKVxuICB9XG5cbiAgY29uc3RydWN0b3Iodm0sIG9wdGlvbnMpIHtcbiAgICBzdXBlcihcbiAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHtcbiAgICAgICAgICBicm93c2VyU3VwcG9ydHNDc3NWYXJzOiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3VwcG9ydHNDc3NWYXJpYWJsZXMod2luZG93KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaXNVbmJvdW5kZWQ6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaXNTdXJmYWNlQWN0aXZlOiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdm0uJGVsW1JpcHBsZUJhc2UuTUFUQ0hFU10oJzphY3RpdmUnKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaXNTdXJmYWNlRGlzYWJsZWQ6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB2bS5kaXNhYmxlZFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICB2bS4kc2V0KHZtLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgdm0uJGRlbGV0ZSh2bS5jbGFzc2VzLCBjbGFzc05hbWUpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb250YWluc0V2ZW50VGFyZ2V0OiB0YXJnZXQgPT4gdm0uJGVsLmNvbnRhaW5zKHRhcmdldCksXG4gICAgICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIHZtLiRlbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciwgYXBwbHlQYXNzaXZlKCkpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICB2bS4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIsIGFwcGx5UGFzc2l2ZSgpKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+XG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgZXZ0VHlwZSxcbiAgICAgICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICAgICAgYXBwbHlQYXNzaXZlKClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT5cbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgICBldnRUeXBlLFxuICAgICAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgICAgICBhcHBseVBhc3NpdmUoKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdXBkYXRlQ3NzVmFyaWFibGU6ICh2YXJOYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdm0uJHNldCh2bS5zdHlsZXMsIHZhck5hbWUsIHZhbHVlKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHZtLiRlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0V2luZG93UGFnZU9mZnNldDogKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogd2luZG93LnBhZ2VYT2Zmc2V0LCB5OiB3aW5kb3cucGFnZVlPZmZzZXQgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKVxuICAgIClcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgUmlwcGxlTWl4aW4gPSB7XG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMpXG4gICAgdGhpcy5yaXBwbGUuaW5pdCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5yaXBwbGUuZGVzdHJveSgpXG4gIH1cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPGN1c3RvbS1lbGVtZW50IFxuICAgIDp0YWc9XCJ0YWdcIiBcbiAgICA6Y2xhc3Nlcz1cImNsYXNzZXNcIlxuICAgIDpzdHlsZXM9XCJzdHlsZXNcIiBcbiAgICBjbGFzcz1cIm1kYy1yaXBwbGVcIj5cbiAgICA8c2xvdCAvPlxuICA8L2N1c3RvbS1lbGVtZW50PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7IEN1c3RvbUVsZW1lbnRNaXhpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgeyBSaXBwbGVNaXhpbiB9IGZyb20gJy4vbWRjLXJpcHBsZS1iYXNlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtcmlwcGxlJyxcbiAgbWl4aW5zOiBbQ3VzdG9tRWxlbWVudE1peGluLCBSaXBwbGVNaXhpbl0sXG4gIHByb3BzOiB7XG4gICAgdGFnOiBTdHJpbmdcbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNSaXBwbGUgZnJvbSAnLi9tZGMtcmlwcGxlLnZ1ZSdcblxuZXhwb3J0ICogZnJvbSAnLi9tZGMtcmlwcGxlLWJhc2UuanMnXG5cbmV4cG9ydCB7IG1kY1JpcHBsZSB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNSaXBwbGVcbn0pXG4iLCI8dGVtcGxhdGU+XG4gIDxjdXN0b20tYnV0dG9uIFxuICAgIHJlZj1cInJvb3RcIlxuICAgIDpjbGFzcz1cImNsYXNzZXNcIiBcbiAgICA6c3R5bGU9XCJzdHlsZXNcIlxuICAgIDpocmVmPVwiaHJlZlwiIFxuICAgIDpsaW5rPVwibGlua1wiIFxuICAgIDpkaXNhYmxlZD1cImRpc2FibGVkXCJcbiAgICB2LW9uPVwibGlzdGVuZXJzXCI+XG4gICAgPHNsb3QgLz5cbiAgPC9jdXN0b20tYnV0dG9uPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7IERpc3BhdGNoRXZlbnRNaXhpbiwgQ3VzdG9tQnV0dG9uTWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IHsgUmlwcGxlTWl4aW4gfSBmcm9tICcuLi9yaXBwbGUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1idXR0b24tYmFzZScsXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbiwgQ3VzdG9tQnV0dG9uTWl4aW4sIFJpcHBsZU1peGluXSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjxzY3JpcHQ+XG5pbXBvcnQgbWRjQnV0dG9uQmFzZSBmcm9tICcuL21kYy1idXR0b24tYmFzZS52dWUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1idXR0b24nLFxuICBleHRlbmRzOiBtZGNCdXR0b25CYXNlLFxuICBwcm9wczoge1xuICAgIHJhaXNlZDogQm9vbGVhbixcbiAgICB1bmVsZXZhdGVkOiBCb29sZWFuLFxuICAgIG91dGxpbmVkOiBCb29sZWFuLFxuICAgIGRlbnNlOiBCb29sZWFuXG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1idXR0b24nOiB0cnVlLFxuICAgICAgICAnbWRjLWJ1dHRvbi0tcmFpc2VkJzogdGhpcy5yYWlzZWQsXG4gICAgICAgICdtZGMtYnV0dG9uLS11bmVsZXZhdGVkJzogdGhpcy51bmVsZXZhdGVkLFxuICAgICAgICAnbWRjLWJ1dHRvbi0tb3V0bGluZWQnOiB0aGlzLm91dGxpbmVkLFxuICAgICAgICAnbWRjLWJ1dHRvbi0tZGVuc2UnOiB0aGlzLmRlbnNlXG4gICAgICB9XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIHJhaXNlZCgpIHtcbiAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsICdtZGMtYnV0dG9uLS1yYWlzZWQnLCB0aGlzLnJhaXNlZClcbiAgICB9LFxuICAgIHVuZWxldmF0ZWQoKSB7XG4gICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCAnbWRjLWJ1dHRvbi0tdW5lbGV2YXRlZCcsIHRoaXMudW5lbGV2YXRlZClcbiAgICB9LFxuICAgIG91dGxpbmVkKCkge1xuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21kYy1idXR0b24tLW91dGxpbmVkJywgdGhpcy5vdXRsaW5lZClcbiAgICB9LFxuICAgIGRlbnNlKCkge1xuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21kYy1idXR0b24tLWRlbnNlJywgdGhpcy5kZW5zZSlcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjQnV0dG9uIGZyb20gJy4vbWRjLWJ1dHRvbi52dWUnXG5pbXBvcnQgbWRjQnV0dG9uQmFzZSBmcm9tICcuL21kYy1idXR0b24tYmFzZS52dWUnXG5cbmV4cG9ydCB7IG1kY0J1dHRvbkJhc2UsIG1kY0J1dHRvbiB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNCdXR0b25cbn0pXG4iLCI8dGVtcGxhdGU+XG4gIDxkaXZcbiAgICA6Y2xhc3M9XCJ7J21kYy1jYXJkLS1vdXRsaW5lZCc6IG91dGxpbmVkfVwiXG4gICAgY2xhc3M9XCJtZGMtY2FyZFwiPlxuICAgIDxzbG90Lz5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWNhcmQnLFxuICBwcm9wczoge1xuICAgIG91dGxpbmVkOiBCb29sZWFuXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxyXG4gIDxjdXN0b20tbGluayBcclxuICAgIDpjbGFzcz1cImNsYXNzZXNcIlxyXG4gICAgOnN0eWxlPVwic3R5bGVzXCIgXG4gICAgOmxpbms9XCJsaW5rXCIgXHJcbiAgICBjbGFzcz1cIm1kYy1jYXJkLXByaW1hcnktYWN0aW9uIG1kYy1jYXJkX19wcmltYXJ5LWFjdGlvblwiIFxyXG4gICAgdi1vbj1cImxpc3RlbmVyc1wiPlxyXG4gICAgPHNsb3QgLz5cclxuICA8L2N1c3RvbS1saW5rPlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IHsgRGlzcGF0Y2hFdmVudE1peGluLCBDdXN0b21MaW5rTWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xyXG5pbXBvcnQgeyBSaXBwbGVNaXhpbiB9IGZyb20gJy4uL3JpcHBsZS9pbmRleCdcclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6ICdtZGMtY2FyZC1wcmltYXJ5LWFjdGlvbicsXHJcbiAgbWl4aW5zOiBbRGlzcGF0Y2hFdmVudE1peGluLCBDdXN0b21MaW5rTWl4aW4sIFJpcHBsZU1peGluXSxcclxuICBkYXRhKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2xhc3Nlczoge30sXHJcbiAgICAgIHN0eWxlczoge31cclxuICAgIH1cclxuICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbiIsIjx0ZW1wbGF0ZT5cclxuICA8c2VjdGlvbiBcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgXHJcbiAgICA6c3R5bGU9XCJzdHlsZXNcIiBcbiAgICBjbGFzcz1cIm1kYy1jYXJkLW1lZGlhIG1kYy1jYXJkX19tZWRpYVwiPlxyXG4gICAgPGRpdiBcbiAgICAgIHYtaWY9XCIkc2xvdHMuZGVmYXVsdFwiIFxuICAgICAgY2xhc3M9XCJtZGMtY2FyZF9fbWVkaWEtY29udGVudFwiPlxyXG4gICAgICA8c2xvdC8+XHJcbiAgICA8L2Rpdj5cclxuICA8L3NlY3Rpb24+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgbmFtZTogJ21kYy1jYXJkLW1lZGlhJyxcclxuICBwcm9wczoge1xyXG4gICAgc3JjOiBTdHJpbmcsXHJcbiAgICBzcXVhcmU6IEJvb2xlYW5cclxuICB9LFxyXG4gIGNvbXB1dGVkOiB7XHJcbiAgICBzdHlsZXMoKSB7XHJcbiAgICAgIHZhciBzdHlsZXMgPSB7XHJcbiAgICAgICAgYmFja2dyb3VuZEltYWdlOiBgdXJsKCR7dGhpcy5zcmN9KWBcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHN0eWxlc1xyXG4gICAgfSxcclxuICAgIGNsYXNzZXMoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNxdWFyZSA/ICdtZGMtY2FyZF9fbWVkaWEtLXNxdWFyZScgOiAnbWRjLWNhcmRfX21lZGlhLS0xNi05J1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG48L3NjcmlwdD5cclxuIiwiPHRlbXBsYXRlPlxuICA8c2VjdGlvbiBjbGFzcz1cIm1kYy1jYXJkLWhlYWRlciBtZGMtY2FyZF9fcHJpbWFyeVwiPlxuICAgIDxzbG90PlxuICAgICAgPGgxIFxuICAgICAgICB2LWlmPVwidGl0bGVcIlxuICAgICAgICA6Y2xhc3M9XCJ7J21kYy1jYXJkX190aXRsZS0tbGFyZ2UnOiBsYXJnZVRpdGxlfVwiXG4gICAgICAgIGNsYXNzPVwibWRjLWNhcmRfX3RpdGxlXCJcbiAgICAgID5cbiAgICAgICAge3sgdGl0bGUgfX1cbiAgICAgIDwvaDE+XG4gICAgICA8aDIgXG4gICAgICAgIHYtaWY9XCJzdWJ0aXRsZVwiXG4gICAgICAgIGNsYXNzPVwibWRjLWNhcmRfX3N1YnRpdGxlXCJcbiAgICAgID5cbiAgICAgICAge3sgc3VidGl0bGUgfX0gXG4gICAgICA8L2gyPlxuICAgIDwvc2xvdD5cbiAgPC9zZWN0aW9uPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1jYXJkLWhlYWRlcicsXG4gIHByb3BzOiB7XG4gICAgdGl0bGU6IFN0cmluZyxcbiAgICBzdWJ0aXRsZTogU3RyaW5nLFxuICAgICdsYXJnZS10aXRsZSc6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogdHJ1ZSB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8aDEgXG4gICAgOmNsYXNzPVwieydtZGMtY2FyZF9fdGl0bGUtLWxhcmdlJzogbGFyZ2V9XCJcbiAgICBjbGFzcz1cIm1kYy1jYXJkLXRpdGxlIG1kYy1jYXJkX190aXRsZVwiPlxuICAgIDxzbG90Lz5cbiAgPC9oMT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtY2FyZC10aXRsZScsXG4gIHByb3BzOiB7XG4gICAgbGFyZ2U6IEJvb2xlYW5cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxoMiBjbGFzcz1cIm1kYy1jYXJkLXN1YnRpdGxlIG1kYy1jYXJkX19zdWJ0aXRsZVwiPlxuICAgIDxzbG90Lz5cbiAgPC9oMj5cbjwvdGVtcGxhdGU+XG5cblxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWNhcmQtc3VidGl0bGUnXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPHNlY3Rpb24gY2xhc3M9XCJtZGMtY2FyZC10ZXh0IG1kYy1jYXJkX19zdXBwb3J0aW5nLXRleHRcIj5cbiAgICA8c2xvdC8+XG4gIDwvc2VjdGlvbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtY2FyZC10ZXh0J1xufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XHJcbiAgPHNlY3Rpb24gXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIFxyXG4gICAgY2xhc3M9XCJtZGMtY2FyZC1hY3Rpb25zIG1kYy1jYXJkX19hY3Rpb25zXCI+XHJcbiAgICA8c2xvdC8+XHJcbiAgPC9zZWN0aW9uPlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6ICdtZGMtY2FyZC1hY3Rpb25zJyxcclxuICBwcm9wczoge1xyXG4gICAgZnVsbEJsZWVkOiBCb29sZWFuXHJcbiAgfSxcclxuICBjb21wdXRlZDoge1xyXG4gICAgY2xhc3NlcygpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAnbWRjLWNhcmRfX2FjdGlvbnMtLWZ1bGwtYmxlZWQnOiB0aGlzLmZ1bGxCbGVlZFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG4iLCI8dGVtcGxhdGU+XHJcbiAgPGRpdiBjbGFzcz1cIm1kYy1jYXJkLWFjdGlvbi1idXR0b25zIG1kYy1jYXJkX19hY3Rpb24tYnV0dG9uc1wiPlxyXG4gICAgPHNsb3QvPlxyXG4gIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6ICdtZGMtY2FyZC1hY3Rpb24tYnV0dG9ucydcclxufVxyXG48L3NjcmlwdD5cclxuIiwiPHNjcmlwdD5cclxuaW1wb3J0IHsgbWRjQnV0dG9uQmFzZSB9IGZyb20gJy4uL2J1dHRvbidcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnbWRjLWNhcmQtYWN0aW9uLWJ1dHRvbicsXHJcbiAgZXh0ZW5kczogbWRjQnV0dG9uQmFzZSxcclxuICBkYXRhKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2xhc3Nlczoge1xyXG4gICAgICAgICdtZGMtYnV0dG9uJzogdHJ1ZSxcclxuICAgICAgICAnbWRjLWNhcmRfX2FjdGlvbic6IHRydWUsXHJcbiAgICAgICAgJ21kYy1jYXJkLWFjdGlvbi1idXR0b24nOiB0cnVlXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbiIsIjx0ZW1wbGF0ZT5cclxuICA8ZGl2IGNsYXNzPVwibWRjLWNhcmQtYWN0aW9uLWljb25zIG1kYy1jYXJkX19hY3Rpb24taWNvbnNcIj5cclxuICAgIDxzbG90Lz5cclxuICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnbWRjLWNhcmQtYWN0aW9uLWljb25zJ1xyXG59XHJcbjwvc2NyaXB0PlxyXG4iLCI8dGVtcGxhdGU+XHJcbiAgPHNwYW4gXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIFxuICAgIDpzdHlsZT1cInN0eWxlc1wiIFxyXG4gICAgdi1vbj1cImxpc3RlbmVyc1wiPlxyXG4gICAgPHNsb3Q+e3sgaWNvbiB9fTwvc2xvdD5cclxuICA8L3NwYW4+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5pbXBvcnQgeyBEaXNwYXRjaEV2ZW50TWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xyXG5pbXBvcnQgeyBSaXBwbGVCYXNlIH0gZnJvbSAnLi4vcmlwcGxlJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6ICdtZGMtY2FyZC1hY3Rpb24taWNvbicsXHJcbiAgbWl4aW5zOiBbRGlzcGF0Y2hFdmVudE1peGluXSxcclxuICBwcm9wczoge1xyXG4gICAgaWNvbjogU3RyaW5nXHJcbiAgfSxcclxuICBkYXRhKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2xhc3Nlczoge1xyXG4gICAgICAgICdtZGMtY2FyZC1hY3Rpb24taWNvbic6IHRydWUsXHJcbiAgICAgICAgJ21hdGVyaWFsLWljb25zJzogISF0aGlzLmljb24sXHJcbiAgICAgICAgJ21kYy1jYXJkX19hY3Rpb24nOiB0cnVlLFxyXG4gICAgICAgICdtZGMtY2FyZF9fYWN0aW9uLS1pY29uJzogdHJ1ZSxcclxuICAgICAgICAnbWRjLWljb24tdG9nZ2xlJzogdHJ1ZVxyXG4gICAgICB9LFxyXG4gICAgICBzdHlsZXM6IHt9XHJcbiAgICB9XHJcbiAgfSxcclxuICB3YXRjaDoge1xyXG4gICAgaWNvbigpIHtcclxuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21hdGVyaWFsLWljb25zJywgISF0aGlzLmljb24pXHJcbiAgICB9XHJcbiAgfSxcclxuICBtb3VudGVkKCkge1xyXG4gICAgdGhpcy5yaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzLCB7XHJcbiAgICAgIGlzVW5ib3VuZGVkOiAoKSA9PiB0cnVlXHJcbiAgICB9KVxyXG4gICAgdGhpcy5yaXBwbGUuaW5pdCgpXHJcbiAgfSxcclxuICBiZWZvcmVEZXN0cm95KCkge1xyXG4gICAgdGhpcy5yaXBwbGUuZGVzdHJveSgpXHJcbiAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcclxuaW1wb3J0IG1kY0NhcmQgZnJvbSAnLi9tZGMtY2FyZC52dWUnXHJcbmltcG9ydCBtZGNDYXJkUHJpbWFyeUFjdGlvbiBmcm9tICcuL21kYy1jYXJkLXByaW1hcnktYWN0aW9uLnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRNZWRpYSBmcm9tICcuL21kYy1jYXJkLW1lZGlhLnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRIZWFkZXIgZnJvbSAnLi9tZGMtY2FyZC1oZWFkZXIudnVlJ1xyXG5pbXBvcnQgbWRjQ2FyZFRpdGxlIGZyb20gJy4vbWRjLWNhcmQtdGl0bGUudnVlJ1xyXG5pbXBvcnQgbWRjQ2FyZFN1YnRpdGxlIGZyb20gJy4vbWRjLWNhcmQtc3VidGl0bGUudnVlJ1xyXG5pbXBvcnQgbWRjQ2FyZFRleHQgZnJvbSAnLi9tZGMtY2FyZC10ZXh0LnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRBY3Rpb25zIGZyb20gJy4vbWRjLWNhcmQtYWN0aW9ucy52dWUnXHJcbmltcG9ydCBtZGNDYXJkQWN0aW9uQnV0dG9ucyBmcm9tICcuL21kYy1jYXJkLWFjdGlvbi1idXR0b25zLnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRBY3Rpb25CdXR0b24gZnJvbSAnLi9tZGMtY2FyZC1hY3Rpb24tYnV0dG9uLnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRBY3Rpb25JY29ucyBmcm9tICcuL21kYy1jYXJkLWFjdGlvbi1pY29ucy52dWUnXHJcbmltcG9ydCBtZGNDYXJkQWN0aW9uSWNvbiBmcm9tICcuL21kYy1jYXJkLWFjdGlvbi1pY29uLnZ1ZSdcclxuXHJcbmV4cG9ydCB7XHJcbiAgbWRjQ2FyZCxcclxuICBtZGNDYXJkUHJpbWFyeUFjdGlvbixcclxuICBtZGNDYXJkTWVkaWEsXHJcbiAgbWRjQ2FyZEhlYWRlcixcclxuICBtZGNDYXJkVGl0bGUsXHJcbiAgbWRjQ2FyZFN1YnRpdGxlLFxyXG4gIG1kY0NhcmRUZXh0LFxyXG4gIG1kY0NhcmRBY3Rpb25zLFxyXG4gIG1kY0NhcmRBY3Rpb25CdXR0b25zLFxyXG4gIG1kY0NhcmRBY3Rpb25CdXR0b24sXHJcbiAgbWRjQ2FyZEFjdGlvbkljb25zLFxyXG4gIG1kY0NhcmRBY3Rpb25JY29uXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xyXG4gIG1kY0NhcmQsXHJcbiAgbWRjQ2FyZFByaW1hcnlBY3Rpb24sXHJcbiAgbWRjQ2FyZE1lZGlhLFxyXG4gIG1kY0NhcmRIZWFkZXIsXHJcbiAgbWRjQ2FyZFRpdGxlLFxyXG4gIG1kY0NhcmRTdWJ0aXRsZSxcclxuICBtZGNDYXJkVGV4dCxcclxuICBtZGNDYXJkQWN0aW9ucyxcclxuICBtZGNDYXJkQWN0aW9uQnV0dG9ucyxcclxuICBtZGNDYXJkQWN0aW9uQnV0dG9uLFxyXG4gIG1kY0NhcmRBY3Rpb25JY29ucyxcclxuICBtZGNDYXJkQWN0aW9uSWNvblxyXG59KVxyXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnLi9mb3VuZGF0aW9uJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgRlxuICovXG5jbGFzcyBNRENDb21wb25lbnQge1xuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gcm9vdFxuICAgKiBAcmV0dXJuIHshTURDQ29tcG9uZW50fVxuICAgKi9cbiAgc3RhdGljIGF0dGFjaFRvKHJvb3QpIHtcbiAgICAvLyBTdWJjbGFzc2VzIHdoaWNoIGV4dGVuZCBNRENCYXNlIHNob3VsZCBwcm92aWRlIGFuIGF0dGFjaFRvKCkgbWV0aG9kIHRoYXQgdGFrZXMgYSByb290IGVsZW1lbnQgYW5kXG4gICAgLy8gcmV0dXJucyBhbiBpbnN0YW50aWF0ZWQgY29tcG9uZW50IHdpdGggaXRzIHJvb3Qgc2V0IHRvIHRoYXQgZWxlbWVudC4gQWxzbyBub3RlIHRoYXQgaW4gdGhlIGNhc2VzIG9mXG4gICAgLy8gc3ViY2xhc3NlcywgYW4gZXhwbGljaXQgZm91bmRhdGlvbiBjbGFzcyB3aWxsIG5vdCBoYXZlIHRvIGJlIHBhc3NlZCBpbjsgaXQgd2lsbCBzaW1wbHkgYmUgaW5pdGlhbGl6ZWRcbiAgICAvLyBmcm9tIGdldERlZmF1bHRGb3VuZGF0aW9uKCkuXG4gICAgcmV0dXJuIG5ldyBNRENDb21wb25lbnQocm9vdCwgbmV3IE1EQ0ZvdW5kYXRpb24oKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gcm9vdFxuICAgKiBAcGFyYW0ge0Y9fSBmb3VuZGF0aW9uXG4gICAqIEBwYXJhbSB7Li4uP30gYXJnc1xuICAgKi9cbiAgY29uc3RydWN0b3Iocm9vdCwgZm91bmRhdGlvbiA9IHVuZGVmaW5lZCwgLi4uYXJncykge1xuICAgIC8qKiBAcHJvdGVjdGVkIHshRWxlbWVudH0gKi9cbiAgICB0aGlzLnJvb3RfID0gcm9vdDtcbiAgICB0aGlzLmluaXRpYWxpemUoLi4uYXJncyk7XG4gICAgLy8gTm90ZSB0aGF0IHdlIGluaXRpYWxpemUgZm91bmRhdGlvbiBoZXJlIGFuZCBub3Qgd2l0aGluIHRoZSBjb25zdHJ1Y3RvcidzIGRlZmF1bHQgcGFyYW0gc28gdGhhdFxuICAgIC8vIHRoaXMucm9vdF8gaXMgZGVmaW5lZCBhbmQgY2FuIGJlIHVzZWQgd2l0aGluIHRoZSBmb3VuZGF0aW9uIGNsYXNzLlxuICAgIC8qKiBAcHJvdGVjdGVkIHshRn0gKi9cbiAgICB0aGlzLmZvdW5kYXRpb25fID0gZm91bmRhdGlvbiA9PT0gdW5kZWZpbmVkID8gdGhpcy5nZXREZWZhdWx0Rm91bmRhdGlvbigpIDogZm91bmRhdGlvbjtcbiAgICB0aGlzLmZvdW5kYXRpb25fLmluaXQoKTtcbiAgICB0aGlzLmluaXRpYWxTeW5jV2l0aERPTSgpO1xuICB9XG5cbiAgaW5pdGlhbGl6ZSgvKiAuLi5hcmdzICovKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUgdGhpcyB0byBkbyBhbnkgYWRkaXRpb25hbCBzZXR1cCB3b3JrIHRoYXQgd291bGQgYmUgY29uc2lkZXJlZCBwYXJ0IG9mIGFcbiAgICAvLyBcImNvbnN0cnVjdG9yXCIuIEVzc2VudGlhbGx5LCBpdCBpcyBhIGhvb2sgaW50byB0aGUgcGFyZW50IGNvbnN0cnVjdG9yIGJlZm9yZSB0aGUgZm91bmRhdGlvbiBpc1xuICAgIC8vIGluaXRpYWxpemVkLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYmVzaWRlcyByb290IGFuZCBmb3VuZGF0aW9uIHdpbGwgYmUgcGFzc2VkIGluIGhlcmUuXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IUZ9IGZvdW5kYXRpb25cbiAgICovXG4gIGdldERlZmF1bHRGb3VuZGF0aW9uKCkge1xuICAgIC8vIFN1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byByZXR1cm4gYSBwcm9wZXJseSBjb25maWd1cmVkIGZvdW5kYXRpb24gY2xhc3MgZm9yIHRoZVxuICAgIC8vIGNvbXBvbmVudC5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSBnZXREZWZhdWx0Rm91bmRhdGlvbiB0byByZXR1cm4gYSBwcm9wZXJseSBjb25maWd1cmVkICcgK1xuICAgICAgJ2ZvdW5kYXRpb24gY2xhc3MnKTtcbiAgfVxuXG4gIGluaXRpYWxTeW5jV2l0aERPTSgpIHtcbiAgICAvLyBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB0aGV5IG5lZWQgdG8gcGVyZm9ybSB3b3JrIHRvIHN5bmNocm9uaXplIHdpdGggYSBob3N0IERPTVxuICAgIC8vIG9iamVjdC4gQW4gZXhhbXBsZSBvZiB0aGlzIHdvdWxkIGJlIGEgZm9ybSBjb250cm9sIHdyYXBwZXIgdGhhdCBuZWVkcyB0byBzeW5jaHJvbml6ZSBpdHMgaW50ZXJuYWwgc3RhdGVcbiAgICAvLyB0byBzb21lIHByb3BlcnR5IG9yIGF0dHJpYnV0ZSBvZiB0aGUgaG9zdCBET00uIFBsZWFzZSBub3RlOiB0aGlzIGlzICpub3QqIHRoZSBwbGFjZSB0byBwZXJmb3JtIERPTVxuICAgIC8vIHJlYWRzL3dyaXRlcyB0aGF0IHdvdWxkIGNhdXNlIGxheW91dCAvIHBhaW50LCBhcyB0aGlzIGlzIGNhbGxlZCBzeW5jaHJvbm91c2x5IGZyb20gd2l0aGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBtYXkgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJlbGVhc2UgYW55IHJlc291cmNlcyAvIGRlcmVnaXN0ZXIgYW55IGxpc3RlbmVycyB0aGV5IGhhdmVcbiAgICAvLyBhdHRhY2hlZC4gQW4gZXhhbXBsZSBvZiB0aGlzIG1pZ2h0IGJlIGRlcmVnaXN0ZXJpbmcgYSByZXNpemUgZXZlbnQgZnJvbSB0aGUgd2luZG93IG9iamVjdC5cbiAgICB0aGlzLmZvdW5kYXRpb25fLmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcGVyIG1ldGhvZCB0byBhZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGNvbXBvbmVudCdzIHJvb3QgZWxlbWVudC4gVGhpcyBpcyBtb3N0IHVzZWZ1bCB3aGVuXG4gICAqIGxpc3RlbmluZyBmb3IgY3VzdG9tIGV2ZW50cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGxpc3RlbihldnRUeXBlLCBoYW5kbGVyKSB7XG4gICAgdGhpcy5yb290Xy5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBwZXIgbWV0aG9kIHRvIHJlbW92ZSBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgY29tcG9uZW50J3Mgcm9vdCBlbGVtZW50LiBUaGlzIGlzIG1vc3QgdXNlZnVsIHdoZW5cbiAgICogdW5saXN0ZW5pbmcgZm9yIGN1c3RvbSBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICB1bmxpc3RlbihldnRUeXBlLCBoYW5kbGVyKSB7XG4gICAgdGhpcy5yb290Xy5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVzIGEgY3Jvc3MtYnJvd3Nlci1jb21wYXRpYmxlIGN1c3RvbSBldmVudCBmcm9tIHRoZSBjb21wb25lbnQgcm9vdCBvZiB0aGUgZ2l2ZW4gdHlwZSxcbiAgICogd2l0aCB0aGUgZ2l2ZW4gZGF0YS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHshT2JqZWN0fSBldnREYXRhXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHNob3VsZEJ1YmJsZVxuICAgKi9cbiAgZW1pdChldnRUeXBlLCBldnREYXRhLCBzaG91bGRCdWJibGUgPSBmYWxzZSkge1xuICAgIGxldCBldnQ7XG4gICAgaWYgKHR5cGVvZiBDdXN0b21FdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXZ0ID0gbmV3IEN1c3RvbUV2ZW50KGV2dFR5cGUsIHtcbiAgICAgICAgZGV0YWlsOiBldnREYXRhLFxuICAgICAgICBidWJibGVzOiBzaG91bGRCdWJibGUsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2dFR5cGUsIHNob3VsZEJ1YmJsZSwgZmFsc2UsIGV2dERhdGEpO1xuICAgIH1cblxuICAgIHRoaXMucm9vdF8uZGlzcGF0Y2hFdmVudChldnQpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0NvbXBvbmVudDtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgUmlwcGxlLiBQcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIG1hbmFnaW5nXG4gKiAtIGNsYXNzZXNcbiAqIC0gZG9tXG4gKiAtIENTUyB2YXJpYWJsZXNcbiAqIC0gcG9zaXRpb25cbiAqIC0gZGltZW5zaW9uc1xuICogLSBzY3JvbGwgcG9zaXRpb25cbiAqIC0gZXZlbnQgaGFuZGxlcnNcbiAqIC0gdW5ib3VuZGVkLCBhY3RpdmUgYW5kIGRpc2FibGVkIHN0YXRlc1xuICpcbiAqIEFkZGl0aW9uYWxseSwgcHJvdmlkZXMgdHlwZSBpbmZvcm1hdGlvbiBmb3IgdGhlIGFkYXB0ZXIgdG8gdGhlIENsb3N1cmVcbiAqIGNvbXBpbGVyLlxuICpcbiAqIEltcGxlbWVudCB0aGlzIGFkYXB0ZXIgZm9yIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZSB0byBkZWxlZ2F0ZSB1cGRhdGVzIHRvXG4gKiB0aGUgY29tcG9uZW50IGluIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZS4gU2VlIGFyY2hpdGVjdHVyZSBkb2N1bWVudGF0aW9uXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9jb2RlL2FyY2hpdGVjdHVyZS5tZFxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDUmlwcGxlQWRhcHRlciB7XG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBicm93c2VyU3VwcG9ydHNDc3NWYXJzKCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNVbmJvdW5kZWQoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc1N1cmZhY2VBY3RpdmUoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc1N1cmZhY2VEaXNhYmxlZCgpIHt9XG5cbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHBhcmFtIHshRXZlbnRUYXJnZXR9IHRhcmdldCAqL1xuICBjb250YWluc0V2ZW50VGFyZ2V0KHRhcmdldCkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVyUmVzaXplSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhck5hbWVcbiAgICogQHBhcmFtIHs/bnVtYmVyfHN0cmluZ30gdmFsdWVcbiAgICovXG4gIHVwZGF0ZUNzc1ZhcmlhYmxlKHZhck5hbWUsIHZhbHVlKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHshQ2xpZW50UmVjdH0gKi9cbiAgY29tcHV0ZUJvdW5kaW5nUmVjdCgpIHt9XG5cbiAgLyoqIEByZXR1cm4ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19ICovXG4gIGdldFdpbmRvd1BhZ2VPZmZzZXQoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENSaXBwbGVBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIC8vIFJpcHBsZSBpcyBhIHNwZWNpYWwgY2FzZSB3aGVyZSB0aGUgXCJyb290XCIgY29tcG9uZW50IGlzIHJlYWxseSBhIFwibWl4aW5cIiBvZiBzb3J0cyxcbiAgLy8gZ2l2ZW4gdGhhdCBpdCdzIGFuICd1cGdyYWRlJyB0byBhbiBleGlzdGluZyBjb21wb25lbnQuIFRoYXQgYmVpbmcgc2FpZCBpdCBpcyB0aGUgcm9vdFxuICAvLyBDU1MgY2xhc3MgdGhhdCBhbGwgb3RoZXIgQ1NTIGNsYXNzZXMgZGVyaXZlIGZyb20uXG4gIFJPT1Q6ICdtZGMtcmlwcGxlLXVwZ3JhZGVkJyxcbiAgVU5CT1VOREVEOiAnbWRjLXJpcHBsZS11cGdyYWRlZC0tdW5ib3VuZGVkJyxcbiAgQkdfRk9DVVNFRDogJ21kYy1yaXBwbGUtdXBncmFkZWQtLWJhY2tncm91bmQtZm9jdXNlZCcsXG4gIEZHX0FDVElWQVRJT046ICdtZGMtcmlwcGxlLXVwZ3JhZGVkLS1mb3JlZ3JvdW5kLWFjdGl2YXRpb24nLFxuICBGR19ERUFDVElWQVRJT046ICdtZGMtcmlwcGxlLXVwZ3JhZGVkLS1mb3JlZ3JvdW5kLWRlYWN0aXZhdGlvbicsXG59O1xuXG5jb25zdCBzdHJpbmdzID0ge1xuICBWQVJfTEVGVDogJy0tbWRjLXJpcHBsZS1sZWZ0JyxcbiAgVkFSX1RPUDogJy0tbWRjLXJpcHBsZS10b3AnLFxuICBWQVJfRkdfU0laRTogJy0tbWRjLXJpcHBsZS1mZy1zaXplJyxcbiAgVkFSX0ZHX1NDQUxFOiAnLS1tZGMtcmlwcGxlLWZnLXNjYWxlJyxcbiAgVkFSX0ZHX1RSQU5TTEFURV9TVEFSVDogJy0tbWRjLXJpcHBsZS1mZy10cmFuc2xhdGUtc3RhcnQnLFxuICBWQVJfRkdfVFJBTlNMQVRFX0VORDogJy0tbWRjLXJpcHBsZS1mZy10cmFuc2xhdGUtZW5kJyxcbn07XG5cbmNvbnN0IG51bWJlcnMgPSB7XG4gIFBBRERJTkc6IDEwLFxuICBJTklUSUFMX09SSUdJTl9TQ0FMRTogMC42LFxuICBERUFDVElWQVRJT05fVElNRU9VVF9NUzogMjI1LCAvLyBDb3JyZXNwb25kcyB0byAkbWRjLXJpcHBsZS10cmFuc2xhdGUtZHVyYXRpb24gKGkuZS4gYWN0aXZhdGlvbiBhbmltYXRpb24gZHVyYXRpb24pXG4gIEZHX0RFQUNUSVZBVElPTl9NUzogMTUwLCAvLyBDb3JyZXNwb25kcyB0byAkbWRjLXJpcHBsZS1mYWRlLW91dC1kdXJhdGlvbiAoaS5lLiBkZWFjdGl2YXRpb24gYW5pbWF0aW9uIGR1cmF0aW9uKVxuICBUQVBfREVMQVlfTVM6IDMwMCwgLy8gRGVsYXkgYmV0d2VlbiB0b3VjaCBhbmQgc2ltdWxhdGVkIG1vdXNlIGV2ZW50cyBvbiB0b3VjaCBkZXZpY2VzXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogU3RvcmVzIHJlc3VsdCBmcm9tIHN1cHBvcnRzQ3NzVmFyaWFibGVzIHRvIGF2b2lkIHJlZHVuZGFudCBwcm9jZXNzaW5nIHRvIGRldGVjdCBDU1MgY3VzdG9tIHZhcmlhYmxlIHN1cHBvcnQuXG4gKiBAcHJpdmF0ZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gKi9cbmxldCBzdXBwb3J0c0Nzc1ZhcmlhYmxlc187XG5cbi8qKlxuICogU3RvcmVzIHJlc3VsdCBmcm9tIGFwcGx5UGFzc2l2ZSB0byBhdm9pZCByZWR1bmRhbnQgcHJvY2Vzc2luZyB0byBkZXRlY3QgcGFzc2l2ZSBldmVudCBsaXN0ZW5lciBzdXBwb3J0LlxuICogQHByaXZhdGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICovXG5sZXQgc3VwcG9ydHNQYXNzaXZlXztcblxuLyoqXG4gKiBAcGFyYW0geyFXaW5kb3d9IHdpbmRvd09ialxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0RWRnZVBzZXVkb1ZhckJ1Zyh3aW5kb3dPYmopIHtcbiAgLy8gRGV0ZWN0IHZlcnNpb25zIG9mIEVkZ2Ugd2l0aCBidWdneSB2YXIoKSBzdXBwb3J0XG4gIC8vIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTE0OTU0NDgvXG4gIGNvbnN0IGRvY3VtZW50ID0gd2luZG93T2JqLmRvY3VtZW50O1xuICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIG5vZGUuY2xhc3NOYW1lID0gJ21kYy1yaXBwbGUtc3VyZmFjZS0tdGVzdC1lZGdlLXZhci1idWcnO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5vZGUpO1xuXG4gIC8vIFRoZSBidWcgZXhpc3RzIGlmIDo6YmVmb3JlIHN0eWxlIGVuZHMgdXAgcHJvcGFnYXRpbmcgdG8gdGhlIHBhcmVudCBlbGVtZW50LlxuICAvLyBBZGRpdGlvbmFsbHksIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBudWxsIGluIGlmcmFtZXMgd2l0aCBkaXNwbGF5OiBcIm5vbmVcIiBpbiBGaXJlZm94LFxuICAvLyBidXQgRmlyZWZveCBpcyBrbm93biB0byBzdXBwb3J0IENTUyBjdXN0b20gcHJvcGVydGllcyBjb3JyZWN0bHkuXG4gIC8vIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSB3aW5kb3dPYmouZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgY29uc3QgaGFzUHNldWRvVmFyQnVnID0gY29tcHV0ZWRTdHlsZSAhPT0gbnVsbCAmJiBjb21wdXRlZFN0eWxlLmJvcmRlclRvcFN0eWxlID09PSAnc29saWQnO1xuICBub2RlLnJlbW92ZSgpO1xuICByZXR1cm4gaGFzUHNldWRvVmFyQnVnO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IVdpbmRvd30gd2luZG93T2JqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBmb3JjZVJlZnJlc2hcbiAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIHN1cHBvcnRzQ3NzVmFyaWFibGVzKHdpbmRvd09iaiwgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgbGV0IHN1cHBvcnRzQ3NzVmFyaWFibGVzID0gc3VwcG9ydHNDc3NWYXJpYWJsZXNfO1xuICBpZiAodHlwZW9mIHN1cHBvcnRzQ3NzVmFyaWFibGVzXyA9PT0gJ2Jvb2xlYW4nICYmICFmb3JjZVJlZnJlc2gpIHtcbiAgICByZXR1cm4gc3VwcG9ydHNDc3NWYXJpYWJsZXM7XG4gIH1cblxuICBjb25zdCBzdXBwb3J0c0Z1bmN0aW9uUHJlc2VudCA9IHdpbmRvd09iai5DU1MgJiYgdHlwZW9mIHdpbmRvd09iai5DU1Muc3VwcG9ydHMgPT09ICdmdW5jdGlvbic7XG4gIGlmICghc3VwcG9ydHNGdW5jdGlvblByZXNlbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBleHBsaWNpdGx5U3VwcG9ydHNDc3NWYXJzID0gd2luZG93T2JqLkNTUy5zdXBwb3J0cygnLS1jc3MtdmFycycsICd5ZXMnKTtcbiAgLy8gU2VlOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU0NjY5XG4gIC8vIFNlZTogUkVBRE1FIHNlY3Rpb24gb24gU2FmYXJpXG4gIGNvbnN0IHdlQXJlRmVhdHVyZURldGVjdGluZ1NhZmFyaTEwcGx1cyA9IChcbiAgICB3aW5kb3dPYmouQ1NTLnN1cHBvcnRzKCcoLS1jc3MtdmFyczogeWVzKScpICYmXG4gICAgd2luZG93T2JqLkNTUy5zdXBwb3J0cygnY29sb3InLCAnIzAwMDAwMDAwJylcbiAgKTtcblxuICBpZiAoZXhwbGljaXRseVN1cHBvcnRzQ3NzVmFycyB8fCB3ZUFyZUZlYXR1cmVEZXRlY3RpbmdTYWZhcmkxMHBsdXMpIHtcbiAgICBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyA9ICFkZXRlY3RFZGdlUHNldWRvVmFyQnVnKHdpbmRvd09iaik7XG4gIH0gZWxzZSB7XG4gICAgc3VwcG9ydHNDc3NWYXJpYWJsZXMgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICghZm9yY2VSZWZyZXNoKSB7XG4gICAgc3VwcG9ydHNDc3NWYXJpYWJsZXNfID0gc3VwcG9ydHNDc3NWYXJpYWJsZXM7XG4gIH1cbiAgcmV0dXJuIHN1cHBvcnRzQ3NzVmFyaWFibGVzO1xufVxuXG4vL1xuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgY3VycmVudCBicm93c2VyIHN1cHBvcnRzIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzLCBhbmQgaWYgc28sIHVzZSB0aGVtLlxuICogQHBhcmFtIHshV2luZG93PX0gZ2xvYmFsT2JqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBmb3JjZVJlZnJlc2hcbiAqIEByZXR1cm4ge2Jvb2xlYW58e3Bhc3NpdmU6IGJvb2xlYW59fVxuICovXG5mdW5jdGlvbiBhcHBseVBhc3NpdmUoZ2xvYmFsT2JqID0gd2luZG93LCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkge1xuICBpZiAoc3VwcG9ydHNQYXNzaXZlXyA9PT0gdW5kZWZpbmVkIHx8IGZvcmNlUmVmcmVzaCkge1xuICAgIGxldCBpc1N1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBnbG9iYWxPYmouZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIHtnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgaXNTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgfX0pO1xuICAgIH0gY2F0Y2ggKGUpIHsgfVxuXG4gICAgc3VwcG9ydHNQYXNzaXZlXyA9IGlzU3VwcG9ydGVkO1xuICB9XG5cbiAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZV8gPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFPYmplY3R9IEhUTUxFbGVtZW50UHJvdG90eXBlXG4gKiBAcmV0dXJuIHshQXJyYXk8c3RyaW5nPn1cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hlc1Byb3BlcnR5KEhUTUxFbGVtZW50UHJvdG90eXBlKSB7XG4gIHJldHVybiBbXG4gICAgJ3dlYmtpdE1hdGNoZXNTZWxlY3RvcicsICdtc01hdGNoZXNTZWxlY3RvcicsICdtYXRjaGVzJyxcbiAgXS5maWx0ZXIoKHApID0+IHAgaW4gSFRNTEVsZW1lbnRQcm90b3R5cGUpLnBvcCgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IUV2ZW50fSBldlxuICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwYWdlT2Zmc2V0XG4gKiBAcGFyYW0geyFDbGllbnRSZWN0fSBjbGllbnRSZWN0XG4gKiBAcmV0dXJuIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICovXG5mdW5jdGlvbiBnZXROb3JtYWxpemVkRXZlbnRDb29yZHMoZXYsIHBhZ2VPZmZzZXQsIGNsaWVudFJlY3QpIHtcbiAgY29uc3Qge3gsIHl9ID0gcGFnZU9mZnNldDtcbiAgY29uc3QgZG9jdW1lbnRYID0geCArIGNsaWVudFJlY3QubGVmdDtcbiAgY29uc3QgZG9jdW1lbnRZID0geSArIGNsaWVudFJlY3QudG9wO1xuXG4gIGxldCBub3JtYWxpemVkWDtcbiAgbGV0IG5vcm1hbGl6ZWRZO1xuICAvLyBEZXRlcm1pbmUgdG91Y2ggcG9pbnQgcmVsYXRpdmUgdG8gdGhlIHJpcHBsZSBjb250YWluZXIuXG4gIGlmIChldi50eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICBub3JtYWxpemVkWCA9IGV2LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYIC0gZG9jdW1lbnRYO1xuICAgIG5vcm1hbGl6ZWRZID0gZXYuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkgLSBkb2N1bWVudFk7XG4gIH0gZWxzZSB7XG4gICAgbm9ybWFsaXplZFggPSBldi5wYWdlWCAtIGRvY3VtZW50WDtcbiAgICBub3JtYWxpemVkWSA9IGV2LnBhZ2VZIC0gZG9jdW1lbnRZO1xuICB9XG5cbiAgcmV0dXJuIHt4OiBub3JtYWxpemVkWCwgeTogbm9ybWFsaXplZFl9O1xufVxuXG5leHBvcnQge3N1cHBvcnRzQ3NzVmFyaWFibGVzLCBhcHBseVBhc3NpdmUsIGdldE1hdGNoZXNQcm9wZXJ0eSwgZ2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENSaXBwbGVBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7Z2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzfSBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGlzQWN0aXZhdGVkOiAoYm9vbGVhbnx1bmRlZmluZWQpLFxuICogICBoYXNEZWFjdGl2YXRpb25VWFJ1bjogKGJvb2xlYW58dW5kZWZpbmVkKSxcbiAqICAgd2FzQWN0aXZhdGVkQnlQb2ludGVyOiAoYm9vbGVhbnx1bmRlZmluZWQpLFxuICogICB3YXNFbGVtZW50TWFkZUFjdGl2ZTogKGJvb2xlYW58dW5kZWZpbmVkKSxcbiAqICAgYWN0aXZhdGlvbkV2ZW50OiBFdmVudCxcbiAqICAgaXNQcm9ncmFtbWF0aWM6IChib29sZWFufHVuZGVmaW5lZClcbiAqIH19XG4gKi9cbmxldCBBY3RpdmF0aW9uU3RhdGVUeXBlO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGFjdGl2YXRlOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gKiAgIGRlYWN0aXZhdGU6IChzdHJpbmd8dW5kZWZpbmVkKSxcbiAqICAgZm9jdXM6IChzdHJpbmd8dW5kZWZpbmVkKSxcbiAqICAgYmx1cjogKHN0cmluZ3x1bmRlZmluZWQpXG4gKiB9fVxuICovXG5sZXQgTGlzdGVuZXJJbmZvVHlwZTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBhY3RpdmF0ZTogZnVuY3Rpb24oIUV2ZW50KSxcbiAqICAgZGVhY3RpdmF0ZTogZnVuY3Rpb24oIUV2ZW50KSxcbiAqICAgZm9jdXM6IGZ1bmN0aW9uKCksXG4gKiAgIGJsdXI6IGZ1bmN0aW9uKClcbiAqIH19XG4gKi9cbmxldCBMaXN0ZW5lcnNUeXBlO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIHg6IG51bWJlcixcbiAqICAgeTogbnVtYmVyXG4gKiB9fVxuICovXG5sZXQgUG9pbnRUeXBlO1xuXG4vLyBBY3RpdmF0aW9uIGV2ZW50cyByZWdpc3RlcmVkIG9uIHRoZSByb290IGVsZW1lbnQgb2YgZWFjaCBpbnN0YW5jZSBmb3IgYWN0aXZhdGlvblxuY29uc3QgQUNUSVZBVElPTl9FVkVOVF9UWVBFUyA9IFsndG91Y2hzdGFydCcsICdwb2ludGVyZG93bicsICdtb3VzZWRvd24nLCAna2V5ZG93biddO1xuXG4vLyBEZWFjdGl2YXRpb24gZXZlbnRzIHJlZ2lzdGVyZWQgb24gZG9jdW1lbnRFbGVtZW50IHdoZW4gYSBwb2ludGVyLXJlbGF0ZWQgZG93biBldmVudCBvY2N1cnNcbmNvbnN0IFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTID0gWyd0b3VjaGVuZCcsICdwb2ludGVydXAnLCAnbW91c2V1cCddO1xuXG4vLyBUcmFja3MgYWN0aXZhdGlvbnMgdGhhdCBoYXZlIG9jY3VycmVkIG9uIHRoZSBjdXJyZW50IGZyYW1lLCB0byBhdm9pZCBzaW11bHRhbmVvdXMgbmVzdGVkIGFjdGl2YXRpb25zXG4vKiogQHR5cGUgeyFBcnJheTwhRXZlbnRUYXJnZXQ+fSAqL1xubGV0IGFjdGl2YXRlZFRhcmdldHMgPSBbXTtcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDUmlwcGxlQWRhcHRlcj59XG4gKi9cbmNsYXNzIE1EQ1JpcHBsZUZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIHJldHVybiBudW1iZXJzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYnJvd3NlclN1cHBvcnRzQ3NzVmFyczogKCkgPT4gLyogYm9vbGVhbiAtIGNhY2hlZCAqLyB7fSxcbiAgICAgIGlzVW5ib3VuZGVkOiAoKSA9PiAvKiBib29sZWFuICovIHt9LFxuICAgICAgaXNTdXJmYWNlQWN0aXZlOiAoKSA9PiAvKiBib29sZWFuICovIHt9LFxuICAgICAgaXNTdXJmYWNlRGlzYWJsZWQ6ICgpID0+IC8qIGJvb2xlYW4gKi8ge30sXG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgY29udGFpbnNFdmVudFRhcmdldDogKC8qIHRhcmdldDogIUV2ZW50VGFyZ2V0ICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0VHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnRUeXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dFR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnRUeXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgdXBkYXRlQ3NzVmFyaWFibGU6ICgvKiB2YXJOYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogKCkgPT4gLyogQ2xpZW50UmVjdCAqLyB7fSxcbiAgICAgIGdldFdpbmRvd1BhZ2VPZmZzZXQ6ICgpID0+IC8qIHt4OiBudW1iZXIsIHk6IG51bWJlcn0gKi8ge30sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1JpcHBsZUZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMubGF5b3V0RnJhbWVfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUNsaWVudFJlY3R9ICovXG4gICAgdGhpcy5mcmFtZV8gPSAvKiogQHR5cGUgeyFDbGllbnRSZWN0fSAqLyAoe3dpZHRoOiAwLCBoZWlnaHQ6IDB9KTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUFjdGl2YXRpb25TdGF0ZVR5cGV9ICovXG4gICAgdGhpcy5hY3RpdmF0aW9uU3RhdGVfID0gdGhpcy5kZWZhdWx0QWN0aXZhdGlvblN0YXRlXygpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5pbml0aWFsU2l6ZV8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5tYXhSYWRpdXNfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KX0gKi9cbiAgICB0aGlzLmFjdGl2YXRlSGFuZGxlcl8gPSAoZSkgPT4gdGhpcy5hY3RpdmF0ZV8oZSk7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCl9ICovXG4gICAgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcl8gPSAoZSkgPT4gdGhpcy5kZWFjdGl2YXRlXyhlKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oP0V2ZW50PSl9ICovXG4gICAgdGhpcy5mb2N1c0hhbmRsZXJfID0gKCkgPT4gdGhpcy5oYW5kbGVGb2N1cygpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbig/RXZlbnQ9KX0gKi9cbiAgICB0aGlzLmJsdXJIYW5kbGVyXyA9ICgpID0+IHRoaXMuaGFuZGxlQmx1cigpO1xuXG4gICAgLyoqIEBwcml2YXRlIHshRnVuY3Rpb259ICovXG4gICAgdGhpcy5yZXNpemVIYW5kbGVyXyA9ICgpID0+IHRoaXMubGF5b3V0KCk7XG5cbiAgICAvKiogQHByaXZhdGUge3tsZWZ0OiBudW1iZXIsIHRvcDpudW1iZXJ9fSAqL1xuICAgIHRoaXMudW5ib3VuZGVkQ29vcmRzXyA9IHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgfTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuZmdTY2FsZV8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5hY3RpdmF0aW9uVGltZXJfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuZmdEZWFjdGl2YXRpb25SZW1vdmFsVGltZXJfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF8gPSBmYWxzZTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUZ1bmN0aW9ufSAqL1xuICAgIHRoaXMuYWN0aXZhdGlvblRpbWVyQ2FsbGJhY2tfID0gKCkgPT4ge1xuICAgICAgdGhpcy5hY3RpdmF0aW9uQW5pbWF0aW9uSGFzRW5kZWRfID0gdHJ1ZTtcbiAgICAgIHRoaXMucnVuRGVhY3RpdmF0aW9uVVhMb2dpY0lmUmVhZHlfKCk7XG4gICAgfTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7P0V2ZW50fSAqL1xuICAgIHRoaXMucHJldmlvdXNBY3RpdmF0aW9uRXZlbnRfID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXZSBjb21wdXRlIHRoaXMgcHJvcGVydHkgc28gdGhhdCB3ZSBhcmUgbm90IHF1ZXJ5aW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjbGllbnRcbiAgICogdW50aWwgdGhlIHBvaW50IGluIHRpbWUgd2hlcmUgdGhlIGZvdW5kYXRpb24gcmVxdWVzdHMgaXQuIFRoaXMgcHJldmVudHMgc2NlbmFyaW9zIHdoZXJlXG4gICAqIGNsaWVudC1zaWRlIGZlYXR1cmUtZGV0ZWN0aW9uIG1heSBoYXBwZW4gdG9vIGVhcmx5LCBzdWNoIGFzIHdoZW4gY29tcG9uZW50cyBhcmUgcmVuZGVyZWQgb24gdGhlIHNlcnZlclxuICAgKiBhbmQgdGhlbiBpbml0aWFsaXplZCBhdCBtb3VudCB0aW1lIG9uIHRoZSBjbGllbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdXBwb3J0c1ByZXNzUmlwcGxlXygpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5icm93c2VyU3VwcG9ydHNDc3NWYXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IUFjdGl2YXRpb25TdGF0ZVR5cGV9XG4gICAqL1xuICBkZWZhdWx0QWN0aXZhdGlvblN0YXRlXygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNBY3RpdmF0ZWQ6IGZhbHNlLFxuICAgICAgaGFzRGVhY3RpdmF0aW9uVVhSdW46IGZhbHNlLFxuICAgICAgd2FzQWN0aXZhdGVkQnlQb2ludGVyOiBmYWxzZSxcbiAgICAgIHdhc0VsZW1lbnRNYWRlQWN0aXZlOiBmYWxzZSxcbiAgICAgIGFjdGl2YXRpb25FdmVudDogbnVsbCxcbiAgICAgIGlzUHJvZ3JhbW1hdGljOiBmYWxzZSxcbiAgICB9O1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBpbml0KCkge1xuICAgIGNvbnN0IHN1cHBvcnRzUHJlc3NSaXBwbGUgPSB0aGlzLnN1cHBvcnRzUHJlc3NSaXBwbGVfKCk7XG5cbiAgICB0aGlzLnJlZ2lzdGVyUm9vdEhhbmRsZXJzXyhzdXBwb3J0c1ByZXNzUmlwcGxlKTtcblxuICAgIGlmIChzdXBwb3J0c1ByZXNzUmlwcGxlKSB7XG4gICAgICBjb25zdCB7Uk9PVCwgVU5CT1VOREVEfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoUk9PVCk7XG4gICAgICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzVW5ib3VuZGVkKCkpIHtcbiAgICAgICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKFVOQk9VTkRFRCk7XG4gICAgICAgICAgLy8gVW5ib3VuZGVkIHJpcHBsZXMgbmVlZCBsYXlvdXQgbG9naWMgYXBwbGllZCBpbW1lZGlhdGVseSB0byBzZXQgY29vcmRpbmF0ZXMgZm9yIGJvdGggc2hhZGUgYW5kIHJpcHBsZVxuICAgICAgICAgIHRoaXMubGF5b3V0SW50ZXJuYWxfKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5zdXBwb3J0c1ByZXNzUmlwcGxlXygpKSB7XG4gICAgICBpZiAodGhpcy5hY3RpdmF0aW9uVGltZXJfKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmFjdGl2YXRpb25UaW1lcl8pO1xuICAgICAgICB0aGlzLmFjdGl2YXRpb25UaW1lcl8gPSAwO1xuICAgICAgICBjb25zdCB7RkdfQUNUSVZBVElPTn0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoRkdfQUNUSVZBVElPTik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtST09ULCBVTkJPVU5ERUR9ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhST09UKTtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhVTkJPVU5ERUQpO1xuICAgICAgICB0aGlzLnJlbW92ZUNzc1ZhcnNfKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmRlcmVnaXN0ZXJSb290SGFuZGxlcnNfKCk7XG4gICAgdGhpcy5kZXJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBzdXBwb3J0c1ByZXNzUmlwcGxlIFBhc3NlZCBmcm9tIGluaXQgdG8gc2F2ZSBhIHJlZHVuZGFudCBmdW5jdGlvbiBjYWxsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZWdpc3RlclJvb3RIYW5kbGVyc18oc3VwcG9ydHNQcmVzc1JpcHBsZSkge1xuICAgIGlmIChzdXBwb3J0c1ByZXNzUmlwcGxlKSB7XG4gICAgICBBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcih0eXBlLCB0aGlzLmFjdGl2YXRlSGFuZGxlcl8pO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5hZGFwdGVyXy5pc1VuYm91bmRlZCgpKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdibHVyJywgdGhpcy5ibHVySGFuZGxlcl8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXyhlKSB7XG4gICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXl1cCcsIHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXJfKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcl8pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGRlcmVnaXN0ZXJSb290SGFuZGxlcnNfKCkge1xuICAgIEFDVElWQVRJT05fRVZFTlRfVFlQRVMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIHRoaXMuYWN0aXZhdGVIYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdmb2N1cycsIHRoaXMuZm9jdXNIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdibHVyJywgdGhpcy5ibHVySGFuZGxlcl8pO1xuXG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNVbmJvdW5kZWQoKSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgZGVyZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleXVwJywgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcl8pO1xuICAgIFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXJfKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICByZW1vdmVDc3NWYXJzXygpIHtcbiAgICBjb25zdCB7c3RyaW5nc30gPSBNRENSaXBwbGVGb3VuZGF0aW9uO1xuICAgIE9iamVjdC5rZXlzKHN0cmluZ3MpLmZvckVhY2goKGspID0+IHtcbiAgICAgIGlmIChrLmluZGV4T2YoJ1ZBUl8nKSA9PT0gMCkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKHN0cmluZ3Nba10sIG51bGwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7P0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhY3RpdmF0ZV8oZSkge1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzU3VyZmFjZURpc2FibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhY3RpdmF0aW9uU3RhdGUgPSB0aGlzLmFjdGl2YXRpb25TdGF0ZV87XG4gICAgaWYgKGFjdGl2YXRpb25TdGF0ZS5pc0FjdGl2YXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEF2b2lkIHJlYWN0aW5nIHRvIGZvbGxvdy1vbiBldmVudHMgZmlyZWQgYnkgdG91Y2ggZGV2aWNlIGFmdGVyIGFuIGFscmVhZHktcHJvY2Vzc2VkIHVzZXIgaW50ZXJhY3Rpb25cbiAgICBjb25zdCBwcmV2aW91c0FjdGl2YXRpb25FdmVudCA9IHRoaXMucHJldmlvdXNBY3RpdmF0aW9uRXZlbnRfO1xuICAgIGNvbnN0IGlzU2FtZUludGVyYWN0aW9uID0gcHJldmlvdXNBY3RpdmF0aW9uRXZlbnQgJiYgZSAmJiBwcmV2aW91c0FjdGl2YXRpb25FdmVudC50eXBlICE9PSBlLnR5cGU7XG4gICAgaWYgKGlzU2FtZUludGVyYWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYWN0aXZhdGlvblN0YXRlLmlzQWN0aXZhdGVkID0gdHJ1ZTtcbiAgICBhY3RpdmF0aW9uU3RhdGUuaXNQcm9ncmFtbWF0aWMgPSBlID09PSBudWxsO1xuICAgIGFjdGl2YXRpb25TdGF0ZS5hY3RpdmF0aW9uRXZlbnQgPSBlO1xuICAgIGFjdGl2YXRpb25TdGF0ZS53YXNBY3RpdmF0ZWRCeVBvaW50ZXIgPSBhY3RpdmF0aW9uU3RhdGUuaXNQcm9ncmFtbWF0aWMgPyBmYWxzZSA6IChcbiAgICAgIGUudHlwZSA9PT0gJ21vdXNlZG93bicgfHwgZS50eXBlID09PSAndG91Y2hzdGFydCcgfHwgZS50eXBlID09PSAncG9pbnRlcmRvd24nXG4gICAgKTtcblxuICAgIGNvbnN0IGhhc0FjdGl2YXRlZENoaWxkID1cbiAgICAgIGUgJiYgYWN0aXZhdGVkVGFyZ2V0cy5sZW5ndGggPiAwICYmIGFjdGl2YXRlZFRhcmdldHMuc29tZSgodGFyZ2V0KSA9PiB0aGlzLmFkYXB0ZXJfLmNvbnRhaW5zRXZlbnRUYXJnZXQodGFyZ2V0KSk7XG4gICAgaWYgKGhhc0FjdGl2YXRlZENoaWxkKSB7XG4gICAgICAvLyBJbW1lZGlhdGVseSByZXNldCBhY3RpdmF0aW9uIHN0YXRlLCB3aGlsZSBwcmVzZXJ2aW5nIGxvZ2ljIHRoYXQgcHJldmVudHMgdG91Y2ggZm9sbG93LW9uIGV2ZW50c1xuICAgICAgdGhpcy5yZXNldEFjdGl2YXRpb25TdGF0ZV8oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZSkge1xuICAgICAgYWN0aXZhdGVkVGFyZ2V0cy5wdXNoKC8qKiBAdHlwZSB7IUV2ZW50VGFyZ2V0fSAqLyAoZS50YXJnZXQpKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVyc18oZSk7XG4gICAgfVxuXG4gICAgYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlID0gdGhpcy5jaGVja0VsZW1lbnRNYWRlQWN0aXZlXyhlKTtcbiAgICBpZiAoYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlKSB7XG4gICAgICB0aGlzLmFuaW1hdGVBY3RpdmF0aW9uXygpO1xuICAgIH1cblxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAvLyBSZXNldCBhcnJheSBvbiBuZXh0IGZyYW1lIGFmdGVyIHRoZSBjdXJyZW50IGV2ZW50IGhhcyBoYWQgYSBjaGFuY2UgdG8gYnViYmxlIHRvIHByZXZlbnQgYW5jZXN0b3IgcmlwcGxlc1xuICAgICAgYWN0aXZhdGVkVGFyZ2V0cyA9IFtdO1xuXG4gICAgICBpZiAoIWFjdGl2YXRpb25TdGF0ZS53YXNFbGVtZW50TWFkZUFjdGl2ZSAmJiAoZS5rZXkgPT09ICcgJyB8fCBlLmtleUNvZGUgPT09IDMyKSkge1xuICAgICAgICAvLyBJZiBzcGFjZSB3YXMgcHJlc3NlZCwgdHJ5IGFnYWluIHdpdGhpbiBhbiByQUYgY2FsbCB0byBkZXRlY3QgOmFjdGl2ZSwgYmVjYXVzZSBkaWZmZXJlbnQgVUFzIHJlcG9ydFxuICAgICAgICAvLyBhY3RpdmUgc3RhdGVzIGluY29uc2lzdGVudGx5IHdoZW4gdGhleSdyZSBjYWxsZWQgd2l0aGluIGV2ZW50IGhhbmRsaW5nIGNvZGU6XG4gICAgICAgIC8vIC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NjM1OTcxXG4gICAgICAgIC8vIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI5Mzc0MVxuICAgICAgICAvLyBXZSB0cnkgZmlyc3Qgb3V0c2lkZSByQUYgdG8gc3VwcG9ydCBFZGdlLCB3aGljaCBkb2VzIG5vdCBleGhpYml0IHRoaXMgcHJvYmxlbSwgYnV0IHdpbGwgY3Jhc2ggaWYgYSBDU1NcbiAgICAgICAgLy8gdmFyaWFibGUgaXMgc2V0IHdpdGhpbiBhIHJBRiBjYWxsYmFjayBmb3IgYSBzdWJtaXQgYnV0dG9uIGludGVyYWN0aW9uICgjMjI0MSkuXG4gICAgICAgIGFjdGl2YXRpb25TdGF0ZS53YXNFbGVtZW50TWFkZUFjdGl2ZSA9IHRoaXMuY2hlY2tFbGVtZW50TWFkZUFjdGl2ZV8oZSk7XG4gICAgICAgIGlmIChhY3RpdmF0aW9uU3RhdGUud2FzRWxlbWVudE1hZGVBY3RpdmUpIHtcbiAgICAgICAgICB0aGlzLmFuaW1hdGVBY3RpdmF0aW9uXygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlKSB7XG4gICAgICAgIC8vIFJlc2V0IGFjdGl2YXRpb24gc3RhdGUgaW1tZWRpYXRlbHkgaWYgZWxlbWVudCB3YXMgbm90IG1hZGUgYWN0aXZlLlxuICAgICAgICB0aGlzLmFjdGl2YXRpb25TdGF0ZV8gPSB0aGlzLmRlZmF1bHRBY3RpdmF0aW9uU3RhdGVfKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHs/RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNoZWNrRWxlbWVudE1hZGVBY3RpdmVfKGUpIHtcbiAgICByZXR1cm4gKGUgJiYgZS50eXBlID09PSAna2V5ZG93bicpID8gdGhpcy5hZGFwdGVyXy5pc1N1cmZhY2VBY3RpdmUoKSA6IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHs/RXZlbnQ9fSBldmVudCBPcHRpb25hbCBldmVudCBjb250YWluaW5nIHBvc2l0aW9uIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgYWN0aXZhdGUoZXZlbnQgPSBudWxsKSB7XG4gICAgdGhpcy5hY3RpdmF0ZV8oZXZlbnQpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGFuaW1hdGVBY3RpdmF0aW9uXygpIHtcbiAgICBjb25zdCB7VkFSX0ZHX1RSQU5TTEFURV9TVEFSVCwgVkFSX0ZHX1RSQU5TTEFURV9FTkR9ID0gTURDUmlwcGxlRm91bmRhdGlvbi5zdHJpbmdzO1xuICAgIGNvbnN0IHtGR19ERUFDVElWQVRJT04sIEZHX0FDVElWQVRJT059ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIGNvbnN0IHtERUFDVElWQVRJT05fVElNRU9VVF9NU30gPSBNRENSaXBwbGVGb3VuZGF0aW9uLm51bWJlcnM7XG5cbiAgICB0aGlzLmxheW91dEludGVybmFsXygpO1xuXG4gICAgbGV0IHRyYW5zbGF0ZVN0YXJ0ID0gJyc7XG4gICAgbGV0IHRyYW5zbGF0ZUVuZCA9ICcnO1xuXG4gICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmlzVW5ib3VuZGVkKCkpIHtcbiAgICAgIGNvbnN0IHtzdGFydFBvaW50LCBlbmRQb2ludH0gPSB0aGlzLmdldEZnVHJhbnNsYXRpb25Db29yZGluYXRlc18oKTtcbiAgICAgIHRyYW5zbGF0ZVN0YXJ0ID0gYCR7c3RhcnRQb2ludC54fXB4LCAke3N0YXJ0UG9pbnQueX1weGA7XG4gICAgICB0cmFuc2xhdGVFbmQgPSBgJHtlbmRQb2ludC54fXB4LCAke2VuZFBvaW50Lnl9cHhgO1xuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoVkFSX0ZHX1RSQU5TTEFURV9TVEFSVCwgdHJhbnNsYXRlU3RhcnQpO1xuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoVkFSX0ZHX1RSQU5TTEFURV9FTkQsIHRyYW5zbGF0ZUVuZCk7XG4gICAgLy8gQ2FuY2VsIGFueSBvbmdvaW5nIGFjdGl2YXRpb24vZGVhY3RpdmF0aW9uIGFuaW1hdGlvbnNcbiAgICBjbGVhclRpbWVvdXQodGhpcy5hY3RpdmF0aW9uVGltZXJfKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5mZ0RlYWN0aXZhdGlvblJlbW92YWxUaW1lcl8pO1xuICAgIHRoaXMucm1Cb3VuZGVkQWN0aXZhdGlvbkNsYXNzZXNfKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhGR19ERUFDVElWQVRJT04pO1xuXG4gICAgLy8gRm9yY2UgbGF5b3V0IGluIG9yZGVyIHRvIHJlLXRyaWdnZXIgdGhlIGFuaW1hdGlvbi5cbiAgICB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKEZHX0FDVElWQVRJT04pO1xuICAgIHRoaXMuYWN0aXZhdGlvblRpbWVyXyA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5hY3RpdmF0aW9uVGltZXJDYWxsYmFja18oKSwgREVBQ1RJVkFUSU9OX1RJTUVPVVRfTVMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge3tzdGFydFBvaW50OiBQb2ludFR5cGUsIGVuZFBvaW50OiBQb2ludFR5cGV9fVxuICAgKi9cbiAgZ2V0RmdUcmFuc2xhdGlvbkNvb3JkaW5hdGVzXygpIHtcbiAgICBjb25zdCB7YWN0aXZhdGlvbkV2ZW50LCB3YXNBY3RpdmF0ZWRCeVBvaW50ZXJ9ID0gdGhpcy5hY3RpdmF0aW9uU3RhdGVfO1xuXG4gICAgbGV0IHN0YXJ0UG9pbnQ7XG4gICAgaWYgKHdhc0FjdGl2YXRlZEJ5UG9pbnRlcikge1xuICAgICAgc3RhcnRQb2ludCA9IGdldE5vcm1hbGl6ZWRFdmVudENvb3JkcyhcbiAgICAgICAgLyoqIEB0eXBlIHshRXZlbnR9ICovIChhY3RpdmF0aW9uRXZlbnQpLFxuICAgICAgICB0aGlzLmFkYXB0ZXJfLmdldFdpbmRvd1BhZ2VPZmZzZXQoKSwgdGhpcy5hZGFwdGVyXy5jb21wdXRlQm91bmRpbmdSZWN0KClcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0UG9pbnQgPSB7XG4gICAgICAgIHg6IHRoaXMuZnJhbWVfLndpZHRoIC8gMixcbiAgICAgICAgeTogdGhpcy5mcmFtZV8uaGVpZ2h0IC8gMixcbiAgICAgIH07XG4gICAgfVxuICAgIC8vIENlbnRlciB0aGUgZWxlbWVudCBhcm91bmQgdGhlIHN0YXJ0IHBvaW50LlxuICAgIHN0YXJ0UG9pbnQgPSB7XG4gICAgICB4OiBzdGFydFBvaW50LnggLSAodGhpcy5pbml0aWFsU2l6ZV8gLyAyKSxcbiAgICAgIHk6IHN0YXJ0UG9pbnQueSAtICh0aGlzLmluaXRpYWxTaXplXyAvIDIpLFxuICAgIH07XG5cbiAgICBjb25zdCBlbmRQb2ludCA9IHtcbiAgICAgIHg6ICh0aGlzLmZyYW1lXy53aWR0aCAvIDIpIC0gKHRoaXMuaW5pdGlhbFNpemVfIC8gMiksXG4gICAgICB5OiAodGhpcy5mcmFtZV8uaGVpZ2h0IC8gMikgLSAodGhpcy5pbml0aWFsU2l6ZV8gLyAyKSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtzdGFydFBvaW50LCBlbmRQb2ludH07XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcnVuRGVhY3RpdmF0aW9uVVhMb2dpY0lmUmVhZHlfKCkge1xuICAgIC8vIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBib3RoIHdoZW4gYSBwb2ludGluZyBkZXZpY2UgaXMgcmVsZWFzZWQsIGFuZCB3aGVuIHRoZSBhY3RpdmF0aW9uIGFuaW1hdGlvbiBlbmRzLlxuICAgIC8vIFRoZSBkZWFjdGl2YXRpb24gYW5pbWF0aW9uIHNob3VsZCBvbmx5IHJ1biBhZnRlciBib3RoIG9mIHRob3NlIG9jY3VyLlxuICAgIGNvbnN0IHtGR19ERUFDVElWQVRJT059ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIGNvbnN0IHtoYXNEZWFjdGl2YXRpb25VWFJ1biwgaXNBY3RpdmF0ZWR9ID0gdGhpcy5hY3RpdmF0aW9uU3RhdGVfO1xuICAgIGNvbnN0IGFjdGl2YXRpb25IYXNFbmRlZCA9IGhhc0RlYWN0aXZhdGlvblVYUnVuIHx8ICFpc0FjdGl2YXRlZDtcblxuICAgIGlmIChhY3RpdmF0aW9uSGFzRW5kZWQgJiYgdGhpcy5hY3RpdmF0aW9uQW5pbWF0aW9uSGFzRW5kZWRfKSB7XG4gICAgICB0aGlzLnJtQm91bmRlZEFjdGl2YXRpb25DbGFzc2VzXygpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhGR19ERUFDVElWQVRJT04pO1xuICAgICAgdGhpcy5mZ0RlYWN0aXZhdGlvblJlbW92YWxUaW1lcl8gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhGR19ERUFDVElWQVRJT04pO1xuICAgICAgfSwgbnVtYmVycy5GR19ERUFDVElWQVRJT05fTVMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBybUJvdW5kZWRBY3RpdmF0aW9uQ2xhc3Nlc18oKSB7XG4gICAgY29uc3Qge0ZHX0FDVElWQVRJT059ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoRkdfQUNUSVZBVElPTik7XG4gICAgdGhpcy5hY3RpdmF0aW9uQW5pbWF0aW9uSGFzRW5kZWRfID0gZmFsc2U7XG4gICAgdGhpcy5hZGFwdGVyXy5jb21wdXRlQm91bmRpbmdSZWN0KCk7XG4gIH1cblxuICByZXNldEFjdGl2YXRpb25TdGF0ZV8oKSB7XG4gICAgdGhpcy5wcmV2aW91c0FjdGl2YXRpb25FdmVudF8gPSB0aGlzLmFjdGl2YXRpb25TdGF0ZV8uYWN0aXZhdGlvbkV2ZW50O1xuICAgIHRoaXMuYWN0aXZhdGlvblN0YXRlXyA9IHRoaXMuZGVmYXVsdEFjdGl2YXRpb25TdGF0ZV8oKTtcbiAgICAvLyBUb3VjaCBkZXZpY2VzIG1heSBmaXJlIGFkZGl0aW9uYWwgZXZlbnRzIGZvciB0aGUgc2FtZSBpbnRlcmFjdGlvbiB3aXRoaW4gYSBzaG9ydCB0aW1lLlxuICAgIC8vIFN0b3JlIHRoZSBwcmV2aW91cyBldmVudCB1bnRpbCBpdCdzIHNhZmUgdG8gYXNzdW1lIHRoYXQgc3Vic2VxdWVudCBldmVudHMgYXJlIGZvciBuZXcgaW50ZXJhY3Rpb25zLlxuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5wcmV2aW91c0FjdGl2YXRpb25FdmVudF8gPSBudWxsLCBNRENSaXBwbGVGb3VuZGF0aW9uLm51bWJlcnMuVEFQX0RFTEFZX01TKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gez9FdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGVhY3RpdmF0ZV8oZSkge1xuICAgIGNvbnN0IGFjdGl2YXRpb25TdGF0ZSA9IHRoaXMuYWN0aXZhdGlvblN0YXRlXztcbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaW4gc2NlbmFyaW9zIHN1Y2ggYXMgd2hlbiB5b3UgaGF2ZSBhIGtleXVwIGV2ZW50IHRoYXQgYmx1cnMgdGhlIGVsZW1lbnQuXG4gICAgaWYgKCFhY3RpdmF0aW9uU3RhdGUuaXNBY3RpdmF0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzdGF0ZSA9IC8qKiBAdHlwZSB7IUFjdGl2YXRpb25TdGF0ZVR5cGV9ICovIChPYmplY3QuYXNzaWduKHt9LCBhY3RpdmF0aW9uU3RhdGUpKTtcblxuICAgIGlmIChhY3RpdmF0aW9uU3RhdGUuaXNQcm9ncmFtbWF0aWMpIHtcbiAgICAgIGNvbnN0IGV2dE9iamVjdCA9IG51bGw7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5hbmltYXRlRGVhY3RpdmF0aW9uXyhldnRPYmplY3QsIHN0YXRlKSk7XG4gICAgICB0aGlzLnJlc2V0QWN0aXZhdGlvblN0YXRlXygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlcmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVyc18oKTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuYWN0aXZhdGlvblN0YXRlXy5oYXNEZWFjdGl2YXRpb25VWFJ1biA9IHRydWU7XG4gICAgICAgIHRoaXMuYW5pbWF0ZURlYWN0aXZhdGlvbl8oZSwgc3RhdGUpO1xuICAgICAgICB0aGlzLnJlc2V0QWN0aXZhdGlvblN0YXRlXygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7P0V2ZW50PX0gZXZlbnQgT3B0aW9uYWwgZXZlbnQgY29udGFpbmluZyBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAgICovXG4gIGRlYWN0aXZhdGUoZXZlbnQgPSBudWxsKSB7XG4gICAgdGhpcy5kZWFjdGl2YXRlXyhldmVudCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKiBAcGFyYW0geyFBY3RpdmF0aW9uU3RhdGVUeXBlfSBvcHRpb25zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhbmltYXRlRGVhY3RpdmF0aW9uXyhlLCB7d2FzQWN0aXZhdGVkQnlQb2ludGVyLCB3YXNFbGVtZW50TWFkZUFjdGl2ZX0pIHtcbiAgICBpZiAod2FzQWN0aXZhdGVkQnlQb2ludGVyIHx8IHdhc0VsZW1lbnRNYWRlQWN0aXZlKSB7XG4gICAgICB0aGlzLnJ1bkRlYWN0aXZhdGlvblVYTG9naWNJZlJlYWR5XygpO1xuICAgIH1cbiAgfVxuXG4gIGxheW91dCgpIHtcbiAgICBpZiAodGhpcy5sYXlvdXRGcmFtZV8pIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubGF5b3V0RnJhbWVfKTtcbiAgICB9XG4gICAgdGhpcy5sYXlvdXRGcmFtZV8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5sYXlvdXRJbnRlcm5hbF8oKTtcbiAgICAgIHRoaXMubGF5b3V0RnJhbWVfID0gMDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBsYXlvdXRJbnRlcm5hbF8oKSB7XG4gICAgdGhpcy5mcmFtZV8gPSB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKTtcbiAgICBjb25zdCBtYXhEaW0gPSBNYXRoLm1heCh0aGlzLmZyYW1lXy5oZWlnaHQsIHRoaXMuZnJhbWVfLndpZHRoKTtcblxuICAgIC8vIFN1cmZhY2UgZGlhbWV0ZXIgaXMgdHJlYXRlZCBkaWZmZXJlbnRseSBmb3IgdW5ib3VuZGVkIHZzLiBib3VuZGVkIHJpcHBsZXMuXG4gICAgLy8gVW5ib3VuZGVkIHJpcHBsZSBkaWFtZXRlciBpcyBjYWxjdWxhdGVkIHNtYWxsZXIgc2luY2UgdGhlIHN1cmZhY2UgaXMgZXhwZWN0ZWQgdG8gYWxyZWFkeSBiZSBwYWRkZWQgYXBwcm9wcmlhdGVseVxuICAgIC8vIHRvIGV4dGVuZCB0aGUgaGl0Ym94LCBhbmQgdGhlIHJpcHBsZSBpcyBleHBlY3RlZCB0byBtZWV0IHRoZSBlZGdlcyBvZiB0aGUgcGFkZGVkIGhpdGJveCAod2hpY2ggaXMgdHlwaWNhbGx5XG4gICAgLy8gc3F1YXJlKS4gQm91bmRlZCByaXBwbGVzLCBvbiB0aGUgb3RoZXIgaGFuZCwgYXJlIGZ1bGx5IGV4cGVjdGVkIHRvIGV4cGFuZCBiZXlvbmQgdGhlIHN1cmZhY2UncyBsb25nZXN0IGRpYW1ldGVyXG4gICAgLy8gKGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIGRpYWdvbmFsIHBsdXMgYSBjb25zdGFudCBwYWRkaW5nKSwgYW5kIGFyZSBjbGlwcGVkIGF0IHRoZSBzdXJmYWNlJ3MgYm9yZGVyIHZpYVxuICAgIC8vIGBvdmVyZmxvdzogaGlkZGVuYC5cbiAgICBjb25zdCBnZXRCb3VuZGVkUmFkaXVzID0gKCkgPT4ge1xuICAgICAgY29uc3QgaHlwb3RlbnVzZSA9IE1hdGguc3FydChNYXRoLnBvdyh0aGlzLmZyYW1lXy53aWR0aCwgMikgKyBNYXRoLnBvdyh0aGlzLmZyYW1lXy5oZWlnaHQsIDIpKTtcbiAgICAgIHJldHVybiBoeXBvdGVudXNlICsgTURDUmlwcGxlRm91bmRhdGlvbi5udW1iZXJzLlBBRERJTkc7XG4gICAgfTtcblxuICAgIHRoaXMubWF4UmFkaXVzXyA9IHRoaXMuYWRhcHRlcl8uaXNVbmJvdW5kZWQoKSA/IG1heERpbSA6IGdldEJvdW5kZWRSYWRpdXMoKTtcblxuICAgIC8vIFJpcHBsZSBpcyBzaXplZCBhcyBhIGZyYWN0aW9uIG9mIHRoZSBsYXJnZXN0IGRpbWVuc2lvbiBvZiB0aGUgc3VyZmFjZSwgdGhlbiBzY2FsZXMgdXAgdXNpbmcgYSBDU1Mgc2NhbGUgdHJhbnNmb3JtXG4gICAgdGhpcy5pbml0aWFsU2l6ZV8gPSBtYXhEaW0gKiBNRENSaXBwbGVGb3VuZGF0aW9uLm51bWJlcnMuSU5JVElBTF9PUklHSU5fU0NBTEU7XG4gICAgdGhpcy5mZ1NjYWxlXyA9IHRoaXMubWF4UmFkaXVzXyAvIHRoaXMuaW5pdGlhbFNpemVfO1xuXG4gICAgdGhpcy51cGRhdGVMYXlvdXRDc3NWYXJzXygpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHVwZGF0ZUxheW91dENzc1ZhcnNfKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIFZBUl9GR19TSVpFLCBWQVJfTEVGVCwgVkFSX1RPUCwgVkFSX0ZHX1NDQUxFLFxuICAgIH0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLnN0cmluZ3M7XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKFZBUl9GR19TSVpFLCBgJHt0aGlzLmluaXRpYWxTaXplX31weGApO1xuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoVkFSX0ZHX1NDQUxFLCB0aGlzLmZnU2NhbGVfKTtcblxuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzVW5ib3VuZGVkKCkpIHtcbiAgICAgIHRoaXMudW5ib3VuZGVkQ29vcmRzXyA9IHtcbiAgICAgICAgbGVmdDogTWF0aC5yb3VuZCgodGhpcy5mcmFtZV8ud2lkdGggLyAyKSAtICh0aGlzLmluaXRpYWxTaXplXyAvIDIpKSxcbiAgICAgICAgdG9wOiBNYXRoLnJvdW5kKCh0aGlzLmZyYW1lXy5oZWlnaHQgLyAyKSAtICh0aGlzLmluaXRpYWxTaXplXyAvIDIpKSxcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoVkFSX0xFRlQsIGAke3RoaXMudW5ib3VuZGVkQ29vcmRzXy5sZWZ0fXB4YCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKFZBUl9UT1AsIGAke3RoaXMudW5ib3VuZGVkQ29vcmRzXy50b3B9cHhgKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSB1bmJvdW5kZWQgKi9cbiAgc2V0VW5ib3VuZGVkKHVuYm91bmRlZCkge1xuICAgIGNvbnN0IHtVTkJPVU5ERUR9ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIGlmICh1bmJvdW5kZWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoVU5CT1VOREVEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhVTkJPVU5ERUQpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUZvY3VzKCkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PlxuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQkdfRk9DVVNFRCkpO1xuICB9XG5cbiAgaGFuZGxlQmx1cigpIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT5cbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzLkJHX0ZPQ1VTRUQpKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENSaXBwbGVGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENDb21wb25lbnQgZnJvbSAnQG1hdGVyaWFsL2Jhc2UvY29tcG9uZW50JztcbmltcG9ydCBNRENSaXBwbGVBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQgTURDUmlwcGxlRm91bmRhdGlvbiBmcm9tICcuL2ZvdW5kYXRpb24nO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIEBleHRlbmRzIE1EQ0NvbXBvbmVudDwhTURDUmlwcGxlRm91bmRhdGlvbj5cbiAqL1xuY2xhc3MgTURDUmlwcGxlIGV4dGVuZHMgTURDQ29tcG9uZW50IHtcbiAgLyoqIEBwYXJhbSB7Li4uP30gYXJncyAqL1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMudW5ib3VuZGVkXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSByb290XG4gICAqIEBwYXJhbSB7e2lzVW5ib3VuZGVkOiAoYm9vbGVhbnx1bmRlZmluZWQpfT19IG9wdGlvbnNcbiAgICogQHJldHVybiB7IU1EQ1JpcHBsZX1cbiAgICovXG4gIHN0YXRpYyBhdHRhY2hUbyhyb290LCB7aXNVbmJvdW5kZWQgPSB1bmRlZmluZWR9ID0ge30pIHtcbiAgICBjb25zdCByaXBwbGUgPSBuZXcgTURDUmlwcGxlKHJvb3QpO1xuICAgIC8vIE9ubHkgb3ZlcnJpZGUgdW5ib3VuZGVkIGJlaGF2aW9yIGlmIG9wdGlvbiBpcyBleHBsaWNpdGx5IHNwZWNpZmllZFxuICAgIGlmIChpc1VuYm91bmRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByaXBwbGUudW5ib3VuZGVkID0gLyoqIEB0eXBlIHtib29sZWFufSAqLyAoaXNVbmJvdW5kZWQpO1xuICAgIH1cbiAgICByZXR1cm4gcmlwcGxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IVJpcHBsZUNhcGFibGVTdXJmYWNlfSBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHshTURDUmlwcGxlQWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVBZGFwdGVyKGluc3RhbmNlKSB7XG4gICAgY29uc3QgTUFUQ0hFUyA9IHV0aWwuZ2V0TWF0Y2hlc1Byb3BlcnR5KEhUTUxFbGVtZW50LnByb3RvdHlwZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgYnJvd3NlclN1cHBvcnRzQ3NzVmFyczogKCkgPT4gdXRpbC5zdXBwb3J0c0Nzc1ZhcmlhYmxlcyh3aW5kb3cpLFxuICAgICAgaXNVbmJvdW5kZWQ6ICgpID0+IGluc3RhbmNlLnVuYm91bmRlZCxcbiAgICAgIGlzU3VyZmFjZUFjdGl2ZTogKCkgPT4gaW5zdGFuY2Uucm9vdF9bTUFUQ0hFU10oJzphY3RpdmUnKSxcbiAgICAgIGlzU3VyZmFjZURpc2FibGVkOiAoKSA9PiBpbnN0YW5jZS5kaXNhYmxlZCxcbiAgICAgIGFkZENsYXNzOiAoY2xhc3NOYW1lKSA9PiBpbnN0YW5jZS5yb290Xy5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSksXG4gICAgICByZW1vdmVDbGFzczogKGNsYXNzTmFtZSkgPT4gaW5zdGFuY2Uucm9vdF8uY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpLFxuICAgICAgY29udGFpbnNFdmVudFRhcmdldDogKHRhcmdldCkgPT4gaW5zdGFuY2Uucm9vdF8uY29udGFpbnModGFyZ2V0KSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT5cbiAgICAgICAgaW5zdGFuY2Uucm9vdF8uYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCB1dGlsLmFwcGx5UGFzc2l2ZSgpKSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PlxuICAgICAgICBpbnN0YW5jZS5yb290Xy5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIsIHV0aWwuYXBwbHlQYXNzaXZlKCkpLFxuICAgICAgcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+XG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIsIHV0aWwuYXBwbHlQYXNzaXZlKCkpLFxuICAgICAgZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT5cbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlciwgdXRpbC5hcHBseVBhc3NpdmUoKSksXG4gICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6IChoYW5kbGVyKSA9PiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKGhhbmRsZXIpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKSxcbiAgICAgIHVwZGF0ZUNzc1ZhcmlhYmxlOiAodmFyTmFtZSwgdmFsdWUpID0+IGluc3RhbmNlLnJvb3RfLnN0eWxlLnNldFByb3BlcnR5KHZhck5hbWUsIHZhbHVlKSxcbiAgICAgIGNvbXB1dGVCb3VuZGluZ1JlY3Q6ICgpID0+IGluc3RhbmNlLnJvb3RfLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgZ2V0V2luZG93UGFnZU9mZnNldDogKCkgPT4gKHt4OiB3aW5kb3cucGFnZVhPZmZzZXQsIHk6IHdpbmRvdy5wYWdlWU9mZnNldH0pLFxuICAgIH07XG4gIH1cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgZ2V0IHVuYm91bmRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmJvdW5kZWRfO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gdW5ib3VuZGVkICovXG4gIHNldCB1bmJvdW5kZWQodW5ib3VuZGVkKSB7XG4gICAgdGhpcy51bmJvdW5kZWRfID0gQm9vbGVhbih1bmJvdW5kZWQpO1xuICAgIHRoaXMuc2V0VW5ib3VuZGVkXygpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3N1cmUgQ29tcGlsZXIgdGhyb3dzIGFuIGFjY2VzcyBjb250cm9sIGVycm9yIHdoZW4gZGlyZWN0bHkgYWNjZXNzaW5nIGFcbiAgICogcHJvdGVjdGVkIG9yIHByaXZhdGUgcHJvcGVydHkgaW5zaWRlIGEgZ2V0dGVyL3NldHRlciwgbGlrZSB1bmJvdW5kZWQgYWJvdmUuXG4gICAqIEJ5IGFjY2Vzc2luZyB0aGUgcHJvdGVjdGVkIHByb3BlcnR5IGluc2lkZSBhIG1ldGhvZCwgd2Ugc29sdmUgdGhhdCBwcm9ibGVtLlxuICAgKiBUaGF0J3Mgd2h5IHRoaXMgZnVuY3Rpb24gZXhpc3RzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0VW5ib3VuZGVkXygpIHtcbiAgICB0aGlzLmZvdW5kYXRpb25fLnNldFVuYm91bmRlZCh0aGlzLnVuYm91bmRlZF8pO1xuICB9XG5cbiAgYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5hY3RpdmF0ZSgpO1xuICB9XG5cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb25fLmRlYWN0aXZhdGUoKTtcbiAgfVxuXG4gIGxheW91dCgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb25fLmxheW91dCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFNRENSaXBwbGVGb3VuZGF0aW9ufVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldERlZmF1bHRGb3VuZGF0aW9uKCkge1xuICAgIHJldHVybiBuZXcgTURDUmlwcGxlRm91bmRhdGlvbihNRENSaXBwbGUuY3JlYXRlQWRhcHRlcih0aGlzKSk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGluaXRpYWxTeW5jV2l0aERPTSgpIHtcbiAgICB0aGlzLnVuYm91bmRlZCA9ICdtZGNSaXBwbGVJc1VuYm91bmRlZCcgaW4gdGhpcy5yb290Xy5kYXRhc2V0O1xuICB9XG59XG5cbi8qKlxuICogU2VlIE1hdGVyaWFsIERlc2lnbiBzcGVjIGZvciBtb3JlIGRldGFpbHMgb24gd2hlbiB0byB1c2UgcmlwcGxlcy5cbiAqIGh0dHBzOi8vbWF0ZXJpYWwuaW8vZ3VpZGVsaW5lcy9tb3Rpb24vY2hvcmVvZ3JhcGh5Lmh0bWwjY2hvcmVvZ3JhcGh5LWNyZWF0aW9uXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIFJpcHBsZUNhcGFibGVTdXJmYWNlIHt9XG5cbi8qKiBAcHJvdGVjdGVkIHshRWxlbWVudH0gKi9cblJpcHBsZUNhcGFibGVTdXJmYWNlLnByb3RvdHlwZS5yb290XztcblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgcmlwcGxlIGJsZWVkcyBvdXQgb2YgdGhlIGJvdW5kcyBvZiB0aGUgZWxlbWVudC5cbiAqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH1cbiAqL1xuUmlwcGxlQ2FwYWJsZVN1cmZhY2UucHJvdG90eXBlLnVuYm91bmRlZDtcblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgcmlwcGxlIGlzIGF0dGFjaGVkIHRvIGEgZGlzYWJsZWQgY29tcG9uZW50LlxuICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICovXG5SaXBwbGVDYXBhYmxlU3VyZmFjZS5wcm90b3R5cGUuZGlzYWJsZWQ7XG5cbmV4cG9ydCB7TURDUmlwcGxlLCBNRENSaXBwbGVGb3VuZGF0aW9uLCBSaXBwbGVDYXBhYmxlU3VyZmFjZSwgdXRpbH07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7TURDUmlwcGxlfSBmcm9tICdAbWF0ZXJpYWwvcmlwcGxlL2luZGV4Jztcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBjaGVja2VkOiBib29sZWFuLFxuICogICBpbmRldGVybWluYXRlOiBib29sZWFuLFxuICogICBkaXNhYmxlZDogYm9vbGVhbixcbiAqICAgdmFsdWU6ID9zdHJpbmdcbiAqIH19XG4gKi9cbmxldCBNRENTZWxlY3Rpb25Db250cm9sU3RhdGU7XG5cbi8qKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENTZWxlY3Rpb25Db250cm9sIHtcbiAgLyoqIEByZXR1cm4gez9NRENSaXBwbGV9ICovXG4gIGdldCByaXBwbGUoKSB7fVxufVxuXG5leHBvcnQge01EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZSwgTURDU2VsZWN0aW9uQ29udHJvbH07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7TURDU2VsZWN0aW9uQ29udHJvbFN0YXRlfSBmcm9tICdAbWF0ZXJpYWwvc2VsZWN0aW9uLWNvbnRyb2wvaW5kZXgnO1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgQ2hlY2tib3guIFByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgbWFuYWdpbmdcbiAqIC0gY2xhc3Nlc1xuICogLSBkb21cbiAqIC0gZXZlbnQgaGFuZGxlcnNcbiAqXG4gKiBBZGRpdGlvbmFsbHksIHByb3ZpZGVzIHR5cGUgaW5mb3JtYXRpb24gZm9yIHRoZSBhZGFwdGVyIHRvIHRoZSBDbG9zdXJlXG4gKiBjb21waWxlci5cbiAqXG4gKiBJbXBsZW1lbnQgdGhpcyBhZGFwdGVyIGZvciB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UgdG8gZGVsZWdhdGUgdXBkYXRlcyB0b1xuICogdGhlIGNvbXBvbmVudCBpbiB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UuIFNlZSBhcmNoaXRlY3R1cmUgZG9jdW1lbnRhdGlvblxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvY29kZS9hcmNoaXRlY3R1cmUubWRcbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ0NoZWNrYm94QWRhcHRlciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYW4gYXR0cmlidXRlIHdpdGggYSBnaXZlbiB2YWx1ZSBvbiB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXROYXRpdmVDb250cm9sQXR0cihhdHRyLCB2YWx1ZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBhdHRyaWJ1dGUgZnJvbSB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICovXG4gIHJlbW92ZU5hdGl2ZUNvbnRyb2xBdHRyKGF0dHIpIHt9XG5cbiAgLyoqIEBwYXJhbSB7IUV2ZW50TGlzdGVuZXJ9IGhhbmRsZXIgKi9cbiAgcmVnaXN0ZXJBbmltYXRpb25FbmRIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqIEBwYXJhbSB7IUV2ZW50TGlzdGVuZXJ9IGhhbmRsZXIgKi9cbiAgZGVyZWdpc3RlckFuaW1hdGlvbkVuZEhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKiogQHBhcmFtIHshRXZlbnRMaXN0ZW5lcn0gaGFuZGxlciAqL1xuICByZWdpc3RlckNoYW5nZUhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKiogQHBhcmFtIHshRXZlbnRMaXN0ZW5lcn0gaGFuZGxlciAqL1xuICBkZXJlZ2lzdGVyQ2hhbmdlSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHshTURDU2VsZWN0aW9uQ29udHJvbFN0YXRlfSAqL1xuICBnZXROYXRpdmVDb250cm9sKCkge31cblxuICBmb3JjZUxheW91dCgpIHt9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzQXR0YWNoZWRUb0RPTSgpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0NoZWNrYm94QWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGNvbnN0IHtzdHJpbmd9ICovXG5jb25zdCBST09UID0gJ21kYy1jaGVja2JveCc7XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgVVBHUkFERUQ6ICdtZGMtY2hlY2tib3gtLXVwZ3JhZGVkJyxcbiAgQ0hFQ0tFRDogJ21kYy1jaGVja2JveC0tY2hlY2tlZCcsXG4gIElOREVURVJNSU5BVEU6ICdtZGMtY2hlY2tib3gtLWluZGV0ZXJtaW5hdGUnLFxuICBESVNBQkxFRDogJ21kYy1jaGVja2JveC0tZGlzYWJsZWQnLFxuICBBTklNX1VOQ0hFQ0tFRF9DSEVDS0VEOiAnbWRjLWNoZWNrYm94LS1hbmltLXVuY2hlY2tlZC1jaGVja2VkJyxcbiAgQU5JTV9VTkNIRUNLRURfSU5ERVRFUk1JTkFURTogJ21kYy1jaGVja2JveC0tYW5pbS11bmNoZWNrZWQtaW5kZXRlcm1pbmF0ZScsXG4gIEFOSU1fQ0hFQ0tFRF9VTkNIRUNLRUQ6ICdtZGMtY2hlY2tib3gtLWFuaW0tY2hlY2tlZC11bmNoZWNrZWQnLFxuICBBTklNX0NIRUNLRURfSU5ERVRFUk1JTkFURTogJ21kYy1jaGVja2JveC0tYW5pbS1jaGVja2VkLWluZGV0ZXJtaW5hdGUnLFxuICBBTklNX0lOREVURVJNSU5BVEVfQ0hFQ0tFRDogJ21kYy1jaGVja2JveC0tYW5pbS1pbmRldGVybWluYXRlLWNoZWNrZWQnLFxuICBBTklNX0lOREVURVJNSU5BVEVfVU5DSEVDS0VEOiAnbWRjLWNoZWNrYm94LS1hbmltLWluZGV0ZXJtaW5hdGUtdW5jaGVja2VkJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgTkFUSVZFX0NPTlRST0xfU0VMRUNUT1I6IGAuJHtST09UfV9fbmF0aXZlLWNvbnRyb2xgLFxuICBUUkFOU0lUSU9OX1NUQVRFX0lOSVQ6ICdpbml0JyxcbiAgVFJBTlNJVElPTl9TVEFURV9DSEVDS0VEOiAnY2hlY2tlZCcsXG4gIFRSQU5TSVRJT05fU1RBVEVfVU5DSEVDS0VEOiAndW5jaGVja2VkJyxcbiAgVFJBTlNJVElPTl9TVEFURV9JTkRFVEVSTUlOQVRFOiAnaW5kZXRlcm1pbmF0ZScsXG4gIEFSSUFfQ0hFQ0tFRF9BVFRSOiAnYXJpYS1jaGVja2VkJyxcbiAgQVJJQV9DSEVDS0VEX0lOREVURVJNSU5BVEVfVkFMVUU6ICdtaXhlZCcsXG59O1xuXG4vKiogQGVudW0ge251bWJlcn0gKi9cbmNvbnN0IG51bWJlcnMgPSB7XG4gIEFOSU1fRU5EX0xBVENIX01TOiAyNTAsXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7TURDU2VsZWN0aW9uQ29udHJvbFN0YXRlfSBmcm9tICdAbWF0ZXJpYWwvc2VsZWN0aW9uLWNvbnRyb2wvaW5kZXgnO1xuaW1wb3J0IE1EQ0NoZWNrYm94QWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8qKiBAY29uc3QgeyFBcnJheTxzdHJpbmc+fSAqL1xuY29uc3QgQ0JfUFJPVE9fUFJPUFMgPSBbJ2NoZWNrZWQnLCAnaW5kZXRlcm1pbmF0ZSddO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENDaGVja2JveEFkYXB0ZXI+fVxuICovXG5jbGFzcyBNRENDaGVja2JveEZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7Y3NzQ2xhc3Nlc30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nc30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7bnVtYmVyc30gKi9cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIHJldHVybiBudW1iZXJzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4geyFNRENDaGVja2JveEFkYXB0ZXJ9ICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ0NoZWNrYm94QWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXROYXRpdmVDb250cm9sQXR0cjogKC8qIGF0dHI6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVOYXRpdmVDb250cm9sQXR0cjogKC8qIGF0dHI6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZWdpc3RlckFuaW1hdGlvbkVuZEhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJBbmltYXRpb25FbmRIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlckNoYW5nZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJDaGFuZ2VIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBnZXROYXRpdmVDb250cm9sOiAoKSA9PiAvKiAhTURDU2VsZWN0aW9uQ29udHJvbFN0YXRlICovIHt9LFxuICAgICAgZm9yY2VMYXlvdXQ6ICgpID0+IHt9LFxuICAgICAgaXNBdHRhY2hlZFRvRE9NOiAoKSA9PiAvKiBib29sZWFuICovIHt9LFxuICAgIH0pO1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDQ2hlY2tib3hGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUge3N0cmluZ30gKi9cbiAgICB0aGlzLmN1cnJlbnRDaGVja1N0YXRlXyA9IHN0cmluZ3MuVFJBTlNJVElPTl9TVEFURV9JTklUO1xuXG4gICAgLyoqIEBwcml2YXRlIHtzdHJpbmd9ICovXG4gICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uQ2xhc3NfID0gJyc7XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLmFuaW1FbmRMYXRjaFRpbWVyXyA9IDA7XG5cbiAgICB0aGlzLmFuaW1FbmRIYW5kbGVyXyA9IC8qKiBAcHJpdmF0ZSB7IUV2ZW50TGlzdGVuZXJ9ICovIChcbiAgICAgICgpID0+IHRoaXMuaGFuZGxlQW5pbWF0aW9uRW5kKCkpO1xuXG4gICAgdGhpcy5jaGFuZ2VIYW5kbGVyXyA9IC8qKiBAcHJpdmF0ZSB7IUV2ZW50TGlzdGVuZXJ9ICovIChcbiAgICAgICgpID0+IHRoaXMuaGFuZGxlQ2hhbmdlKCkpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBpbml0KCkge1xuICAgIHRoaXMuY3VycmVudENoZWNrU3RhdGVfID0gdGhpcy5kZXRlcm1pbmVDaGVja1N0YXRlXyh0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkpO1xuICAgIHRoaXMudXBkYXRlQXJpYUNoZWNrZWRfKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLlVQR1JBREVEKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyQ2hhbmdlSGFuZGxlcih0aGlzLmNoYW5nZUhhbmRsZXJfKTtcbiAgICB0aGlzLmluc3RhbGxQcm9wZXJ0eUNoYW5nZUhvb2tzXygpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckNoYW5nZUhhbmRsZXIodGhpcy5jaGFuZ2VIYW5kbGVyXyk7XG4gICAgdGhpcy51bmluc3RhbGxQcm9wZXJ0eUNoYW5nZUhvb2tzXygpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzQ2hlY2tlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVDb250cm9sXygpLmNoZWNrZWQ7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBjaGVja2VkICovXG4gIHNldENoZWNrZWQoY2hlY2tlZCkge1xuICAgIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS5jaGVja2VkID0gY2hlY2tlZDtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc0luZGV0ZXJtaW5hdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS5pbmRldGVybWluYXRlO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gaW5kZXRlcm1pbmF0ZSAqL1xuICBzZXRJbmRldGVybWluYXRlKGluZGV0ZXJtaW5hdGUpIHtcbiAgICB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkuaW5kZXRlcm1pbmF0ZSA9IGluZGV0ZXJtaW5hdGU7XG4gIH1cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNEaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVDb250cm9sXygpLmRpc2FibGVkO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWQgKi9cbiAgc2V0RGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5ESVNBQkxFRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5ESVNBQkxFRCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEByZXR1cm4gez9zdHJpbmd9ICovXG4gIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkudmFsdWU7XG4gIH1cblxuICAvKiogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZSAqL1xuICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGFuaW1hdGlvbmVuZCBldmVudCBmb3IgdGhlIGNoZWNrYm94XG4gICAqL1xuICBoYW5kbGVBbmltYXRpb25FbmQoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuYW5pbUVuZExhdGNoVGltZXJfKTtcbiAgICB0aGlzLmFuaW1FbmRMYXRjaFRpbWVyXyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyh0aGlzLmN1cnJlbnRBbmltYXRpb25DbGFzc18pO1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyQW5pbWF0aW9uRW5kSGFuZGxlcih0aGlzLmFuaW1FbmRIYW5kbGVyXyk7XG4gICAgfSwgbnVtYmVycy5BTklNX0VORF9MQVRDSF9NUyk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgY2hhbmdlIGV2ZW50IGZvciB0aGUgY2hlY2tib3hcbiAgICovXG4gIGhhbmRsZUNoYW5nZSgpIHtcbiAgICB0aGlzLnRyYW5zaXRpb25DaGVja1N0YXRlXygpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGluc3RhbGxQcm9wZXJ0eUNoYW5nZUhvb2tzXygpIHtcbiAgICBjb25zdCBuYXRpdmVDYiA9IHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKTtcbiAgICBjb25zdCBjYlByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5hdGl2ZUNiKTtcblxuICAgIENCX1BST1RPX1BST1BTLmZvckVhY2goKGNvbnRyb2xTdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY2JQcm90bywgY29udHJvbFN0YXRlKTtcbiAgICAgIC8vIFdlIGhhdmUgdG8gY2hlY2sgZm9yIHRoaXMgZGVzY3JpcHRvciwgc2luY2Ugc29tZSBicm93c2VycyAoU2FmYXJpKSBkb24ndCBzdXBwb3J0IGl0cyByZXR1cm4uXG4gICAgICAvLyBTZWU6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD00OTczOVxuICAgICAgaWYgKHZhbGlkRGVzY3JpcHRvcihkZXNjKSkge1xuICAgICAgICBjb25zdCBuYXRpdmVDYkRlc2MgPSAvKiogQHR5cGUgeyFPYmplY3RQcm9wZXJ0eURlc2NyaXB0b3J9ICovICh7XG4gICAgICAgICAgZ2V0OiBkZXNjLmdldCxcbiAgICAgICAgICBzZXQ6IChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgZGVzYy5zZXQuY2FsbChuYXRpdmVDYiwgc3RhdGUpO1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uQ2hlY2tTdGF0ZV8oKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZGVzYy5jb25maWd1cmFibGUsXG4gICAgICAgICAgZW51bWVyYWJsZTogZGVzYy5lbnVtZXJhYmxlLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hdGl2ZUNiLCBjb250cm9sU3RhdGUsIG5hdGl2ZUNiRGVzYyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgdW5pbnN0YWxsUHJvcGVydHlDaGFuZ2VIb29rc18oKSB7XG4gICAgY29uc3QgbmF0aXZlQ2IgPSB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCk7XG4gICAgY29uc3QgY2JQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihuYXRpdmVDYik7XG5cbiAgICBDQl9QUk9UT19QUk9QUy5mb3JFYWNoKChjb250cm9sU3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IGRlc2MgPSAvKiogQHR5cGUgeyFPYmplY3RQcm9wZXJ0eURlc2NyaXB0b3J9ICovIChcbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjYlByb3RvLCBjb250cm9sU3RhdGUpKTtcbiAgICAgIGlmICh2YWxpZERlc2NyaXB0b3IoZGVzYykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hdGl2ZUNiLCBjb250cm9sU3RhdGUsIGRlc2MpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHRyYW5zaXRpb25DaGVja1N0YXRlXygpIHtcbiAgICBjb25zdCBuYXRpdmVDYiA9IHRoaXMuYWRhcHRlcl8uZ2V0TmF0aXZlQ29udHJvbCgpO1xuICAgIGlmICghbmF0aXZlQ2IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb2xkU3RhdGUgPSB0aGlzLmN1cnJlbnRDaGVja1N0YXRlXztcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRoaXMuZGV0ZXJtaW5lQ2hlY2tTdGF0ZV8obmF0aXZlQ2IpO1xuICAgIGlmIChvbGRTdGF0ZSA9PT0gbmV3U3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZUFyaWFDaGVja2VkXygpO1xuXG4gICAgLy8gQ2hlY2sgdG8gZW5zdXJlIHRoYXQgdGhlcmUgaXNuJ3QgYSBwcmV2aW91c2x5IGV4aXN0aW5nIGFuaW1hdGlvbiBjbGFzcywgaW4gY2FzZSBmb3IgZXhhbXBsZVxuICAgIC8vIHRoZSB1c2VyIGludGVyYWN0ZWQgd2l0aCB0aGUgY2hlY2tib3ggYmVmb3JlIHRoZSBhbmltYXRpb24gd2FzIGZpbmlzaGVkLlxuICAgIGlmICh0aGlzLmN1cnJlbnRBbmltYXRpb25DbGFzc18ubGVuZ3RoID4gMCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYW5pbUVuZExhdGNoVGltZXJfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZm9yY2VMYXlvdXQoKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3ModGhpcy5jdXJyZW50QW5pbWF0aW9uQ2xhc3NfKTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25DbGFzc18gPSB0aGlzLmdldFRyYW5zaXRpb25BbmltYXRpb25DbGFzc18ob2xkU3RhdGUsIG5ld1N0YXRlKTtcbiAgICB0aGlzLmN1cnJlbnRDaGVja1N0YXRlXyA9IG5ld1N0YXRlO1xuXG4gICAgLy8gQ2hlY2sgZm9yIHBhcmVudE5vZGUgc28gdGhhdCBhbmltYXRpb25zIGFyZSBvbmx5IHJ1biB3aGVuIHRoZSBlbGVtZW50IGlzIGF0dGFjaGVkXG4gICAgLy8gdG8gdGhlIERPTS5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc0F0dGFjaGVkVG9ET00oKSAmJiB0aGlzLmN1cnJlbnRBbmltYXRpb25DbGFzc18ubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyh0aGlzLmN1cnJlbnRBbmltYXRpb25DbGFzc18pO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckFuaW1hdGlvbkVuZEhhbmRsZXIodGhpcy5hbmltRW5kSGFuZGxlcl8pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENTZWxlY3Rpb25Db250cm9sU3RhdGV9IG5hdGl2ZUNiXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRldGVybWluZUNoZWNrU3RhdGVfKG5hdGl2ZUNiKSB7XG4gICAgY29uc3Qge1xuICAgICAgVFJBTlNJVElPTl9TVEFURV9JTkRFVEVSTUlOQVRFLFxuICAgICAgVFJBTlNJVElPTl9TVEFURV9DSEVDS0VELFxuICAgICAgVFJBTlNJVElPTl9TVEFURV9VTkNIRUNLRUQsXG4gICAgfSA9IHN0cmluZ3M7XG5cbiAgICBpZiAobmF0aXZlQ2IuaW5kZXRlcm1pbmF0ZSkge1xuICAgICAgcmV0dXJuIFRSQU5TSVRJT05fU1RBVEVfSU5ERVRFUk1JTkFURTtcbiAgICB9XG4gICAgcmV0dXJuIG5hdGl2ZUNiLmNoZWNrZWQgPyBUUkFOU0lUSU9OX1NUQVRFX0NIRUNLRUQgOiBUUkFOU0lUSU9OX1NUQVRFX1VOQ0hFQ0tFRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2xkU3RhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ld1N0YXRlXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldFRyYW5zaXRpb25BbmltYXRpb25DbGFzc18ob2xkU3RhdGUsIG5ld1N0YXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgVFJBTlNJVElPTl9TVEFURV9JTklULFxuICAgICAgVFJBTlNJVElPTl9TVEFURV9DSEVDS0VELFxuICAgICAgVFJBTlNJVElPTl9TVEFURV9VTkNIRUNLRUQsXG4gICAgfSA9IHN0cmluZ3M7XG5cbiAgICBjb25zdCB7XG4gICAgICBBTklNX1VOQ0hFQ0tFRF9DSEVDS0VELFxuICAgICAgQU5JTV9VTkNIRUNLRURfSU5ERVRFUk1JTkFURSxcbiAgICAgIEFOSU1fQ0hFQ0tFRF9VTkNIRUNLRUQsXG4gICAgICBBTklNX0NIRUNLRURfSU5ERVRFUk1JTkFURSxcbiAgICAgIEFOSU1fSU5ERVRFUk1JTkFURV9DSEVDS0VELFxuICAgICAgQU5JTV9JTkRFVEVSTUlOQVRFX1VOQ0hFQ0tFRCxcbiAgICB9ID0gTURDQ2hlY2tib3hGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG5cbiAgICBzd2l0Y2ggKG9sZFN0YXRlKSB7XG4gICAgY2FzZSBUUkFOU0lUSU9OX1NUQVRFX0lOSVQ6XG4gICAgICBpZiAobmV3U3RhdGUgPT09IFRSQU5TSVRJT05fU1RBVEVfVU5DSEVDS0VEKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAvLyBmYWxsdGhyb3VnaFxuICAgIGNhc2UgVFJBTlNJVElPTl9TVEFURV9VTkNIRUNLRUQ6XG4gICAgICByZXR1cm4gbmV3U3RhdGUgPT09IFRSQU5TSVRJT05fU1RBVEVfQ0hFQ0tFRCA/IEFOSU1fVU5DSEVDS0VEX0NIRUNLRUQgOiBBTklNX1VOQ0hFQ0tFRF9JTkRFVEVSTUlOQVRFO1xuICAgIGNhc2UgVFJBTlNJVElPTl9TVEFURV9DSEVDS0VEOlxuICAgICAgcmV0dXJuIG5ld1N0YXRlID09PSBUUkFOU0lUSU9OX1NUQVRFX1VOQ0hFQ0tFRCA/IEFOSU1fQ0hFQ0tFRF9VTkNIRUNLRUQgOiBBTklNX0NIRUNLRURfSU5ERVRFUk1JTkFURTtcbiAgICAvLyBUUkFOU0lUSU9OX1NUQVRFX0lOREVURVJNSU5BVEVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG5ld1N0YXRlID09PSBUUkFOU0lUSU9OX1NUQVRFX0NIRUNLRUQgP1xuICAgICAgICBBTklNX0lOREVURVJNSU5BVEVfQ0hFQ0tFRCA6IEFOSU1fSU5ERVRFUk1JTkFURV9VTkNIRUNLRUQ7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQXJpYUNoZWNrZWRfKCkge1xuICAgIC8vIEVuc3VyZSBhcmlhLWNoZWNrZWQgaXMgc2V0IHRvIG1peGVkIGlmIGNoZWNrYm94IGlzIGluIGluZGV0ZXJtaW5hdGUgc3RhdGUuXG4gICAgaWYgKHRoaXMuaXNJbmRldGVybWluYXRlKCkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0TmF0aXZlQ29udHJvbEF0dHIoXG4gICAgICAgIHN0cmluZ3MuQVJJQV9DSEVDS0VEX0FUVFIsIHN0cmluZ3MuQVJJQV9DSEVDS0VEX0lOREVURVJNSU5BVEVfVkFMVUUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZU5hdGl2ZUNvbnRyb2xBdHRyKHN0cmluZ3MuQVJJQV9DSEVDS0VEX0FUVFIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshTURDU2VsZWN0aW9uQ29udHJvbFN0YXRlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TmF0aXZlQ29udHJvbF8oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uZ2V0TmF0aXZlQ29udHJvbCgpIHx8IHtcbiAgICAgIGNoZWNrZWQ6IGZhbHNlLFxuICAgICAgaW5kZXRlcm1pbmF0ZTogZmFsc2UsXG4gICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3RQcm9wZXJ0eURlc2NyaXB0b3J8dW5kZWZpbmVkfSBpbnB1dFByb3BEZXNjXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiB2YWxpZERlc2NyaXB0b3IoaW5wdXRQcm9wRGVzYykge1xuICByZXR1cm4gISFpbnB1dFByb3BEZXNjICYmIHR5cGVvZiBpbnB1dFByb3BEZXNjLnNldCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDQ2hlY2tib3hGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBGb3JtIEZpZWxkLiBQcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIG1hbmFnaW5nXG4gKiAtIGV2ZW50IGhhbmRsZXJzXG4gKiAtIHJpcHBsZSBhY3RpdmF0aW9uXG4gKlxuICogQWRkaXRpb25hbGx5LCBwcm92aWRlcyB0eXBlIGluZm9ybWF0aW9uIGZvciB0aGUgYWRhcHRlciB0byB0aGUgQ2xvc3VyZVxuICogY29tcGlsZXIuXG4gKlxuICogSW1wbGVtZW50IHRoaXMgYWRhcHRlciBmb3IgeW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlIHRvIGRlbGVnYXRlIHVwZGF0ZXMgdG9cbiAqIHRoZSBjb21wb25lbnQgaW4geW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlLiBTZWUgYXJjaGl0ZWN0dXJlIGRvY3VtZW50YXRpb25cbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2NvZGUvYXJjaGl0ZWN0dXJlLm1kXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENGb3JtRmllbGRBZGFwdGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7IUV2ZW50TGlzdGVuZXJ9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7IUV2ZW50TGlzdGVuZXJ9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICBhY3RpdmF0ZUlucHV0UmlwcGxlKCkge31cblxuICBkZWFjdGl2YXRlSW5wdXRSaXBwbGUoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENGb3JtRmllbGRBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy1mb3JtLWZpZWxkJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgTEFCRUxfU0VMRUNUT1I6ICcubWRjLWZvcm0tZmllbGQgPiBsYWJlbCcsXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ0Zvcm1GaWVsZEFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENGb3JtRmllbGRBZGFwdGVyPn1cbiAqL1xuY2xhc3MgTURDRm9ybUZpZWxkRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtjc3NDbGFzc2VzfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmdzfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKiogQHJldHVybiB7IU1EQ0Zvcm1GaWVsZEFkYXB0ZXJ9ICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgYWN0aXZhdGVJbnB1dFJpcHBsZTogKCkgPT4ge30sXG4gICAgICBkZWFjdGl2YXRlSW5wdXRSaXBwbGU6ICgpID0+IHt9LFxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENGb3JtRmllbGRGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUgeyFFdmVudExpc3RlbmVyfSAqL1xuICAgIHRoaXMuY2xpY2tIYW5kbGVyXyA9IC8qKiBAdHlwZSB7IUV2ZW50TGlzdGVuZXJ9ICovIChcbiAgICAgICgpID0+IHRoaXMuaGFuZGxlQ2xpY2tfKCkpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmNsaWNrSGFuZGxlcl8pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGhhbmRsZUNsaWNrXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmFjdGl2YXRlSW5wdXRSaXBwbGUoKTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5hZGFwdGVyXy5kZWFjdGl2YXRlSW5wdXRSaXBwbGUoKSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDRm9ybUZpZWxkRm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIG5vUHJlZml4OiBzdHJpbmcsXG4gKiAgIHdlYmtpdFByZWZpeDogc3RyaW5nLFxuICogICBzdHlsZVByb3BlcnR5OiBzdHJpbmdcbiAqIH19XG4gKi9cbmxldCBWZW5kb3JQcm9wZXJ0eU1hcFR5cGU7XG5cbi8qKiBAY29uc3Qge09iamVjdDxzdHJpbmcsICFWZW5kb3JQcm9wZXJ0eU1hcFR5cGU+fSAqL1xuY29uc3QgZXZlbnRUeXBlTWFwID0ge1xuICAnYW5pbWF0aW9uc3RhcnQnOiB7XG4gICAgbm9QcmVmaXg6ICdhbmltYXRpb25zdGFydCcsXG4gICAgd2Via2l0UHJlZml4OiAnd2Via2l0QW5pbWF0aW9uU3RhcnQnLFxuICAgIHN0eWxlUHJvcGVydHk6ICdhbmltYXRpb24nLFxuICB9LFxuICAnYW5pbWF0aW9uZW5kJzoge1xuICAgIG5vUHJlZml4OiAnYW5pbWF0aW9uZW5kJyxcbiAgICB3ZWJraXRQcmVmaXg6ICd3ZWJraXRBbmltYXRpb25FbmQnLFxuICAgIHN0eWxlUHJvcGVydHk6ICdhbmltYXRpb24nLFxuICB9LFxuICAnYW5pbWF0aW9uaXRlcmF0aW9uJzoge1xuICAgIG5vUHJlZml4OiAnYW5pbWF0aW9uaXRlcmF0aW9uJyxcbiAgICB3ZWJraXRQcmVmaXg6ICd3ZWJraXRBbmltYXRpb25JdGVyYXRpb24nLFxuICAgIHN0eWxlUHJvcGVydHk6ICdhbmltYXRpb24nLFxuICB9LFxuICAndHJhbnNpdGlvbmVuZCc6IHtcbiAgICBub1ByZWZpeDogJ3RyYW5zaXRpb25lbmQnLFxuICAgIHdlYmtpdFByZWZpeDogJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICAgIHN0eWxlUHJvcGVydHk6ICd0cmFuc2l0aW9uJyxcbiAgfSxcbn07XG5cbi8qKiBAY29uc3Qge09iamVjdDxzdHJpbmcsICFWZW5kb3JQcm9wZXJ0eU1hcFR5cGU+fSAqL1xuY29uc3QgY3NzUHJvcGVydHlNYXAgPSB7XG4gICdhbmltYXRpb24nOiB7XG4gICAgbm9QcmVmaXg6ICdhbmltYXRpb24nLFxuICAgIHdlYmtpdFByZWZpeDogJy13ZWJraXQtYW5pbWF0aW9uJyxcbiAgfSxcbiAgJ3RyYW5zZm9ybSc6IHtcbiAgICBub1ByZWZpeDogJ3RyYW5zZm9ybScsXG4gICAgd2Via2l0UHJlZml4OiAnLXdlYmtpdC10cmFuc2Zvcm0nLFxuICB9LFxuICAndHJhbnNpdGlvbic6IHtcbiAgICBub1ByZWZpeDogJ3RyYW5zaXRpb24nLFxuICAgIHdlYmtpdFByZWZpeDogJy13ZWJraXQtdHJhbnNpdGlvbicsXG4gIH0sXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7IU9iamVjdH0gd2luZG93T2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNQcm9wZXJTaGFwZSh3aW5kb3dPYmopIHtcbiAgcmV0dXJuICh3aW5kb3dPYmpbJ2RvY3VtZW50J10gIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygd2luZG93T2JqWydkb2N1bWVudCddWydjcmVhdGVFbGVtZW50J10gPT09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGV2ZW50Rm91bmRJbk1hcHMoZXZlbnRUeXBlKSB7XG4gIHJldHVybiAoZXZlbnRUeXBlIGluIGV2ZW50VHlwZU1hcCB8fCBldmVudFR5cGUgaW4gY3NzUHJvcGVydHlNYXApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGVcbiAqIEBwYXJhbSB7IU9iamVjdDxzdHJpbmcsICFWZW5kb3JQcm9wZXJ0eU1hcFR5cGU+fSBtYXBcbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldEphdmFTY3JpcHRFdmVudE5hbWUoZXZlbnRUeXBlLCBtYXAsIGVsKSB7XG4gIHJldHVybiBtYXBbZXZlbnRUeXBlXS5zdHlsZVByb3BlcnR5IGluIGVsLnN0eWxlID8gbWFwW2V2ZW50VHlwZV0ubm9QcmVmaXggOiBtYXBbZXZlbnRUeXBlXS53ZWJraXRQcmVmaXg7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSBicm93c2VyIHByZWZpeCBmb3IgQ1NTMyBhbmltYXRpb24gZXZlbnRzXG4gKiBhbmQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcGFyYW0geyFPYmplY3R9IHdpbmRvd09ialxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRBbmltYXRpb25OYW1lKHdpbmRvd09iaiwgZXZlbnRUeXBlKSB7XG4gIGlmICghaGFzUHJvcGVyU2hhcGUod2luZG93T2JqKSB8fCAhZXZlbnRGb3VuZEluTWFwcyhldmVudFR5cGUpKSB7XG4gICAgcmV0dXJuIGV2ZW50VHlwZTtcbiAgfVxuXG4gIGNvbnN0IG1hcCA9IC8qKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsICFWZW5kb3JQcm9wZXJ0eU1hcFR5cGU+fSAqLyAoXG4gICAgZXZlbnRUeXBlIGluIGV2ZW50VHlwZU1hcCA/IGV2ZW50VHlwZU1hcCA6IGNzc1Byb3BlcnR5TWFwXG4gICk7XG4gIGNvbnN0IGVsID0gd2luZG93T2JqWydkb2N1bWVudCddWydjcmVhdGVFbGVtZW50J10oJ2RpdicpO1xuICBsZXQgZXZlbnROYW1lID0gJyc7XG5cbiAgaWYgKG1hcCA9PT0gZXZlbnRUeXBlTWFwKSB7XG4gICAgZXZlbnROYW1lID0gZ2V0SmF2YVNjcmlwdEV2ZW50TmFtZShldmVudFR5cGUsIG1hcCwgZWwpO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50TmFtZSA9IG1hcFtldmVudFR5cGVdLm5vUHJlZml4IGluIGVsLnN0eWxlID8gbWFwW2V2ZW50VHlwZV0ubm9QcmVmaXggOiBtYXBbZXZlbnRUeXBlXS53ZWJraXRQcmVmaXg7XG4gIH1cblxuICByZXR1cm4gZXZlbnROYW1lO1xufVxuXG4vLyBQdWJsaWMgZnVuY3Rpb25zIHRvIGFjY2VzcyBnZXRBbmltYXRpb25OYW1lKCkgZm9yIEphdmFTY3JpcHQgZXZlbnRzIG9yIENTU1xuLy8gcHJvcGVydHkgbmFtZXMuXG5cbmNvbnN0IHRyYW5zZm9ybVN0eWxlUHJvcGVydGllcyA9IFsndHJhbnNmb3JtJywgJ1dlYmtpdFRyYW5zZm9ybScsICdNb3pUcmFuc2Zvcm0nLCAnT1RyYW5zZm9ybScsICdNU1RyYW5zZm9ybSddO1xuXG4vKipcbiAqIEBwYXJhbSB7IU9iamVjdH0gd2luZG93T2JqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvcnJlY3RFdmVudE5hbWUod2luZG93T2JqLCBldmVudFR5cGUpIHtcbiAgcmV0dXJuIGdldEFuaW1hdGlvbk5hbWUod2luZG93T2JqLCBldmVudFR5cGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IU9iamVjdH0gd2luZG93T2JqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvcnJlY3RQcm9wZXJ0eU5hbWUod2luZG93T2JqLCBldmVudFR5cGUpIHtcbiAgcmV0dXJuIGdldEFuaW1hdGlvbk5hbWUod2luZG93T2JqLCBldmVudFR5cGUpO1xufVxuXG5leHBvcnQge3RyYW5zZm9ybVN0eWxlUHJvcGVydGllcywgZ2V0Q29ycmVjdEV2ZW50TmFtZSwgZ2V0Q29ycmVjdFByb3BlcnR5TmFtZX07XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXZcbiAgICA6Y2xhc3M9XCJmb3JtRmllbGRDbGFzc2VzXCJcbiAgICBjbGFzcz1cIm1kYy1jaGVja2JveC13cmFwcGVyXCI+XG4gICAgPGRpdlxuICAgICAgcmVmPVwicm9vdFwiXG4gICAgICA6Y2xhc3M9XCJjbGFzc2VzXCJcbiAgICAgIDpzdHlsZT1cInN0eWxlc1wiXG4gICAgICBjbGFzcz1cIm1kYy1jaGVja2JveFwiPlxuICAgICAgPGlucHV0XG4gICAgICAgIHJlZj1cImNvbnRyb2xcIlxuICAgICAgICA6aWQ9XCJ2bWFfdWlkX1wiXG4gICAgICAgIDpuYW1lPVwibmFtZVwiXG4gICAgICAgIDp2YWx1ZT1cInZhbHVlXCJcbiAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgY2xhc3M9XCJtZGMtY2hlY2tib3hfX25hdGl2ZS1jb250cm9sXCJcbiAgICAgICAgQGNoYW5nZT1cIm9uQ2hhbmdlXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwibWRjLWNoZWNrYm94X19iYWNrZ3JvdW5kXCI+XG4gICAgICAgIDxzdmdcbiAgICAgICAgICBjbGFzcz1cIm1kYy1jaGVja2JveF9fY2hlY2ttYXJrXCJcbiAgICAgICAgICB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XG4gICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgIGNsYXNzPVwibWRjLWNoZWNrYm94X19jaGVja21hcmstcGF0aFwiXG4gICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICBzdHJva2U9XCJ3aGl0ZVwiXG4gICAgICAgICAgICBkPVwiTTEuNzMsMTIuOTEgOC4xLDE5LjI4IDIyLjc5LDQuNTlcIi8+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgICA8ZGl2IGNsYXNzPVwibWRjLWNoZWNrYm94X19taXhlZG1hcmtcIi8+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8bGFiZWxcbiAgICAgIHJlZj1cImxhYmVsXCJcbiAgICAgIDpmb3I9XCJ2bWFfdWlkX1wiXG4gICAgPjxzbG90Pnt7IGxhYmVsIH19PC9zbG90PjwvbGFiZWw+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbi8qIGdsb2JhbCBIVE1MRWxlbWVudCAqL1xuaW1wb3J0IE1EQ0NoZWNrYm94Rm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvY2hlY2tib3gvZm91bmRhdGlvbidcbmltcG9ydCBNRENGb3JtRmllbGRGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9mb3JtLWZpZWxkL2ZvdW5kYXRpb24nXG5pbXBvcnQgeyBnZXRDb3JyZWN0RXZlbnROYW1lIH0gZnJvbSAnQG1hdGVyaWFsL2FuaW1hdGlvbidcbmltcG9ydCB7IERpc3BhdGNoRm9jdXNNaXhpbiwgVk1BVW5pcXVlSWRNaXhpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgeyBSaXBwbGVCYXNlIH0gZnJvbSAnLi4vcmlwcGxlJ1xuaW1wb3J0IHsgYXBwbHlQYXNzaXZlIH0gZnJvbSAnLi4vYmFzZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWNoZWNrYm94JyxcbiAgbWl4aW5zOiBbRGlzcGF0Y2hGb2N1c01peGluLCBWTUFVbmlxdWVJZE1peGluXSxcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAnY2hlY2tlZCcsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgY2hlY2tlZDogW0Jvb2xlYW4sIEFycmF5XSxcbiAgICBpbmRldGVybWluYXRlOiBCb29sZWFuLFxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgIGxhYmVsOiBTdHJpbmcsXG4gICAgJ2FsaWduLWVuZCc6IEJvb2xlYW4sXG4gICAgdmFsdWU6IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgICBkZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gJ29uJ1xuICAgICAgfVxuICAgIH0sXG4gICAgbmFtZTogU3RyaW5nXG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0eWxlczoge30sXG4gICAgICBjbGFzc2VzOiB7fVxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBoYXNMYWJlbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhYmVsIHx8IHRoaXMuJHNsb3RzLmRlZmF1bHRcbiAgICB9LFxuICAgIGZvcm1GaWVsZENsYXNzZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWRjLWZvcm0tZmllbGQnOiB0aGlzLmhhc0xhYmVsLFxuICAgICAgICAnbWRjLWZvcm0tZmllbGQtLWFsaWduLWVuZCc6IHRoaXMuaGFzTGFiZWwgJiYgdGhpcy5hbGlnbkVuZFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBjaGVja2VkOiAnc2V0Q2hlY2tlZCcsXG4gICAgZGlzYWJsZWQodmFsdWUpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXREaXNhYmxlZCh2YWx1ZSlcbiAgICB9LFxuICAgIGluZGV0ZXJtaW5hdGUodmFsdWUpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRJbmRldGVybWluYXRlKHZhbHVlKVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDQ2hlY2tib3hGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIHNldE5hdGl2ZUNvbnRyb2xBdHRyOiAoYXR0ciwgdmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5jb250cm9sLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSlcbiAgICAgIH0sXG4gICAgICByZW1vdmVOYXRpdmVDb250cm9sQXR0cjogYXR0ciA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuY29udHJvbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cilcbiAgICAgIH0sXG4gICAgICByZWdpc3RlckFuaW1hdGlvbkVuZEhhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5yb290LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgZ2V0Q29ycmVjdEV2ZW50TmFtZSh3aW5kb3csICdhbmltYXRpb25lbmQnKSxcbiAgICAgICAgICBoYW5kbGVyXG4gICAgICAgICksXG4gICAgICBkZXJlZ2lzdGVyQW5pbWF0aW9uRW5kSGFuZGxlcjogaGFuZGxlciA9PlxuICAgICAgICB0aGlzLiRyZWZzLnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICBnZXRDb3JyZWN0RXZlbnROYW1lKHdpbmRvdywgJ2FuaW1hdGlvbmVuZCcpLFxuICAgICAgICAgIGhhbmRsZXJcbiAgICAgICAgKSxcbiAgICAgIHJlZ2lzdGVyQ2hhbmdlSGFuZGxlcjogaGFuZGxlciA9PlxuICAgICAgICB0aGlzLiRyZWZzLmNvbnRyb2wuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVyQ2hhbmdlSGFuZGxlcjogaGFuZGxlciA9PlxuICAgICAgICB0aGlzLiRyZWZzLmNvbnRyb2wucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgaGFuZGxlciksXG4gICAgICBnZXROYXRpdmVDb250cm9sOiAoKSA9PiB0aGlzLiRyZWZzLmNvbnRyb2wsXG4gICAgICBmb3JjZUxheW91dDogKCkgPT4gdGhpcy4kcmVmcy5yb290Lm9mZnNldFdpZHRoLFxuICAgICAgaXNBdHRhY2hlZFRvRE9NOiAoKSA9PiBCb29sZWFuKHRoaXMuJGVsLnBhcmVudE5vZGUpXG4gICAgfSlcblxuICAgIHRoaXMucmlwcGxlID0gbmV3IFJpcHBsZUJhc2UodGhpcywge1xuICAgICAgaXNVbmJvdW5kZWQ6ICgpID0+IHRydWUsXG4gICAgICBpc1N1cmZhY2VBY3RpdmU6ICgpID0+IFJpcHBsZUJhc2UuaXNTdXJmYWNlQWN0aXZlKHRoaXMuJHJlZnMuY29udHJvbCksXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmNvbnRyb2wuYWRkRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIsIGFwcGx5UGFzc2l2ZSgpKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5jb250cm9sLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyLCBhcHBseVBhc3NpdmUoKSlcbiAgICAgIH0sXG4gICAgICBjb21wdXRlQm91bmRpbmdSZWN0OiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiRyZWZzLnJvb3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5mb3JtRmllbGQgPSBuZXcgTURDRm9ybUZpZWxkRm91bmRhdGlvbih7XG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5sYWJlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5sYWJlbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgYWN0aXZhdGVJbnB1dFJpcHBsZTogKCkgPT4ge1xuICAgICAgICB0aGlzLnJpcHBsZSAmJiB0aGlzLnJpcHBsZS5hY3RpdmF0ZSgpXG4gICAgICB9LFxuICAgICAgZGVhY3RpdmF0ZUlucHV0UmlwcGxlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMucmlwcGxlICYmIHRoaXMucmlwcGxlLmRlYWN0aXZhdGUoKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gICAgdGhpcy5yaXBwbGUuaW5pdCgpXG4gICAgdGhpcy5mb3JtRmllbGQuaW5pdCgpXG4gICAgdGhpcy5zZXRDaGVja2VkKHRoaXMuY2hlY2tlZClcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0RGlzYWJsZWQodGhpcy5kaXNhYmxlZClcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0SW5kZXRlcm1pbmF0ZSh0aGlzLmluZGV0ZXJtaW5hdGUpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5mb3JtRmllbGQuZGVzdHJveSgpXG4gICAgdGhpcy5yaXBwbGUuZGVzdHJveSgpXG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgc2V0Q2hlY2tlZChjaGVja2VkKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0Q2hlY2tlZChcbiAgICAgICAgQXJyYXkuaXNBcnJheShjaGVja2VkKSA/IGNoZWNrZWQuaW5kZXhPZih0aGlzLnZhbHVlKSA+IC0xIDogY2hlY2tlZFxuICAgICAgKVxuICAgIH0sXG5cbiAgICBvbkNoYW5nZSgpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTppbmRldGVybWluYXRlJywgdGhpcy5mb3VuZGF0aW9uLmlzSW5kZXRlcm1pbmF0ZSgpKVxuICAgICAgY29uc3QgaXNDaGVja2VkID0gdGhpcy5mb3VuZGF0aW9uLmlzQ2hlY2tlZCgpXG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuY2hlY2tlZCkpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5jaGVja2VkLmluZGV4T2YodGhpcy52YWx1ZSlcbiAgICAgICAgaWYgKGlzQ2hlY2tlZCkge1xuICAgICAgICAgIGlkeCA8IDAgJiYgdGhpcy4kZW1pdCgnY2hhbmdlJywgdGhpcy5jaGVja2VkLmNvbmNhdCh0aGlzLnZhbHVlKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZHggPiAtMSAmJlxuICAgICAgICAgICAgdGhpcy4kZW1pdChcbiAgICAgICAgICAgICAgJ2NoYW5nZScsXG4gICAgICAgICAgICAgIHRoaXMuY2hlY2tlZC5zbGljZSgwLCBpZHgpLmNvbmNhdCh0aGlzLmNoZWNrZWQuc2xpY2UoaWR4ICsgMSkpXG4gICAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGlzQ2hlY2tlZClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjQ2hlY2tib3ggZnJvbSAnLi9tZGMtY2hlY2tib3gudnVlJ1xuXG5leHBvcnQgeyBtZGNDaGVja2JveCB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNDaGVja2JveFxufSlcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgQ2hpcC5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBDaGlwIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENDaGlwQWRhcHRlciB7XG4gIC8qKlxuICAgKiBBZGRzIGEgY2xhc3MgdG8gdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2xhc3MgZnJvbSB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcm9vdCBlbGVtZW50IGNvbnRhaW5zIHRoZSBnaXZlbiBjbGFzcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY2xhc3MgdG8gdGhlIGxlYWRpbmcgaWNvbiBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBhZGRDbGFzc1RvTGVhZGluZ0ljb24oY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2xhc3MgZnJvbSB0aGUgbGVhZGluZyBpY29uIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIHJlbW92ZUNsYXNzRnJvbUxlYWRpbmdJY29uKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRhcmdldCBoYXMgY2xhc3NOYW1lLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwYXJhbSB7IUV2ZW50VGFyZ2V0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXZlbnRUYXJnZXRIYXNDbGFzcyh0YXJnZXQsIGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogRW1pdHMgYSBjdXN0b20gXCJNRENDaGlwOmludGVyYWN0aW9uXCIgZXZlbnQgZGVub3RpbmcgdGhlIGNoaXAgaGFzIGJlZW5cbiAgICogaW50ZXJhY3RlZCB3aXRoICh0eXBpY2FsbHkgb24gY2xpY2sgb3Iga2V5ZG93bikuXG4gICAqL1xuICBub3RpZnlJbnRlcmFjdGlvbigpIHt9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGEgY3VzdG9tIFwiTURDQ2hpcDp0cmFpbGluZ0ljb25JbnRlcmFjdGlvblwiIGV2ZW50IGRlbm90aW5nIHRoZSB0cmFpbGluZyBpY29uIGhhcyBiZWVuXG4gICAqIGludGVyYWN0ZWQgd2l0aCAodHlwaWNhbGx5IG9uIGNsaWNrIG9yIGtleWRvd24pLlxuICAgKi9cbiAgbm90aWZ5VHJhaWxpbmdJY29uSW50ZXJhY3Rpb24oKSB7fVxuXG4gIC8qKlxuICAgKiBFbWl0cyBhIGN1c3RvbSBldmVudCBcIk1EQ0NoaXA6cmVtb3ZhbFwiIGRlbm90aW5nIHRoZSBjaGlwIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICovXG4gIG5vdGlmeVJlbW92YWwoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb21wdXRlZCBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gc3R5bGUgcHJvcGVydHkgb24gdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRDb21wdXRlZFN0eWxlVmFsdWUocHJvcGVydHlOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gc3R5bGUgcHJvcGVydHkgb24gdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNldFN0eWxlUHJvcGVydHkocHJvcGVydHlOYW1lLCB2YWx1ZSkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDQ2hpcEFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBFTlRSWV9BTklNQVRJT05fTkFNRTogJ21kYy1jaGlwLWVudHJ5JyxcbiAgSU5URVJBQ1RJT05fRVZFTlQ6ICdNRENDaGlwOmludGVyYWN0aW9uJyxcbiAgVFJBSUxJTkdfSUNPTl9JTlRFUkFDVElPTl9FVkVOVDogJ01EQ0NoaXA6dHJhaWxpbmdJY29uSW50ZXJhY3Rpb24nLFxuICBSRU1PVkFMX0VWRU5UOiAnTURDQ2hpcDpyZW1vdmFsJyxcbiAgQ0hFQ0tNQVJLX1NFTEVDVE9SOiAnLm1kYy1jaGlwX19jaGVja21hcmsnLFxuICBMRUFESU5HX0lDT05fU0VMRUNUT1I6ICcubWRjLWNoaXBfX2ljb24tLWxlYWRpbmcnLFxuICBUUkFJTElOR19JQ09OX1NFTEVDVE9SOiAnLm1kYy1jaGlwX19pY29uLS10cmFpbGluZycsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIENIRUNLTUFSSzogJ21kYy1jaGlwX19jaGVja21hcmsnLFxuICBDSElQX0VYSVQ6ICdtZGMtY2hpcC0tZXhpdCcsXG4gIEhJRERFTl9MRUFESU5HX0lDT046ICdtZGMtY2hpcF9faWNvbi0tbGVhZGluZy1oaWRkZW4nLFxuICBMRUFESU5HX0lDT046ICdtZGMtY2hpcF9faWNvbi0tbGVhZGluZycsXG4gIFRSQUlMSU5HX0lDT046ICdtZGMtY2hpcF9faWNvbi0tdHJhaWxpbmcnLFxuICBTRUxFQ1RFRDogJ21kYy1jaGlwLS1zZWxlY3RlZCcsXG59O1xuXG5leHBvcnQge3N0cmluZ3MsIGNzc0NsYXNzZXN9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ0NoaXBBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge3N0cmluZ3MsIGNzc0NsYXNzZXN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENDaGlwQWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDQ2hpcEZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENDaGlwQWRhcHRlcn0gZm9yIHR5cGluZyBpbmZvcm1hdGlvbiBvbiBwYXJhbWV0ZXJzIGFuZCByZXR1cm5cbiAgICogdHlwZXMuXG4gICAqIEByZXR1cm4geyFNRENDaGlwQWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ0NoaXBBZGFwdGVyfSAqLyAoe1xuICAgICAgYWRkQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgaGFzQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgYWRkQ2xhc3NUb0xlYWRpbmdJY29uOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzRnJvbUxlYWRpbmdJY29uOiAoKSA9PiB7fSxcbiAgICAgIGV2ZW50VGFyZ2V0SGFzQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgbm90aWZ5SW50ZXJhY3Rpb246ICgpID0+IHt9LFxuICAgICAgbm90aWZ5VHJhaWxpbmdJY29uSW50ZXJhY3Rpb246ICgpID0+IHt9LFxuICAgICAgbm90aWZ5UmVtb3ZhbDogKCkgPT4ge30sXG4gICAgICBnZXRDb21wdXRlZFN0eWxlVmFsdWU6ICgpID0+IHt9LFxuICAgICAgc2V0U3R5bGVQcm9wZXJ0eTogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDQ2hpcEFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0NoaXBGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGEgdHJhaWxpbmcgaWNvbiBjbGljayBzaG91bGQgaW1tZWRpYXRlbHkgdHJpZ2dlciBleGl0L3JlbW92YWwgb2YgdGhlIGNoaXAuXG4gICAgICogQHByaXZhdGUge2Jvb2xlYW59XG4gICAgICogKi9cbiAgICB0aGlzLnNob3VsZFJlbW92ZU9uVHJhaWxpbmdJY29uQ2xpY2tfID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNTZWxlY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhjc3NDbGFzc2VzLlNFTEVDVEVEKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqL1xuICBzZXRTZWxlY3RlZChzZWxlY3RlZCkge1xuICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLlNFTEVDVEVEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLlNFTEVDVEVEKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGdldFNob3VsZFJlbW92ZU9uVHJhaWxpbmdJY29uQ2xpY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hvdWxkUmVtb3ZlT25UcmFpbGluZ0ljb25DbGlja187XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZW1vdmVcbiAgICovXG4gIHNldFNob3VsZFJlbW92ZU9uVHJhaWxpbmdJY29uQ2xpY2soc2hvdWxkUmVtb3ZlKSB7XG4gICAgdGhpcy5zaG91bGRSZW1vdmVPblRyYWlsaW5nSWNvbkNsaWNrXyA9IHNob3VsZFJlbW92ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCZWdpbnMgdGhlIGV4aXQgYW5pbWF0aW9uIHdoaWNoIGxlYWRzIHRvIHJlbW92YWwgb2YgdGhlIGNoaXAuXG4gICAqL1xuICBiZWdpbkV4aXQoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLkNISVBfRVhJVCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhbiBpbnRlcmFjdGlvbiBldmVudCBvbiB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqL1xuICBoYW5kbGVJbnRlcmFjdGlvbihldnQpIHtcbiAgICBpZiAoZXZ0LnR5cGUgPT09ICdjbGljaycgfHwgZXZ0LmtleSA9PT0gJ0VudGVyJyB8fCBldnQua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5SW50ZXJhY3Rpb24oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIHRyYW5zaXRpb24gZW5kIGV2ZW50IG9uIHRoZSByb290IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICovXG4gIGhhbmRsZVRyYW5zaXRpb25FbmQoZXZ0KSB7XG4gICAgLy8gSGFuZGxlIHRyYW5zaXRpb24gZW5kIGV2ZW50IG9uIHRoZSBjaGlwIHdoZW4gaXQgaXMgYWJvdXQgdG8gYmUgcmVtb3ZlZC5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5ldmVudFRhcmdldEhhc0NsYXNzKC8qKiBAdHlwZSB7IUV2ZW50VGFyZ2V0fSAqLyAoZXZ0LnRhcmdldCksIGNzc0NsYXNzZXMuQ0hJUF9FWElUKSkge1xuICAgICAgaWYgKGV2dC5wcm9wZXJ0eU5hbWUgPT09ICd3aWR0aCcpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlSZW1vdmFsKCk7XG4gICAgICB9IGVsc2UgaWYgKGV2dC5wcm9wZXJ0eU5hbWUgPT09ICdvcGFjaXR5Jykge1xuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vdXNpbmctY3NzLXRyYW5zaXRpb25zLWF1dG8tZGltZW5zaW9ucy8jYXJ0aWNsZS1oZWFkZXItaWQtNVxuICAgICAgICBjb25zdCBjaGlwV2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldENvbXB1dGVkU3R5bGVWYWx1ZSgnd2lkdGgnKTtcblxuICAgICAgICAvLyBPbiB0aGUgbmV4dCBmcmFtZSAob25jZSB3ZSBnZXQgdGhlIGNvbXB1dGVkIHdpZHRoKSwgZXhwbGljaXRseSBzZXQgdGhlIGNoaXAncyB3aWR0aFxuICAgICAgICAvLyB0byBpdHMgY3VycmVudCBwaXhlbCB3aWR0aCwgc28gd2UgYXJlbid0IHRyYW5zaXRpb25pbmcgb3V0IG9mICdhdXRvJy5cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlUHJvcGVydHkoJ3dpZHRoJywgY2hpcFdpZHRoKTtcblxuICAgICAgICAgIC8vIFRvIG1pdGlnYXRlIGppdHRlciwgc3RhcnQgdHJhbnNpdGlvbmluZyBwYWRkaW5nIGFuZCBtYXJnaW4gYmVmb3JlIHdpZHRoLlxuICAgICAgICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGVQcm9wZXJ0eSgncGFkZGluZycsICcwJyk7XG4gICAgICAgICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZVByb3BlcnR5KCdtYXJnaW4nLCAnMCcpO1xuXG4gICAgICAgICAgLy8gT24gdGhlIG5leHQgZnJhbWUgKG9uY2Ugd2lkdGggaXMgZXhwbGljaXRseSBzZXQpLCB0cmFuc2l0aW9uIHdpZHRoIHRvIDAuXG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGVQcm9wZXJ0eSgnd2lkdGgnLCAnMCcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgYSB0cmFuc2l0aW9uIGVuZCBldmVudCBvbiB0aGUgbGVhZGluZyBpY29uIG9yIGNoZWNrbWFyaywgc2luY2UgdGhlIHRyYW5zaXRpb24gZW5kIGV2ZW50IGJ1YmJsZXMuXG4gICAgaWYgKGV2dC5wcm9wZXJ0eU5hbWUgIT09ICdvcGFjaXR5Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5ldmVudFRhcmdldEhhc0NsYXNzKC8qKiBAdHlwZSB7IUV2ZW50VGFyZ2V0fSAqLyAoZXZ0LnRhcmdldCksIGNzc0NsYXNzZXMuTEVBRElOR19JQ09OKSAmJlxuICAgICAgICB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuU0VMRUNURUQpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzVG9MZWFkaW5nSWNvbihjc3NDbGFzc2VzLkhJRERFTl9MRUFESU5HX0lDT04pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hZGFwdGVyXy5ldmVudFRhcmdldEhhc0NsYXNzKC8qKiBAdHlwZSB7IUV2ZW50VGFyZ2V0fSAqLyAoZXZ0LnRhcmdldCksIGNzc0NsYXNzZXMuQ0hFQ0tNQVJLKSAmJlxuICAgICAgICAgICAgICAgIXRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5TRUxFQ1RFRCkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3NGcm9tTGVhZGluZ0ljb24oY3NzQ2xhc3Nlcy5ISURERU5fTEVBRElOR19JQ09OKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhbiBpbnRlcmFjdGlvbiBldmVudCBvbiB0aGUgdHJhaWxpbmcgaWNvbiBlbGVtZW50LiBUaGlzIGlzIHVzZWQgdG9cbiAgICogcHJldmVudCB0aGUgcmlwcGxlIGZyb20gYWN0aXZhdGluZyBvbiBpbnRlcmFjdGlvbiB3aXRoIHRoZSB0cmFpbGluZyBpY29uLlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqL1xuICBoYW5kbGVUcmFpbGluZ0ljb25JbnRlcmFjdGlvbihldnQpIHtcbiAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgaWYgKGV2dC50eXBlID09PSAnY2xpY2snIHx8IGV2dC5rZXkgPT09ICdFbnRlcicgfHwgZXZ0LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeVRyYWlsaW5nSWNvbkludGVyYWN0aW9uKCk7XG4gICAgICBpZiAodGhpcy5zaG91bGRSZW1vdmVPblRyYWlsaW5nSWNvbkNsaWNrXykge1xuICAgICAgICB0aGlzLmJlZ2luRXhpdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGRldGFpbDoge1xuICogICAgIGNoaXA6IHtmb3VuZGF0aW9uOiAhTURDQ2hpcEZvdW5kYXRpb259LFxuICogICB9LFxuICogICBidWJibGVzOiBib29sZWFuLFxuICogfX1cbiAqL1xubGV0IE1EQ0NoaXBJbnRlcmFjdGlvbkV2ZW50VHlwZTtcblxuZXhwb3J0IHtNRENDaGlwRm91bmRhdGlvbiwgTURDQ2hpcEludGVyYWN0aW9uRXZlbnRUeXBlfTtcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdlxuICAgIDpjbGFzcz1cImNsYXNzZXNcIlxuICAgIDpzdHlsZT1cInN0eWxlc1wiXG4gICAgdGFiaW5kZXg9XCIwXCJcbiAgICBAY2xpY2s9XCJoYW5kbGVJbnRlcmFjdGlvblwiXG4gICAgQGtleWRvd249XCJoYW5kbGVJbnRlcmFjdGlvblwiXG4gICAgQHRyYW5zaXRpb25lbmQ9XCJoYW5kbGVUcmFuc2l0aW9uRW5kXCJcbiAgPlxuICAgIDxpXG4gICAgICB2LWlmPVwiaGF2ZWxlYWRpbmdJY29uXCJcbiAgICAgIHJlZj1cImxlYWRpbmdJY29uXCJcbiAgICAgIDpjbGFzcz1cImxlYWRpbmdDbGFzc2VzXCJcbiAgICAgIGNsYXNzPVwibWRjLWNoaXBfX2ljb24gbWRjLWNoaXBfX2ljb24tLWxlYWRpbmdcIlxuICAgID57eyBsZWFkaW5nSWNvbiB9fTwvaT5cbiAgICA8ZGl2XG4gICAgICB2LWlmPVwiaXNGaWx0ZXJcIlxuICAgICAgY2xhc3M9XCJtZGMtY2hpcF9fY2hlY2ttYXJrXCI+XG4gICAgICA8c3ZnXG4gICAgICAgIGNsYXNzPVwibWRjLWNoaXBfX2NoZWNrbWFyay1zdmdcIlxuICAgICAgICB2aWV3Qm94PVwiLTIgLTMgMzAgMzBcIj5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBjbGFzcz1cIm1kYy1jaGlwX19jaGVja21hcmstcGF0aFwiXG4gICAgICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgICAgIHN0cm9rZT1cImJsYWNrXCJcbiAgICAgICAgICBkPVwiTTEuNzMsMTIuOTEgOC4xLDE5LjI4IDIyLjc5LDQuNTlcIi8+XG4gICAgICA8L3N2Zz5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLWNoaXBfX3RleHRcIj5cbiAgICAgIDxzbG90Lz5cbiAgICA8L2Rpdj5cbiAgICA8aVxuICAgICAgdi1pZj1cImhhdmV0cmFpbGluZ0ljb25cIlxuICAgICAgcmVmPVwidHJhaWxpbmdJY29uXCJcbiAgICAgIDpjbGFzcz1cInRyYWlsaW5nQ2xhc3Nlc1wiXG4gICAgICBjbGFzcz1cIm1kYy1jaGlwX19pY29uIG1kYy1jaGlwX19pY29uLS10cmFpbGluZ1wiXG4gICAgICB0YWJpbmRleD1cIjBcIlxuICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICBAY2xpY2s9XCJoYW5kbGVUcmFpbGluZ0ljb25JbnRlcmFjdGlvblwiXG4gICAgICBAa2V5ZG93bj1cImhhbmRsZVRyYWlsaW5nSWNvbkludGVyYWN0aW9uXCJcbiAgICA+e3sgdHJhaWxpbmdJY29uIH19PC9pPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5hcHBseVBhc3NpdmVcbjxzY3JpcHQ+XG5pbXBvcnQgeyBNRENDaGlwRm91bmRhdGlvbiB9IGZyb20gJ0BtYXRlcmlhbC9jaGlwcy9jaGlwL2ZvdW5kYXRpb24nXG5pbXBvcnQgeyBDdXN0b21MaW5rTWl4aW4sIGVtaXRDdXN0b21FdmVudCB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgeyBSaXBwbGVCYXNlIH0gZnJvbSAnLi4vcmlwcGxlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtY2hpcCcsXG4gIG1peGluczogW0N1c3RvbUxpbmtNaXhpbl0sXG4gIHByb3BzOiB7XG4gICAgbGVhZGluZ0ljb246IFtTdHJpbmddLFxuICAgIHRyYWlsaW5nSWNvbjogW1N0cmluZ10sXG4gICAgbGVhZGluZ0ljb25DbGFzc2VzOiBbT2JqZWN0XSxcbiAgICB0cmFpbGluZ0ljb25DbGFzc2VzOiBbT2JqZWN0XVxuICB9LFxuICBpbmplY3Q6IFsnbWRjQ2hpcFNldCddLFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgICdtZGMtY2hpcCc6IHRydWVcbiAgICAgIH0sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGlzRmlsdGVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWRjQ2hpcFNldCAmJiB0aGlzLm1kY0NoaXBTZXQuZmlsdGVyXG4gICAgfSxcbiAgICBoYXZlbGVhZGluZ0ljb24oKSB7XG4gICAgICByZXR1cm4gISF0aGlzLmxlYWRpbmdJY29uIHx8IHRoaXMubGVhZGluZ0ljb25DbGFzc2VzXG4gICAgfSxcbiAgICBoYXZldHJhaWxpbmdJY29uKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy50cmFpbGluZ0ljb24gfHwgdGhpcy50cmFpbGluZ0ljb25DbGFzc2VzXG4gICAgfSxcbiAgICBsZWFkaW5nQ2xhc3NlcygpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICB7fSxcbiAgICAgICAge1xuICAgICAgICAgICdtYXRlcmlhbC1pY29ucyc6ICEhdGhpcy5sZWFkaW5nSWNvblxuICAgICAgICB9LFxuICAgICAgICB0aGlzLmxlYWRpbmdJY29uQ2xhc3Nlc1xuICAgICAgKVxuICAgIH0sXG4gICAgdHJhaWxpbmdDbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHt9LFxuICAgICAgICB7XG4gICAgICAgICAgJ21hdGVyaWFsLWljb25zJzogISF0aGlzLnRyYWlsaW5nSWNvblxuICAgICAgICB9LFxuICAgICAgICB0aGlzLnRyYWlsaW5nSWNvbkNsYXNzZXNcbiAgICAgIClcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ0NoaXBGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSksXG4gICAgICBhZGRDbGFzc1RvTGVhZGluZ0ljb246IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmhhdmVsZWFkaW5nSWNvbikge1xuICAgICAgICAgIHRoaXMuJHJlZnMubGVhZGluZ0ljb24uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZW1vdmVDbGFzc0Zyb21MZWFkaW5nSWNvbjogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgaWYgKHRoaXMuaGF2ZWxlYWRpbmdJY29uKSB7XG4gICAgICAgICAgdGhpcy4kcmVmcy5sZWFkaW5nSWNvbi5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGV2ZW50VGFyZ2V0SGFzQ2xhc3M6ICh0YXJnZXQsIGNsYXNzTmFtZSkgPT5cbiAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpLFxuICAgICAgbm90aWZ5SW50ZXJhY3Rpb246ICgpID0+IHtcbiAgICAgICAgZW1pdEN1c3RvbUV2ZW50KFxuICAgICAgICAgIHRoaXMuJGVsLFxuICAgICAgICAgIE1EQ0NoaXBGb3VuZGF0aW9uLnN0cmluZ3MuSU5URVJBQ1RJT05fRVZFTlQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2hpcDogdGhpc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApXG4gICAgICAgIHRoaXMubWRjQ2hpcFNldCAmJiB0aGlzLm1kY0NoaXBTZXQuaGFuZGxlSW50ZXJhY3Rpb25cbiAgICAgIH0sXG4gICAgICBub3RpZnlUcmFpbGluZ0ljb25JbnRlcmFjdGlvbjogKCkgPT4ge1xuICAgICAgICBlbWl0Q3VzdG9tRXZlbnQoXG4gICAgICAgICAgdGhpcy4kZWwsXG4gICAgICAgICAgTURDQ2hpcEZvdW5kYXRpb24uc3RyaW5ncy5UUkFJTElOR19JQ09OX0lOVEVSQUNUSU9OX0VWRU5ULFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNoaXA6IHRoaXNcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIG5vdGlmeVJlbW92YWw6ICgpID0+IHtcbiAgICAgICAgZW1pdEN1c3RvbUV2ZW50KFxuICAgICAgICAgIHRoaXMuJGVsLFxuICAgICAgICAgIE1EQ0NoaXBGb3VuZGF0aW9uLnN0cmluZ3MuUkVNT1ZBTF9FVkVOVCxcbiAgICAgICAgICB7IGNoaXA6IHRoaXMgfSxcbiAgICAgICAgICB0cnVlXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBnZXRDb21wdXRlZFN0eWxlVmFsdWU6IHByb3BlcnR5TmFtZSA9PlxuICAgICAgICB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRlbCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eU5hbWUpLFxuICAgICAgc2V0U3R5bGVQcm9wZXJ0eTogKHByb3BlcnR5LCB2YWx1ZSkgPT5cbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuc3R5bGVzLCBwcm9wZXJ0eSwgdmFsdWUpXG4gICAgfSlcblxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcblxuICAgIHRoaXMucmlwcGxlID0gbmV3IFJpcHBsZUJhc2UodGhpcylcbiAgICB0aGlzLnJpcHBsZS5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLnJpcHBsZS5kZXN0cm95KClcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBoYW5kbGVJbnRlcmFjdGlvbihldnQpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5oYW5kbGVJbnRlcmFjdGlvbihldnQpXG4gICAgfSxcbiAgICBoYW5kbGVUcmFuc2l0aW9uRW5kKGV2dCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLmhhbmRsZVRyYW5zaXRpb25FbmQoZXZ0KVxuICAgIH0sXG4gICAgaGFuZGxlVHJhaWxpbmdJY29uSW50ZXJhY3Rpb24oZXZ0KSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uaGFuZGxlVHJhaWxpbmdJY29uSW50ZXJhY3Rpb24oZXZ0KVxuICAgIH0sXG4gICAgdG9nZ2xlU2VsZWN0ZWQoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24udG9nZ2xlU2VsZWN0ZWQoKVxuICAgIH0sXG4gICAgaXNTZWxlY3RlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvdW5kYXRpb24uaXNTZWxlY3RlZCgpXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCB7TURDQ2hpcEludGVyYWN0aW9uRXZlbnRUeXBlfSBmcm9tICcuLi9jaGlwL2ZvdW5kYXRpb24nO1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgQ2hpcCBTZXQuXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgQ2hpcCBTZXQgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ0NoaXBTZXRBZGFwdGVyIHtcbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcm9vdCBlbGVtZW50IGNvbnRhaW5zIHRoZSBnaXZlbiBjbGFzcyBuYW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGNoaXAgb2JqZWN0IGZyb20gdGhlIGNoaXAgc2V0LlxuICAgKiBAcGFyYW0geyFPYmplY3R9IGNoaXBcbiAgICovXG4gIHJlbW92ZUNoaXAoY2hpcCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDQ2hpcFNldEFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBDSElQX1NFTEVDVE9SOiAnLm1kYy1jaGlwJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgQ0hPSUNFOiAnbWRjLWNoaXAtc2V0LS1jaG9pY2UnLFxuICBGSUxURVI6ICdtZGMtY2hpcC1zZXQtLWZpbHRlcicsXG59O1xuXG5leHBvcnQge3N0cmluZ3MsIGNzc0NsYXNzZXN9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ0NoaXBTZXRBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCB7TURDQ2hpcEZvdW5kYXRpb24sIE1EQ0NoaXBJbnRlcmFjdGlvbkV2ZW50VHlwZX0gZnJvbSAnLi4vY2hpcC9mb3VuZGF0aW9uJztcbmltcG9ydCB7c3RyaW5ncywgY3NzQ2xhc3Nlc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENDaGlwU2V0QWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDQ2hpcFNldEZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENDaGlwU2V0QWRhcHRlcn0gZm9yIHR5cGluZyBpbmZvcm1hdGlvbiBvbiBwYXJhbWV0ZXJzIGFuZCByZXR1cm5cbiAgICogdHlwZXMuXG4gICAqIEByZXR1cm4geyFNRENDaGlwU2V0QWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ0NoaXBTZXRBZGFwdGVyfSAqLyAoe1xuICAgICAgaGFzQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQ2hpcDogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDQ2hpcFNldEFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0NoaXBTZXRGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VsZWN0ZWQgY2hpcHMgaW4gdGhlIHNldC4gT25seSB1c2VkIGZvciBjaG9pY2UgY2hpcCBzZXQgb3IgZmlsdGVyIGNoaXAgc2V0LlxuICAgICAqIEBwcml2YXRlIHshQXJyYXk8IU1EQ0NoaXBGb3VuZGF0aW9uPn1cbiAgICAgKi9cbiAgICB0aGlzLnNlbGVjdGVkQ2hpcHNfID0gW107XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0cyB0aGUgZ2l2ZW4gY2hpcC4gRGVzZWxlY3RzIGFsbCBvdGhlciBjaGlwcyBpZiB0aGUgY2hpcCBzZXQgaXMgb2YgdGhlIGNob2ljZSB2YXJpYW50LlxuICAgKiBAcGFyYW0geyFNRENDaGlwRm91bmRhdGlvbn0gY2hpcEZvdW5kYXRpb25cbiAgICovXG4gIHNlbGVjdChjaGlwRm91bmRhdGlvbikge1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuQ0hPSUNFKSkge1xuICAgICAgdGhpcy5kZXNlbGVjdEFsbF8oKTtcbiAgICB9XG4gICAgY2hpcEZvdW5kYXRpb24uc2V0U2VsZWN0ZWQodHJ1ZSk7XG4gICAgdGhpcy5zZWxlY3RlZENoaXBzXy5wdXNoKGNoaXBGb3VuZGF0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlbGVjdHMgdGhlIGdpdmVuIGNoaXAuXG4gICAqIEBwYXJhbSB7IU1EQ0NoaXBGb3VuZGF0aW9ufSBjaGlwRm91bmRhdGlvblxuICAgKi9cbiAgZGVzZWxlY3QoY2hpcEZvdW5kYXRpb24pIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuc2VsZWN0ZWRDaGlwc18uaW5kZXhPZihjaGlwRm91bmRhdGlvbik7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWRDaGlwc18uc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgY2hpcEZvdW5kYXRpb24uc2V0U2VsZWN0ZWQoZmFsc2UpO1xuICB9XG5cbiAgLyoqIERlc2VsZWN0cyBhbGwgc2VsZWN0ZWQgY2hpcHMuICovXG4gIGRlc2VsZWN0QWxsXygpIHtcbiAgICB0aGlzLnNlbGVjdGVkQ2hpcHNfLmZvckVhY2goKGNoaXBGb3VuZGF0aW9uKSA9PiB7XG4gICAgICBjaGlwRm91bmRhdGlvbi5zZXRTZWxlY3RlZChmYWxzZSk7XG4gICAgfSk7XG4gICAgdGhpcy5zZWxlY3RlZENoaXBzXy5sZW5ndGggPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBjaGlwIGludGVyYWN0aW9uIGV2ZW50XG4gICAqIEBwYXJhbSB7IU1EQ0NoaXBJbnRlcmFjdGlvbkV2ZW50VHlwZX0gZXZ0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVDaGlwSW50ZXJhY3Rpb24oZXZ0KSB7XG4gICAgY29uc3QgY2hpcEZvdW5kYXRpb24gPSBldnQuZGV0YWlsLmNoaXAuZm91bmRhdGlvbjtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhjc3NDbGFzc2VzLkNIT0lDRSkgfHwgdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhjc3NDbGFzc2VzLkZJTFRFUikpIHtcbiAgICAgIGlmIChjaGlwRm91bmRhdGlvbi5pc1NlbGVjdGVkKCkpIHtcbiAgICAgICAgdGhpcy5kZXNlbGVjdChjaGlwRm91bmRhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlbGVjdChjaGlwRm91bmRhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGV2ZW50IHdoZW4gYSBjaGlwIGlzIHJlbW92ZWQuXG4gICAqIEBwYXJhbSB7IU1EQ0NoaXBJbnRlcmFjdGlvbkV2ZW50VHlwZX0gZXZ0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVDaGlwUmVtb3ZhbChldnQpIHtcbiAgICBjb25zdCB7Y2hpcH0gPSBldnQuZGV0YWlsO1xuICAgIHRoaXMuZGVzZWxlY3QoY2hpcC5mb3VuZGF0aW9uKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNoaXAoY2hpcCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDQ2hpcFNldEZvdW5kYXRpb247XG4iLCJcbjxzY3JpcHQ+XG5pbXBvcnQgTURDQ2hpcFNldEZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2NoaXBzL2NoaXAtc2V0L2ZvdW5kYXRpb24nXG5pbXBvcnQgeyBNRENDaGlwRm91bmRhdGlvbiB9IGZyb20gJ0BtYXRlcmlhbC9jaGlwcy9jaGlwL2ZvdW5kYXRpb24nXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1jaGlwLXNldCcsXG4gIHByb3BzOiB7XG4gICAgY2hvaWNlOiBbQm9vbGVhbl0sXG4gICAgZmlsdGVyOiBbQm9vbGVhbl0sXG4gICAgaW5wdXQ6IFtCb29sZWFuXVxuICB9LFxuICBwcm92aWRlKCkge1xuICAgIHJldHVybiB7IG1kY0NoaXBTZXQ6IHRoaXMgfVxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgICdtZGMtY2hpcC1zZXQnOiB0cnVlLFxuICAgICAgICAnbWRjLWNoaXAtc2V0LS1jaG9pY2UnOiB0aGlzLmNob2ljZSxcbiAgICAgICAgJ21kYy1jaGlwLXNldC0tZmlsdGVyJzogdGhpcy5maWx0ZXIsXG4gICAgICAgICdtZGMtY2hpcC1zZXQtLWlucHV0JzogdGhpcy5pbnB1dFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDQ2hpcFNldEZvdW5kYXRpb24oe1xuICAgICAgaGFzQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSxcbiAgICAgIHJlbW92ZUNoaXA6IGNoaXAgPT4ge1xuICAgICAgICAvLyBUT0RPOiBtYXkgbmVlZCByZWZhY3RvcmluZ1xuICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiBjaGlwLiRkZXN0cm95KCkpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBoYW5kbGVDaGlwSW50ZXJhY3Rpb24oZXZ0KSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uaGFuZGxlQ2hpcEludGVyYWN0aW9uKGV2dClcbiAgICB9LFxuICAgIGhhbmRsZUNoaXBSZW1vdmFsKGV2dCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLmhhbmRsZUNoaXBSZW1vdmFsKGV2dClcbiAgICB9XG4gIH0sXG4gIHJlbmRlcihoKSB7XG4gICAgcmV0dXJuIGgoXG4gICAgICAnZGl2JyxcbiAgICAgIHtcbiAgICAgICAgY2xhc3M6IHRoaXMuY2xhc3NlcyxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBbTURDQ2hpcEZvdW5kYXRpb24uc3RyaW5ncy5JTlRFUkFDVElPTl9FVkVOVF06IGV2dCA9PlxuICAgICAgICAgICAgdGhpcy5oYW5kbGVDaGlwSW50ZXJhY3Rpb24oZXZ0KSxcbiAgICAgICAgICBbTURDQ2hpcEZvdW5kYXRpb24uc3RyaW5ncy5SRU1PVkFMX0VWRU5UXTogZXZ0ID0+XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNoaXBSZW1vdmFsKGV2dClcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRoaXMuJHNsb3RzLmRlZmF1bHRcbiAgICApXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjQ2hpcCBmcm9tICcuL21kYy1jaGlwLnZ1ZSdcbmltcG9ydCBtZGNDaGlwU2V0IGZyb20gJy4vbWRjLWNoaXAtc2V0LnZ1ZSdcblxuZXhwb3J0IHsgbWRjQ2hpcCwgbWRjQ2hpcFNldCB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNDaGlwLFxuICBtZGNDaGlwU2V0XG59KVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJy4vZm91bmRhdGlvbic7XG5pbXBvcnQgTURDQ29tcG9uZW50IGZyb20gJy4vY29tcG9uZW50JztcblxuZXhwb3J0IHtNRENGb3VuZGF0aW9uLCBNRENDb21wb25lbnR9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy1kaWFsb2cnLFxuICBPUEVOOiAnbWRjLWRpYWxvZy0tb3BlbicsXG4gIEFOSU1BVElORzogJ21kYy1kaWFsb2ctLWFuaW1hdGluZycsXG4gIEJBQ0tEUk9QOiAnbWRjLWRpYWxvZ19fYmFja2Ryb3AnLFxuICBTQ1JPTExfTE9DSzogJ21kYy1kaWFsb2ctc2Nyb2xsLWxvY2snLFxuICBBQ0NFUFRfQlROOiAnbWRjLWRpYWxvZ19fZm9vdGVyX19idXR0b24tLWFjY2VwdCcsXG4gIENBTkNFTF9CVE46ICdtZGMtZGlhbG9nX19mb290ZXJfX2J1dHRvbi0tY2FuY2VsJyxcbn07XG5cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIE9QRU5fRElBTE9HX1NFTEVDVE9SOiAnLm1kYy1kaWFsb2ctLW9wZW4nLFxuICBESUFMT0dfU1VSRkFDRV9TRUxFQ1RPUjogJy5tZGMtZGlhbG9nX19zdXJmYWNlJyxcbiAgQUNDRVBUX1NFTEVDVE9SOiAnLm1kYy1kaWFsb2dfX2Zvb3Rlcl9fYnV0dG9uLS1hY2NlcHQnLFxuICBBQ0NFUFRfRVZFTlQ6ICdNRENEaWFsb2c6YWNjZXB0JyxcbiAgQ0FOQ0VMX0VWRU5UOiAnTURDRGlhbG9nOmNhbmNlbCcsXG59O1xuXG5jb25zdCBudW1iZXJzID0ge1xuICBESUFMT0dfQU5JTUFUSU9OX1RJTUVfTVM6IDEyMCxcbn07XG5cbmV4cG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc307XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge01EQ0ZvdW5kYXRpb259IGZyb20gJ0BtYXRlcmlhbC9iYXNlL2luZGV4JztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNRENEaWFsb2dGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICByZXR1cm4gbnVtYmVycztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuICh7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgYWRkQm9keUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQm9keUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZXZlbnRUYXJnZXRIYXNDbGFzczogKC8qIHRhcmdldDogRXZlbnRUYXJnZXQsIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnQ6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0OiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJTdXJmYWNlSW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0OiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclN1cmZhY2VJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnQ6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBub3RpZnlBY2NlcHQ6ICgpID0+IHt9LFxuICAgICAgbm90aWZ5Q2FuY2VsOiAoKSA9PiB7fSxcbiAgICAgIHRyYXBGb2N1c09uU3VyZmFjZTogKCkgPT4ge30sXG4gICAgICB1bnRyYXBGb2N1c09uU3VyZmFjZTogKCkgPT4ge30sXG4gICAgICBpc0RpYWxvZzogKC8qIGVsOiBFbGVtZW50ICovKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgIH0pO1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDRGlhbG9nRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuICAgIHRoaXMuaXNPcGVuXyA9IGZhbHNlO1xuICAgIHRoaXMuY29tcG9uZW50Q2xpY2tIYW5kbGVyXyA9IChldnQpID0+IHtcbiAgICAgIGlmICh0aGlzLmFkYXB0ZXJfLmV2ZW50VGFyZ2V0SGFzQ2xhc3MoZXZ0LnRhcmdldCwgY3NzQ2xhc3Nlcy5CQUNLRFJPUCkpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwodHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmRpYWxvZ0NsaWNrSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZURpYWxvZ0NsaWNrXyhldnQpO1xuICAgIHRoaXMuZG9jdW1lbnRLZXlkb3duSGFuZGxlcl8gPSAoZXZ0KSA9PiB7XG4gICAgICBpZiAoZXZ0LmtleSAmJiBldnQua2V5ID09PSAnRXNjYXBlJyB8fCBldnQua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwodHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMudGltZXJJZF8gPSAwO1xuICAgIHRoaXMuYW5pbWF0aW9uVGltZXJFbmRfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVBbmltYXRpb25UaW1lckVuZF8oZXZ0KTtcbiAgfTtcblxuICBkZXN0cm95KCkge1xuICAgIC8vIEVuc3VyZSB0aGF0IGRpYWxvZyBpcyBjbGVhbmVkIHVwIHdoZW4gZGVzdHJveWVkXG4gICAgaWYgKHRoaXMuaXNPcGVuXykge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgICAvLyBGaW5hbCBjbGVhbnVwIG9mIGFuaW1hdGluZyBjbGFzcyBpbiBjYXNlIHRoZSB0aW1lciBoYXMgbm90IGNvbXBsZXRlZC5cbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkcpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySWRfKTtcbiAgfVxuXG4gIG9wZW4oKSB7XG4gICAgdGhpcy5pc09wZW5fID0gdHJ1ZTtcbiAgICB0aGlzLmRpc2FibGVTY3JvbGxfKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXIodGhpcy5kb2N1bWVudEtleWRvd25IYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclN1cmZhY2VJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5kaWFsb2dDbGlja0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY29tcG9uZW50Q2xpY2tIYW5kbGVyXyk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJJZF8pO1xuICAgIHRoaXMudGltZXJJZF8gPSBzZXRUaW1lb3V0KHRoaXMuYW5pbWF0aW9uVGltZXJFbmRfLCBNRENEaWFsb2dGb3VuZGF0aW9uLm51bWJlcnMuRElBTE9HX0FOSU1BVElPTl9USU1FX01TKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkcpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDRGlhbG9nRm91bmRhdGlvbi5jc3NDbGFzc2VzLk9QRU4pO1xuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5pc09wZW5fID0gZmFsc2U7XG4gICAgdGhpcy5lbmFibGVTY3JvbGxfKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyU3VyZmFjZUludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmRpYWxvZ0NsaWNrSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXIodGhpcy5kb2N1bWVudEtleWRvd25IYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY29tcG9uZW50Q2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy51bnRyYXBGb2N1c09uU3VyZmFjZSgpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySWRfKTtcbiAgICB0aGlzLnRpbWVySWRfID0gc2V0VGltZW91dCh0aGlzLmFuaW1hdGlvblRpbWVyRW5kXywgTURDRGlhbG9nRm91bmRhdGlvbi5udW1iZXJzLkRJQUxPR19BTklNQVRJT05fVElNRV9NUyk7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENEaWFsb2dGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQU5JTUFUSU5HKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5PUEVOKTtcbiAgfVxuXG4gIGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc09wZW5fO1xuICB9XG5cbiAgYWNjZXB0KHNob3VsZE5vdGlmeSkge1xuICAgIGlmIChzaG91bGROb3RpZnkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5QWNjZXB0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbG9zZSgpO1xuICB9XG5cbiAgY2FuY2VsKHNob3VsZE5vdGlmeSkge1xuICAgIGlmIChzaG91bGROb3RpZnkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2FuY2VsKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbG9zZSgpO1xuICB9XG5cbiAgaGFuZGxlRGlhbG9nQ2xpY2tfKGV2dCkge1xuICAgIGNvbnN0IHt0YXJnZXR9ID0gZXZ0O1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmV2ZW50VGFyZ2V0SGFzQ2xhc3ModGFyZ2V0LCBjc3NDbGFzc2VzLkFDQ0VQVF9CVE4pKSB7XG4gICAgICB0aGlzLmFjY2VwdCh0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYWRhcHRlcl8uZXZlbnRUYXJnZXRIYXNDbGFzcyh0YXJnZXQsIGNzc0NsYXNzZXMuQ0FOQ0VMX0JUTikpIHtcbiAgICAgIHRoaXMuY2FuY2VsKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUFuaW1hdGlvblRpbWVyRW5kXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkcpO1xuICAgIGlmICh0aGlzLmlzT3Blbl8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8udHJhcEZvY3VzT25TdXJmYWNlKCk7XG4gICAgfVxuICB9O1xuXG4gIGRpc2FibGVTY3JvbGxfKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQm9keUNsYXNzKGNzc0NsYXNzZXMuU0NST0xMX0xPQ0spO1xuICB9XG5cbiAgZW5hYmxlU2Nyb2xsXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUJvZHlDbGFzcyhjc3NDbGFzc2VzLlNDUk9MTF9MT0NLKTtcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgZWxlbWVudERvY3VtZW50ID0gZWwub3duZXJEb2N1bWVudCB8fCBlbDtcbiAgdmFyIGJhc2ljVGFiYmFibGVzID0gW107XG4gIHZhciBvcmRlcmVkVGFiYmFibGVzID0gW107XG5cbiAgLy8gQSBub2RlIGlzIFwiYXZhaWxhYmxlXCIgaWZcbiAgLy8gLSBpdCdzIGNvbXB1dGVkIHN0eWxlXG4gIHZhciBpc1VuYXZhaWxhYmxlID0gY3JlYXRlSXNVbmF2YWlsYWJsZShlbGVtZW50RG9jdW1lbnQpO1xuXG4gIHZhciBjYW5kaWRhdGVTZWxlY3RvcnMgPSBbXG4gICAgJ2lucHV0JyxcbiAgICAnc2VsZWN0JyxcbiAgICAnYVtocmVmXScsXG4gICAgJ3RleHRhcmVhJyxcbiAgICAnYnV0dG9uJyxcbiAgICAnW3RhYmluZGV4XScsXG4gIF07XG5cbiAgdmFyIGNhbmRpZGF0ZXMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKGNhbmRpZGF0ZVNlbGVjdG9ycy5qb2luKCcsJykpO1xuXG4gIGlmIChvcHRpb25zLmluY2x1ZGVDb250YWluZXIpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuXG4gICAgaWYgKFxuICAgICAgY2FuZGlkYXRlU2VsZWN0b3JzLnNvbWUoZnVuY3Rpb24oY2FuZGlkYXRlU2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXMuY2FsbChlbCwgY2FuZGlkYXRlU2VsZWN0b3IpO1xuICAgICAgfSlcbiAgICApIHtcbiAgICAgIGNhbmRpZGF0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoY2FuZGlkYXRlcyk7XG4gICAgICBjYW5kaWRhdGVzLnVuc2hpZnQoZWwpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjYW5kaWRhdGUsIGNhbmRpZGF0ZUluZGV4QXR0ciwgY2FuZGlkYXRlSW5kZXg7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2FuZGlkYXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjYW5kaWRhdGUgPSBjYW5kaWRhdGVzW2ldO1xuICAgIGNhbmRpZGF0ZUluZGV4QXR0ciA9IHBhcnNlSW50KGNhbmRpZGF0ZS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JyksIDEwKVxuICAgIGNhbmRpZGF0ZUluZGV4ID0gaXNOYU4oY2FuZGlkYXRlSW5kZXhBdHRyKSA/IGNhbmRpZGF0ZS50YWJJbmRleCA6IGNhbmRpZGF0ZUluZGV4QXR0cjtcblxuICAgIGlmIChcbiAgICAgIGNhbmRpZGF0ZUluZGV4IDwgMFxuICAgICAgfHwgKGNhbmRpZGF0ZS50YWdOYW1lID09PSAnSU5QVVQnICYmIGNhbmRpZGF0ZS50eXBlID09PSAnaGlkZGVuJylcbiAgICAgIHx8IGNhbmRpZGF0ZS5kaXNhYmxlZFxuICAgICAgfHwgaXNVbmF2YWlsYWJsZShjYW5kaWRhdGUsIGVsZW1lbnREb2N1bWVudClcbiAgICApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChjYW5kaWRhdGVJbmRleCA9PT0gMCkge1xuICAgICAgYmFzaWNUYWJiYWJsZXMucHVzaChjYW5kaWRhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcmRlcmVkVGFiYmFibGVzLnB1c2goe1xuICAgICAgICBpbmRleDogaSxcbiAgICAgICAgdGFiSW5kZXg6IGNhbmRpZGF0ZUluZGV4LFxuICAgICAgICBub2RlOiBjYW5kaWRhdGUsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdGFiYmFibGVOb2RlcyA9IG9yZGVyZWRUYWJiYWJsZXNcbiAgICAuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gYS50YWJJbmRleCA9PT0gYi50YWJJbmRleCA/IGEuaW5kZXggLSBiLmluZGV4IDogYS50YWJJbmRleCAtIGIudGFiSW5kZXg7XG4gICAgfSlcbiAgICAubWFwKGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiBhLm5vZGVcbiAgICB9KTtcblxuICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0YWJiYWJsZU5vZGVzLCBiYXNpY1RhYmJhYmxlcyk7XG5cbiAgcmV0dXJuIHRhYmJhYmxlTm9kZXM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUlzVW5hdmFpbGFibGUoZWxlbWVudERvY3VtZW50KSB7XG4gIC8vIE5vZGUgY2FjaGUgbXVzdCBiZSByZWZyZXNoZWQgb24gZXZlcnkgY2hlY2ssIGluIGNhc2VcbiAgLy8gdGhlIGNvbnRlbnQgb2YgdGhlIGVsZW1lbnQgaGFzIGNoYW5nZWRcbiAgdmFyIGlzT2ZmQ2FjaGUgPSBbXTtcblxuICAvLyBcIm9mZlwiIG1lYW5zIGBkaXNwbGF5OiBub25lO2AsIGFzIG9wcG9zZWQgdG8gXCJoaWRkZW5cIixcbiAgLy8gd2hpY2ggbWVhbnMgYHZpc2liaWxpdHk6IGhpZGRlbjtgLiBnZXRDb21wdXRlZFN0eWxlXG4gIC8vIGFjY3VyYXRlbHkgcmVmbGVjdHMgdmlzaWJsaXR5IGluIGNvbnRleHQgYnV0IG5vdFxuICAvLyBcIm9mZlwiIHN0YXRlLCBzbyB3ZSBuZWVkIHRvIHJlY3Vyc2l2ZWx5IGNoZWNrIHBhcmVudHMuXG5cbiAgZnVuY3Rpb24gaXNPZmYobm9kZSwgbm9kZUNvbXB1dGVkU3R5bGUpIHtcbiAgICBpZiAobm9kZSA9PT0gZWxlbWVudERvY3VtZW50LmRvY3VtZW50RWxlbWVudCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gRmluZCB0aGUgY2FjaGVkIG5vZGUgKEFycmF5LnByb3RvdHlwZS5maW5kIG5vdCBhdmFpbGFibGUgaW4gSUU5KVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBpc09mZkNhY2hlLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaXNPZmZDYWNoZVtpXVswXSA9PT0gbm9kZSkgcmV0dXJuIGlzT2ZmQ2FjaGVbaV1bMV07XG4gICAgfVxuXG4gICAgbm9kZUNvbXB1dGVkU3R5bGUgPSBub2RlQ29tcHV0ZWRTdHlsZSB8fCBlbGVtZW50RG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblxuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcblxuICAgIGlmIChub2RlQ29tcHV0ZWRTdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcbiAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIHJlc3VsdCA9IGlzT2ZmKG5vZGUucGFyZW50Tm9kZSk7XG4gICAgfVxuXG4gICAgaXNPZmZDYWNoZS5wdXNoKFtub2RlLCByZXN1bHRdKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gaXNVbmF2YWlsYWJsZShub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IGVsZW1lbnREb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBjb21wdXRlZFN0eWxlID0gZWxlbWVudERvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cbiAgICBpZiAoaXNPZmYobm9kZSwgY29tcHV0ZWRTdHlsZSkpIHJldHVybiB0cnVlO1xuXG4gICAgcmV0dXJuIGNvbXB1dGVkU3R5bGUudmlzaWJpbGl0eSA9PT0gJ2hpZGRlbic7XG4gIH1cbn1cbiIsInZhciB0YWJiYWJsZSA9IHJlcXVpcmUoJ3RhYmJhYmxlJyk7XG5cbnZhciBsaXN0ZW5pbmdGb2N1c1RyYXAgPSBudWxsO1xuXG5mdW5jdGlvbiBmb2N1c1RyYXAoZWxlbWVudCwgdXNlck9wdGlvbnMpIHtcbiAgdmFyIHRhYmJhYmxlTm9kZXMgPSBbXTtcbiAgdmFyIGZpcnN0VGFiYmFibGVOb2RlID0gbnVsbDtcbiAgdmFyIGxhc3RUYWJiYWJsZU5vZGUgPSBudWxsO1xuICB2YXIgbm9kZUZvY3VzZWRCZWZvcmVBY3RpdmF0aW9uID0gbnVsbDtcbiAgdmFyIGFjdGl2ZSA9IGZhbHNlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG4gIHZhciB0YWJFdmVudCA9IG51bGw7XG5cbiAgdmFyIGNvbnRhaW5lciA9ICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpXG4gICAgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsZW1lbnQpXG4gICAgOiBlbGVtZW50O1xuXG4gIHZhciBjb25maWcgPSB1c2VyT3B0aW9ucyB8fCB7fTtcbiAgY29uZmlnLnJldHVybkZvY3VzT25EZWFjdGl2YXRlID0gKHVzZXJPcHRpb25zICYmIHVzZXJPcHRpb25zLnJldHVybkZvY3VzT25EZWFjdGl2YXRlICE9PSB1bmRlZmluZWQpXG4gICAgPyB1c2VyT3B0aW9ucy5yZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZVxuICAgIDogdHJ1ZTtcbiAgY29uZmlnLmVzY2FwZURlYWN0aXZhdGVzID0gKHVzZXJPcHRpb25zICYmIHVzZXJPcHRpb25zLmVzY2FwZURlYWN0aXZhdGVzICE9PSB1bmRlZmluZWQpXG4gICAgPyB1c2VyT3B0aW9ucy5lc2NhcGVEZWFjdGl2YXRlc1xuICAgIDogdHJ1ZTtcblxuICB2YXIgdHJhcCA9IHtcbiAgICBhY3RpdmF0ZTogYWN0aXZhdGUsXG4gICAgZGVhY3RpdmF0ZTogZGVhY3RpdmF0ZSxcbiAgICBwYXVzZTogcGF1c2UsXG4gICAgdW5wYXVzZTogdW5wYXVzZSxcbiAgfTtcblxuICByZXR1cm4gdHJhcDtcblxuICBmdW5jdGlvbiBhY3RpdmF0ZShhY3RpdmF0ZU9wdGlvbnMpIHtcbiAgICBpZiAoYWN0aXZlKSByZXR1cm47XG5cbiAgICB2YXIgZGVmYXVsdGVkQWN0aXZhdGVPcHRpb25zID0ge1xuICAgICAgb25BY3RpdmF0ZTogKGFjdGl2YXRlT3B0aW9ucyAmJiBhY3RpdmF0ZU9wdGlvbnMub25BY3RpdmF0ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICA/IGFjdGl2YXRlT3B0aW9ucy5vbkFjdGl2YXRlXG4gICAgICAgIDogY29uZmlnLm9uQWN0aXZhdGUsXG4gICAgfTtcblxuICAgIGFjdGl2ZSA9IHRydWU7XG4gICAgcGF1c2VkID0gZmFsc2U7XG4gICAgbm9kZUZvY3VzZWRCZWZvcmVBY3RpdmF0aW9uID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuICAgIGlmIChkZWZhdWx0ZWRBY3RpdmF0ZU9wdGlvbnMub25BY3RpdmF0ZSkge1xuICAgICAgZGVmYXVsdGVkQWN0aXZhdGVPcHRpb25zLm9uQWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICBhZGRMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdHJhcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYWN0aXZhdGUoZGVhY3RpdmF0ZU9wdGlvbnMpIHtcbiAgICBpZiAoIWFjdGl2ZSkgcmV0dXJuO1xuXG4gICAgdmFyIGRlZmF1bHRlZERlYWN0aXZhdGVPcHRpb25zID0ge1xuICAgICAgcmV0dXJuRm9jdXM6IChkZWFjdGl2YXRlT3B0aW9ucyAmJiBkZWFjdGl2YXRlT3B0aW9ucy5yZXR1cm5Gb2N1cyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICA/IGRlYWN0aXZhdGVPcHRpb25zLnJldHVybkZvY3VzXG4gICAgICAgIDogY29uZmlnLnJldHVybkZvY3VzT25EZWFjdGl2YXRlLFxuICAgICAgb25EZWFjdGl2YXRlOiAoZGVhY3RpdmF0ZU9wdGlvbnMgJiYgZGVhY3RpdmF0ZU9wdGlvbnMub25EZWFjdGl2YXRlICE9PSB1bmRlZmluZWQpXG4gICAgICAgID8gZGVhY3RpdmF0ZU9wdGlvbnMub25EZWFjdGl2YXRlXG4gICAgICAgIDogY29uZmlnLm9uRGVhY3RpdmF0ZSxcbiAgICB9O1xuXG4gICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG5cbiAgICBpZiAoZGVmYXVsdGVkRGVhY3RpdmF0ZU9wdGlvbnMub25EZWFjdGl2YXRlKSB7XG4gICAgICBkZWZhdWx0ZWREZWFjdGl2YXRlT3B0aW9ucy5vbkRlYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICBpZiAoZGVmYXVsdGVkRGVhY3RpdmF0ZU9wdGlvbnMucmV0dXJuRm9jdXMpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnlGb2N1cyhub2RlRm9jdXNlZEJlZm9yZUFjdGl2YXRpb24pO1xuICAgICAgfSwgMCk7XG4gICAgfVxuXG4gICAgYWN0aXZlID0gZmFsc2U7XG4gICAgcGF1c2VkID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICBpZiAocGF1c2VkIHx8ICFhY3RpdmUpIHJldHVybjtcbiAgICBwYXVzZWQgPSB0cnVlO1xuICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5wYXVzZSgpIHtcbiAgICBpZiAoIXBhdXNlZCB8fCAhYWN0aXZlKSByZXR1cm47XG4gICAgcGF1c2VkID0gZmFsc2U7XG4gICAgYWRkTGlzdGVuZXJzKCk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKCFhY3RpdmUpIHJldHVybjtcblxuICAgIC8vIFRoZXJlIGNhbiBiZSBvbmx5IG9uZSBsaXN0ZW5pbmcgZm9jdXMgdHJhcCBhdCBhIHRpbWVcbiAgICBpZiAobGlzdGVuaW5nRm9jdXNUcmFwKSB7XG4gICAgICBsaXN0ZW5pbmdGb2N1c1RyYXAucGF1c2UoKTtcbiAgICB9XG4gICAgbGlzdGVuaW5nRm9jdXNUcmFwID0gdHJhcDtcblxuICAgIHVwZGF0ZVRhYmJhYmxlTm9kZXMoKTtcbiAgICAvLyBFbnN1cmUgdGhhdCB0aGUgZm9jdXNlZCBlbGVtZW50IGRvZXNuJ3QgY2FwdHVyZSB0aGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhlIGZvY3VzIHRyYXAgYWN0aXZhdGlvblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5Rm9jdXMoZmlyc3RGb2N1c05vZGUoKSk7XG4gICAgfSwgMCk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBjaGVja0ZvY3VzLCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNoZWNrQ2xpY2ssIHRydWUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGNoZWNrUG9pbnRlckRvd24sIHRydWUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBjaGVja1BvaW50ZXJEb3duLCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgY2hlY2tLZXksIHRydWUpO1xuXG4gICAgcmV0dXJuIHRyYXA7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKCFhY3RpdmUgfHwgbGlzdGVuaW5nRm9jdXNUcmFwICE9PSB0cmFwKSByZXR1cm47XG5cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIGNoZWNrRm9jdXMsIHRydWUpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2hlY2tDbGljaywgdHJ1ZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgY2hlY2tQb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGNoZWNrUG9pbnRlckRvd24sIHRydWUpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBjaGVja0tleSwgdHJ1ZSk7XG5cbiAgICBsaXN0ZW5pbmdGb2N1c1RyYXAgPSBudWxsO1xuXG4gICAgcmV0dXJuIHRyYXA7XG4gIH1cblxuICBmdW5jdGlvbiBnZXROb2RlRm9yT3B0aW9uKG9wdGlvbk5hbWUpIHtcbiAgICB2YXIgb3B0aW9uVmFsdWUgPSBjb25maWdbb3B0aW9uTmFtZV07XG4gICAgdmFyIG5vZGUgPSBvcHRpb25WYWx1ZTtcbiAgICBpZiAoIW9wdGlvblZhbHVlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25WYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKG9wdGlvblZhbHVlKTtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2AnICsgb3B0aW9uTmFtZSArICdgIHJlZmVycyB0byBubyBrbm93biBub2RlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9uVmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG5vZGUgPSBvcHRpb25WYWx1ZSgpO1xuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYCcgKyBvcHRpb25OYW1lICsgJ2AgZGlkIG5vdCByZXR1cm4gYSBub2RlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyc3RGb2N1c05vZGUoKSB7XG4gICAgdmFyIG5vZGU7XG4gICAgaWYgKGdldE5vZGVGb3JPcHRpb24oJ2luaXRpYWxGb2N1cycpICE9PSBudWxsKSB7XG4gICAgICBub2RlID0gZ2V0Tm9kZUZvck9wdGlvbignaW5pdGlhbEZvY3VzJyk7XG4gICAgfSBlbHNlIGlmIChjb250YWluZXIuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIG5vZGUgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gdGFiYmFibGVOb2Rlc1swXSB8fCBnZXROb2RlRm9yT3B0aW9uKCdmYWxsYmFja0ZvY3VzJyk7XG4gICAgfVxuXG4gICAgaWYgKCFub2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5cXCd0IGhhdmUgYSBmb2N1cy10cmFwIHdpdGhvdXQgYXQgbGVhc3Qgb25lIGZvY3VzYWJsZSBlbGVtZW50Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRvbmUgb24gbW91c2Vkb3duIGFuZCB0b3VjaHN0YXJ0IGluc3RlYWQgb2YgY2xpY2tcbiAgLy8gc28gdGhhdCBpdCBwcmVjZWRlcyB0aGUgZm9jdXMgZXZlbnRcbiAgZnVuY3Rpb24gY2hlY2tQb2ludGVyRG93bihlKSB7XG4gICAgaWYgKGNvbmZpZy5jbGlja091dHNpZGVEZWFjdGl2YXRlcyAmJiAhY29udGFpbmVyLmNvbnRhaW5zKGUudGFyZ2V0KSkge1xuICAgICAgZGVhY3RpdmF0ZSh7IHJldHVybkZvY3VzOiBmYWxzZSB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0NsaWNrKGUpIHtcbiAgICBpZiAoY29uZmlnLmNsaWNrT3V0c2lkZURlYWN0aXZhdGVzKSByZXR1cm47XG4gICAgaWYgKGNvbnRhaW5lci5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRm9jdXMoZSkge1xuICAgIGlmIChjb250YWluZXIuY29udGFpbnMoZS50YXJnZXQpKSByZXR1cm47XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgLy8gQ2hlY2tpbmcgZm9yIGEgYmx1ciBtZXRob2QgaGVyZSByZXNvbHZlcyBhIEZpcmVmb3ggaXNzdWUgKCMxNSlcbiAgICBpZiAodHlwZW9mIGUudGFyZ2V0LmJsdXIgPT09ICdmdW5jdGlvbicpIGUudGFyZ2V0LmJsdXIoKTtcblxuICAgIGlmICh0YWJFdmVudCkge1xuICAgICAgcmVhZGp1c3RGb2N1cyh0YWJFdmVudCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tLZXkoZSkge1xuICAgIGlmIChlLmtleSA9PT0gJ1RhYicgfHwgZS5rZXlDb2RlID09PSA5KSB7XG4gICAgICBoYW5kbGVUYWIoZSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5lc2NhcGVEZWFjdGl2YXRlcyAhPT0gZmFsc2UgJiYgaXNFc2NhcGVFdmVudChlKSkge1xuICAgICAgZGVhY3RpdmF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVRhYihlKSB7XG4gICAgdXBkYXRlVGFiYmFibGVOb2RlcygpO1xuXG4gICAgaWYgKGUudGFyZ2V0Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSAmJiBOdW1iZXIoZS50YXJnZXQuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpKSA8IDApIHtcbiAgICAgIHJldHVybiB0YWJFdmVudCA9IGU7XG4gICAgfVxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciBjdXJyZW50Rm9jdXNJbmRleCA9IHRhYmJhYmxlTm9kZXMuaW5kZXhPZihlLnRhcmdldCk7XG5cbiAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgaWYgKGUudGFyZ2V0ID09PSBmaXJzdFRhYmJhYmxlTm9kZSB8fCB0YWJiYWJsZU5vZGVzLmluZGV4T2YoZS50YXJnZXQpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gdHJ5Rm9jdXMobGFzdFRhYmJhYmxlTm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ5Rm9jdXModGFiYmFibGVOb2Rlc1tjdXJyZW50Rm9jdXNJbmRleCAtIDFdKTtcbiAgICB9XG5cbiAgICBpZiAoZS50YXJnZXQgPT09IGxhc3RUYWJiYWJsZU5vZGUpIHJldHVybiB0cnlGb2N1cyhmaXJzdFRhYmJhYmxlTm9kZSk7XG5cbiAgICB0cnlGb2N1cyh0YWJiYWJsZU5vZGVzW2N1cnJlbnRGb2N1c0luZGV4ICsgMV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVGFiYmFibGVOb2RlcygpIHtcbiAgICB0YWJiYWJsZU5vZGVzID0gdGFiYmFibGUoY29udGFpbmVyKTtcbiAgICBmaXJzdFRhYmJhYmxlTm9kZSA9IHRhYmJhYmxlTm9kZXNbMF07XG4gICAgbGFzdFRhYmJhYmxlTm9kZSA9IHRhYmJhYmxlTm9kZXNbdGFiYmFibGVOb2Rlcy5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRqdXN0Rm9jdXMoZSkge1xuICAgIGlmIChlLnNoaWZ0S2V5KSByZXR1cm4gdHJ5Rm9jdXMobGFzdFRhYmJhYmxlTm9kZSk7XG5cbiAgICB0cnlGb2N1cyhmaXJzdFRhYmJhYmxlTm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFc2NhcGVFdmVudChlKSB7XG4gIHJldHVybiBlLmtleSA9PT0gJ0VzY2FwZScgfHwgZS5rZXkgPT09ICdFc2MnIHx8IGUua2V5Q29kZSA9PT0gMjc7XG59XG5cbmZ1bmN0aW9uIHRyeUZvY3VzKG5vZGUpIHtcbiAgaWYgKCFub2RlIHx8ICFub2RlLmZvY3VzKSByZXR1cm47XG4gIGlmIChub2RlID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSAgcmV0dXJuO1xuXG4gIG5vZGUuZm9jdXMoKTtcbiAgaWYgKG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgbm9kZS5zZWxlY3QoKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvY3VzVHJhcDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBjcmVhdGVGb2N1c1RyYXAgZnJvbSAnZm9jdXMtdHJhcCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGb2N1c1RyYXBJbnN0YW5jZShzdXJmYWNlRWwsIGFjY2VwdEJ1dHRvbkVsLCBmb2N1c1RyYXBGYWN0b3J5ID0gY3JlYXRlRm9jdXNUcmFwKSB7XG4gIHJldHVybiBmb2N1c1RyYXBGYWN0b3J5KHN1cmZhY2VFbCwge1xuICAgIGluaXRpYWxGb2N1czogYWNjZXB0QnV0dG9uRWwsXG4gICAgY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXM6IHRydWUsXG4gIH0pO1xufVxuIiwiPHRlbXBsYXRlPlxuICA8YXNpZGVcbiAgICByZWY9XCJyb290XCJcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCJcbiAgICA6c3R5bGU9XCJzdHlsZXNcIlxuICAgIDphcmlhLWxhYmVsbGVkYnk9XCInbGFiZWwnICsgdm1hX3VpZF9cIlxuICAgIDphcmlhLWRlc2NyaWJlZGJ5PVwiJ2Rlc2MnICsgdm1hX3VpZF9cIlxuICAgIGNsYXNzPVwibWRjLWRpYWxvZ1wiXG4gICAgcm9sZT1cImFsZXJ0ZGlhbG9nXCJcbiAgPlxuICAgIDxkaXZcbiAgICAgIHJlZj1cInN1cmZhY2VcIlxuICAgICAgOmNsYXNzPVwic3VyZmFjZUNsYXNzZXNcIlxuICAgICAgY2xhc3M9XCJtZGMtZGlhbG9nX19zdXJmYWNlXCI+XG4gICAgICA8aGVhZGVyXG4gICAgICAgIHYtaWY9XCJ0aXRsZVwiXG4gICAgICAgIGNsYXNzPVwibWRjLWRpYWxvZ19faGVhZGVyXCI+XG4gICAgICAgIDxoMlxuICAgICAgICAgIDppZD1cIidsYWJlbCcgKyB2bWFfdWlkX1wiXG4gICAgICAgICAgY2xhc3M9XCJtZGMtZGlhbG9nX19oZWFkZXJfX3RpdGxlXCI+XG4gICAgICAgICAge3sgdGl0bGUgfX1cbiAgICAgICAgPC9oMj5cbiAgICAgIDwvaGVhZGVyPlxuICAgICAgPHNlY3Rpb25cbiAgICAgICAgOmlkPVwiJ2Rlc2MnICsgdm1hX3VpZF9cIlxuICAgICAgICA6Y2xhc3M9XCJib2R5Q2xhc3Nlc1wiXG4gICAgICAgIGNsYXNzPVwibWRjLWRpYWxvZ19fYm9keVwiPlxuICAgICAgICA8c2xvdCAvPlxuICAgICAgPC9zZWN0aW9uPlxuICAgICAgPGZvb3RlclxuICAgICAgICB2LWlmPVwiYWNjZXB0fHxjYW5jZWxcIlxuICAgICAgICBjbGFzcz1cIm1kYy1kaWFsb2dfX2Zvb3RlclwiPlxuICAgICAgICA8bWRjQnV0dG9uXG4gICAgICAgICAgdi1pZj1cImNhbmNlbFwiXG4gICAgICAgICAgcmVmPVwiY2FuY2VsXCJcbiAgICAgICAgICA6Y2xhc3M9XCJ7J21kYy1kaWFsb2dfX2FjdGlvbic6YWNjZW50fVwiXG4gICAgICAgICAgY2xhc3M9XCJtZGMtZGlhbG9nX19mb290ZXJfX2J1dHRvbiBtZGMtZGlhbG9nX19mb290ZXJfX2J1dHRvbi0tY2FuY2VsXCJcbiAgICAgICAgICBAY2xpY2s9XCJvbkNhbmNlbFwiXG4gICAgICAgID57eyBjYW5jZWwgfX08L21kY0J1dHRvbj5cbiAgICAgICAgPG1kY0J1dHRvblxuICAgICAgICAgIHJlZj1cImFjY2VwdFwiXG4gICAgICAgICAgOmNsYXNzPVwieydtZGMtZGlhbG9nX19hY3Rpb24nOmFjY2VudH1cIlxuICAgICAgICAgIDpkaXNhYmxlZD1cImFjY2VwdERpc2FibGVkXCJcbiAgICAgICAgICBjbGFzcz1cIm1kYy1kaWFsb2dfX2Zvb3Rlcl9fYnV0dG9uIG1kYy1kaWFsb2dfX2Zvb3Rlcl9fYnV0dG9uLS1hY2NlcHRcIlxuICAgICAgICAgIEBjbGljaz1cIm9uQWNjZXB0XCJcbiAgICAgICAgPnt7IGFjY2VwdCB9fTwvbWRjQnV0dG9uPlxuICAgICAgPC9mb290ZXI+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1kaWFsb2dfX2JhY2tkcm9wXCIvPlxuICA8L2FzaWRlPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENEaWFsb2dGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9kaWFsb2cvZm91bmRhdGlvbidcbmltcG9ydCB7IGNyZWF0ZUZvY3VzVHJhcEluc3RhbmNlIH0gZnJvbSAnQG1hdGVyaWFsL2RpYWxvZy91dGlsJ1xuaW1wb3J0IHsgbWRjQnV0dG9uIH0gZnJvbSAnLi4vYnV0dG9uJ1xuaW1wb3J0IHsgVk1BVW5pcXVlSWRNaXhpbiB9IGZyb20gJy4uL2Jhc2UnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1kaWFsb2cnLFxuICBjb21wb25lbnRzOiB7XG4gICAgbWRjQnV0dG9uOiBtZGNCdXR0b25cbiAgfSxcbiAgbWl4aW5zOiBbVk1BVW5pcXVlSWRNaXhpbl0sXG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ29wZW4nLFxuICAgIGV2ZW50OiAnY2hhbmdlJ1xuICB9LFxuICBwcm9wczoge1xuICAgIHRpdGxlOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIGFjY2VwdDogeyB0eXBlOiBTdHJpbmcsIGRlZmF1bHQ6ICdPaycgfSxcbiAgICBhY2NlcHREaXNhYmxlZDogQm9vbGVhbixcbiAgICBjYW5jZWw6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgYWNjZW50OiBCb29sZWFuLFxuICAgIHNjcm9sbGFibGU6IEJvb2xlYW4sXG4gICAgb3BlbjogQm9vbGVhblxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgICdtZGMtdGhlbWUtLWRhcmsnOiB0aGlzLmRhcmtcbiAgICAgIH0sXG4gICAgICBzdHlsZXM6IHt9LFxuICAgICAgc3VyZmFjZUNsYXNzZXM6IHt9LFxuICAgICAgYm9keUNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1kaWFsb2dfX2JvZHktLXNjcm9sbGFibGUnOiB0aGlzLnNjcm9sbGFibGVcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7IG9wZW46ICdvbk9wZW5fJyB9LFxuICBtb3VudGVkKCkge1xuICAgIGlmICh0aGlzLmFjY2VwdCkge1xuICAgICAgdGhpcy5mb2N1c1RyYXAgPSBjcmVhdGVGb2N1c1RyYXBJbnN0YW5jZShcbiAgICAgICAgdGhpcy4kcmVmcy5zdXJmYWNlLFxuICAgICAgICB0aGlzLiRyZWZzLmFjY2VwdFxuICAgICAgKVxuICAgIH1cblxuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENEaWFsb2dGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIGFkZEJvZHlDbGFzczogY2xhc3NOYW1lID0+IGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpLFxuICAgICAgcmVtb3ZlQm9keUNsYXNzOiBjbGFzc05hbWUgPT4gZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSksXG4gICAgICBldmVudFRhcmdldEhhc0NsYXNzOiAodGFyZ2V0LCBjbGFzc05hbWUpID0+XG4gICAgICAgIHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PlxuICAgICAgICB0aGlzLiRyZWZzLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyKSxcbiAgICAgIHJlZ2lzdGVyU3VyZmFjZUludGVyYWN0aW9uSGFuZGxlcjogKC8qZXZ0LCBoYW5kbGVyKi8pID0+IHtcbiAgICAgICAgLy8gVk1BX0hBQ0s6IGhhbmRsZSBidXR0b24gY2xpY2tzIG91cnNlbHZlc1xuICAgICAgICAvLyB0aGlzLiRyZWZzLnN1cmZhY2UuYWRkRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlclN1cmZhY2VJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKmV2dCwgaGFuZGxlciovKSA9PiB7XG4gICAgICAgIC8vIFZNQV9IQUNLOiBoYW5kbGUgYnV0dG9uIGNsaWNrcyBvdXJzZWx2ZXNcbiAgICAgICAgLy8gdGhpcy4kcmVmcy5zdXJmYWNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcjogaGFuZGxlciA9PlxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcjogaGFuZGxlciA9PlxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlciksXG4gICAgICBub3RpZnlBY2NlcHQ6ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZmFsc2UpXG4gICAgICAgIHRoaXMuJGVtaXQoJ2FjY2VwdCcpXG4gICAgICB9LFxuICAgICAgbm90aWZ5Q2FuY2VsOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGZhbHNlKVxuICAgICAgICB0aGlzLiRlbWl0KCdjYW5jZWwnKVxuICAgICAgfSxcbiAgICAgIHRyYXBGb2N1c09uU3VyZmFjZTogKCkgPT4gdGhpcy5mb2N1c1RyYXAgJiYgdGhpcy5mb2N1c1RyYXAuYWN0aXZhdGUoKSxcbiAgICAgIHVudHJhcEZvY3VzT25TdXJmYWNlOiAoKSA9PiB0aGlzLmZvY3VzVHJhcCAmJiB0aGlzLmZvY3VzVHJhcC5kZWFjdGl2YXRlKCksXG4gICAgICBpc0RpYWxvZzogZWwgPT4gdGhpcy4kcmVmcy5zdXJmYWNlID09PSBlbFxuICAgIH0pXG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gICAgdGhpcy5vcGVuICYmIHRoaXMuZm91bmRhdGlvbi5vcGVuKClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbk9wZW5fKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uLm9wZW4oKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uLmNsb3NlKClcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uQ2FuY2VsKCkge1xuICAgICAgaWYgKHRoaXMuJGxpc3RlbmVyc1sndmFsaWRhdGVDYW5jZWwnXSkge1xuICAgICAgICB0aGlzLiRlbWl0KCd2YWxpZGF0ZUNhbmNlbCcsIHtcbiAgICAgICAgICBjYW5jZWw6IChub3RpZnkgPSB0cnVlKSA9PiB7XG4gICAgICAgICAgICAvLyBpZiBub3RpZnkgPSBmYWxzZSwgdGhlIGRpYWxvZyB3aWxsIGNsb3NlXG4gICAgICAgICAgICAvLyBidXQgdGhlIG5vdGlmeUFjY2VwdCBtZXRob2Qgd2lsbCBub3QgYmUgY2FsbGVkXG4gICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIG5vdGlmeSBsaXN0ZW5lcnMgdGhlIG9wZW4gc3RhdGVcbiAgICAgICAgICAgIC8vIGlzIGNoYW5naW5nLlxuICAgICAgICAgICAgaWYgKCFub3RpZnkpIHtcbiAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZmFsc2UpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZvdW5kYXRpb24uY2FuY2VsKG5vdGlmeSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24uY2FuY2VsKHRydWUpXG4gICAgICB9XG4gICAgfSxcbiAgICBvbkFjY2VwdCgpIHtcbiAgICAgIGlmICh0aGlzLiRsaXN0ZW5lcnNbJ3ZhbGlkYXRlJ10pIHtcbiAgICAgICAgdGhpcy4kZW1pdCgndmFsaWRhdGUnLCB7XG4gICAgICAgICAgYWNjZXB0OiAobm90aWZ5ID0gdHJ1ZSkgPT4ge1xuICAgICAgICAgICAgLy8gaWYgbm90aWZ5ID0gZmFsc2UsIHRoZSBkaWFsb2cgd2lsbCBjbG9zZVxuICAgICAgICAgICAgLy8gYnV0IHRoZSBub3RpZnlBY2NlcHQgbWV0aG9kIHdpbGwgbm90IGJlIGNhbGxlZFxuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBub3RpZnkgbGlzdGVuZXJzIHRoZSBvcGVuIHN0YXRlXG4gICAgICAgICAgICAvLyBpcyBjaGFuZ2luZy5cbiAgICAgICAgICAgIGlmICghbm90aWZ5KSB7XG4gICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGZhbHNlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mb3VuZGF0aW9uLmFjY2VwdChub3RpZnkpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uLmFjY2VwdCh0cnVlKVxuICAgICAgfVxuICAgIH0sXG4gICAgc2hvdygpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5vcGVuKClcbiAgICB9LFxuICAgIGNsb3NlKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLmNsb3NlKClcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjRGlhbG9nIGZyb20gJy4vbWRjLWRpYWxvZy52dWUnXG5cbmV4cG9ydCB7IG1kY0RpYWxvZyB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNEaWFsb2dcbn0pXG4iLCI8dGVtcGxhdGU+XG4gIDxuYXYgY2xhc3M9XCJtZGMtcGVybWFuZW50LWRyYXdlciBtZGMtZHJhd2VyLS1wZXJtYW5lbnQgbWRjLXR5cG9ncmFwaHlcIj5cbiAgICA8bmF2IGNsYXNzPVwibWRjLWRyYXdlcl9fY29udGVudFwiPlxuICAgICAgPGRpdiBcbiAgICAgICAgdi1pZj1cInRvb2xiYXJTcGFjZXJcIiBcbiAgICAgICAgY2xhc3M9XCJtZGMtZHJhd2VyX190b29sYmFyLXNwYWNlclwiLz5cbiAgICAgIDxzbG90IC8+XG4gICAgPC9uYXY+XG4gIDwvbmF2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1wZXJtYW5lbnQtZHJhd2VyJyxcbiAgcHJvcHM6IHtcbiAgICAndG9vbGJhci1zcGFjZXInOiBCb29sZWFuXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGNvbnN0IEZPQ1VTQUJMRV9FTEVNRU5UUyA9XG4gICdhW2hyZWZdLCBhcmVhW2hyZWZdLCBpbnB1dDpub3QoW2Rpc2FibGVkXSksIHNlbGVjdDpub3QoW2Rpc2FibGVkXSksIHRleHRhcmVhOm5vdChbZGlzYWJsZWRdKSwgJyArXG4gICdidXR0b246bm90KFtkaXNhYmxlZF0pLCBpZnJhbWUsIG9iamVjdCwgZW1iZWQsIFt0YWJpbmRleF0sIFtjb250ZW50ZWRpdGFibGVdJztcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7TURDRm91bmRhdGlvbn0gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvaW5kZXgnO1xuXG5leHBvcnQgY2xhc3MgTURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBoYXNDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGhhc05lY2Vzc2FyeURvbTogKCkgPT4gLyogYm9vbGVhbiAqLyBmYWxzZSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0OiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dDogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0OiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckRyYXdlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dDogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgc2V0VHJhbnNsYXRlWDogKC8qIHZhbHVlOiBudW1iZXIgfCBudWxsICovKSA9PiB7fSxcbiAgICAgIGdldEZvY3VzYWJsZUVsZW1lbnRzOiAoKSA9PiAvKiBOb2RlTGlzdCAqLyB7fSxcbiAgICAgIHNhdmVFbGVtZW50VGFiU3RhdGU6ICgvKiBlbDogRWxlbWVudCAqLykgPT4ge30sXG4gICAgICByZXN0b3JlRWxlbWVudFRhYlN0YXRlOiAoLyogZWw6IEVsZW1lbnQgKi8pID0+IHt9LFxuICAgICAgbWFrZUVsZW1lbnRVbnRhYmJhYmxlOiAoLyogZWw6IEVsZW1lbnQgKi8pID0+IHt9LFxuICAgICAgbm90aWZ5T3BlbjogKCkgPT4ge30sXG4gICAgICBub3RpZnlDbG9zZTogKCkgPT4ge30sXG4gICAgICBpc1J0bDogKCkgPT4gLyogYm9vbGVhbiAqLyBmYWxzZSxcbiAgICAgIGdldERyYXdlcldpZHRoOiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICB9O1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlciwgcm9vdENzc0NsYXNzLCBhbmltYXRpbmdDc3NDbGFzcywgb3BlbkNzc0NsYXNzKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIHRoaXMucm9vdENzc0NsYXNzXyA9IHJvb3RDc3NDbGFzcztcbiAgICB0aGlzLmFuaW1hdGluZ0Nzc0NsYXNzXyA9IGFuaW1hdGluZ0Nzc0NsYXNzO1xuICAgIHRoaXMub3BlbkNzc0NsYXNzXyA9IG9wZW5Dc3NDbGFzcztcblxuICAgIHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVUcmFuc2l0aW9uRW5kXyhldnQpO1xuXG4gICAgdGhpcy5pbmVydF8gPSBmYWxzZTtcblxuICAgIHRoaXMuY29tcG9uZW50VG91Y2hTdGFydEhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVUb3VjaFN0YXJ0XyhldnQpO1xuICAgIHRoaXMuY29tcG9uZW50VG91Y2hNb3ZlSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZVRvdWNoTW92ZV8oZXZ0KTtcbiAgICB0aGlzLmNvbXBvbmVudFRvdWNoRW5kSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZVRvdWNoRW5kXyhldnQpO1xuICAgIHRoaXMuZG9jdW1lbnRLZXlkb3duSGFuZGxlcl8gPSAoZXZ0KSA9PiB7XG4gICAgICBpZiAoZXZ0LmtleSAmJiBldnQua2V5ID09PSAnRXNjYXBlJyB8fCBldnQua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBpbml0KCkge1xuICAgIGNvbnN0IFJPT1QgPSB0aGlzLnJvb3RDc3NDbGFzc187XG4gICAgY29uc3QgT1BFTiA9IHRoaXMub3BlbkNzc0NsYXNzXztcblxuICAgIGlmICghdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhST09UKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke1JPT1R9IGNsYXNzIHJlcXVpcmVkIGluIHJvb3QgZWxlbWVudC5gKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuYWRhcHRlcl8uaGFzTmVjZXNzYXJ5RG9tKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUmVxdWlyZWQgRE9NIG5vZGVzIG1pc3NpbmcgaW4gJHtST09UfSBjb21wb25lbnQuYCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoT1BFTikpIHtcbiAgICAgIHRoaXMuaXNPcGVuXyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGV0YWJpbmF0ZV8oKTtcbiAgICAgIHRoaXMuaXNPcGVuXyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJEcmF3ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLmNvbXBvbmVudFRvdWNoU3RhcnRIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigndG91Y2htb3ZlJywgdGhpcy5jb21wb25lbnRUb3VjaE1vdmVIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigndG91Y2hlbmQnLCB0aGlzLmNvbXBvbmVudFRvdWNoRW5kSGFuZGxlcl8pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJEcmF3ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLmNvbXBvbmVudFRvdWNoU3RhcnRIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCd0b3VjaG1vdmUnLCB0aGlzLmNvbXBvbmVudFRvdWNoTW92ZUhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ3RvdWNoZW5kJywgdGhpcy5jb21wb25lbnRUb3VjaEVuZEhhbmRsZXJfKTtcbiAgICAvLyBEZXJlZ2lzdGVyIHRoZSBkb2N1bWVudCBrZXlkb3duIGhhbmRsZXIganVzdCBpbiBjYXNlIHRoZSBjb21wb25lbnQgaXMgZGVzdHJveWVkIHdoaWxlIHRoZSBtZW51IGlzIG9wZW4uXG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcih0aGlzLmRvY3VtZW50S2V5ZG93bkhhbmRsZXJfKTtcbiAgfVxuXG4gIG9wZW4oKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyKHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcih0aGlzLmRvY3VtZW50S2V5ZG93bkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKHRoaXMuYW5pbWF0aW5nQ3NzQ2xhc3NfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKHRoaXMub3BlbkNzc0NsYXNzXyk7XG4gICAgdGhpcy5yZXRhYmluYXRlXygpO1xuICAgIC8vIERlYm91bmNlIG11bHRpcGxlIGNhbGxzXG4gICAgaWYgKCF0aGlzLmlzT3Blbl8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5T3BlbigpO1xuICAgIH1cbiAgICB0aGlzLmlzT3Blbl8gPSB0cnVlO1xuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcih0aGlzLmRvY3VtZW50S2V5ZG93bkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXIodGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3ModGhpcy5hbmltYXRpbmdDc3NDbGFzc18pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3ModGhpcy5vcGVuQ3NzQ2xhc3NfKTtcbiAgICB0aGlzLmRldGFiaW5hdGVfKCk7XG4gICAgLy8gRGVib3VuY2UgbXVsdGlwbGUgY2FsbHNcbiAgICBpZiAodGhpcy5pc09wZW5fKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUNsb3NlKCk7XG4gICAgfVxuICAgIHRoaXMuaXNPcGVuXyA9IGZhbHNlO1xuICB9XG5cbiAgaXNPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLmlzT3Blbl87XG4gIH1cblxuICAvKipcbiAgICogIFJlbmRlciBhbGwgY2hpbGRyZW4gb2YgdGhlIGRyYXdlciBpbmVydCB3aGVuIGl0J3MgY2xvc2VkLlxuICAgKi9cbiAgZGV0YWJpbmF0ZV8oKSB7XG4gICAgaWYgKHRoaXMuaW5lcnRfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmFkYXB0ZXJfLmdldEZvY3VzYWJsZUVsZW1lbnRzKCk7XG4gICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uc2F2ZUVsZW1lbnRUYWJTdGF0ZShlbGVtZW50c1tpXSk7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ubWFrZUVsZW1lbnRVbnRhYmJhYmxlKGVsZW1lbnRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmluZXJ0XyA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogIE1ha2UgYWxsIGNoaWxkcmVuIG9mIHRoZSBkcmF3ZXIgdGFiYmFibGUgYWdhaW4gd2hlbiBpdCdzIG9wZW4uXG4gICAqL1xuICByZXRhYmluYXRlXygpIHtcbiAgICBpZiAoIXRoaXMuaW5lcnRfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmFkYXB0ZXJfLmdldEZvY3VzYWJsZUVsZW1lbnRzKCk7XG4gICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ucmVzdG9yZUVsZW1lbnRUYWJTdGF0ZShlbGVtZW50c1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5pbmVydF8gPSBmYWxzZTtcbiAgfVxuXG4gIGhhbmRsZVRvdWNoU3RhcnRfKGV2dCkge1xuICAgIGlmICghdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyh0aGlzLm9wZW5Dc3NDbGFzc18pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChldnQucG9pbnRlclR5cGUgJiYgZXZ0LnBvaW50ZXJUeXBlICE9PSAndG91Y2gnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kaXJlY3Rpb25fID0gdGhpcy5hZGFwdGVyXy5pc1J0bCgpID8gLTEgOiAxO1xuICAgIHRoaXMuZHJhd2VyV2lkdGhfID0gdGhpcy5hZGFwdGVyXy5nZXREcmF3ZXJXaWR0aCgpO1xuICAgIHRoaXMuc3RhcnRYXyA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0ucGFnZVggOiBldnQucGFnZVg7XG4gICAgdGhpcy5jdXJyZW50WF8gPSB0aGlzLnN0YXJ0WF87XG5cbiAgICB0aGlzLnVwZGF0ZVJhZl8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGVEcmF3ZXJfLmJpbmQodGhpcykpO1xuICB9XG5cbiAgaGFuZGxlVG91Y2hNb3ZlXyhldnQpIHtcbiAgICBpZiAoZXZ0LnBvaW50ZXJUeXBlICYmIGV2dC5wb2ludGVyVHlwZSAhPT0gJ3RvdWNoJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudFhfID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXS5wYWdlWCA6IGV2dC5wYWdlWDtcbiAgfVxuXG4gIGhhbmRsZVRvdWNoRW5kXyhldnQpIHtcbiAgICBpZiAoZXZ0LnBvaW50ZXJUeXBlICYmIGV2dC5wb2ludGVyVHlwZSAhPT0gJ3RvdWNoJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucHJlcGFyZUZvclRvdWNoRW5kXygpO1xuXG4gICAgLy8gRGlkIHRoZSB1c2VyIGNsb3NlIHRoZSBkcmF3ZXIgYnkgbW9yZSB0aGFuIDUwJT9cbiAgICBpZiAoTWF0aC5hYnModGhpcy5uZXdQb3NpdGlvbl8gLyB0aGlzLmRyYXdlcldpZHRoXykgPj0gMC41KSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyaWdnZXJpbmcgYW4gb3BlbiBoZXJlIG1lYW5zIHdlJ2xsIGdldCBhIG5pY2UgYW5pbWF0aW9uIGJhY2sgdG8gdGhlIGZ1bGx5IG9wZW4gc3RhdGUuXG4gICAgICB0aGlzLm9wZW4oKTtcbiAgICB9XG4gIH1cblxuICBwcmVwYXJlRm9yVG91Y2hFbmRfKCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlUmFmXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRUcmFuc2xhdGVYKG51bGwpO1xuICB9XG5cbiAgdXBkYXRlRHJhd2VyXygpIHtcbiAgICB0aGlzLnVwZGF0ZVJhZl8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGVEcmF3ZXJfLmJpbmQodGhpcykpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0VHJhbnNsYXRlWCh0aGlzLm5ld1Bvc2l0aW9uXyk7XG4gIH1cblxuICBnZXQgbmV3UG9zaXRpb25fKCkge1xuICAgIGxldCBuZXdQb3MgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuZGlyZWN0aW9uXyA9PT0gMSkge1xuICAgICAgbmV3UG9zID0gTWF0aC5taW4oMCwgdGhpcy5jdXJyZW50WF8gLSB0aGlzLnN0YXJ0WF8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdQb3MgPSBNYXRoLm1heCgwLCB0aGlzLmN1cnJlbnRYXyAtIHRoaXMuc3RhcnRYXyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1BvcztcbiAgfVxuXG4gIGlzUm9vdFRyYW5zaXRpb25pbmdFdmVudFRhcmdldF8oKSB7XG4gICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9uIHNob3VsZCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmV0dXJuIHRydWUgb3IgZmFsc2VcbiAgICAvLyBpZiB0aGUgZXZlbnQgdGFyZ2V0IGlzIHRoZSByb290IGV2ZW50IHRhcmdldCBjdXJyZW50bHkgdHJhbnNpdGlvbmluZy5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBoYW5kbGVUcmFuc2l0aW9uRW5kXyhldnQpIHtcbiAgICBpZiAodGhpcy5pc1Jvb3RUcmFuc2l0aW9uaW5nRXZlbnRUYXJnZXRfKGV2dC50YXJnZXQpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKHRoaXMuYW5pbWF0aW5nQ3NzQ2xhc3NfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyKHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfKTtcbiAgICB9XG4gIH07XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQge0ZPQ1VTQUJMRV9FTEVNRU5UU30gZnJvbSAnLi9jb25zdGFudHMnO1xuZXhwb3J0IHtNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb259IGZyb20gJy4vZm91bmRhdGlvbic7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge0ZPQ1VTQUJMRV9FTEVNRU5UU30gZnJvbSAnLi4vc2xpZGFibGUvaW5kZXgnO1xuXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy1kcmF3ZXItLXBlcnNpc3RlbnQnLFxuICBPUEVOOiAnbWRjLWRyYXdlci0tb3BlbicsXG4gIEFOSU1BVElORzogJ21kYy1kcmF3ZXItLWFuaW1hdGluZycsXG59O1xuXG5leHBvcnQgY29uc3Qgc3RyaW5ncyA9IHtcbiAgRFJBV0VSX1NFTEVDVE9SOiAnLm1kYy1kcmF3ZXItLXBlcnNpc3RlbnQgLm1kYy1kcmF3ZXJfX2RyYXdlcicsXG4gIEZPQ1VTQUJMRV9FTEVNRU5UUyxcbiAgT1BFTl9FVkVOVDogJ01EQ1BlcnNpc3RlbnREcmF3ZXI6b3BlbicsXG4gIENMT1NFX0VWRU5UOiAnTURDUGVyc2lzdGVudERyYXdlcjpjbG9zZScsXG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb259IGZyb20gJy4uL3NsaWRhYmxlL2luZGV4JztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNRENQZXJzaXN0ZW50RHJhd2VyRm91bmRhdGlvbiBleHRlbmRzIE1EQ1NsaWRhYmxlRHJhd2VyRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oTURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCB7XG4gICAgICBpc0RyYXdlcjogKCkgPT4gZmFsc2UsXG4gICAgfSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoXG4gICAgICBPYmplY3QuYXNzaWduKE1EQ1BlcnNpc3RlbnREcmF3ZXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSxcbiAgICAgIE1EQ1BlcnNpc3RlbnREcmF3ZXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuUk9PVCxcbiAgICAgIE1EQ1BlcnNpc3RlbnREcmF3ZXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQU5JTUFUSU5HLFxuICAgICAgTURDUGVyc2lzdGVudERyYXdlckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5PUEVOKTtcbiAgfVxuXG4gIGlzUm9vdFRyYW5zaXRpb25pbmdFdmVudFRhcmdldF8oZWwpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5pc0RyYXdlcihlbCk7XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmNvbnN0IFRBQl9EQVRBID0gJ2RhdGEtbWRjLXRhYmluZGV4JztcbmNvbnN0IFRBQl9EQVRBX0hBTkRMRUQgPSAnZGF0YS1tZGMtdGFiaW5kZXgtaGFuZGxlZCc7XG5cbmxldCBzdG9yZWRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWVfO1xubGV0IHN1cHBvcnRzUGFzc2l2ZV87XG5cbi8vIFJlbWFwIHRvdWNoIGV2ZW50cyB0byBwb2ludGVyIGV2ZW50cywgaWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRvdWNoIGV2ZW50cy5cbmV4cG9ydCBmdW5jdGlvbiByZW1hcEV2ZW50KGV2ZW50TmFtZSwgZ2xvYmFsT2JqID0gd2luZG93KSB7XG4gIGlmICghKCdvbnRvdWNoc3RhcnQnIGluIGdsb2JhbE9iai5kb2N1bWVudCkpIHtcbiAgICBzd2l0Y2ggKGV2ZW50TmFtZSkge1xuICAgIGNhc2UgJ3RvdWNoc3RhcnQnOlxuICAgICAgcmV0dXJuICdwb2ludGVyZG93bic7XG4gICAgY2FzZSAndG91Y2htb3ZlJzpcbiAgICAgIHJldHVybiAncG9pbnRlcm1vdmUnO1xuICAgIGNhc2UgJ3RvdWNoZW5kJzpcbiAgICAgIHJldHVybiAncG9pbnRlcnVwJztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXZlbnROYW1lO1xufVxuXG4vLyBDaG9vc2UgdGhlIGNvcnJlY3QgdHJhbnNmb3JtIHByb3BlcnR5IHRvIHVzZSBvbiB0aGUgY3VycmVudCBicm93c2VyLlxuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zZm9ybVByb3BlcnR5TmFtZShnbG9iYWxPYmogPSB3aW5kb3csIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gIGlmIChzdG9yZWRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWVfID09PSB1bmRlZmluZWQgfHwgZm9yY2VSZWZyZXNoKSB7XG4gICAgY29uc3QgZWwgPSBnbG9iYWxPYmouZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3QgdHJhbnNmb3JtUHJvcGVydHlOYW1lID0gKCd0cmFuc2Zvcm0nIGluIGVsLnN0eWxlID8gJ3RyYW5zZm9ybScgOiAnLXdlYmtpdC10cmFuc2Zvcm0nKTtcbiAgICBzdG9yZWRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWVfID0gdHJhbnNmb3JtUHJvcGVydHlOYW1lO1xuICB9XG5cbiAgcmV0dXJuIHN0b3JlZFRyYW5zZm9ybVByb3BlcnR5TmFtZV87XG59XG5cbi8vIERldGVybWluZSB3aGV0aGVyIHRoZSBjdXJyZW50IGJyb3dzZXIgc3VwcG9ydHMgQ1NTIHByb3BlcnRpZXMuXG5leHBvcnQgZnVuY3Rpb24gc3VwcG9ydHNDc3NDdXN0b21Qcm9wZXJ0aWVzKGdsb2JhbE9iaiA9IHdpbmRvdykge1xuICBpZiAoJ0NTUycgaW4gZ2xvYmFsT2JqKSB7XG4gICAgcmV0dXJuIGdsb2JhbE9iai5DU1Muc3VwcG9ydHMoJygtLWNvbG9yOiByZWQpJyk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBEZXRlcm1pbmUgd2hldGhlciB0aGUgY3VycmVudCBicm93c2VyIHN1cHBvcnRzIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzLCBhbmQgaWYgc28sIHVzZSB0aGVtLlxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UGFzc2l2ZShnbG9iYWxPYmogPSB3aW5kb3csIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gIGlmIChzdXBwb3J0c1Bhc3NpdmVfID09PSB1bmRlZmluZWQgfHwgZm9yY2VSZWZyZXNoKSB7XG4gICAgbGV0IGlzU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGdsb2JhbE9iai5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwge2dldCBwYXNzaXZlKCkge1xuICAgICAgICBpc1N1cHBvcnRlZCA9IHRydWU7XG4gICAgICB9fSk7XG4gICAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgICBzdXBwb3J0c1Bhc3NpdmVfID0gaXNTdXBwb3J0ZWQ7XG4gIH1cblxuICByZXR1cm4gc3VwcG9ydHNQYXNzaXZlXyA/IHtwYXNzaXZlOiB0cnVlfSA6IGZhbHNlO1xufVxuXG4vLyBTYXZlIHRoZSB0YWIgc3RhdGUgZm9yIGFuIGVsZW1lbnQuXG5leHBvcnQgZnVuY3Rpb24gc2F2ZUVsZW1lbnRUYWJTdGF0ZShlbCkge1xuICBpZiAoZWwuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKFRBQl9EQVRBLCBlbC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykpO1xuICB9XG4gIGVsLnNldEF0dHJpYnV0ZShUQUJfREFUQV9IQU5ETEVELCB0cnVlKTtcbn1cblxuLy8gUmVzdG9yZSB0aGUgdGFiIHN0YXRlIGZvciBhbiBlbGVtZW50LCBpZiBpdCB3YXMgc2F2ZWQuXG5leHBvcnQgZnVuY3Rpb24gcmVzdG9yZUVsZW1lbnRUYWJTdGF0ZShlbCkge1xuICAvLyBPbmx5IG1vZGlmeSBlbGVtZW50cyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQsIGluIGNhc2UgYW55dGhpbmcgd2FzIGR5bmFtaWNhbGx5IGFkZGVkIHNpbmNlIHdlIHNhdmVkIHN0YXRlLlxuICBpZiAoZWwuaGFzQXR0cmlidXRlKFRBQl9EQVRBX0hBTkRMRUQpKSB7XG4gICAgaWYgKGVsLmhhc0F0dHJpYnV0ZShUQUJfREFUQSkpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCBlbC5nZXRBdHRyaWJ1dGUoVEFCX0RBVEEpKTtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShUQUJfREFUQSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICB9XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKFRBQl9EQVRBX0hBTkRMRUQpO1xuICB9XG59XG4iLCI8dGVtcGxhdGU+XG4gIDxhc2lkZVxuICAgIDpjbGFzcz1cImNsYXNzZXNcIlxuICAgIGNsYXNzPVwibWRjLXBlcnNpc3RlbnQtZHJhd2VyIG1kYy1kcmF3ZXItLXBlcnNpc3RlbnQgbWRjLXR5cG9ncmFwaHlcIj5cbiAgICA8bmF2XG4gICAgICByZWY9XCJkcmF3ZXJcIlxuICAgICAgY2xhc3M9XCJtZGMtZHJhd2VyX19kcmF3ZXJcIj5cbiAgICAgIDxkaXZcbiAgICAgICAgdi1pZj1cInRvb2xiYXJTcGFjZXJcIlxuICAgICAgICBjbGFzcz1cIm1kYy1kcmF3ZXJfX3Rvb2xiYXItc3BhY2VyXCIvPlxuICAgICAgPHNsb3QgLz5cbiAgICA8L25hdj5cbiAgPC9hc2lkZT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDUGVyc2lzdGVudERyYXdlckZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2RyYXdlci9wZXJzaXN0ZW50L2ZvdW5kYXRpb24nXG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJ0BtYXRlcmlhbC9kcmF3ZXIvdXRpbCdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXBlcnNpc3RlbnQtZHJhd2VyJyxcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAnb3BlbicsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgJ3Rvb2xiYXItc3BhY2VyJzogQm9vbGVhbixcbiAgICBvcGVuOiBCb29sZWFuXG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHt9XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIG9wZW46ICdfcmVmcmVzaCdcbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICBjb25zdCB7IEZPQ1VTQUJMRV9FTEVNRU5UUyB9ID0gTURDUGVyc2lzdGVudERyYXdlckZvdW5kYXRpb24uc3RyaW5nc1xuXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ1BlcnNpc3RlbnREcmF3ZXJGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICB9LFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSlcbiAgICAgIH0sXG4gICAgICBoYXNDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgaGFzTmVjZXNzYXJ5RG9tOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuJHJlZnMuZHJhd2VyXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICB1dGlsLnJlbWFwRXZlbnQoZXZ0KSxcbiAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgIHV0aWwuYXBwbHlQYXNzaXZlKClcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICB1dGlsLnJlbWFwRXZlbnQoZXZ0KSxcbiAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgIHV0aWwuYXBwbHlQYXNzaXZlKClcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgdXRpbC5yZW1hcEV2ZW50KGV2dCksXG4gICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICB1dGlsLmFwcGx5UGFzc2l2ZSgpXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgdXRpbC5yZW1hcEV2ZW50KGV2dCksXG4gICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICB1dGlsLmFwcGx5UGFzc2l2ZSgpXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICByZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5kcmF3ZXIuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5kcmF3ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBnZXREcmF3ZXJXaWR0aDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5kcmF3ZXIub2Zmc2V0V2lkdGhcbiAgICAgIH0sXG4gICAgICBzZXRUcmFuc2xhdGVYOiB2YWx1ZSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgIHV0aWwuZ2V0VHJhbnNmb3JtUHJvcGVydHlOYW1lKCksXG4gICAgICAgICAgdmFsdWUgPT09IG51bGwgPyBudWxsIDogYHRyYW5zbGF0ZVgoJHt2YWx1ZX1weClgXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBnZXRGb2N1c2FibGVFbGVtZW50czogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5kcmF3ZXIucXVlcnlTZWxlY3RvckFsbChGT0NVU0FCTEVfRUxFTUVOVFMpXG4gICAgICB9LFxuICAgICAgc2F2ZUVsZW1lbnRUYWJTdGF0ZTogZWwgPT4ge1xuICAgICAgICB1dGlsLnNhdmVFbGVtZW50VGFiU3RhdGUoZWwpXG4gICAgICB9LFxuICAgICAgcmVzdG9yZUVsZW1lbnRUYWJTdGF0ZTogZWwgPT4ge1xuICAgICAgICB1dGlsLnJlc3RvcmVFbGVtZW50VGFiU3RhdGUoZWwpXG4gICAgICB9LFxuICAgICAgbWFrZUVsZW1lbnRVbnRhYmJhYmxlOiBlbCA9PiB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAtMSlcbiAgICAgIH0sXG4gICAgICBub3RpZnlPcGVuOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIHRydWUpXG4gICAgICAgIHRoaXMuJGVtaXQoJ29wZW4nKVxuICAgICAgfSxcbiAgICAgIG5vdGlmeUNsb3NlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGZhbHNlKVxuICAgICAgICB0aGlzLiRlbWl0KCdjbG9zZScpXG4gICAgICB9LFxuICAgICAgaXNSdGw6ICgpID0+IHtcbiAgICAgICAgLyogZ2xvYmFsIGdldENvbXB1dGVkU3R5bGUgKi9cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBnZXRDb21wdXRlZFN0eWxlKHRoaXMuJGVsKS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXJlY3Rpb24nKSA9PT0gJ3J0bCdcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIGlzRHJhd2VyOiBlbCA9PiB7XG4gICAgICAgIHJldHVybiBlbCA9PT0gdGhpcy4kcmVmcy5kcmF3ZXJcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gICAgdGhpcy5fcmVmcmVzaCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBudWxsXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBfcmVmcmVzaCgpIHtcbiAgICAgIGlmICh0aGlzLm9wZW4pIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5vcGVuKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uY2xvc2UoKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge0ZPQ1VTQUJMRV9FTEVNRU5UU30gZnJvbSAnLi4vc2xpZGFibGUvaW5kZXgnO1xuXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy1kcmF3ZXItLXRlbXBvcmFyeScsXG4gIE9QRU46ICdtZGMtZHJhd2VyLS1vcGVuJyxcbiAgQU5JTUFUSU5HOiAnbWRjLWRyYXdlci0tYW5pbWF0aW5nJyxcbiAgU0NST0xMX0xPQ0s6ICdtZGMtZHJhd2VyLXNjcm9sbC1sb2NrJyxcbn07XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBEUkFXRVJfU0VMRUNUT1I6ICcubWRjLWRyYXdlci0tdGVtcG9yYXJ5IC5tZGMtZHJhd2VyX19kcmF3ZXInLFxuICBPUEFDSVRZX1ZBUl9OQU1FOiAnLS1tZGMtdGVtcG9yYXJ5LWRyYXdlci1vcGFjaXR5JyxcbiAgRk9DVVNBQkxFX0VMRU1FTlRTLFxuICBPUEVOX0VWRU5UOiAnTURDVGVtcG9yYXJ5RHJhd2VyOm9wZW4nLFxuICBDTE9TRV9FVkVOVDogJ01EQ1RlbXBvcmFyeURyYXdlcjpjbG9zZScsXG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb259IGZyb20gJy4uL3NsaWRhYmxlL2luZGV4JztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNRENUZW1wb3JhcnlEcmF3ZXJGb3VuZGF0aW9uIGV4dGVuZHMgTURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIHtcbiAgICAgIGFkZEJvZHlDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUJvZHlDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGlzRHJhd2VyOiAoKSA9PiBmYWxzZSxcbiAgICAgIHVwZGF0ZUNzc1ZhcmlhYmxlOiAoLyogdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBldmVudFRhcmdldEhhc0NsYXNzOiAoLyogdGFyZ2V0OiBFdmVudFRhcmdldCwgY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgfSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoXG4gICAgICBPYmplY3QuYXNzaWduKE1EQ1RlbXBvcmFyeURyYXdlckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpLFxuICAgICAgTURDVGVtcG9yYXJ5RHJhd2VyRm91bmRhdGlvbi5jc3NDbGFzc2VzLlJPT1QsXG4gICAgICBNRENUZW1wb3JhcnlEcmF3ZXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQU5JTUFUSU5HLFxuICAgICAgTURDVGVtcG9yYXJ5RHJhd2VyRm91bmRhdGlvbi5jc3NDbGFzc2VzLk9QRU4pO1xuXG4gICAgdGhpcy5jb21wb25lbnRDbGlja0hhbmRsZXJfID0gKGV2dCkgPT4ge1xuICAgICAgaWYgKHRoaXMuYWRhcHRlcl8uZXZlbnRUYXJnZXRIYXNDbGFzcyhldnQudGFyZ2V0LCBjc3NDbGFzc2VzLlJPT1QpKSB7XG4gICAgICAgIHRoaXMuY2xvc2UodHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgc3VwZXIuaW5pdCgpO1xuXG4gICAgLy8gTWFrZSBicm93c2VyIGF3YXJlIG9mIGN1c3RvbSBwcm9wZXJ0eSBiZWluZyB1c2VkIGluIHRoaXMgZWxlbWVudC5cbiAgICAvLyBXb3JrYXJvdW5kIGZvciBjZXJ0YWluIHR5cGVzIG9mIGhhcmQtdG8tcmVwcm9kdWNlIGhlaXNlbmJ1Z3MuXG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZSgwKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY29tcG9uZW50Q2xpY2tIYW5kbGVyXyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcblxuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmNvbXBvbmVudENsaWNrSGFuZGxlcl8pO1xuICAgIHRoaXMuZW5hYmxlU2Nyb2xsXygpO1xuICB9XG5cbiAgb3BlbigpIHtcbiAgICB0aGlzLmRpc2FibGVTY3JvbGxfKCk7XG4gICAgLy8gTWFrZSBzdXJlIGN1c3RvbSBwcm9wZXJ0eSB2YWx1ZXMgYXJlIGNsZWFyZWQgYmVmb3JlIHN0YXJ0aW5nLlxuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoJycpO1xuXG4gICAgc3VwZXIub3BlbigpO1xuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgLy8gTWFrZSBzdXJlIGN1c3RvbSBwcm9wZXJ0eSB2YWx1ZXMgYXJlIGNsZWFyZWQgYmVmb3JlIG1ha2luZyBhbnkgY2hhbmdlcy5cbiAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKCcnKTtcblxuICAgIHN1cGVyLmNsb3NlKCk7XG4gIH1cblxuICBwcmVwYXJlRm9yVG91Y2hFbmRfKCkge1xuICAgIHN1cGVyLnByZXBhcmVGb3JUb3VjaEVuZF8oKTtcblxuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoJycpO1xuICB9XG5cbiAgdXBkYXRlRHJhd2VyXygpIHtcbiAgICBzdXBlci51cGRhdGVEcmF3ZXJfKCk7XG5cbiAgICBjb25zdCBuZXdPcGFjaXR5ID0gTWF0aC5tYXgoMCwgMSArIHRoaXMuZGlyZWN0aW9uXyAqICh0aGlzLm5ld1Bvc2l0aW9uXyAvIHRoaXMuZHJhd2VyV2lkdGhfKSk7XG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShuZXdPcGFjaXR5KTtcbiAgfVxuXG4gIGlzUm9vdFRyYW5zaXRpb25pbmdFdmVudFRhcmdldF8oZWwpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5pc0RyYXdlcihlbCk7XG4gIH1cblxuICBoYW5kbGVUcmFuc2l0aW9uRW5kXyhldnQpIHtcbiAgICBzdXBlci5oYW5kbGVUcmFuc2l0aW9uRW5kXyhldnQpO1xuICAgIGlmICghdGhpcy5pc09wZW5fKSB7XG4gICAgICB0aGlzLmVuYWJsZVNjcm9sbF8oKTtcbiAgICB9XG4gIH07XG5cbiAgZGlzYWJsZVNjcm9sbF8oKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRCb2R5Q2xhc3MoY3NzQ2xhc3Nlcy5TQ1JPTExfTE9DSyk7XG4gIH1cblxuICBlbmFibGVTY3JvbGxfKCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQm9keUNsYXNzKGNzc0NsYXNzZXMuU0NST0xMX0xPQ0spO1xuICB9XG59XG4iLCI8dGVtcGxhdGU+XG4gIDxhc2lkZVxuICAgIDpjbGFzcz1cImNsYXNzZXNcIlxuICAgIGNsYXNzPVwibWRjLXRlbXBvcmFyeS1kcmF3ZXIgbWRjLWRyYXdlci0tdGVtcG9yYXJ5IG1kYy10eXBvZ3JhcGh5XCI+XG4gICAgPG5hdlxuICAgICAgcmVmPVwiZHJhd2VyXCJcbiAgICAgIGNsYXNzPVwibWRjLWRyYXdlcl9fZHJhd2VyXCI+XG4gICAgICA8ZGl2XG4gICAgICAgIHYtaWY9XCJ0b29sYmFyU3BhY2VyXCJcbiAgICAgICAgY2xhc3M9XCJtZGMtZHJhd2VyX190b29sYmFyLXNwYWNlclwiLz5cbiAgICAgIDxzbG90IC8+XG4gICAgPC9uYXY+XG4gIDwvYXNpZGU+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ1RlbXBvcmFyeURyYXdlckZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2RyYXdlci90ZW1wb3JhcnkvZm91bmRhdGlvbidcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnQG1hdGVyaWFsL2RyYXdlci91dGlsJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtdGVtcG9yYXJ5LWRyYXdlcicsXG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ29wZW4nLFxuICAgIGV2ZW50OiAnY2hhbmdlJ1xuICB9LFxuICBwcm9wczoge1xuICAgIG9wZW46IEJvb2xlYW4sXG4gICAgJ3Rvb2xiYXItc3BhY2VyJzogQm9vbGVhblxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7fVxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBvcGVuOiAnX3JlZnJlc2gnXG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgRk9DVVNBQkxFX0VMRU1FTlRTLFxuICAgICAgT1BBQ0lUWV9WQVJfTkFNRVxuICAgIH0gPSBNRENUZW1wb3JhcnlEcmF3ZXJGb3VuZGF0aW9uLnN0cmluZ3NcblxuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENUZW1wb3JhcnlEcmF3ZXJGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICB9LFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSlcbiAgICAgIH0sXG4gICAgICBoYXNDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgYWRkQm9keUNsYXNzOiBjbGFzc05hbWUgPT4gZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSksXG4gICAgICByZW1vdmVCb2R5Q2xhc3M6IGNsYXNzTmFtZSA9PiBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKSxcbiAgICAgIGV2ZW50VGFyZ2V0SGFzQ2xhc3M6ICh0YXJnZXQsIGNsYXNzTmFtZSkgPT5cbiAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpLFxuICAgICAgaGFzTmVjZXNzYXJ5RG9tOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuJHJlZnMuZHJhd2VyXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICB1dGlsLnJlbWFwRXZlbnQoZXZ0KSxcbiAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgIHV0aWwuYXBwbHlQYXNzaXZlKClcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICB1dGlsLnJlbWFwRXZlbnQoZXZ0KSxcbiAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgIHV0aWwuYXBwbHlQYXNzaXZlKClcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgdXRpbC5yZW1hcEV2ZW50KGV2dCksXG4gICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICB1dGlsLmFwcGx5UGFzc2l2ZSgpXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgdXRpbC5yZW1hcEV2ZW50KGV2dCksXG4gICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICB1dGlsLmFwcGx5UGFzc2l2ZSgpXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICByZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5kcmF3ZXIuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5kcmF3ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBnZXREcmF3ZXJXaWR0aDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5kcmF3ZXIub2Zmc2V0V2lkdGhcbiAgICAgIH0sXG4gICAgICBzZXRUcmFuc2xhdGVYOiB2YWx1ZSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgIHV0aWwuZ2V0VHJhbnNmb3JtUHJvcGVydHlOYW1lKCksXG4gICAgICAgICAgdmFsdWUgPT09IG51bGwgPyBudWxsIDogYHRyYW5zbGF0ZVgoJHt2YWx1ZX1weClgXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICB1cGRhdGVDc3NWYXJpYWJsZTogdmFsdWUgPT4ge1xuICAgICAgICBpZiAodXRpbC5zdXBwb3J0c0Nzc0N1c3RvbVByb3BlcnRpZXMoKSkge1xuICAgICAgICAgIHRoaXMuJGVsLnN0eWxlLnNldFByb3BlcnR5KE9QQUNJVFlfVkFSX05BTUUsIHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2V0Rm9jdXNhYmxlRWxlbWVudHM6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMuZHJhd2VyLnF1ZXJ5U2VsZWN0b3JBbGwoRk9DVVNBQkxFX0VMRU1FTlRTKVxuICAgICAgfSxcbiAgICAgIHNhdmVFbGVtZW50VGFiU3RhdGU6IGVsID0+IHtcbiAgICAgICAgdXRpbC5zYXZlRWxlbWVudFRhYlN0YXRlKGVsKVxuICAgICAgfSxcbiAgICAgIHJlc3RvcmVFbGVtZW50VGFiU3RhdGU6IGVsID0+IHtcbiAgICAgICAgdXRpbC5yZXN0b3JlRWxlbWVudFRhYlN0YXRlKGVsKVxuICAgICAgfSxcbiAgICAgIG1ha2VFbGVtZW50VW50YWJiYWJsZTogZWwgPT4ge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgLTEpXG4gICAgICB9LFxuICAgICAgbm90aWZ5T3BlbjogKCkgPT4ge1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCB0cnVlKVxuICAgICAgICB0aGlzLiRlbWl0KCdvcGVuJylcbiAgICAgIH0sXG4gICAgICBub3RpZnlDbG9zZTogKCkgPT4ge1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBmYWxzZSlcbiAgICAgICAgdGhpcy4kZW1pdCgnY2xvc2UnKVxuICAgICAgfSxcbiAgICAgIGlzUnRsOiAoKSA9PiB7XG4gICAgICAgIC8qIGdsb2JhbCBnZXRDb21wdXRlZFN0eWxlICovXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRlbCkuZ2V0UHJvcGVydHlWYWx1ZSgnZGlyZWN0aW9uJykgPT09ICdydGwnXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBpc0RyYXdlcjogZWwgPT4gZWwgPT09IHRoaXMuJHJlZnMuZHJhd2VyXG4gICAgfSlcbiAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICAgIHRoaXMuX3JlZnJlc2goKVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbnVsbFxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgX3JlZnJlc2goKSB7XG4gICAgICBpZiAodGhpcy5vcGVuKSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24ub3BlbigpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLmNsb3NlKClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8Y29tcG9uZW50XG4gICAgcmVmPVwiZHJhd2VyXCJcbiAgICA6aXM9XCJ0eXBlXCJcbiAgICB2LW1vZGVsPVwib3Blbl9cIlxuICAgIDp0b29sYmFyLXNwYWNlcj1cInRvb2xiYXJTcGFjZXJcIlxuICAgIGNsYXNzPVwibWRjLWRyYXdlclwiXG4gICAgQGNoYW5nZT1cIm9uQ2hhbmdlXCJcbiAgICBAb3Blbj1cIiRlbWl0KCdvcGVuJylcIlxuICAgIEBjbG9zZT1cIiRlbWl0KCdjbG9zZScpXCIgPlxuICAgIDxzbG90IC8+XG4gIDwvY29tcG9uZW50PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBtZGNQZXJtYW5lbnREcmF3ZXIgZnJvbSAnLi9tZGMtcGVybWFuZW50LWRyYXdlci52dWUnXG5pbXBvcnQgbWRjUGVyc2lzdGVudERyYXdlciBmcm9tICcuL21kYy1wZXJzaXN0ZW50LWRyYXdlci52dWUnXG5pbXBvcnQgbWRjVGVtcG9yYXJ5RHJhd2VyIGZyb20gJy4vbWRjLXRlbXBvcmFyeS1kcmF3ZXIudnVlJ1xuXG5jb25zdCBtZWRpYSA9IG5ldyBjbGFzcyB7XG4gIGdldCBzbWFsbCgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5fc21hbGwgfHwgKHRoaXMuX3NtYWxsID0gd2luZG93Lm1hdGNoTWVkaWEoJyhtYXgtd2lkdGg6IDgzOXB4KScpKVxuICAgIClcbiAgfVxuXG4gIGdldCBsYXJnZSgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5fbGFyZ2UgfHwgKHRoaXMuX2xhcmdlID0gd2luZG93Lm1hdGNoTWVkaWEoJyhtaW4td2lkdGg6IDEyMDBweCknKSlcbiAgICApXG4gIH1cbn0oKVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtZHJhd2VyJyxcbiAgY29tcG9uZW50czoge1xuICAgICdtZGMtcGVybWFuZW50LWRyYXdlcic6IG1kY1Blcm1hbmVudERyYXdlcixcbiAgICAnbWRjLXBlcnNpc3RlbnQtZHJhd2VyJzogbWRjUGVyc2lzdGVudERyYXdlcixcbiAgICAnbWRjLXRlbXBvcmFyeS1kcmF3ZXInOiBtZGNUZW1wb3JhcnlEcmF3ZXJcbiAgfSxcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAnb3BlbicsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgb3BlbjogQm9vbGVhbixcbiAgICBwZXJtYW5lbnQ6IEJvb2xlYW4sXG4gICAgcGVyc2lzdGVudDogQm9vbGVhbixcbiAgICB0ZW1wb3Jhcnk6IEJvb2xlYW4sXG4gICAgZHJhd2VyVHlwZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgdmFsaWRhdG9yOiB2YWwgPT4ge1xuICAgICAgICByZXR1cm4gdmFsIGluIFsndGVtcG9yYXJ5JywgJ3BlcnNpc3RlbnQnLCAncGVybWFuZW50J11cbiAgICAgIH1cbiAgICB9LFxuICAgIHRvb2xiYXJTcGFjZXI6IEJvb2xlYW4sXG4gICAgdG9nZ2xlT246IFN0cmluZyxcbiAgICB0b2dnbGVPblNvdXJjZTogeyB0eXBlOiBPYmplY3QsIHJlcXVpcmVkOiBmYWxzZSB9LFxuICAgIG9wZW5PbjogU3RyaW5nLFxuICAgIG9wZW5PblNvdXJjZTogeyB0eXBlOiBPYmplY3QsIHJlcXVpcmVkOiBmYWxzZSB9LFxuICAgIGNsb3NlT246IFN0cmluZyxcbiAgICBjbG9zZU9uU291cmNlOiB7IHR5cGU6IE9iamVjdCwgcmVxdWlyZWQ6IGZhbHNlIH1cbiAgfSxcbiAgcHJvdmlkZSgpIHtcbiAgICByZXR1cm4geyBtZGNEcmF3ZXI6IHRoaXMgfVxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzbWFsbDogZmFsc2UsXG4gICAgICBsYXJnZTogZmFsc2UsXG4gICAgICBvcGVuXzogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgdHlwZSgpIHtcbiAgICAgIGlmICh0aGlzLnBlcm1hbmVudCkge1xuICAgICAgICByZXR1cm4gJ21kYy1wZXJtYW5lbnQtZHJhd2VyJ1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnBlcnNpc3RlbnQpIHtcbiAgICAgICAgcmV0dXJuICdtZGMtcGVyc2lzdGVudC1kcmF3ZXInXG4gICAgICB9IGVsc2UgaWYgKHRoaXMudGVtcG9yYXJ5KSB7XG4gICAgICAgIHJldHVybiAnbWRjLXRlbXBvcmFyeS1kcmF3ZXInXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuZHJhd2VyVHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3Blcm1hbmVudCc6XG4gICAgICAgICAgICByZXR1cm4gJ21kYy1wZXJtYW5lbnQtZHJhd2VyJ1xuICAgICAgICAgIGNhc2UgJ3BlcnNpc3RlbnQnOlxuICAgICAgICAgICAgcmV0dXJuICdtZGMtcGVyc2lzdGVudC1kcmF3ZXInXG4gICAgICAgICAgY2FzZSAndGVtcG9yYXJ5JzpcbiAgICAgICAgICAgIHJldHVybiAnbWRjLXRlbXBvcmFyeS1kcmF3ZXInXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNtYWxsID8gJ21kYy10ZW1wb3JhcnktZHJhd2VyJyA6ICdtZGMtcGVyc2lzdGVudC1kcmF3ZXInXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGlzUGVybWFuZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGVybWFuZW50IHx8IHRoaXMudHlwZSA9PT0gJ21kYy1wZXJtYW5lbnQtZHJhd2VyJ1xuICAgIH0sXG4gICAgaXNQZXJzaXN0ZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVudCB8fCB0aGlzLnR5cGUgPT09ICdtZGMtcGVyc2lzdGVudC1kcmF3ZXInXG4gICAgfSxcbiAgICBpc1RlbXBvcmFyeSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRlbXBvcmFyeSB8fCB0aGlzLnR5cGUgPT09ICdtZGMtdGVtcG9yYXJ5LWRyYXdlcidcbiAgICB9LFxuICAgIGlzUmVzcG9uc2l2ZSgpIHtcbiAgICAgIHJldHVybiAhKFxuICAgICAgICB0aGlzLnBlcm1hbmVudCB8fFxuICAgICAgICB0aGlzLnBlcnNpc3RlbnQgfHxcbiAgICAgICAgdGhpcy50ZW1wb3JhcnkgfHxcbiAgICAgICAgdGhpcy5kcmF3ZXJUeXBlXG4gICAgICApXG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIG9wZW46ICdvbk9wZW5fJ1xuICB9LFxuICBjcmVhdGVkKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubWF0Y2hNZWRpYSkge1xuICAgICAgdGhpcy5zbWFsbCA9IG1lZGlhLnNtYWxsLm1hdGNoZXNcbiAgICAgIHRoaXMubGFyZ2UgPSBtZWRpYS5sYXJnZS5tYXRjaGVzXG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIGlmICh0aGlzLnRvZ2dsZU9uKSB7XG4gICAgICB0aGlzLnRvZ2dsZU9uRXZlbnRTb3VyY2UgPSB0aGlzLnRvZ2dsZU9uU291cmNlIHx8IHRoaXMuJHJvb3RcbiAgICAgIHRoaXMudG9nZ2xlT25FdmVudFNvdXJjZS4kb24odGhpcy50b2dnbGVPbiwgdGhpcy50b2dnbGUpXG4gICAgfVxuICAgIGlmICh0aGlzLm9wZW5Pbikge1xuICAgICAgdGhpcy5vcGVuT25FdmVudFNvdXJjZSA9IHRoaXMub3Blbk9uU291cmNlIHx8IHRoaXMuJHJvb3RcbiAgICAgIHRoaXMub3Blbk9uRXZlbnRTb3VyY2UuJG9uKHRoaXMub3Blbk9uLCB0aGlzLnNob3cpXG4gICAgfVxuICAgIGlmICh0aGlzLmNsb3NlT24pIHtcbiAgICAgIHRoaXMuY2xvc2VPbkV2ZW50U291cmNlID0gdGhpcy5jbG9zZU9uU291cmNlIHx8IHRoaXMuJHJvb3RcbiAgICAgIHRoaXMuY2xvc2VPbkV2ZW50U291cmNlLiRvbih0aGlzLmNsb3NlT24sIHRoaXMuY2xvc2UpXG4gICAgfVxuICAgIG1lZGlhLnNtYWxsLmFkZExpc3RlbmVyKHRoaXMucmVmcmVzaE1lZGlhKVxuICAgIG1lZGlhLmxhcmdlLmFkZExpc3RlbmVyKHRoaXMucmVmcmVzaE1lZGlhKVxuICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHRoaXMucmVmcmVzaE1lZGlhKCkpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgbWVkaWEuc21hbGwucmVtb3ZlTGlzdGVuZXIodGhpcy5yZWZyZXNoTWVkaWEpXG4gICAgbWVkaWEubGFyZ2UucmVtb3ZlTGlzdGVuZXIodGhpcy5yZWZyZXNoTWVkaWEpXG5cbiAgICBpZiAodGhpcy50b2dnbGVPbkV2ZW50U291cmNlKSB7XG4gICAgICB0aGlzLnRvZ2dsZU9uRXZlbnRTb3VyY2UuJG9mZih0aGlzLnRvZ2dsZU9uLCB0aGlzLnRvZ2dsZSlcbiAgICB9XG4gICAgaWYgKHRoaXMub3Blbk9uRXZlbnRTb3VyY2UpIHtcbiAgICAgIHRoaXMub3Blbk9uRXZlbnRTb3VyY2UuJG9mZih0aGlzLm9wZW5PbiwgdGhpcy5zaG93KVxuICAgIH1cbiAgICBpZiAodGhpcy5jbG9zZU9uRXZlbnRTb3VyY2UpIHtcbiAgICAgIHRoaXMuY2xvc2VPbkV2ZW50U291cmNlLiRvZmYodGhpcy5jbG9zZU9uLCB0aGlzLmNsb3NlKVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uT3Blbl8odmFsdWUpIHtcbiAgICAgIHRoaXMuaXNQZXJtYW5lbnQgfHwgKHRoaXMub3Blbl8gPSB2YWx1ZSlcbiAgICB9LFxuICAgIG9uQ2hhbmdlKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBldmVudClcbiAgICAgIHRoaXMuJHJvb3QuJGVtaXQoJ3ZtYTpsYXlvdXQnKVxuICAgIH0sXG4gICAgc2hvdygpIHtcbiAgICAgIHRoaXMub3Blbl8gPSB0cnVlXG4gICAgfSxcbiAgICBjbG9zZSgpIHtcbiAgICAgIHRoaXMuaXNQZXJtYW5lbnQgfHwgKHRoaXMub3Blbl8gPSBmYWxzZSlcbiAgICB9LFxuICAgIHRvZ2dsZSgpIHtcbiAgICAgIHRoaXMuaXNQZXJtYW5lbnQgfHwgKHRoaXMuaXNPcGVuKCkgPyB0aGlzLmNsb3NlKCkgOiB0aGlzLnNob3coKSlcbiAgICB9LFxuICAgIGlzT3BlbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzUGVybWFuZW50IHx8IHRoaXMub3Blbl9cbiAgICB9LFxuICAgIHJlZnJlc2hNZWRpYSgpIHtcbiAgICAgIHRoaXMuc21hbGwgPSBtZWRpYS5zbWFsbC5tYXRjaGVzXG4gICAgICB0aGlzLmxhcmdlID0gbWVkaWEubGFyZ2UubWF0Y2hlc1xuICAgICAgaWYgKHRoaXMuaXNSZXNwb25zaXZlKSB7XG4gICAgICAgIGlmICh0aGlzLmxhcmdlKSB7XG4gICAgICAgICAgdGhpcy5zaG93KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNsb3NlKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJtZGMtZHJhd2VyLWxheW91dFwiPlxuICAgIDxzbG90IC8+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1kcmF3ZXItbGF5b3V0J1xufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxoZWFkZXIgXG4gICAgdi1pZj1cInNob3dcIiBcbiAgICBjbGFzcz1cIm1kYy1kcmF3ZXItaGVhZGVyIG1kYy1kcmF3ZXJfX2hlYWRlclwiPlxuICAgIDxkaXYgY2xhc3M9XCJtZGMtZHJhd2VyX19oZWFkZXItY29udGVudFwiPlxuICAgICAgPHNsb3QgLz5cbiAgICA8L2Rpdj5cbiAgPC9oZWFkZXI+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWRyYXdlci1oZWFkZXInLFxuICBwcm9wczoge1xuICAgIHBlcm1hbmVudDogQm9vbGVhbixcbiAgICBwZXJzaXN0ZW50OiBCb29sZWFuLFxuICAgIHRlbXBvcmFyeTogQm9vbGVhblxuICB9LFxuICBpbmplY3Q6IFsnbWRjRHJhd2VyJ10sXG4gIGNvbXB1dGVkOiB7XG4gICAgc2hvdygpIHtcbiAgICAgIGlmICh0aGlzLnRlbXBvcmFyeSB8fCB0aGlzLnBlcnNpc3RlbnQgfHwgdGhpcy5wZXJtYW5lbnQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAodGhpcy50ZW1wb3JhcnkgJiYgdGhpcy5tZGNEcmF3ZXIuaXNUZW1wb3JhcnkpIHx8XG4gICAgICAgICAgKHRoaXMucGVyc2lzdGVudCAmJiB0aGlzLm1kY0RyYXdlci5pc1BlcnNpc3RlbnQpIHx8XG4gICAgICAgICAgKHRoaXMucGVybWFuZW50ICYmIHRoaXMubWRjRHJhd2VyLmlzUGVybWFuZW50KVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxuYXYgXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIFxuICAgIGNsYXNzPVwibWRjLWRyYXdlci1saXN0IG1kYy1saXN0XCI+XG4gICAgPHNsb3QvPlxuICA8L25hdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtZHJhd2VyLWxpc3QnLFxuICBwcm9wczoge1xuICAgIGRlbnNlOiBCb29sZWFuXG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1saXN0LS1kZW5zZSc6IHRoaXMuZGVuc2VcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8Y3VzdG9tLWxpbmtcbiAgICA6bGluaz1cImxpbmtcIlxuICAgIDpjbGFzcz1cIltjbGFzc2VzLCBpdGVtQ2xhc3Nlc11cIlxuICAgIDpzdHlsZT1cInN0eWxlc1wiXG4gICAgY2xhc3M9XCJtZGMtZHJhd2VyLWl0ZW0gbWRjLWxpc3QtaXRlbVwiXG4gICAgdi1vbj1cIm15bGlzdGVuZXJzXCI+XG4gICAgPHNwYW5cbiAgICAgIHYtaWY9XCJoYXNTdGFydERldGFpbFwiXG4gICAgICBjbGFzcz1cIm1kYy1saXN0LWl0ZW1fX2dyYXBoaWNcIj5cbiAgICAgIDxzbG90IG5hbWU9XCJzdGFydC1kZXRhaWxcIj5cbiAgICAgICAgPGlcbiAgICAgICAgICBjbGFzcz1cIm1hdGVyaWFsLWljb25zXCJcbiAgICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIj57eyBzdGFydEljb24gfX08L2k+XG4gICAgICA8L3Nsb3Q+XG4gICAgPC9zcGFuPlxuICAgIDxzbG90Lz5cbiAgPC9jdXN0b20tbGluaz5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBEaXNwYXRjaEV2ZW50TWl4aW4sIEN1c3RvbUxpbmtNaXhpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgeyBSaXBwbGVCYXNlIH0gZnJvbSAnLi4vcmlwcGxlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtZHJhd2VyLWl0ZW0nLFxuICBpbmplY3Q6IFsnbWRjRHJhd2VyJ10sXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbiwgQ3VzdG9tTGlua01peGluXSxcbiAgcHJvcHM6IHtcbiAgICBzdGFydEljb246IFN0cmluZyxcbiAgICB0ZW1wb3JhcnlDbG9zZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9LFxuICAgIGFjdGl2YXRlZDogQm9vbGVhbixcbiAgICBleGFjdEFjdGl2ZUNsYXNzOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnbWRjLWxpc3QtaXRlbS0tYWN0aXZhdGVkJ1xuICAgIH1cbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIG15bGlzdGVuZXJzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4udGhpcy4kbGlzdGVuZXJzLFxuICAgICAgICBjbGljazogZSA9PiB7XG4gICAgICAgICAgdGhpcy5tZGNEcmF3ZXIuaXNUZW1wb3JhcnkgJiZcbiAgICAgICAgICAgIHRoaXMudGVtcG9yYXJ5Q2xvc2UgJiZcbiAgICAgICAgICAgIHRoaXMubWRjRHJhd2VyLmNsb3NlKClcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgaXRlbUNsYXNzZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWRjLWxpc3QtaXRlbS0tYWN0aXZhdGVkJzogdGhpcy5hY3RpdmF0ZWRcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhc1N0YXJ0RGV0YWlsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhcnRJY29uIHx8IHRoaXMuJHNsb3RzWydzdGFydC1kZXRhaWwnXVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMpXG4gICAgdGhpcy5yaXBwbGUuaW5pdCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5yaXBwbGUgJiYgdGhpcy5yaXBwbGUuZGVzdHJveSgpXG4gICAgdGhpcy5yaXBwbGUgPSBudWxsXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8aHIgY2xhc3M9XCJtZGMtbGlzdC1kaXZpZGVyXCI+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWRyYXdlci1kaXZpZGVyJ1xufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNEcmF3ZXIgZnJvbSAnLi9tZGMtZHJhd2VyLnZ1ZSdcbmltcG9ydCBtZGNEcmF3ZXJMYXlvdXQgZnJvbSAnLi9tZGMtZHJhd2VyLWxheW91dC52dWUnXG5pbXBvcnQgbWRjRHJhd2VySGVhZGVyIGZyb20gJy4vbWRjLWRyYXdlci1oZWFkZXIudnVlJ1xuaW1wb3J0IG1kY0RyYXdlckxpc3QgZnJvbSAnLi9tZGMtZHJhd2VyLWxpc3QudnVlJ1xuaW1wb3J0IG1kY0RyYXdlckl0ZW0gZnJvbSAnLi9tZGMtZHJhd2VyLWl0ZW0udnVlJ1xuaW1wb3J0IG1kY0RyYXdlckRpdmlkZXIgZnJvbSAnLi9tZGMtZHJhd2VyLWRpdmlkZXIudnVlJ1xuXG5leHBvcnQge1xuICBtZGNEcmF3ZXIsXG4gIG1kY0RyYXdlckxheW91dCxcbiAgbWRjRHJhd2VySGVhZGVyLFxuICBtZGNEcmF3ZXJMaXN0LFxuICBtZGNEcmF3ZXJJdGVtLFxuICBtZGNEcmF3ZXJEaXZpZGVyXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNEcmF3ZXIsXG4gIG1kY0RyYXdlckxheW91dCxcbiAgbWRjRHJhd2VySGVhZGVyLFxuICBtZGNEcmF3ZXJMaXN0LFxuICBtZGNEcmF3ZXJJdGVtLFxuICBtZGNEcmF3ZXJEaXZpZGVyXG59KVxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2XG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiXG4gICAgY2xhc3M9XCJtZGMtZWxldmF0aW9uXCI+XG4gICAgPHNsb3QvPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtZWxldmF0aW9uJyxcbiAgcHJvcHM6IHtcbiAgICB6OiB7XG4gICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgbGV0IGVsZXZhdGlvbkNsYXNzZXMgPSB7fVxuICAgIGVsZXZhdGlvbkNsYXNzZXNbYG1kYy1lbGV2YXRpb24tLXoke3RoaXMuen1gXSA9IHRydWVcblxuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiBlbGV2YXRpb25DbGFzc2VzXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0VsZXZhdGlvbiBmcm9tICcuL21kYy1lbGV2YXRpb24udnVlJ1xuXG5leHBvcnQgeyBtZGNFbGV2YXRpb24gfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjRWxldmF0aW9uXG59KVxuIiwiPHRlbXBsYXRlPlxuICA8Y3VzdG9tLWJ1dHRvbiBcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgXG4gICAgOnN0eWxlPVwic3R5bGVzXCIgXG4gICAgOmhyZWY9XCJocmVmXCJcbiAgICA6bGluaz1cImxpbmtcIiBcbiAgICBjbGFzcz1cIm1kYy1mYWJcIiBcbiAgICB2LW9uPVwibGlzdGVuZXJzXCIgPlxuICAgIDxzcGFuIGNsYXNzPVwibWRjLWZhYl9faWNvblwiPlxuICAgICAgPHNsb3Q+e3sgaWNvbiB9fTwvc2xvdD5cbiAgICA8L3NwYW4+XG4gIDwvY3VzdG9tLWJ1dHRvbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBEaXNwYXRjaEV2ZW50TWl4aW4sIEN1c3RvbUJ1dHRvbk1peGluIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCB7IFJpcHBsZU1peGluIH0gZnJvbSAnLi4vcmlwcGxlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtZmFiJyxcbiAgbWl4aW5zOiBbRGlzcGF0Y2hFdmVudE1peGluLCBDdXN0b21CdXR0b25NaXhpbiwgUmlwcGxlTWl4aW5dLFxuICBwcm9wczoge1xuICAgIGljb246IFN0cmluZyxcbiAgICBtaW5pOiBCb29sZWFuLFxuICAgIGFic29sdXRlOiBCb29sZWFuLFxuICAgIGZpeGVkOiBCb29sZWFuXG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21hdGVyaWFsLWljb25zJzogdGhpcy5pY29uLFxuICAgICAgICAnbWRjLWZhYi0tbWluaSc6IHRoaXMubWluaSxcbiAgICAgICAgJ21kYy1mYWItLWFic29sdXRlJzogdGhpcy5hYnNvbHV0ZSxcbiAgICAgICAgJ21kYy1mYWItLWZpeGVkJzogdGhpcy5maXhlZFxuICAgICAgfSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgaWNvbigpIHtcbiAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsICdtYXRlcmlhbC1pY29ucycsIHRoaXMuaWNvbilcbiAgICB9LFxuICAgIG1pbmkoKSB7XG4gICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCAnbWRjLWZhYi0tbWluaScsIHRoaXMubWluaSlcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjRkFCIGZyb20gJy4vbWRjLWZhYi52dWUnXG5cbmV4cG9ydCB7IG1kY0ZBQiB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNGQUJcbn0pXG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHN0cmluZ3MgPSB7XG4gIFRJTEVTX1NFTEVDVE9SOiAnLm1kYy1ncmlkLWxpc3RfX3RpbGVzJyxcbiAgVElMRV9TRUxFQ1RPUjogJy5tZGMtZ3JpZC10aWxlJyxcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge01EQ0ZvdW5kYXRpb259IGZyb20gJ0BtYXRlcmlhbC9iYXNlL2luZGV4JztcbmltcG9ydCB7c3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNRENHcmlkTGlzdEZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0T2Zmc2V0V2lkdGg6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgZ2V0TnVtYmVyT2ZUaWxlczogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBnZXRPZmZzZXRXaWR0aEZvclRpbGVBdEluZGV4OiAoLyogaW5kZXg6IG51bWJlciAqLykgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBzZXRTdHlsZUZvclRpbGVzRWxlbWVudDogKC8qIHByb3BlcnR5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgIH07XG4gIH1cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDR3JpZExpc3RGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gICAgdGhpcy5yZXNpemVIYW5kbGVyXyA9ICgpID0+IHRoaXMuYWxpZ25DZW50ZXIoKTtcbiAgICB0aGlzLnJlc2l6ZUZyYW1lXyA9IDA7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmFsaWduQ2VudGVyKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclJlc2l6ZUhhbmRsZXIodGhpcy5yZXNpemVIYW5kbGVyXyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICB9XG4gIGFsaWduQ2VudGVyKCkge1xuICAgIGlmICh0aGlzLnJlc2l6ZUZyYW1lXyAhPT0gMCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yZXNpemVGcmFtZV8pO1xuICAgIH1cbiAgICB0aGlzLnJlc2l6ZUZyYW1lXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmFsaWduQ2VudGVyXygpO1xuICAgICAgdGhpcy5yZXNpemVGcmFtZV8gPSAwO1xuICAgIH0pO1xuICB9XG4gIGFsaWduQ2VudGVyXygpIHtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5nZXROdW1iZXJPZlRpbGVzKCkgPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBncmlkV2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldE9mZnNldFdpZHRoKCk7XG4gICAgY29uc3QgaXRlbVdpZHRoID0gdGhpcy5hZGFwdGVyXy5nZXRPZmZzZXRXaWR0aEZvclRpbGVBdEluZGV4KDApO1xuICAgIGNvbnN0IHRpbGVzV2lkdGggPSBpdGVtV2lkdGggKiBNYXRoLmZsb29yKGdyaWRXaWR0aCAvIGl0ZW1XaWR0aCk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZUZvclRpbGVzRWxlbWVudCgnd2lkdGgnLCBgJHt0aWxlc1dpZHRofXB4YCk7XG4gIH1cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1ncmlkLWxpc3RcIj5cbiAgICA8dWwgXG4gICAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgXG4gICAgICA6c3R5bGU9XCJzdHlsZXNcIiBcbiAgICAgIGNsYXNzPVwibWRjLWdyaWQtbGlzdF9fdGlsZXNcIj5cbiAgICAgIDxzbG90Lz5cbiAgICA8L3VsPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDR3JpZExpc3RGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9ncmlkLWxpc3QvZm91bmRhdGlvbidcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWdyaWQtbGlzdCcsXG4gIHByb3BzOiB7XG4gICAgd2lkdGg6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgcmF0aW86IFN0cmluZyxcbiAgICAnbmFycm93LWd1dHRlcic6IEJvb2xlYW4sXG4gICAgJ2hlYWRlci1jYXB0aW9uJzogQm9vbGVhbixcbiAgICAnaWNvbi1hbGlnbi1zdGFydCc6IEJvb2xlYW4sXG4gICAgJ2ljb24tYWxpZ24tZW5kJzogQm9vbGVhbixcbiAgICAnd2l0aC1zdXBwb3J0LXRleHQnOiBCb29sZWFuLFxuICAgIGludGVyYWN0aXZlOiBCb29sZWFuXG4gIH0sXG4gIHByb3ZpZGUoKSB7XG4gICAgcmV0dXJuIHsgbWRjR3JpZDogdGhpcyB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcygpIHtcbiAgICAgIGxldCBjbGFzc2VzID0ge31cblxuICAgICAgY2xhc3Nlc1snbWRjLWdyaWQtbGlzdC0tdGlsZS1ndXR0ZXItMSddID0gdGhpcy5uYXJyb3dHdXR0ZXJcbiAgICAgIGNsYXNzZXNbJ21kYy1ncmlkLWxpc3QtLWhlYWRlci1jYXB0aW9uJ10gPSB0aGlzLmhlYWRlckNhcHRpb25cbiAgICAgIGNsYXNzZXNbYG1kYy1ncmlkLWxpc3QtLXRpbGUtYXNwZWN0LSR7dGhpcy5yYXRpb31gXSA9IHRoaXMucmF0aW9cbiAgICAgIGNsYXNzZXNbJ21kYy1ncmlkLWxpc3QtLXdpdGgtaWNvbi1hbGlnbi1zdGFydCddID0gdGhpcy5pY29uQWxpZ25TdGFydFxuICAgICAgY2xhc3Nlc1snbWRjLWdyaWQtbGlzdC0td2l0aC1pY29uLWFsaWduLWVuZCddID0gdGhpcy5pY29uQWxpZ25FbmRcbiAgICAgIGNsYXNzZXNbJ21kYy1ncmlkLWxpc3QtLXR3b2xpbmUtY2FwdGlvbiddID0gdGhpcy53aXRoU3VwcG9ydFRleHRcbiAgICAgIGNsYXNzZXNbJ21kYy1ncmlkLWxpc3QtLW5vbi1pbnRlcmFjdGl2ZSddID0gIXRoaXMuaW50ZXJhY3RpdmVcblxuICAgICAgcmV0dXJuIGNsYXNzZXNcbiAgICB9LFxuICAgIHN0eWxlcygpIHtcbiAgICAgIHZhciBkZWZhdWx0V2lkdGggPSAyMDBcbiAgICAgIHJldHVybiB7XG4gICAgICAgICctLW1kYy1ncmlkLWxpc3QtdGlsZS13aWR0aCc6IGAke3RoaXMud2lkdGggfHwgZGVmYXVsdFdpZHRofXB4YFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDR3JpZExpc3RGb3VuZGF0aW9uKHtcbiAgICAgIGdldE9mZnNldFdpZHRoOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiRlbC5vZmZzZXRXaWR0aFxuICAgICAgfSxcbiAgICAgIGdldE51bWJlck9mVGlsZXM6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgTURDR3JpZExpc3RGb3VuZGF0aW9uLnN0cmluZ3MuVElMRV9TRUxFQ1RPUlxuICAgICAgICApLmxlbmd0aFxuICAgICAgfSxcbiAgICAgIGdldE9mZnNldFdpZHRoRm9yVGlsZUF0SW5kZXg6IGluZGV4ID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgTURDR3JpZExpc3RGb3VuZGF0aW9uLnN0cmluZ3MuVElMRV9TRUxFQ1RPUlxuICAgICAgICApW2luZGV4XS5vZmZzZXRXaWR0aFxuICAgICAgfSxcbiAgICAgIHNldFN0eWxlRm9yVGlsZXNFbGVtZW50OiAocHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgTURDR3JpZExpc3RGb3VuZGF0aW9uLnN0cmluZ3MuVElMRVNfU0VMRUNUT1JcbiAgICAgICAgKS5zdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGxpIFxuICAgIDpjbGFzcz1cIltjbGFzc2VzLCBpdGVtQ2xhc3Nlc11cIlxuICAgIDpzdHlsZT1cInN0eWxlc1wiIFxuICAgIDp0YWJpbmRleD1cImlzSW50ZXJhY3RpdmUgPyAnMCcgOiB1bmRlZmluZWRcIlxuICAgIGNsYXNzPVwibWRjLWdyaWQtdGlsZVwiXG4gICAgdi1vbj1cImlzSW50ZXJhY3RpdmUgPyBsaXN0ZW5lcnMgOiBjbGlja0xpc3RlbmVyXCI+XG4gICAgPGRpdiBcbiAgICAgIHYtaWY9XCJjb3ZlclwiIFxuICAgICAgY2xhc3M9XCJtZGMtZ3JpZC10aWxlX19wcmltYXJ5XCI+XG4gICAgICA8ZGl2IFxuICAgICAgICA6c3R5bGU9XCJ7IGJhY2tncm91bmRJbWFnZTogJ3VybCgnICsgc3JjICsgJyknIH1cIlxuICAgICAgICBjbGFzcz1cIm1kYy1ncmlkLXRpbGVfX3ByaW1hcnktY29udGVudFwiLz5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IFxuICAgICAgdi1lbHNlIFxuICAgICAgY2xhc3M9XCJtZGMtZ3JpZC10aWxlX19wcmltYXJ5XCI+XG4gICAgICA8aW1nIFxuICAgICAgICA6c3JjPVwic3JjXCIgXG4gICAgICAgIGNsYXNzPVwibWRjLWdyaWQtdGlsZV9fcHJpbWFyeS1jb250ZW50XCIgPlxuICAgIDwvZGl2PlxuICAgIDxzcGFuIFxuICAgICAgdi1pZj1cInRpdGxlIHx8IHN1cHBvcnRUZXh0XCIgXG4gICAgICBjbGFzcz1cIm1kYy1ncmlkLXRpbGVfX3NlY29uZGFyeVwiPlxuICAgICAgPGkgXG4gICAgICAgIHYtaWY9XCJpY29uXCIgXG4gICAgICAgIGNsYXNzPVwibWRjLWdyaWQtdGlsZV9faWNvbiBtYXRlcmlhbC1pY29uc1wiPnt7IGljb24gfX08L2k+XG4gICAgICA8c3BhbiBcbiAgICAgICAgdi1pZj1cInRpdGxlXCIgXG4gICAgICAgIGNsYXNzPVwibWRjLWdyaWQtdGlsZV9fdGl0bGVcIj57eyB0aXRsZSB9fTwvc3Bhbj5cbiAgICAgIDxzcGFuIFxuICAgICAgICB2LWlmPVwic3VwcG9ydFRleHRcIiBcbiAgICAgICAgY2xhc3M9XCJtZGMtZ3JpZC10aWxlX19zdXBwb3J0LXRleHRcIj57eyBzdXBwb3J0VGV4dCB9fTwvc3Bhbj5cbiAgICA8L3NwYW4+XG4gIDwvbGk+XG48L3RlbXBsYXRlPlxuXG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBEaXNwYXRjaEV2ZW50TWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IHsgUmlwcGxlQmFzZSB9IGZyb20gJy4uL3JpcHBsZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWdyaWQtdGlsZScsXG4gIGluamVjdDogWydtZGNHcmlkJ10sXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbl0sXG4gIHByb3BzOiB7XG4gICAgc3JjOiBTdHJpbmcsXG4gICAgY292ZXI6IEJvb2xlYW4sXG4gICAgaWNvbjogU3RyaW5nLFxuICAgIHRpdGxlOiBTdHJpbmcsXG4gICAgJ3N1cHBvcnQtdGV4dCc6IFN0cmluZyxcbiAgICBzZWxlY3RlZDogQm9vbGVhbixcbiAgICBhY3RpdmF0ZWQ6IEJvb2xlYW5cbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGNsaWNrTGlzdGVuZXIoKSB7XG4gICAgICByZXR1cm4geyBjbGljazogZSA9PiB0aGlzLmRpc3BhdGNoRXZlbnQoZSkgfVxuICAgIH0sXG4gICAgaXRlbUNsYXNzZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWRjLWdyaWQtdGlsZS0tc2VsZWN0ZWQnOiB0aGlzLnNlbGVjdGVkLFxuICAgICAgICAnbWRjLWdyaWQtdGlsZS0tYWN0aXZhdGVkJzogdGhpcy5hY3RpdmF0ZWRcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzSW50ZXJhY3RpdmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZGNHcmlkICYmIHRoaXMubWRjR3JpZC5pbnRlcmFjdGl2ZVxuICAgIH0sXG4gICAgaGFzU3RhcnREZXRhaWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGFydEljb24gfHwgdGhpcy4kc2xvdHNbJ3N0YXJ0LWRldGFpbCddXG4gICAgfSxcbiAgICBoYXNFbmREZXRhaWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmRJY29uIHx8IHRoaXMuJHNsb3RzWydlbmQtZGV0YWlsJ11cbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgaXNJbnRlcmFjdGl2ZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYWRkUmlwcGxlKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlUmlwcGxlKClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5pc0ludGVyYWN0aXZlICYmIHRoaXMuYWRkUmlwcGxlKClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbW92ZVJpcHBsZSgpXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBhZGRSaXBwbGUoKSB7XG4gICAgICBpZiAoIXRoaXMucmlwcGxlKSB7XG4gICAgICAgIGxldCByaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzKVxuICAgICAgICByaXBwbGUuaW5pdCgpXG4gICAgICAgIHRoaXMucmlwcGxlID0gcmlwcGxlXG4gICAgICB9XG4gICAgfSxcbiAgICByZW1vdmVSaXBwbGUoKSB7XG4gICAgICBpZiAodGhpcy5yaXBwbGUpIHtcbiAgICAgICAgbGV0IHJpcHBsZSA9IHRoaXMucmlwcGxlXG4gICAgICAgIHRoaXMucmlwcGxlID0gbnVsbFxuICAgICAgICByaXBwbGUuZGVzdHJveSgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0dyaWRMaXN0IGZyb20gJy4vbWRjLWdyaWQtbGlzdC52dWUnXG5pbXBvcnQgbWRjR3JpZFRpbGUgZnJvbSAnLi9tZGMtZ3JpZC10aWxlLnZ1ZSdcblxuZXhwb3J0IHsgbWRjR3JpZExpc3QsIG1kY0dyaWRUaWxlIH1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY0dyaWRMaXN0LFxuICBtZGNHcmlkVGlsZVxufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPHNwYW4gXG4gICAgOmNsYXNzPVwieydtYXRlcmlhbC1pY29ucyc6ISFpY29ufVwiIFxuICAgIGNsYXNzPVwibWRjLWljb24gbWRjLWljb24tLW1hdGVyaWFsXCI+XG4gICAgPHNsb3Q+e3sgaWNvbiB9fTwvc2xvdD5cbiAgPC9zcGFuPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1pY29uJyxcbiAgcHJvcHM6IHtcbiAgICBpY29uOiBTdHJpbmdcbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcclxuaW1wb3J0IG1kY0ljb24gZnJvbSAnLi9tZGMtaWNvbi52dWUnXHJcblxyXG5leHBvcnQgeyBtZGNJY29uIH1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xyXG4gIG1kY0ljb25cclxufSlcclxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBJY29uIFRvZ2dsZS4gUHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBtYW5hZ2luZ1xuICogLSBjbGFzc2VzXG4gKiAtIGRvbVxuICogLSBpbm5lciB0ZXh0XG4gKiAtIGV2ZW50IGhhbmRsZXJzXG4gKiAtIGV2ZW50IGRpc3BhdGNoXG4gKlxuICogQWRkaXRpb25hbGx5LCBwcm92aWRlcyB0eXBlIGluZm9ybWF0aW9uIGZvciB0aGUgYWRhcHRlciB0byB0aGUgQ2xvc3VyZVxuICogY29tcGlsZXIuXG4gKlxuICogSW1wbGVtZW50IHRoaXMgYWRhcHRlciBmb3IgeW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlIHRvIGRlbGVnYXRlIHVwZGF0ZXMgdG9cbiAqIHRoZSBjb21wb25lbnQgaW4geW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlLiBTZWUgYXJjaGl0ZWN0dXJlIGRvY3VtZW50YXRpb25cbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2NvZGUvYXJjaGl0ZWN0dXJlLm1kXG4gKlxuICogQHJlY29yZFxuICovXG5cbmNsYXNzIE1EQ0ljb25Ub2dnbGVBZGFwdGVyIHtcbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHshRXZlbnRMaXN0ZW5lcn0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHshRXZlbnRMaXN0ZW5lcn0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAqL1xuICBzZXRUZXh0KHRleHQpIHt9XG5cbiAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0VGFiSW5kZXgoKSB7fVxuXG4gIC8qKiBAcGFyYW0ge251bWJlcn0gdGFiSW5kZXggKi9cbiAgc2V0VGFiSW5kZXgodGFiSW5kZXgpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldEF0dHIobmFtZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRBdHRyKG5hbWUsIHZhbHVlKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAqL1xuICBybUF0dHIobmFtZSkge31cblxuICAvKiogQHBhcmFtIHshSWNvblRvZ2dsZUV2ZW50fSBldnREYXRhICovXG4gIG5vdGlmeUNoYW5nZShldnREYXRhKSB7fVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGlzT246IGJvb2xlYW4sXG4gKiB9fVxuICovXG5sZXQgSWNvblRvZ2dsZUV2ZW50O1xuXG5leHBvcnQge01EQ0ljb25Ub2dnbGVBZGFwdGVyLCBJY29uVG9nZ2xlRXZlbnR9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy1pY29uLXRvZ2dsZScsXG4gIERJU0FCTEVEOiAnbWRjLWljb24tdG9nZ2xlLS1kaXNhYmxlZCcsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIERBVEFfVE9HR0xFX09OOiAnZGF0YS10b2dnbGUtb24nLFxuICBEQVRBX1RPR0dMRV9PRkY6ICdkYXRhLXRvZ2dsZS1vZmYnLFxuICBBUklBX1BSRVNTRUQ6ICdhcmlhLXByZXNzZWQnLFxuICBBUklBX0RJU0FCTEVEOiAnYXJpYS1kaXNhYmxlZCcsXG4gIEFSSUFfTEFCRUw6ICdhcmlhLWxhYmVsJyxcbiAgQ0hBTkdFX0VWRU5UOiAnTURDSWNvblRvZ2dsZTpjaGFuZ2UnLFxufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ0ljb25Ub2dnbGVBZGFwdGVyLCBJY29uVG9nZ2xlRXZlbnR9IGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDSWNvblRvZ2dsZUFkYXB0ZXI+fVxuICovXG5jbGFzcyBNRENJY29uVG9nZ2xlRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBzZXRUZXh0OiAoLyogdGV4dDogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGdldFRhYkluZGV4OiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIHNldFRhYkluZGV4OiAoLyogdGFiSW5kZXg6IG51bWJlciAqLykgPT4ge30sXG4gICAgICBnZXRBdHRyOiAoLyogbmFtZTogc3RyaW5nICovKSA9PiAvKiBzdHJpbmcgKi8gJycsXG4gICAgICBzZXRBdHRyOiAoLyogbmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJtQXR0cjogKC8qIG5hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBub3RpZnlDaGFuZ2U6ICgvKiBldnREYXRhOiBJY29uVG9nZ2xlRXZlbnQgKi8pID0+IHt9LFxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENJY29uVG9nZ2xlRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMub25fID0gZmFsc2U7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5kaXNhYmxlZF8gPSBmYWxzZTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuc2F2ZWRUYWJJbmRleF8gPSAtMTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7P0ljb25Ub2dnbGVTdGF0ZX0gKi9cbiAgICB0aGlzLnRvZ2dsZU9uRGF0YV8gPSBudWxsO1xuXG4gICAgLyoqIEBwcml2YXRlIHs/SWNvblRvZ2dsZVN0YXRlfSAqL1xuICAgIHRoaXMudG9nZ2xlT2ZmRGF0YV8gPSBudWxsO1xuXG4gICAgdGhpcy5jbGlja0hhbmRsZXJfID0gLyoqIEBwcml2YXRlIHshRXZlbnRMaXN0ZW5lcn0gKi8gKFxuICAgICAgKCkgPT4gdGhpcy50b2dnbGVGcm9tRXZ0XygpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmlzSGFuZGxpbmdLZXlkb3duXyA9IGZhbHNlO1xuXG4gICAgdGhpcy5rZXlkb3duSGFuZGxlcl8gPSAvKiogQHByaXZhdGUgeyFFdmVudExpc3RlbmVyfSAqLyAoKC8qKiBAdHlwZSB7IUtleWJvYXJkS2V5fSAqLyBldnQpID0+IHtcbiAgICAgIGlmIChpc1NwYWNlKGV2dCkpIHtcbiAgICAgICAgdGhpcy5pc0hhbmRsaW5nS2V5ZG93bl8gPSB0cnVlO1xuICAgICAgICByZXR1cm4gZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmtleXVwSGFuZGxlcl8gPSAvKiogQHByaXZhdGUgeyFFdmVudExpc3RlbmVyfSAqLyAoKC8qKiBAdHlwZSB7IUtleWJvYXJkS2V5fSAqLyBldnQpID0+IHtcbiAgICAgIGlmIChpc1NwYWNlKGV2dCkpIHtcbiAgICAgICAgdGhpcy5pc0hhbmRsaW5nS2V5ZG93bl8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy50b2dnbGVGcm9tRXZ0XygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLnJlZnJlc2hUb2dnbGVEYXRhKCk7XG4gICAgdGhpcy5zYXZlZFRhYkluZGV4XyA9IHRoaXMuYWRhcHRlcl8uZ2V0VGFiSW5kZXgoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXl1cCcsIHRoaXMua2V5dXBIYW5kbGVyXyk7XG4gIH1cblxuICByZWZyZXNoVG9nZ2xlRGF0YSgpIHtcbiAgICBjb25zdCB7REFUQV9UT0dHTEVfT04sIERBVEFfVE9HR0xFX09GRn0gPSBNRENJY29uVG9nZ2xlRm91bmRhdGlvbi5zdHJpbmdzO1xuICAgIHRoaXMudG9nZ2xlT25EYXRhXyA9IHRoaXMucGFyc2VKc29uRGF0YUF0dHJfKERBVEFfVE9HR0xFX09OKTtcbiAgICB0aGlzLnRvZ2dsZU9mZkRhdGFfID0gdGhpcy5wYXJzZUpzb25EYXRhQXR0cl8oREFUQV9UT0dHTEVfT0ZGKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXlkb3duJywgdGhpcy5rZXlkb3duSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5dXAnLCB0aGlzLmtleXVwSGFuZGxlcl8pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHRvZ2dsZUZyb21FdnRfKCkge1xuICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgY29uc3Qge29uXzogaXNPbn0gPSB0aGlzO1xuICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2hhbmdlKC8qKiBAdHlwZSB7IUljb25Ub2dnbGVFdmVudH0gKi8gKHtpc09ufSkpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzT24oKSB7XG4gICAgcmV0dXJuIHRoaXMub25fO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbj19IGlzT24gKi9cbiAgdG9nZ2xlKGlzT24gPSAhdGhpcy5vbl8pIHtcbiAgICB0aGlzLm9uXyA9IGlzT247XG5cbiAgICBjb25zdCB7QVJJQV9MQUJFTCwgQVJJQV9QUkVTU0VEfSA9IE1EQ0ljb25Ub2dnbGVGb3VuZGF0aW9uLnN0cmluZ3M7XG5cbiAgICBpZiAodGhpcy5vbl8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cihBUklBX1BSRVNTRUQsICd0cnVlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cihBUklBX1BSRVNTRUQsICdmYWxzZScpO1xuICAgIH1cblxuICAgIGNvbnN0IHtjc3NDbGFzczogY2xhc3NUb1JlbW92ZX0gPVxuICAgICAgICB0aGlzLm9uXyA/IHRoaXMudG9nZ2xlT2ZmRGF0YV8gOiB0aGlzLnRvZ2dsZU9uRGF0YV87XG5cbiAgICBpZiAoY2xhc3NUb1JlbW92ZSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjbGFzc1RvUmVtb3ZlKTtcbiAgICB9XG5cbiAgICBjb25zdCB7Y29udGVudCwgbGFiZWwsIGNzc0NsYXNzfSA9IHRoaXMub25fID8gdGhpcy50b2dnbGVPbkRhdGFfIDogdGhpcy50b2dnbGVPZmZEYXRhXztcblxuICAgIGlmIChjc3NDbGFzcykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjb250ZW50KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldFRleHQoY29udGVudCk7XG4gICAgfVxuICAgIGlmIChsYWJlbCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKEFSSUFfTEFCRUwsIGxhYmVsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFBdHRyXG4gICAqIEByZXR1cm4geyFJY29uVG9nZ2xlU3RhdGV9XG4gICAqL1xuICBwYXJzZUpzb25EYXRhQXR0cl8oZGF0YUF0dHIpIHtcbiAgICBjb25zdCB2YWwgPSB0aGlzLmFkYXB0ZXJfLmdldEF0dHIoZGF0YUF0dHIpO1xuICAgIGlmICghdmFsKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiAvKiogQHR5cGUgeyFJY29uVG9nZ2xlU3RhdGV9ICovIChKU09OLnBhcnNlKHZhbCkpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzYWJsZWRfO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gaXNEaXNhYmxlZCAqL1xuICBzZXREaXNhYmxlZChpc0Rpc2FibGVkKSB7XG4gICAgdGhpcy5kaXNhYmxlZF8gPSBpc0Rpc2FibGVkO1xuXG4gICAgY29uc3Qge0RJU0FCTEVEfSA9IE1EQ0ljb25Ub2dnbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgY29uc3Qge0FSSUFfRElTQUJMRUR9ID0gTURDSWNvblRvZ2dsZUZvdW5kYXRpb24uc3RyaW5ncztcblxuICAgIGlmICh0aGlzLmRpc2FibGVkXykge1xuICAgICAgdGhpcy5zYXZlZFRhYkluZGV4XyA9IHRoaXMuYWRhcHRlcl8uZ2V0VGFiSW5kZXgoKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0VGFiSW5kZXgoLTEpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKEFSSUFfRElTQUJMRUQsICd0cnVlJyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKERJU0FCTEVEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRUYWJJbmRleCh0aGlzLnNhdmVkVGFiSW5kZXhfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucm1BdHRyKEFSSUFfRElTQUJMRUQpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhESVNBQkxFRCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzS2V5Ym9hcmRBY3RpdmF0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNIYW5kbGluZ0tleWRvd25fO1xuICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAga2V5OiBzdHJpbmcsXG4gKiAgIGtleUNvZGU6IG51bWJlclxuICogfX1cbiAqL1xubGV0IEtleWJvYXJkS2V5O1xuXG4vKipcbiAqIEBwYXJhbSB7IUtleWJvYXJkS2V5fSBrZXlib2FyZEtleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTcGFjZShrZXlib2FyZEtleSkge1xuICByZXR1cm4ga2V5Ym9hcmRLZXkua2V5ID09PSAnU3BhY2UnIHx8IGtleWJvYXJkS2V5LmtleUNvZGUgPT09IDMyO1xufVxuXG5cbi8qKiBAcmVjb3JkICovXG5jbGFzcyBJY29uVG9nZ2xlU3RhdGUge31cblxuLyoqXG4gKiBUaGUgYXJpYS1sYWJlbCB2YWx1ZSBvZiB0aGUgaWNvbiB0b2dnbGUsIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBhcmlhLWxhYmVsLlxuICogQGV4cG9ydCB7c3RyaW5nfHVuZGVmaW5lZH1cbiAqL1xuSWNvblRvZ2dsZVN0YXRlLnByb3RvdHlwZS5sYWJlbDtcblxuLyoqXG4gKiBUaGUgdGV4dCBmb3IgdGhlIGljb24gdG9nZ2xlLCBvciB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gdGV4dC5cbiAqIEBleHBvcnQge3N0cmluZ3x1bmRlZmluZWR9XG4gKi9cbkljb25Ub2dnbGVTdGF0ZS5wcm90b3R5cGUuY29udGVudDtcblxuLyoqXG4gKiBUaGUgQ1NTIGNsYXNzIHRvIGFkZCB0byB0aGUgaWNvbiB0b2dnbGUsIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBDU1MgY2xhc3MuXG4gKiBAZXhwb3J0IHtzdHJpbmd8dW5kZWZpbmVkfVxuICovXG5JY29uVG9nZ2xlU3RhdGUucHJvdG90eXBlLmNzc0NsYXNzO1xuXG5leHBvcnQgZGVmYXVsdCBNRENJY29uVG9nZ2xlRm91bmRhdGlvbjtcbiIsIjx0ZW1wbGF0ZT5cbiAgPHNwYW4gXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIFxuICAgIDpzdHlsZT1cInN0eWxlc1wiIFxuICAgIDp0YWJpbmRleD1cInRhYkluZGV4XCJcbiAgICA6ZGF0YS10b2dnbGUtb249XCJ0b2dnbGVPbkRhdGFcIiBcbiAgICA6ZGF0YS10b2dnbGUtb2ZmPVwidG9nZ2xlT2ZmRGF0YVwiXG4gICAgY2xhc3M9XCJtZGMtaWNvbi10b2dnbGVcIlxuICAgIHJvbGU9XCJidXR0b25cIlxuICAgIGFyaWEtcHJlc3NlZD1cImZhbHNlXCI+XG4gICAgPGkgXG4gICAgICA6Y2xhc3M9XCJpY29uQ2xhc3Nlc1wiIFxuICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCI+e3sgdGV4dCB9fTwvaT5cbiAgPC9zcGFuPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENJY29uVG9nZ2xlRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvaWNvbi10b2dnbGUvZm91bmRhdGlvbidcbmltcG9ydCB7IFJpcHBsZUJhc2UgfSBmcm9tICcuLi9yaXBwbGUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1pY29uLXRvZ2dsZScsXG4gIHByb3BzOiB7XG4gICAgdG9nZ2xlT246IFtTdHJpbmcsIE9iamVjdF0sXG4gICAgdG9nZ2xlT2ZmOiBbU3RyaW5nLCBPYmplY3RdLFxuICAgIHZhbHVlOiBCb29sZWFuLFxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgIGFjY2VudDogQm9vbGVhblxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgICdtZGMtaWNvbi10b2dnbGUtLWFjY2VudCc6IHRoaXMuYWNjZW50XG4gICAgICB9LFxuICAgICAgc3R5bGVzOiB7fSxcbiAgICAgIGljb25DbGFzc2VzOiB7fSxcbiAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgdGV4dDogJydcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgdG9nZ2xlT25EYXRhKCkge1xuICAgICAgbGV0IHRvZ2dsZSA9IHRoaXMudG9nZ2xlT25cbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRvZ2dsZSAmJlxuICAgICAgICBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICB0eXBlb2YgdG9nZ2xlID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgY29udGVudDogdG9nZ2xlLFxuICAgICAgICAgICAgICAgIGNzc0NsYXNzOiAnbWF0ZXJpYWwtaWNvbnMnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRvZ2dsZS5pY29uIHx8IHRvZ2dsZS5jb250ZW50LFxuICAgICAgICAgICAgICAgIGxhYmVsOiB0b2dnbGUubGFiZWwsXG4gICAgICAgICAgICAgICAgY3NzQ2xhc3M6IHRvZ2dsZS5pY29uID8gJ21hdGVyaWFsLWljb25zJyA6IHRvZ2dsZS5jc3NDbGFzc1xuICAgICAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIClcbiAgICB9LFxuICAgIHRvZ2dsZU9mZkRhdGEoKSB7XG4gICAgICBsZXQgdG9nZ2xlID0gdGhpcy50b2dnbGVPZmZcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRvZ2dsZSAmJlxuICAgICAgICBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICB0eXBlb2YgdG9nZ2xlID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgY29udGVudDogdG9nZ2xlLFxuICAgICAgICAgICAgICAgIGNzc0NsYXNzOiAnbWF0ZXJpYWwtaWNvbnMnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRvZ2dsZS5pY29uIHx8IHRvZ2dsZS5jb250ZW50LFxuICAgICAgICAgICAgICAgIGxhYmVsOiB0b2dnbGUubGFiZWwsXG4gICAgICAgICAgICAgICAgY3NzQ2xhc3M6IHRvZ2dsZS5pY29uID8gJ21hdGVyaWFsLWljb25zJyA6IHRvZ2dsZS5jc3NDbGFzc1xuICAgICAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIClcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgdmFsdWUodmFsdWUpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24udG9nZ2xlKHZhbHVlKVxuICAgIH0sXG4gICAgZGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uc2V0RGlzYWJsZWQoZGlzYWJsZWQpXG4gICAgfSxcbiAgICB0b2dnbGVPbkRhdGEoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLnJlZnJlc2hUb2dnbGVEYXRhKClcbiAgICB9LFxuICAgIHRvZ2dsZU9mZkRhdGEoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLnJlZnJlc2hUb2dnbGVEYXRhKClcbiAgICB9LFxuICAgIGFjY2VudCh2YWx1ZSkge1xuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21kYy1pY29uLXRvZ2dsZS0tc2Vjb25kYXJ5JywgdmFsdWUpXG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENJY29uVG9nZ2xlRm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHRoaXMuJHNldCh0aGlzLmljb25DbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRkZWxldGUodGhpcy5pY29uQ2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PlxuICAgICAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PlxuICAgICAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciksXG4gICAgICBzZXRUZXh0OiB0ZXh0ID0+IHtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dFxuICAgICAgfSxcbiAgICAgIGdldFRhYkluZGV4OiAoKSA9PiB0aGlzLnRhYkluZGV4LFxuICAgICAgc2V0VGFiSW5kZXg6IHRhYkluZGV4ID0+IHtcbiAgICAgICAgdGhpcy50YWJJbmRleCA9IHRhYkluZGV4XG4gICAgICB9LFxuICAgICAgZ2V0QXR0cjogKG5hbWUsIHZhbHVlKSA9PiB0aGlzLiRlbC5nZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpLFxuICAgICAgc2V0QXR0cjogKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSlcbiAgICAgIH0sXG4gICAgICBybUF0dHI6IG5hbWUgPT4ge1xuICAgICAgICB0aGlzLiRlbC5yZW1vdmVBdHRyaWJ1dGUobmFtZSlcbiAgICAgIH0sXG4gICAgICBub3RpZnlDaGFuZ2U6IGV2dERhdGEgPT4ge1xuICAgICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIGV2dERhdGEuaXNPbilcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgICB0aGlzLmZvdW5kYXRpb24udG9nZ2xlKHRoaXMudmFsdWUpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpXG5cbiAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMsIHtcbiAgICAgIGlzVW5ib3VuZGVkOiAoKSA9PiB0cnVlLFxuICAgICAgaXNTdXJmYWNlQWN0aXZlOiAoKSA9PiB0aGlzLmZvdW5kYXRpb24uaXNLZXlib2FyZEFjdGl2YXRlZCgpXG4gICAgfSlcbiAgICB0aGlzLnJpcHBsZS5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gICAgdGhpcy5yaXBwbGUuZGVzdHJveSgpXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjSUNvblRvZ2dsZSBmcm9tICcuL21kYy1pY29uLXRvZ2dsZS52dWUnXG5cbmV4cG9ydCB7IG1kY0lDb25Ub2dnbGUgfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjSUNvblRvZ2dsZVxufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1sYXlvdXQtYXBwXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLWxheW91dC1hcHAtLXRvb2xiYXItd3JhcHBlclwiPlxuICAgICAgPHNsb3QgbmFtZT1cInRvb2xiYXJcIiAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cIm1kYy1sYXlvdXQtYXBwLS1tYWluLWNvbnRhaW5lclwiPlxuXG4gICAgICA8ZGl2IGNsYXNzPVwibWRjLWxheW91dC1hcHAtLWRyYXdlci13cmFwcGVyXCI+XG4gICAgICAgIDxzbG90IG5hbWU9XCJkcmF3ZXJcIiAvPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtbGF5b3V0LWFwcC0tY29udGVudC13cmFwcGVyXCI+XG4gICAgICAgIDxzbG90IC8+XG4gICAgICA8L2Rpdj5cblxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGF5b3V0LWFwcCdcbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjTGF5b3V0QXBwIGZyb20gJy4vbWRjLWxheW91dC1hcHAudnVlJ1xuXG5leHBvcnQgeyBtZGNMYXlvdXRBcHAgfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjTGF5b3V0QXBwXG59KVxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IDpjbGFzcz1cImNsYXNzZXNcIj5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLWxheW91dC1ncmlkX19pbm5lclwiPlxuICAgICAgPHNsb3QvPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGF5b3V0LWdyaWQnLFxuICBwcm9wczoge1xuICAgICdmaXhlZC1jb2x1bW4td2lkdGgnOiBCb29sZWFuLFxuICAgICdhbGlnbi1sZWZ0JzogQm9vbGVhbixcbiAgICAnYWxpZ24tcmlnaHQnOiBCb29sZWFuXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdtZGMtbGF5b3V0LWdyaWQnOiB0cnVlLFxuICAgICAgICAnbWRjLWxheW91dC1ncmlkLS1maXhlZC1jb2x1bW4td2lkdGgnOiB0aGlzLmZpeGVkQ29sdW1uV2lkdGgsXG4gICAgICAgICdtZGMtbGF5b3V0LWdyaWQtLWFsaWduLWxlZnQnOiB0aGlzLmFsaWduTGVmdCxcbiAgICAgICAgJ21kYy1sYXlvdXQtZ3JpZC0tYWxpZ24tcmlnaHQnOiB0aGlzLmFsaWduUmlnaHRcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IFxuICAgIDpjbGFzcz1cImNsYXNzZXNcIiBcbiAgICBjbGFzcz1cIm1kYy1sYXlvdXQtY2VsbCBtZGMtbGF5b3V0LWdyaWRfX2NlbGxcIj5cbiAgICA8c2xvdC8+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmNvbnN0IHNwYW5PcHRpb25zID0ge1xuICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdLFxuICBkZWZhdWx0OiBudWxsLFxuICB2YWxpZGF0b3I6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIG51bSA9IE51bWJlcih2YWx1ZSlcbiAgICByZXR1cm4gaXNGaW5pdGUobnVtKSAmJiBudW0gPD0gMTIgJiYgbnVtID4gMFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1sYXlvdXQtY2VsbCcsXG4gIHByb3BzOiB7XG4gICAgc3Bhbjogc3Bhbk9wdGlvbnMsXG4gICAgb3JkZXI6IHNwYW5PcHRpb25zLFxuICAgIHBob25lOiBzcGFuT3B0aW9ucyxcbiAgICB0YWJsZXQ6IHNwYW5PcHRpb25zLFxuICAgIGRlc2t0b3A6IHNwYW5PcHRpb25zLFxuICAgIGFsaWduOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBbJ3RvcCcsICdib3R0b20nLCAnbWlkZGxlJ10uaW5kZXhPZih2YWx1ZSkgIT09IC0xXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMoKSB7XG4gICAgICBsZXQgY2xhc3NlcyA9IFtdXG5cbiAgICAgIGlmICh0aGlzLnNwYW4pIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKGBtZGMtbGF5b3V0LWdyaWRfX2NlbGwtLXNwYW4tJHt0aGlzLnNwYW59YClcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3JkZXIpIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKGBtZGMtbGF5b3V0LWdyaWRfX2NlbGwtLW9yZGVyLSR7dGhpcy5vcmRlcn1gKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5waG9uZSkge1xuICAgICAgICBjbGFzc2VzLnB1c2goYG1kYy1sYXlvdXQtZ3JpZF9fY2VsbC0tc3Bhbi0ke3RoaXMucGhvbmV9LXBob25lYClcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudGFibGV0KSB7XG4gICAgICAgIGNsYXNzZXMucHVzaChgbWRjLWxheW91dC1ncmlkX19jZWxsLS1zcGFuLSR7dGhpcy50YWJsZXR9LXRhYmxldGApXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRlc2t0b3ApIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKGBtZGMtbGF5b3V0LWdyaWRfX2NlbGwtLXNwYW4tJHt0aGlzLmRlc2t0b3B9LWRlc2t0b3BgKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5hbGlnbikge1xuICAgICAgICBjbGFzc2VzLnB1c2goYG1kYy1sYXlvdXQtZ3JpZF9fY2VsbC0tYWxpZ24tJHt0aGlzLmFsaWdufWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbGFzc2VzXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1sYXlvdXQtaW5uZXItZ3JpZCBtZGMtbGF5b3V0LWdyaWRfX2lubmVyXCI+XG4gICAgPHNsb3QvPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGF5b3V0LWlubmVyLWdyaWQnXG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0xheW91dEdyaWQgZnJvbSAnLi9tZGMtbGF5b3V0LWdyaWQudnVlJ1xuaW1wb3J0IG1kY0xheW91dENlbGwgZnJvbSAnLi9tZGMtbGF5b3V0LWNlbGwudnVlJ1xuaW1wb3J0IG1kY0xheW91dElubmVyR3JpZCBmcm9tICcuL21kYy1sYXlvdXQtaW5uZXItZ3JpZC52dWUnXG5cbmV4cG9ydCB7IG1kY0xheW91dEdyaWQsIG1kY0xheW91dENlbGwsIG1kY0xheW91dElubmVyR3JpZCB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNMYXlvdXRHcmlkLFxuICBtZGNMYXlvdXRDZWxsLFxuICBtZGNMYXlvdXRJbm5lckdyaWRcbn0pXG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgQ0xPU0VEX0NMQVNTOiAnbWRjLWxpbmVhci1wcm9ncmVzcy0tY2xvc2VkJyxcbiAgSU5ERVRFUk1JTkFURV9DTEFTUzogJ21kYy1saW5lYXItcHJvZ3Jlc3MtLWluZGV0ZXJtaW5hdGUnLFxuICBSRVZFUlNFRF9DTEFTUzogJ21kYy1saW5lYXItcHJvZ3Jlc3MtLXJldmVyc2VkJyxcbn07XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBQUklNQVJZX0JBUl9TRUxFQ1RPUjogJy5tZGMtbGluZWFyLXByb2dyZXNzX19wcmltYXJ5LWJhcicsXG4gIEJVRkZFUl9TRUxFQ1RPUjogJy5tZGMtbGluZWFyLXByb2dyZXNzX19idWZmZXInLFxufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7TURDRm91bmRhdGlvbn0gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvaW5kZXgnO1xuaW1wb3J0IHt0cmFuc2Zvcm1TdHlsZVByb3BlcnRpZXN9IGZyb20gJ0BtYXRlcmlhbC9hbmltYXRpb24vaW5kZXgnO1xuXG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURDTGluZWFyUHJvZ3Jlc3NGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZ2V0UHJpbWFyeUJhcjogKCkgPT4gLyogZWw6IEVsZW1lbnQgKi8ge30sXG4gICAgICBnZXRCdWZmZXI6ICgpID0+IC8qIGVsOiBFbGVtZW50ICovIHt9LFxuICAgICAgaGFzQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4gZmFsc2UsXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldFN0eWxlOiAoLyogZWw6IEVsZW1lbnQsIHN0eWxlUHJvcGVydHk6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0xpbmVhclByb2dyZXNzRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmRldGVybWluYXRlXyA9ICF0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuSU5ERVRFUk1JTkFURV9DTEFTUyk7XG4gICAgdGhpcy5yZXZlcnNlXyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5SRVZFUlNFRF9DTEFTUyk7XG4gICAgdGhpcy5wcm9ncmVzc18gPSAwO1xuICB9XG5cbiAgc2V0RGV0ZXJtaW5hdGUoaXNEZXRlcm1pbmF0ZSkge1xuICAgIHRoaXMuZGV0ZXJtaW5hdGVfID0gaXNEZXRlcm1pbmF0ZTtcbiAgICBpZiAodGhpcy5kZXRlcm1pbmF0ZV8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5JTkRFVEVSTUlOQVRFX0NMQVNTKTtcbiAgICAgIHRoaXMuc2V0U2NhbGVfKHRoaXMuYWRhcHRlcl8uZ2V0UHJpbWFyeUJhcigpLCB0aGlzLnByb2dyZXNzXyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5JTkRFVEVSTUlOQVRFX0NMQVNTKTtcbiAgICAgIHRoaXMuc2V0U2NhbGVfKHRoaXMuYWRhcHRlcl8uZ2V0UHJpbWFyeUJhcigpLCAxKTtcbiAgICAgIHRoaXMuc2V0U2NhbGVfKHRoaXMuYWRhcHRlcl8uZ2V0QnVmZmVyKCksIDEpO1xuICAgIH1cbiAgfVxuXG4gIHNldFByb2dyZXNzKHZhbHVlKSB7XG4gICAgdGhpcy5wcm9ncmVzc18gPSB2YWx1ZTtcbiAgICBpZiAodGhpcy5kZXRlcm1pbmF0ZV8pIHtcbiAgICAgIHRoaXMuc2V0U2NhbGVfKHRoaXMuYWRhcHRlcl8uZ2V0UHJpbWFyeUJhcigpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgc2V0QnVmZmVyKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZGV0ZXJtaW5hdGVfKSB7XG4gICAgICB0aGlzLnNldFNjYWxlXyh0aGlzLmFkYXB0ZXJfLmdldEJ1ZmZlcigpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgc2V0UmV2ZXJzZShpc1JldmVyc2VkKSB7XG4gICAgdGhpcy5yZXZlcnNlXyA9IGlzUmV2ZXJzZWQ7XG4gICAgaWYgKHRoaXMucmV2ZXJzZV8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5SRVZFUlNFRF9DTEFTUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5SRVZFUlNFRF9DTEFTUyk7XG4gICAgfVxuICB9XG5cbiAgb3BlbigpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuQ0xPU0VEX0NMQVNTKTtcbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5DTE9TRURfQ0xBU1MpO1xuICB9XG5cbiAgc2V0U2NhbGVfKGVsLCBzY2FsZVZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWUgPSAnc2NhbGVYKCcgKyBzY2FsZVZhbHVlICsgJyknO1xuICAgIHRyYW5zZm9ybVN0eWxlUHJvcGVydGllcy5mb3JFYWNoKCh0cmFuc2Zvcm1TdHlsZVByb3BlcnR5KSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlKGVsLCB0cmFuc2Zvcm1TdHlsZVByb3BlcnR5LCB2YWx1ZSk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgXG4gICAgOnN0eWxlPVwic3R5bGVzXCIgXG4gICAgcm9sZT1cInByb2dyZXNzYmFyXCIgXG4gICAgY2xhc3M9XCJtZGMtbGluZWFyLXByb2dyZXNzXCI+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1saW5lYXItcHJvZ3Jlc3NfX2J1ZmZlcmluZy1kb3RzXCIvPlxuICAgIDxkaXYgXG4gICAgICByZWY9XCJidWZmZXJcIiBcbiAgICAgIGNsYXNzPVwibWRjLWxpbmVhci1wcm9ncmVzc19fYnVmZmVyXCIvPlxuICAgIDxkaXYgXG4gICAgICByZWY9XCJwcmltYXJ5XCIgXG4gICAgICBjbGFzcz1cIm1kYy1saW5lYXItcHJvZ3Jlc3NfX2JhciBtZGMtbGluZWFyLXByb2dyZXNzX19wcmltYXJ5LWJhclwiPlxuICAgICAgPHNwYW4gY2xhc3M9XCJtZGMtbGluZWFyLXByb2dyZXNzX19iYXItaW5uZXJcIi8+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1saW5lYXItcHJvZ3Jlc3NfX2JhciBtZGMtbGluZWFyLXByb2dyZXNzX19zZWNvbmRhcnktYmFyXCI+XG4gICAgICA8c3BhbiBjbGFzcz1cIm1kYy1saW5lYXItcHJvZ3Jlc3NfX2Jhci1pbm5lclwiLz5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+ICBcbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDTGluZWFyUHJvZ3Jlc3NGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9saW5lYXItcHJvZ3Jlc3MvZm91bmRhdGlvbidcblxuY29uc3QgUHJvZ3Jlc3NQcm9wVHlwZSA9IHtcbiAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIE51bWJlcih2YWx1ZSkgPj0gMCAmJiBOdW1iZXIodmFsdWUpIDw9IDFcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGluZWFyLXByb2dyZXNzJyxcbiAgcHJvcHM6IHtcbiAgICBvcGVuOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IHRydWUgfSxcbiAgICBpbmRldGVybWluYXRlOiBCb29sZWFuLFxuICAgIHJldmVyc2U6IEJvb2xlYW4sXG4gICAgYWNjZW50OiBCb29sZWFuLFxuICAgIHByb2dyZXNzOiBQcm9ncmVzc1Byb3BUeXBlLFxuICAgIGJ1ZmZlcjogUHJvZ3Jlc3NQcm9wVHlwZVxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7ICdtZGMtbGluZWFyLXByb2dyZXNzLS1hY2NlbnQnOiB0aGlzLmFjY2VudCB9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBvcGVuKCkge1xuICAgICAgaWYgKHRoaXMub3Blbikge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24ub3BlbigpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24uY2xvc2UoKVxuICAgICAgfVxuICAgIH0sXG4gICAgcHJvZ3Jlc3MoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0UHJvZ3Jlc3MoTnVtYmVyKHRoaXMucHJvZ3Jlc3MpKVxuICAgIH0sXG4gICAgYnVmZmVyKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldEJ1ZmZlcihOdW1iZXIodGhpcy5idWZmZXIpKVxuICAgIH0sXG4gICAgaW5kZXRlcm1pbmF0ZSgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXREZXRlcm1pbmF0ZSghdGhpcy5pbmRldGVybWluYXRlKVxuICAgIH0sXG4gICAgcmV2ZXJzZSgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRSZXZlcnNlKHRoaXMucmV2ZXJzZSlcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ0xpbmVhclByb2dyZXNzRm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgfSxcbiAgICAgIGdldFByaW1hcnlCYXI6ICgpID0+IC8qIGVsOiBFbGVtZW50ICovIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMucHJpbWFyeVxuICAgICAgfSxcbiAgICAgIGdldEJ1ZmZlcjogKCkgPT4gLyogZWw6IEVsZW1lbnQgKi8ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5idWZmZXJcbiAgICAgIH0sXG4gICAgICBoYXNDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSlcbiAgICAgIH0sXG4gICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIHNldFN0eWxlOiAoZWwsIHN0eWxlUHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgICAgIGVsLnN0eWxlW3N0eWxlUHJvcGVydHldID0gdmFsdWVcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcblxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXRSZXZlcnNlKHRoaXMucmV2ZXJzZSlcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0UHJvZ3Jlc3MoTnVtYmVyKHRoaXMucHJvZ3Jlc3MpKVxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXRCdWZmZXIoTnVtYmVyKHRoaXMuYnVmZmVyKSlcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0RGV0ZXJtaW5hdGUoIXRoaXMuaW5kZXRlcm1pbmF0ZSlcbiAgICBpZiAodGhpcy5vcGVuKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24ub3BlbigpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5jbG9zZSgpXG4gICAgfVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNMaW5lYXJQcm9ncmVzcyBmcm9tICcuL21kYy1saW5lYXItcHJvZ3Jlc3MudnVlJ1xuXG5leHBvcnQgeyBtZGNMaW5lYXJQcm9ncmVzcyB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNMaW5lYXJQcm9ncmVzc1xufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPHVsIFxuICAgIDpjbGFzcz1cImNsYXNzZXNcIiBcbiAgICBjbGFzcz1cIm1kYy1saXN0XCI+XG4gICAgPHNsb3QvPlxuICA8L3VsPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1saXN0JyxcbiAgcHJvcHM6IHtcbiAgICBkZW5zZTogQm9vbGVhbixcbiAgICBhdmF0YXJMaXN0OiBCb29sZWFuLFxuICAgIHR3b0xpbmU6IEJvb2xlYW4sXG4gICAgYm9yZGVyZWQ6IEJvb2xlYW4sXG4gICAgaW50ZXJhY3RpdmU6IEJvb2xlYW5cbiAgfSxcbiAgcHJvdmlkZSgpIHtcbiAgICByZXR1cm4geyBtZGNMaXN0OiB0aGlzIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21kYy1saXN0LS1kZW5zZSc6IHRoaXMuZGVuc2UsXG4gICAgICAgICdtZGMtbGlzdC0tYXZhdGFyLWxpc3QnOiB0aGlzLmF2YXRhckxpc3QsXG4gICAgICAgICdtZGMtbGlzdC0tdHdvLWxpbmUnOiB0aGlzLnR3b0xpbmUsXG4gICAgICAgICdtZGMtbGlzdC0tYm9yZGVyZWQnOiB0aGlzLmJvcmRlcmVkLFxuICAgICAgICAnbWRjLWxpc3QtLW5vbi1pbnRlcmFjdGl2ZSc6ICF0aGlzLmludGVyYWN0aXZlXG4gICAgICB9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGxpIFxuICAgIDpjbGFzcz1cIltjbGFzc2VzLCBpdGVtQ2xhc3Nlc11cIlxuICAgIDpzdHlsZT1cInN0eWxlc1wiIFxuICAgIDp0YWJpbmRleD1cImlzSW50ZXJhY3RpdmUgPyAnMCcgOiB1bmRlZmluZWRcIiAgIFxuICAgIGNsYXNzPVwibWRjLWxpc3QtaXRlbVwiXG4gICAgdi1vbj1cImlzSW50ZXJhY3RpdmUgPyAkbGlzdGVuZXJzIDoge31cIj5cblxuICAgIDxzcGFuIFxuICAgICAgdi1pZj1cImhhc1N0YXJ0RGV0YWlsXCIgXG4gICAgICBjbGFzcz1cIm1kYy1saXN0LWl0ZW1fX2dyYXBoaWNcIj5cbiAgICAgIDxzbG90IG5hbWU9XCJzdGFydC1kZXRhaWxcIi8+XG4gICAgPC9zcGFuPlxuXG4gICAgPHNwYW4gXG4gICAgICB2LWlmPVwiaGFzU2Vjb25kYXJ5XCIgXG4gICAgICBjbGFzcz1cIm1kYy1saXN0LWl0ZW1fX3RleHRcIj5cbiAgICAgIDxzbG90Lz5cbiAgICAgIDxzcGFuIGNsYXNzPVwibWRjLWxpc3QtaXRlbV9fc2Vjb25kYXJ5LXRleHRcIj5cbiAgICAgICAgPHNsb3QgbmFtZT1cInNlY29uZGFyeVwiLz5cbiAgICAgIDwvc3Bhbj5cbiAgICA8L3NwYW4+XG4gICAgPHNsb3Qgdi1lbHNlLz5cblxuICAgIDxzcGFuIFxuICAgICAgdi1pZj1cImhhc0VuZERldGFpbFwiIFxuICAgICAgY2xhc3M9XCJtZGMtbGlzdC1pdGVtX19tZXRhXCI+XG4gICAgICA8c2xvdCBuYW1lPVwiZW5kLWRldGFpbFwiLz5cbiAgICA8L3NwYW4+XG5cbiAgPC9saT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBSaXBwbGVCYXNlIH0gZnJvbSAnLi4vcmlwcGxlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGlzdC1pdGVtJyxcbiAgaW5qZWN0OiBbJ21kY0xpc3QnXSxcbiAgcHJvcHM6IHtcbiAgICBzZWxlY3RlZDogQm9vbGVhbixcbiAgICBhY3RpdmF0ZWQ6IEJvb2xlYW5cbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGl0ZW1DbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21kYy1saXN0LWl0ZW0tLXNlbGVjdGVkJzogdGhpcy5zZWxlY3RlZCxcbiAgICAgICAgJ21kYy1saXN0LWl0ZW0tLWFjdGl2YXRlZCc6IHRoaXMuYWN0aXZhdGVkXG4gICAgICB9XG4gICAgfSxcbiAgICBpc0ludGVyYWN0aXZlKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWRjTGlzdCAmJiB0aGlzLm1kY0xpc3QuaW50ZXJhY3RpdmVcbiAgICB9LFxuICAgIGhhc1NlY29uZGFyeSgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRzbG90c1snc2Vjb25kYXJ5J10gJiYgKHRoaXMubWRjTGlzdCAmJiB0aGlzLm1kY0xpc3QudHdvTGluZSlcbiAgICB9LFxuICAgIGhhc0VuZERldGFpbCgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuJHNsb3RzWydlbmQtZGV0YWlsJ11cbiAgICB9LFxuICAgIGhhc1N0YXJ0RGV0YWlsKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy4kc2xvdHNbJ3N0YXJ0LWRldGFpbCddXG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGlzSW50ZXJhY3RpdmUodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmFkZFJpcHBsZSgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZVJpcHBsZSgpXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuaXNJbnRlcmFjdGl2ZSAmJiB0aGlzLmFkZFJpcHBsZSgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW1vdmVSaXBwbGUoKVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgYWRkUmlwcGxlKCkge1xuICAgICAgaWYgKCF0aGlzLnJpcHBsZSkge1xuICAgICAgICBsZXQgcmlwcGxlID0gbmV3IFJpcHBsZUJhc2UodGhpcylcbiAgICAgICAgcmlwcGxlLmluaXQoKVxuICAgICAgICB0aGlzLnJpcHBsZSA9IHJpcHBsZVxuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlUmlwcGxlKCkge1xuICAgICAgaWYgKHRoaXMucmlwcGxlKSB7XG4gICAgICAgIGxldCByaXBwbGUgPSB0aGlzLnJpcHBsZVxuICAgICAgICB0aGlzLnJpcHBsZSA9IG51bGxcbiAgICAgICAgcmlwcGxlLmRlc3Ryb3koKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxsaSBcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgXG4gICAgcm9sZT1cInNlcGFyYXRvclwiIFxuICAgIGNsYXNzPVwibWRjLWxpc3QtZGl2aWRlclwiLz5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGlzdC1kaXZpZGVyJyxcbiAgcHJvcHM6IHtcbiAgICBpbnNldDogQm9vbGVhbixcbiAgICBwYWRkZWQ6IEJvb2xlYW5cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21kYy1saXN0LWRpdmlkZXItLWluc2V0JzogdGhpcy5pbnNldCxcbiAgICAgICAgJ21kYy1saXN0LWRpdmlkZXItLXBhZGRlZCc6IHRoaXMucGFkZGVkXG4gICAgICB9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1saXN0LWdyb3VwXCI+PHNsb3QvPjwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1saXN0LWdyb3VwJ1xufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxoMyBjbGFzcz1cIm1kYy1saXN0LWdyb3VwLWhlYWRlciBtZGMtbGlzdC1ncm91cF9fc3ViaGVhZGVyXCI+PHNsb3QvPjwvaDM+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWxpc3QtZ3JvdXAtaGVhZGVyJ1xufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxociBjbGFzcz1cIm1kYy1saXN0LWdyb3VwLWRpdmlkZXIgbWRjLWxpc3QtZGl2aWRlclwiPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1saXN0LWdyb3VwLWRpdmlkZXInXG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0xpc3QgZnJvbSAnLi9tZGMtbGlzdC52dWUnXG5pbXBvcnQgbWRjTGlzdEl0ZW0gZnJvbSAnLi9tZGMtbGlzdC1pdGVtLnZ1ZSdcbmltcG9ydCBtZGNMaXN0RGl2aWRlciBmcm9tICcuL21kYy1saXN0LWRpdmlkZXIudnVlJ1xuaW1wb3J0IG1kY0xpc3RHcm91cCBmcm9tICcuL21kYy1saXN0LWdyb3VwLnZ1ZSdcbmltcG9ydCBtZGNMaXN0R3JvdXBIZWFkZXIgZnJvbSAnLi9tZGMtbGlzdC1ncm91cC1oZWFkZXIudnVlJ1xuaW1wb3J0IG1kY0xpc3RHcm91cERpdmlkZXIgZnJvbSAnLi9tZGMtbGlzdC1ncm91cC1kaXZpZGVyLnZ1ZSdcblxuZXhwb3J0IHtcbiAgbWRjTGlzdCxcbiAgbWRjTGlzdEl0ZW0sXG4gIG1kY0xpc3REaXZpZGVyLFxuICBtZGNMaXN0R3JvdXAsXG4gIG1kY0xpc3RHcm91cEhlYWRlcixcbiAgbWRjTGlzdEdyb3VwRGl2aWRlclxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjTGlzdCxcbiAgbWRjTGlzdEl0ZW0sXG4gIG1kY0xpc3REaXZpZGVyLFxuICBtZGNMaXN0R3JvdXAsXG4gIG1kY0xpc3RHcm91cEhlYWRlcixcbiAgbWRjTGlzdEdyb3VwRGl2aWRlclxufSlcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgTWVudS4gUHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBtYW5hZ2luZ1xuICogLSBjbGFzc2VzXG4gKiAtIGRvbVxuICogLSBmb2N1c1xuICogLSBwb3NpdGlvblxuICogLSBkaW1lbnNpb25zXG4gKiAtIGV2ZW50IGhhbmRsZXJzXG4gKlxuICogQWRkaXRpb25hbGx5LCBwcm92aWRlcyB0eXBlIGluZm9ybWF0aW9uIGZvciB0aGUgYWRhcHRlciB0byB0aGUgQ2xvc3VyZVxuICogY29tcGlsZXIuXG4gKlxuICogSW1wbGVtZW50IHRoaXMgYWRhcHRlciBmb3IgeW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlIHRvIGRlbGVnYXRlIHVwZGF0ZXMgdG9cbiAqIHRoZSBjb21wb25lbnQgaW4geW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlLiBTZWUgYXJjaGl0ZWN0dXJlIGRvY3VtZW50YXRpb25cbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2NvZGUvYXJjaGl0ZWN0dXJlLm1kXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENNZW51QWRhcHRlciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaGFzTmVjZXNzYXJ5RG9tKCkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVOYW1lXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldEF0dHJpYnV0ZUZvckV2ZW50VGFyZ2V0KHRhcmdldCwgYXR0cmlidXRlTmFtZSkge31cblxuICAvKiogQHJldHVybiB7eyB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9fSAqL1xuICBnZXRJbm5lckRpbWVuc2lvbnMoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBoYXNBbmNob3IoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIHRvcDogbnVtYmVyLCByaWdodDogbnVtYmVyLCBib3R0b206IG51bWJlciwgbGVmdDogbnVtYmVyfX0gKi9cbiAgZ2V0QW5jaG9yRGltZW5zaW9ucygpIHt9XG5cbiAgLyoqIEByZXR1cm4ge3sgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfX0gKi9cbiAgZ2V0V2luZG93RGltZW5zaW9ucygpIHt9XG5cbiAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0TnVtYmVyT2ZJdGVtcygpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KX0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KX0gaGFuZGxlciAqL1xuICByZWdpc3RlckJvZHlDbGlja0hhbmRsZXIoaGFuZGxlcikge31cblxuICAvKiogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpfSBoYW5kbGVyICovXG4gIGRlcmVnaXN0ZXJCb2R5Q2xpY2tIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRJbmRleEZvckV2ZW50VGFyZ2V0KHRhcmdldCkge31cblxuICAvKiogQHBhcmFtIHt7aW5kZXg6IG51bWJlcn19IGV2dERhdGEgKi9cbiAgbm90aWZ5U2VsZWN0ZWQoZXZ0RGF0YSkge31cblxuICBub3RpZnlDYW5jZWwoKSB7fVxuXG4gIHNhdmVGb2N1cygpIHt9XG5cbiAgcmVzdG9yZUZvY3VzKCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNGb2N1c2VkKCkge31cblxuICBmb2N1cygpIHt9XG5cbiAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0Rm9jdXNlZEl0ZW1JbmRleCgpIC8qIG51bWJlciAqLyB7fVxuXG4gIC8qKiBAcGFyYW0ge251bWJlcn0gaW5kZXggKi9cbiAgZm9jdXNJdGVtQXRJbmRleChpbmRleCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNSdGwoKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luICovXG4gIHNldFRyYW5zZm9ybU9yaWdpbihvcmlnaW4pIHt9XG5cbiAgLyoqIEBwYXJhbSB7e1xuICAqICAgdG9wOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gICogICByaWdodDogKHN0cmluZ3x1bmRlZmluZWQpLFxuICAqICAgYm90dG9tOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gICogICBsZWZ0OiAoc3RyaW5nfHVuZGVmaW5lZClcbiAgKiB9fSBwb3NpdGlvbiAqL1xuICBzZXRQb3NpdGlvbihwb3NpdGlvbikge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGhlaWdodCAqL1xuICBzZXRNYXhIZWlnaHQoaGVpZ2h0KSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRBdHRyRm9yT3B0aW9uQXRJbmRleChpbmRleCwgYXR0ciwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICAgKi9cbiAgcm1BdHRyRm9yT3B0aW9uQXRJbmRleChpbmRleCwgYXR0cikge31cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzRm9yT3B0aW9uQXRJbmRleChpbmRleCwgY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgcm1DbGFzc0Zvck9wdGlvbkF0SW5kZXgoaW5kZXgsIGNsYXNzTmFtZSkge31cbn1cblxuZXhwb3J0IHtNRENNZW51QWRhcHRlcn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBST09UOiAnbWRjLW1lbnUnLFxuICBPUEVOOiAnbWRjLW1lbnUtLW9wZW4nLFxuICBBTklNQVRJTkdfT1BFTjogJ21kYy1tZW51LS1hbmltYXRpbmctb3BlbicsXG4gIEFOSU1BVElOR19DTE9TRUQ6ICdtZGMtbWVudS0tYW5pbWF0aW5nLWNsb3NlZCcsXG4gIFNFTEVDVEVEX0xJU1RfSVRFTTogJ21kYy1saXN0LWl0ZW0tLXNlbGVjdGVkJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgSVRFTVNfU0VMRUNUT1I6ICcubWRjLW1lbnVfX2l0ZW1zJyxcbiAgU0VMRUNURURfRVZFTlQ6ICdNRENNZW51OnNlbGVjdGVkJyxcbiAgQ0FOQ0VMX0VWRU5UOiAnTURDTWVudTpjYW5jZWwnLFxuICBBUklBX0RJU0FCTEVEX0FUVFI6ICdhcmlhLWRpc2FibGVkJyxcbn07XG5cbi8qKiBAZW51bSB7bnVtYmVyfSAqL1xuY29uc3QgbnVtYmVycyA9IHtcbiAgLy8gQW1vdW50IG9mIHRpbWUgdG8gd2FpdCBiZWZvcmUgdHJpZ2dlcmluZyBhIHNlbGVjdGVkIGV2ZW50IG9uIHRoZSBtZW51LiBOb3RlIHRoYXQgdGhpcyB0aW1lXG4gIC8vIHdpbGwgbW9zdCBsaWtlbHkgYmUgYnVtcGVkIHVwIG9uY2UgaW50ZXJhY3RpdmUgbGlzdHMgYXJlIHN1cHBvcnRlZCB0byBhbGxvdyBmb3IgdGhlIHJpcHBsZSB0b1xuICAvLyBhbmltYXRlIGJlZm9yZSBjbG9zaW5nIHRoZSBtZW51XG4gIFNFTEVDVEVEX1RSSUdHRVJfREVMQVk6IDUwLFxuICAvLyBUb3RhbCBkdXJhdGlvbiBvZiBtZW51IG9wZW4gYW5pbWF0aW9uLlxuICBUUkFOU0lUSU9OX09QRU5fRFVSQVRJT046IDEyMCxcbiAgLy8gVG90YWwgZHVyYXRpb24gb2YgbWVudSBjbG9zZSBhbmltYXRpb24uXG4gIFRSQU5TSVRJT05fQ0xPU0VfRFVSQVRJT046IDc1LFxuICAvLyBNYXJnaW4gbGVmdCB0byB0aGUgZWRnZSBvZiB0aGUgdmlld3BvcnQgd2hlbiBtZW51IGlzIGF0IG1heGltdW0gcG9zc2libGUgaGVpZ2h0LlxuICBNQVJHSU5fVE9fRURHRTogMzIsXG4gIC8vIFJhdGlvIG9mIGFuY2hvciB3aWR0aCB0byBtZW51IHdpZHRoIGZvciBzd2l0Y2hpbmcgZnJvbSBjb3JuZXIgcG9zaXRpb25pbmcgdG8gY2VudGVyIHBvc2l0aW9uaW5nLlxuICBBTkNIT1JfVE9fTUVOVV9XSURUSF9SQVRJTzogMC42NyxcbiAgLy8gUmF0aW8gb2YgdmVydGljYWwgb2Zmc2V0IHRvIG1lbnUgaGVpZ2h0IGZvciBzd2l0Y2hpbmcgZnJvbSBjb3JuZXIgdG8gbWlkLXdheSBvcmlnaW4gcG9zaXRpb25pbmcuXG4gIE9GRlNFVF9UT19NRU5VX0hFSUdIVF9SQVRJTzogMC4xLFxufTtcblxuLyoqXG4gKiBFbnVtIGZvciBiaXRzIGluIHRoZSB7QHNlZSBDb3JuZXIpIGJpdG1hcC5cbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmNvbnN0IENvcm5lckJpdCA9IHtcbiAgQk9UVE9NOiAxLFxuICBDRU5URVI6IDIsXG4gIFJJR0hUOiA0LFxuICBGTElQX1JUTDogOCxcbn07XG5cbi8qKlxuICogRW51bSBmb3IgcmVwcmVzZW50aW5nIGFuIGVsZW1lbnQgY29ybmVyIGZvciBwb3NpdGlvbmluZyB0aGUgbWVudS5cbiAqXG4gKiBUaGUgU1RBUlQgY29uc3RhbnRzIG1hcCB0byBMRUZUIGlmIGVsZW1lbnQgZGlyZWN0aW9uYWxpdHkgaXMgbGVmdFxuICogdG8gcmlnaHQgYW5kIFJJR0hUIGlmIHRoZSBkaXJlY3Rpb25hbGl0eSBpcyByaWdodCB0byBsZWZ0LlxuICogTGlrZXdpc2UgRU5EIG1hcHMgdG8gUklHSFQgb3IgTEVGVCBkZXBlbmRpbmcgb24gdGhlIGRpcmVjdGlvbmFsaXR5LlxuICpcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmNvbnN0IENvcm5lciA9IHtcbiAgVE9QX0xFRlQ6IDAsXG4gIFRPUF9SSUdIVDogQ29ybmVyQml0LlJJR0hULFxuICBCT1RUT01fTEVGVDogQ29ybmVyQml0LkJPVFRPTSxcbiAgQk9UVE9NX1JJR0hUOiBDb3JuZXJCaXQuQk9UVE9NIHwgQ29ybmVyQml0LlJJR0hULFxuICBUT1BfU1RBUlQ6IENvcm5lckJpdC5GTElQX1JUTCxcbiAgVE9QX0VORDogQ29ybmVyQml0LkZMSVBfUlRMIHwgQ29ybmVyQml0LlJJR0hULFxuICBCT1RUT01fU1RBUlQ6IENvcm5lckJpdC5CT1RUT00gfCBDb3JuZXJCaXQuRkxJUF9SVEwsXG4gIEJPVFRPTV9FTkQ6IENvcm5lckJpdC5CT1RUT00gfCBDb3JuZXJCaXQuUklHSFQgfCBDb3JuZXJCaXQuRkxJUF9SVEwsXG59O1xuXG5cbmV4cG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVycywgQ29ybmVyQml0LCBDb3JuZXJ9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgdG9wOiBudW1iZXIsXG4gKiAgIHJpZ2h0OiBudW1iZXIsXG4gKiAgIGJvdHRvbTogbnVtYmVyLFxuICogICBsZWZ0OiBudW1iZXJcbiAqIH19XG4gKi9cbmxldCBBbmNob3JNYXJnaW47XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIHZpZXdwb3J0OiB7IHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH0sXG4gKiAgIHZpZXdwb3J0RGlzdGFuY2U6IHt0b3A6IG51bWJlciwgcmlnaHQ6IG51bWJlciwgYm90dG9tOiBudW1iZXIsIGxlZnQ6IG51bWJlcn0sXG4gKiAgIGFuY2hvckhlaWdodDogbnVtYmVyLFxuICogICBhbmNob3JXaWR0aDogbnVtYmVyLFxuICogICBtZW51SGVpZ2h0OiBudW1iZXIsXG4gKiAgIG1lbnVXaWR0aDogbnVtYmVyLFxuICogfX1cbiAqL1xubGV0IEF1dG9MYXlvdXRNZWFzdXJlbWVudHM7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IHtNRENNZW51QWRhcHRlcn0gZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVycywgQ29ybmVyLCBDb3JuZXJCaXR9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDTWVudUFkYXB0ZXI+fVxuICovXG5jbGFzcyBNRENNZW51Rm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVte2Nzc0NsYXNzZXN9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW17c3RyaW5nc30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bXtudW1iZXJzfSAqL1xuICBzdGF0aWMgZ2V0IG51bWJlcnMoKSB7XG4gICAgcmV0dXJuIG51bWJlcnM7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVte251bWJlcn0gKi9cbiAgc3RhdGljIGdldCBDb3JuZXIoKSB7XG4gICAgcmV0dXJuIENvcm5lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENNZW51QWRhcHRlcn0gZm9yIHR5cGluZyBpbmZvcm1hdGlvbiBvbiBwYXJhbWV0ZXJzIGFuZCByZXR1cm5cbiAgICogdHlwZXMuXG4gICAqIEByZXR1cm4geyFNRENNZW51QWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ01lbnVBZGFwdGVyfSAqLyAoe1xuICAgICAgYWRkQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgaGFzQ2xhc3M6ICgpID0+IGZhbHNlLFxuICAgICAgaGFzTmVjZXNzYXJ5RG9tOiAoKSA9PiBmYWxzZSxcbiAgICAgIGdldEF0dHJpYnV0ZUZvckV2ZW50VGFyZ2V0OiAoKSA9PiB7fSxcbiAgICAgIGdldElubmVyRGltZW5zaW9uczogKCkgPT4gKHt9KSxcbiAgICAgIGhhc0FuY2hvcjogKCkgPT4gZmFsc2UsXG4gICAgICBnZXRBbmNob3JEaW1lbnNpb25zOiAoKSA9PiAoe30pLFxuICAgICAgZ2V0V2luZG93RGltZW5zaW9uczogKCkgPT4gKHt9KSxcbiAgICAgIGdldE51bWJlck9mSXRlbXM6ICgpID0+IDAsXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyQm9keUNsaWNrSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyQm9keUNsaWNrSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBnZXRJbmRleEZvckV2ZW50VGFyZ2V0OiAoKSA9PiAwLFxuICAgICAgbm90aWZ5U2VsZWN0ZWQ6ICgpID0+IHt9LFxuICAgICAgbm90aWZ5Q2FuY2VsOiAoKSA9PiB7fSxcbiAgICAgIHNhdmVGb2N1czogKCkgPT4ge30sXG4gICAgICByZXN0b3JlRm9jdXM6ICgpID0+IHt9LFxuICAgICAgaXNGb2N1c2VkOiAoKSA9PiBmYWxzZSxcbiAgICAgIGZvY3VzOiAoKSA9PiB7fSxcbiAgICAgIGdldEZvY3VzZWRJdGVtSW5kZXg6ICgpID0+IC0xLFxuICAgICAgZm9jdXNJdGVtQXRJbmRleDogKCkgPT4ge30sXG4gICAgICBpc1J0bDogKCkgPT4gZmFsc2UsXG4gICAgICBzZXRUcmFuc2Zvcm1PcmlnaW46ICgpID0+IHt9LFxuICAgICAgc2V0UG9zaXRpb246ICgpID0+IHt9LFxuICAgICAgc2V0TWF4SGVpZ2h0OiAoKSA9PiB7fSxcbiAgICAgIHNldEF0dHJGb3JPcHRpb25BdEluZGV4OiAoKSA9PiB7fSxcbiAgICAgIHJtQXR0ckZvck9wdGlvbkF0SW5kZXg6ICgpID0+IHt9LFxuICAgICAgYWRkQ2xhc3NGb3JPcHRpb25BdEluZGV4OiAoKSA9PiB7fSxcbiAgICAgIHJtQ2xhc3NGb3JPcHRpb25BdEluZGV4OiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0geyFNRENNZW51QWRhcHRlcn0gYWRhcHRlciAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENNZW51Rm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpfSAqL1xuICAgIHRoaXMuY2xpY2tIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlUG9zc2libGVTZWxlY3RlZF8oZXZ0KTtcbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCl9ICovXG4gICAgdGhpcy5rZXlkb3duSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZUtleWJvYXJkRG93bl8oZXZ0KTtcbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCl9ICovXG4gICAgdGhpcy5rZXl1cEhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVLZXlib2FyZFVwXyhldnQpO1xuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KX0gKi9cbiAgICB0aGlzLmRvY3VtZW50Q2xpY2tIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlRG9jdW1lbnRDbGlja18oZXZ0KTtcbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5pc09wZW5fID0gZmFsc2U7XG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5vcGVuQW5pbWF0aW9uRW5kVGltZXJJZF8gPSAwO1xuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuY2xvc2VBbmltYXRpb25FbmRUaW1lcklkXyA9IDA7XG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5zZWxlY3RlZFRyaWdnZXJUaW1lcklkXyA9IDA7XG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5hbmltYXRpb25SZXF1ZXN0SWRfID0gMDtcbiAgICAvKiogQHByaXZhdGUgeyF7IHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH19ICovXG4gICAgdGhpcy5kaW1lbnNpb25zXztcbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLml0ZW1IZWlnaHRfO1xuICAgIC8qKiBAcHJpdmF0ZSB7Q29ybmVyfSAqL1xuICAgIHRoaXMuYW5jaG9yQ29ybmVyXyA9IENvcm5lci5UT1BfU1RBUlQ7XG4gICAgLyoqIEBwcml2YXRlIHtBbmNob3JNYXJnaW59ICovXG4gICAgdGhpcy5hbmNob3JNYXJnaW5fID0ge3RvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMH07XG4gICAgLyoqIEBwcml2YXRlIHs/QXV0b0xheW91dE1lYXN1cmVtZW50c30gKi9cbiAgICB0aGlzLm1lYXN1cmVzXyA9IG51bGw7XG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5zZWxlY3RlZEluZGV4XyA9IC0xO1xuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLnJlbWVtYmVyU2VsZWN0aW9uXyA9IGZhbHNlO1xuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLnF1aWNrT3Blbl8gPSBmYWxzZTtcblxuICAgIC8vIEEga2V5dXAgZXZlbnQgb24gdGhlIG1lbnUgbmVlZHMgdG8gaGF2ZSBhIGNvcnJlc3BvbmRpbmcga2V5ZG93blxuICAgIC8vIGV2ZW50IG9uIHRoZSBtZW51LiBJZiB0aGUgdXNlciBvcGVucyB0aGUgbWVudSB3aXRoIGEga2V5ZG93biBldmVudCBvbiBhXG4gICAgLy8gYnV0dG9uLCB0aGUgbWVudSB3aWxsIG9ubHkgZ2V0IHRoZSBrZXkgdXAgZXZlbnQgY2F1c2luZyBidWdneSBiZWhhdmlvciB3aXRoIHNlbGVjdGVkIGVsZW1lbnRzLlxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmtleURvd25XaXRoaW5NZW51XyA9IGZhbHNlO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBjb25zdCB7Uk9PVCwgT1BFTn0gPSBNRENNZW51Rm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuXG4gICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKFJPT1QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Uk9PVH0gY2xhc3MgcmVxdWlyZWQgaW4gcm9vdCBlbGVtZW50LmApO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5hZGFwdGVyXy5oYXNOZWNlc3NhcnlEb20oKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXF1aXJlZCBET00gbm9kZXMgbWlzc2luZyBpbiAke1JPT1R9IGNvbXBvbmVudC5gKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhPUEVOKSkge1xuICAgICAgdGhpcy5pc09wZW5fID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5dXAnLCB0aGlzLmtleXVwSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleWRvd24nLCB0aGlzLmtleWRvd25IYW5kbGVyXyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnNlbGVjdGVkVHJpZ2dlclRpbWVySWRfKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5vcGVuQW5pbWF0aW9uRW5kVGltZXJJZF8pO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmNsb3NlQW5pbWF0aW9uRW5kVGltZXJJZF8pO1xuICAgIC8vIENhbmNlbCBhbnkgY3VycmVudGx5IHJ1bm5pbmcgYW5pbWF0aW9ucy5cbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvblJlcXVlc3RJZF8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmNsaWNrSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5dXAnLCB0aGlzLmtleXVwSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJCb2R5Q2xpY2tIYW5kbGVyKHRoaXMuZG9jdW1lbnRDbGlja0hhbmRsZXJfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFDb3JuZXJ9IGNvcm5lciBEZWZhdWx0IGFuY2hvciBjb3JuZXIgYWxpZ25tZW50IG9mIHRvcC1sZWZ0IG1lbnUgY29ybmVyLlxuICAgKi9cbiAgc2V0QW5jaG9yQ29ybmVyKGNvcm5lcikge1xuICAgIHRoaXMuYW5jaG9yQ29ybmVyXyA9IGNvcm5lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFBbmNob3JNYXJnaW59IG1hcmdpbiA0LXBsZXQgb2YgbWFyZ2lucyBmcm9tIGFuY2hvci5cbiAgICovXG4gIHNldEFuY2hvck1hcmdpbihtYXJnaW4pIHtcbiAgICB0aGlzLmFuY2hvck1hcmdpbl8udG9wID0gdHlwZW9mIG1hcmdpbi50b3AgPT09ICdudW1iZXInID8gbWFyZ2luLnRvcCA6IDA7XG4gICAgdGhpcy5hbmNob3JNYXJnaW5fLnJpZ2h0ID0gdHlwZW9mIG1hcmdpbi5yaWdodCA9PT0gJ251bWJlcicgPyBtYXJnaW4ucmlnaHQgOiAwO1xuICAgIHRoaXMuYW5jaG9yTWFyZ2luXy5ib3R0b20gPSB0eXBlb2YgbWFyZ2luLmJvdHRvbSA9PT0gJ251bWJlcicgPyBtYXJnaW4uYm90dG9tIDogMDtcbiAgICB0aGlzLmFuY2hvck1hcmdpbl8ubGVmdCA9IHR5cGVvZiBtYXJnaW4ubGVmdCA9PT0gJ251bWJlcicgPyBtYXJnaW4ubGVmdCA6IDA7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSByZW1lbWJlclNlbGVjdGlvbiAqL1xuICBzZXRSZW1lbWJlclNlbGVjdGlvbihyZW1lbWJlclNlbGVjdGlvbikge1xuICAgIHRoaXMucmVtZW1iZXJTZWxlY3Rpb25fID0gcmVtZW1iZXJTZWxlY3Rpb247XG4gICAgdGhpcy5zZXRTZWxlY3RlZEluZGV4KC0xKTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge2Jvb2xlYW59IHF1aWNrT3BlbiAqL1xuICBzZXRRdWlja09wZW4ocXVpY2tPcGVuKSB7XG4gICAgdGhpcy5xdWlja09wZW5fID0gcXVpY2tPcGVuO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7P251bWJlcn0gZm9jdXNJbmRleFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZm9jdXNPbk9wZW5fKGZvY3VzSW5kZXgpIHtcbiAgICBpZiAoZm9jdXNJbmRleCA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgdGhpcyBpbnN0YW5jZSBvZiBNRENNZW51IHJlbWVtYmVycyBzZWxlY3Rpb25zLCBhbmQgdGhlIHVzZXIgaGFzXG4gICAgICAvLyBtYWRlIGEgc2VsZWN0aW9uLCB0aGVuIGZvY3VzIHRoZSBsYXN0IHNlbGVjdGVkIGl0ZW1cbiAgICAgIGlmICh0aGlzLnJlbWVtYmVyU2VsZWN0aW9uXyAmJiB0aGlzLnNlbGVjdGVkSW5kZXhfID49IDApIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5mb2N1c0l0ZW1BdEluZGV4KHRoaXMuc2VsZWN0ZWRJbmRleF8pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWRhcHRlcl8uZm9jdXMoKTtcbiAgICAgIC8vIElmIHRoYXQgZG9lc24ndCB3b3JrLCBmb2N1cyBmaXJzdCBpdGVtIGluc3RlYWQuXG4gICAgICBpZiAoIXRoaXMuYWRhcHRlcl8uaXNGb2N1c2VkKCkpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5mb2N1c0l0ZW1BdEluZGV4KDApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmZvY3VzSXRlbUF0SW5kZXgoZm9jdXNJbmRleCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBjbGlja3MgYW5kIGNhbmNlbCB0aGUgbWVudSBpZiBub3QgYSBjaGlsZCBsaXN0LWl0ZW1cbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlRG9jdW1lbnRDbGlja18oZXZ0KSB7XG4gICAgbGV0IGVsID0gZXZ0LnRhcmdldDtcblxuICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBpZiAodGhpcy5hZGFwdGVyXy5nZXRJbmRleEZvckV2ZW50VGFyZ2V0KGVsKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWwgPSBlbC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2FuY2VsKCk7XG4gICAgdGhpcy5jbG9zZShldnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUga2V5cyB0aGF0IHdlIHdhbnQgdG8gcmVwZWF0IG9uIGhvbGQgKHRhYiBhbmQgYXJyb3dzKS5cbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlS2V5Ym9hcmREb3duXyhldnQpIHtcbiAgICAvLyBEbyBub3RoaW5nIGlmIEFsdCwgQ3RybCBvciBNZXRhIGFyZSBwcmVzc2VkLlxuICAgIGlmIChldnQuYWx0S2V5IHx8IGV2dC5jdHJsS2V5IHx8IGV2dC5tZXRhS2V5KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCB7a2V5Q29kZSwga2V5LCBzaGlmdEtleX0gPSBldnQ7XG4gICAgY29uc3QgaXNUYWIgPSBrZXkgPT09ICdUYWInIHx8IGtleUNvZGUgPT09IDk7XG4gICAgY29uc3QgaXNBcnJvd1VwID0ga2V5ID09PSAnQXJyb3dVcCcgfHwga2V5Q29kZSA9PT0gMzg7XG4gICAgY29uc3QgaXNBcnJvd0Rvd24gPSBrZXkgPT09ICdBcnJvd0Rvd24nIHx8IGtleUNvZGUgPT09IDQwO1xuICAgIGNvbnN0IGlzU3BhY2UgPSBrZXkgPT09ICdTcGFjZScgfHwga2V5Q29kZSA9PT0gMzI7XG4gICAgY29uc3QgaXNFbnRlciA9IGtleSA9PT0gJ0VudGVyJyB8fCBrZXlDb2RlID09PSAxMztcbiAgICAvLyBUaGUgbWVudSBuZWVkcyB0byBrbm93IGlmIHRoZSBrZXlkb3duIGV2ZW50IHdhcyB0cmlnZ2VyZWQgb24gdGhlIG1lbnVcbiAgICB0aGlzLmtleURvd25XaXRoaW5NZW51XyA9IGlzRW50ZXIgfHwgaXNTcGFjZTtcblxuICAgIGNvbnN0IGZvY3VzZWRJdGVtSW5kZXggPSB0aGlzLmFkYXB0ZXJfLmdldEZvY3VzZWRJdGVtSW5kZXgoKTtcbiAgICBjb25zdCBsYXN0SXRlbUluZGV4ID0gdGhpcy5hZGFwdGVyXy5nZXROdW1iZXJPZkl0ZW1zKCkgLSAxO1xuXG4gICAgaWYgKHNoaWZ0S2V5ICYmIGlzVGFiICYmIGZvY3VzZWRJdGVtSW5kZXggPT09IDApIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZm9jdXNJdGVtQXRJbmRleChsYXN0SXRlbUluZGV4KTtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghc2hpZnRLZXkgJiYgaXNUYWIgJiYgZm9jdXNlZEl0ZW1JbmRleCA9PT0gbGFzdEl0ZW1JbmRleCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5mb2N1c0l0ZW1BdEluZGV4KDApO1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIEFycm93e1VwLERvd259IGFuZCBzcGFjZSBkbyBub3QgY2F1c2UgaW5hZHZlcnRlbnQgc2Nyb2xsaW5nXG4gICAgaWYgKGlzQXJyb3dVcCB8fCBpc0Fycm93RG93biB8fCBpc1NwYWNlKSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJvd1VwKSB7XG4gICAgICBpZiAoZm9jdXNlZEl0ZW1JbmRleCA9PT0gMCB8fCB0aGlzLmFkYXB0ZXJfLmlzRm9jdXNlZCgpKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZm9jdXNJdGVtQXRJbmRleChsYXN0SXRlbUluZGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZm9jdXNJdGVtQXRJbmRleChmb2N1c2VkSXRlbUluZGV4IC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0Fycm93RG93bikge1xuICAgICAgaWYgKGZvY3VzZWRJdGVtSW5kZXggPT09IGxhc3RJdGVtSW5kZXggfHwgdGhpcy5hZGFwdGVyXy5pc0ZvY3VzZWQoKSkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmZvY3VzSXRlbUF0SW5kZXgoMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmZvY3VzSXRlbUF0SW5kZXgoZm9jdXNlZEl0ZW1JbmRleCArIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBrZXlzIHRoYXQgd2UgZG9uJ3Qgd2FudCB0byByZXBlYXQgb24gaG9sZCAoRW50ZXIsIFNwYWNlLCBFc2NhcGUpLlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVLZXlib2FyZFVwXyhldnQpIHtcbiAgICAvLyBEbyBub3RoaW5nIGlmIEFsdCwgQ3RybCBvciBNZXRhIGFyZSBwcmVzc2VkLlxuICAgIGlmIChldnQuYWx0S2V5IHx8IGV2dC5jdHJsS2V5IHx8IGV2dC5tZXRhS2V5KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCB7a2V5Q29kZSwga2V5fSA9IGV2dDtcbiAgICBjb25zdCBpc0VudGVyID0ga2V5ID09PSAnRW50ZXInIHx8IGtleUNvZGUgPT09IDEzO1xuICAgIGNvbnN0IGlzU3BhY2UgPSBrZXkgPT09ICdTcGFjZScgfHwga2V5Q29kZSA9PT0gMzI7XG4gICAgY29uc3QgaXNFc2NhcGUgPSBrZXkgPT09ICdFc2NhcGUnIHx8IGtleUNvZGUgPT09IDI3O1xuXG4gICAgaWYgKGlzRW50ZXIgfHwgaXNTcGFjZSkge1xuICAgICAgLy8gSWYgdGhlIGtleWRvd24gZXZlbnQgZGlkbid0IG9jY3VyIG9uIHRoZSBtZW51LCB0aGVuIGl0IHNob3VsZFxuICAgICAgLy8gZGlzcmVnYXJkIHRoZSBwb3NzaWJsZSBzZWxlY3RlZCBldmVudC5cbiAgICAgIGlmICh0aGlzLmtleURvd25XaXRoaW5NZW51Xykge1xuICAgICAgICB0aGlzLmhhbmRsZVBvc3NpYmxlU2VsZWN0ZWRfKGV2dCk7XG4gICAgICB9XG4gICAgICB0aGlzLmtleURvd25XaXRoaW5NZW51XyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpc0VzY2FwZSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlDYW5jZWwoKTtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVQb3NzaWJsZVNlbGVjdGVkXyhldnQpIHtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5nZXRBdHRyaWJ1dGVGb3JFdmVudFRhcmdldChldnQudGFyZ2V0LCBzdHJpbmdzLkFSSUFfRElTQUJMRURfQVRUUikgPT09ICd0cnVlJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRJbmRleCA9IHRoaXMuYWRhcHRlcl8uZ2V0SW5kZXhGb3JFdmVudFRhcmdldChldnQudGFyZ2V0KTtcbiAgICBpZiAodGFyZ2V0SW5kZXggPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIERlYm91bmNlIG11bHRpcGxlIHNlbGVjdGlvbnNcbiAgICBpZiAodGhpcy5zZWxlY3RlZFRyaWdnZXJUaW1lcklkXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNlbGVjdGVkVHJpZ2dlclRpbWVySWRfID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnNlbGVjdGVkVHJpZ2dlclRpbWVySWRfID0gMDtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIGlmICh0aGlzLnJlbWVtYmVyU2VsZWN0aW9uXykge1xuICAgICAgICB0aGlzLnNldFNlbGVjdGVkSW5kZXgodGFyZ2V0SW5kZXgpO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlTZWxlY3RlZCh7aW5kZXg6IHRhcmdldEluZGV4fSk7XG4gICAgfSwgbnVtYmVycy5TRUxFQ1RFRF9UUklHR0VSX0RFTEFZKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBdXRvTGF5b3V0TWVhc3VyZW1lbnRzfSBNZWFzdXJlbWVudHMgdXNlZCB0byBwb3NpdGlvbiBtZW51IHBvcHVwLlxuICAgKi9cbiAgZ2V0QXV0b0xheW91dE1lYXN1cmVtZW50c18oKSB7XG4gICAgY29uc3QgYW5jaG9yUmVjdCA9IHRoaXMuYWRhcHRlcl8uZ2V0QW5jaG9yRGltZW5zaW9ucygpO1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gdGhpcy5hZGFwdGVyXy5nZXRXaW5kb3dEaW1lbnNpb25zKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgICAgdmlld3BvcnREaXN0YW5jZToge1xuICAgICAgICB0b3A6IGFuY2hvclJlY3QudG9wLFxuICAgICAgICByaWdodDogdmlld3BvcnQud2lkdGggLSBhbmNob3JSZWN0LnJpZ2h0LFxuICAgICAgICBsZWZ0OiBhbmNob3JSZWN0LmxlZnQsXG4gICAgICAgIGJvdHRvbTogdmlld3BvcnQuaGVpZ2h0IC0gYW5jaG9yUmVjdC5ib3R0b20sXG4gICAgICB9LFxuICAgICAgYW5jaG9ySGVpZ2h0OiBhbmNob3JSZWN0LmhlaWdodCxcbiAgICAgIGFuY2hvcldpZHRoOiBhbmNob3JSZWN0LndpZHRoLFxuICAgICAgbWVudUhlaWdodDogdGhpcy5kaW1lbnNpb25zXy5oZWlnaHQsXG4gICAgICBtZW51V2lkdGg6IHRoaXMuZGltZW5zaW9uc18ud2lkdGgsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgY29ybmVyIG9mIHRoZSBhbmNob3IgZnJvbSB3aGljaCB0byBhbmltYXRlIGFuZCBwb3NpdGlvbiB0aGUgbWVudS5cbiAgICogQHJldHVybiB7Q29ybmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0T3JpZ2luQ29ybmVyXygpIHtcbiAgICAvLyBEZWZhdWx0czogb3BlbiBmcm9tIHRoZSB0b3AgbGVmdC5cbiAgICBsZXQgY29ybmVyID0gQ29ybmVyLlRPUF9MRUZUO1xuXG4gICAgY29uc3Qge3ZpZXdwb3J0RGlzdGFuY2UsIGFuY2hvckhlaWdodCwgYW5jaG9yV2lkdGgsIG1lbnVIZWlnaHQsIG1lbnVXaWR0aH0gPSB0aGlzLm1lYXN1cmVzXztcbiAgICBjb25zdCBpc0JvdHRvbUFsaWduZWQgPSBCb29sZWFuKHRoaXMuYW5jaG9yQ29ybmVyXyAmIENvcm5lckJpdC5CT1RUT00pO1xuICAgIGNvbnN0IGF2YWlsYWJsZVRvcCA9IGlzQm90dG9tQWxpZ25lZCA/IHZpZXdwb3J0RGlzdGFuY2UudG9wICsgYW5jaG9ySGVpZ2h0ICsgdGhpcy5hbmNob3JNYXJnaW5fLmJvdHRvbVxuICAgICAgOiB2aWV3cG9ydERpc3RhbmNlLnRvcCArIHRoaXMuYW5jaG9yTWFyZ2luXy50b3A7XG4gICAgY29uc3QgYXZhaWxhYmxlQm90dG9tID0gaXNCb3R0b21BbGlnbmVkID8gdmlld3BvcnREaXN0YW5jZS5ib3R0b20gLSB0aGlzLmFuY2hvck1hcmdpbl8uYm90dG9tXG4gICAgICA6IHZpZXdwb3J0RGlzdGFuY2UuYm90dG9tICsgYW5jaG9ySGVpZ2h0IC0gdGhpcy5hbmNob3JNYXJnaW5fLnRvcDtcblxuICAgIGNvbnN0IHRvcE92ZXJmbG93ID0gbWVudUhlaWdodCAtIGF2YWlsYWJsZVRvcDtcbiAgICBjb25zdCBib3R0b21PdmVyZmxvdyA9IG1lbnVIZWlnaHQgLSBhdmFpbGFibGVCb3R0b207XG4gICAgaWYgKGJvdHRvbU92ZXJmbG93ID4gMCAmJiB0b3BPdmVyZmxvdyA8IGJvdHRvbU92ZXJmbG93KSB7XG4gICAgICBjb3JuZXIgfD0gQ29ybmVyQml0LkJPVFRPTTtcbiAgICB9XG5cbiAgICBjb25zdCBpc1J0bCA9IHRoaXMuYWRhcHRlcl8uaXNSdGwoKTtcbiAgICBjb25zdCBpc0ZsaXBSdGwgPSBCb29sZWFuKHRoaXMuYW5jaG9yQ29ybmVyXyAmIENvcm5lckJpdC5GTElQX1JUTCk7XG4gICAgY29uc3QgYXZvaWRIb3Jpem9udGFsT3ZlcmxhcCA9IEJvb2xlYW4odGhpcy5hbmNob3JDb3JuZXJfICYgQ29ybmVyQml0LlJJR0hUKTtcbiAgICBjb25zdCBpc0FsaWduZWRSaWdodCA9IChhdm9pZEhvcml6b250YWxPdmVybGFwICYmICFpc1J0bCkgfHxcbiAgICAgICghYXZvaWRIb3Jpem9udGFsT3ZlcmxhcCAmJiBpc0ZsaXBSdGwgJiYgaXNSdGwpO1xuICAgIGNvbnN0IGF2YWlsYWJsZUxlZnQgPSBpc0FsaWduZWRSaWdodCA/IHZpZXdwb3J0RGlzdGFuY2UubGVmdCArIGFuY2hvcldpZHRoICsgdGhpcy5hbmNob3JNYXJnaW5fLnJpZ2h0IDpcbiAgICAgIHZpZXdwb3J0RGlzdGFuY2UubGVmdCArIHRoaXMuYW5jaG9yTWFyZ2luXy5sZWZ0O1xuICAgIGNvbnN0IGF2YWlsYWJsZVJpZ2h0ID0gaXNBbGlnbmVkUmlnaHQgPyB2aWV3cG9ydERpc3RhbmNlLnJpZ2h0IC0gdGhpcy5hbmNob3JNYXJnaW5fLnJpZ2h0IDpcbiAgICAgIHZpZXdwb3J0RGlzdGFuY2UucmlnaHQgKyBhbmNob3JXaWR0aCAtIHRoaXMuYW5jaG9yTWFyZ2luXy5sZWZ0O1xuXG4gICAgY29uc3QgbGVmdE92ZXJmbG93ID0gbWVudVdpZHRoIC0gYXZhaWxhYmxlTGVmdDtcbiAgICBjb25zdCByaWdodE92ZXJmbG93ID0gbWVudVdpZHRoIC0gYXZhaWxhYmxlUmlnaHQ7XG5cbiAgICBpZiAoKGxlZnRPdmVyZmxvdyA8IDAgJiYgaXNBbGlnbmVkUmlnaHQgJiYgaXNSdGwpIHx8XG4gICAgICAgIChhdm9pZEhvcml6b250YWxPdmVybGFwICYmICFpc0FsaWduZWRSaWdodCAmJiBsZWZ0T3ZlcmZsb3cgPCAwKSB8fFxuICAgICAgICAocmlnaHRPdmVyZmxvdyA+IDAgJiYgbGVmdE92ZXJmbG93IDwgcmlnaHRPdmVyZmxvdykpIHtcbiAgICAgIGNvcm5lciB8PSBDb3JuZXJCaXQuUklHSFQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvcm5lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Nvcm5lcn0gY29ybmVyIE9yaWdpbiBjb3JuZXIgb2YgdGhlIG1lbnUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gSG9yaXpvbnRhbCBvZmZzZXQgb2YgbWVudSBvcmlnaW4gY29ybmVyIGZyb20gY29ycmVzcG9uZGluZyBhbmNob3IgY29ybmVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0SG9yaXpvbnRhbE9yaWdpbk9mZnNldF8oY29ybmVyKSB7XG4gICAgY29uc3Qge2FuY2hvcldpZHRofSA9IHRoaXMubWVhc3VyZXNfO1xuICAgIGNvbnN0IGlzUmlnaHRBbGlnbmVkID0gQm9vbGVhbihjb3JuZXIgJiBDb3JuZXJCaXQuUklHSFQpO1xuICAgIGNvbnN0IGF2b2lkSG9yaXpvbnRhbE92ZXJsYXAgPSBCb29sZWFuKHRoaXMuYW5jaG9yQ29ybmVyXyAmIENvcm5lckJpdC5SSUdIVCk7XG4gICAgbGV0IHggPSAwO1xuICAgIGlmIChpc1JpZ2h0QWxpZ25lZCkge1xuICAgICAgY29uc3QgcmlnaHRPZmZzZXQgPSBhdm9pZEhvcml6b250YWxPdmVybGFwID8gYW5jaG9yV2lkdGggLSB0aGlzLmFuY2hvck1hcmdpbl8ubGVmdCA6IHRoaXMuYW5jaG9yTWFyZ2luXy5yaWdodDtcbiAgICAgIHggPSByaWdodE9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGVmdE9mZnNldCA9IGF2b2lkSG9yaXpvbnRhbE92ZXJsYXAgPyBhbmNob3JXaWR0aCAtIHRoaXMuYW5jaG9yTWFyZ2luXy5yaWdodCA6IHRoaXMuYW5jaG9yTWFyZ2luXy5sZWZ0O1xuICAgICAgeCA9IGxlZnRPZmZzZXQ7XG4gICAgfVxuICAgIHJldHVybiB4O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29ybmVyfSBjb3JuZXIgT3JpZ2luIGNvcm5lciBvZiB0aGUgbWVudS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBWZXJ0aWNhbCBvZmZzZXQgb2YgbWVudSBvcmlnaW4gY29ybmVyIGZyb20gY29ycmVzcG9uZGluZyBhbmNob3IgY29ybmVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0VmVydGljYWxPcmlnaW5PZmZzZXRfKGNvcm5lcikge1xuICAgIGNvbnN0IHt2aWV3cG9ydCwgdmlld3BvcnREaXN0YW5jZSwgYW5jaG9ySGVpZ2h0LCBtZW51SGVpZ2h0fSA9IHRoaXMubWVhc3VyZXNfO1xuICAgIGNvbnN0IGlzQm90dG9tQWxpZ25lZCA9IEJvb2xlYW4oY29ybmVyICYgQ29ybmVyQml0LkJPVFRPTSk7XG4gICAgY29uc3Qge01BUkdJTl9UT19FREdFfSA9IE1EQ01lbnVGb3VuZGF0aW9uLm51bWJlcnM7XG4gICAgY29uc3QgYXZvaWRWZXJ0aWNhbE92ZXJsYXAgPSBCb29sZWFuKHRoaXMuYW5jaG9yQ29ybmVyXyAmIENvcm5lckJpdC5CT1RUT00pO1xuICAgIGNvbnN0IGNhbk92ZXJsYXBWZXJ0aWNhbGx5ID0gIWF2b2lkVmVydGljYWxPdmVybGFwO1xuICAgIGxldCB5ID0gMDtcblxuICAgIGlmIChpc0JvdHRvbUFsaWduZWQpIHtcbiAgICAgIHkgPSBhdm9pZFZlcnRpY2FsT3ZlcmxhcCA/IGFuY2hvckhlaWdodCAtIHRoaXMuYW5jaG9yTWFyZ2luXy50b3AgOiAtdGhpcy5hbmNob3JNYXJnaW5fLmJvdHRvbTtcbiAgICAgIC8vIGFkanVzdCBmb3Igd2hlbiBtZW51IGNhbiBvdmVybGFwIGFuY2hvciwgYnV0IHRvbyB0YWxsIHRvIGJlIGFsaWduZWQgdG8gYm90dG9tXG4gICAgICAvLyBhbmNob3IgY29ybmVyLiBCb3R0b20gbWFyZ2luIGlzIGlnbm9yZWQgaW4gc3VjaCBjYXNlcy5cbiAgICAgIGlmIChjYW5PdmVybGFwVmVydGljYWxseSAmJiBtZW51SGVpZ2h0ID4gdmlld3BvcnREaXN0YW5jZS50b3AgKyBhbmNob3JIZWlnaHQpIHtcbiAgICAgICAgeSA9IC0oTWF0aC5taW4obWVudUhlaWdodCwgdmlld3BvcnQuaGVpZ2h0IC0gTUFSR0lOX1RPX0VER0UpIC0gKHZpZXdwb3J0RGlzdGFuY2UudG9wICsgYW5jaG9ySGVpZ2h0KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgPSBhdm9pZFZlcnRpY2FsT3ZlcmxhcCA/IChhbmNob3JIZWlnaHQgKyB0aGlzLmFuY2hvck1hcmdpbl8uYm90dG9tKSA6IHRoaXMuYW5jaG9yTWFyZ2luXy50b3A7XG4gICAgICAvLyBhZGp1c3QgZm9yIHdoZW4gbWVudSBjYW4gb3ZlcmxhcCBhbmNob3IsIGJ1dCB0b28gdGFsbCB0byBiZSBhbGlnbmVkIHRvIHRvcFxuICAgICAgLy8gYW5jaG9yIGNvcm5lcnMuIFRvcCBtYXJnaW4gaXMgaWdub3JlZCBpbiB0aGF0IGNhc2UuXG4gICAgICBpZiAoY2FuT3ZlcmxhcFZlcnRpY2FsbHkgJiYgbWVudUhlaWdodCA+IHZpZXdwb3J0RGlzdGFuY2UuYm90dG9tICsgYW5jaG9ySGVpZ2h0KSB7XG4gICAgICAgIHkgPSAtKE1hdGgubWluKG1lbnVIZWlnaHQsIHZpZXdwb3J0LmhlaWdodCAtIE1BUkdJTl9UT19FREdFKSAtICh2aWV3cG9ydERpc3RhbmNlLmJvdHRvbSArIGFuY2hvckhlaWdodCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Nvcm5lcn0gY29ybmVyIE9yaWdpbiBjb3JuZXIgb2YgdGhlIG1lbnUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTWF4aW11bSBoZWlnaHQgb2YgdGhlIG1lbnUsIGJhc2VkIG9uIGF2YWlsYWJsZSBzcGFjZS4gMCBpbmRpY2F0ZXMgc2hvdWxkIG5vdCBiZSBzZXQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRNZW51TWF4SGVpZ2h0Xyhjb3JuZXIpIHtcbiAgICBsZXQgbWF4SGVpZ2h0ID0gMDtcbiAgICBjb25zdCB7dmlld3BvcnREaXN0YW5jZX0gPSB0aGlzLm1lYXN1cmVzXztcbiAgICBjb25zdCBpc0JvdHRvbUFsaWduZWQgPSBCb29sZWFuKGNvcm5lciAmIENvcm5lckJpdC5CT1RUT00pO1xuXG4gICAgLy8gV2hlbiBtYXhpbXVtIGhlaWdodCBpcyBub3Qgc3BlY2lmaWVkLCBpdCBpcyBoYW5kbGVkIGZyb20gY3NzLlxuICAgIGlmICh0aGlzLmFuY2hvckNvcm5lcl8gJiBDb3JuZXJCaXQuQk9UVE9NKSB7XG4gICAgICBpZiAoaXNCb3R0b21BbGlnbmVkKSB7XG4gICAgICAgIG1heEhlaWdodCA9IHZpZXdwb3J0RGlzdGFuY2UudG9wICsgdGhpcy5hbmNob3JNYXJnaW5fLnRvcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heEhlaWdodCA9IHZpZXdwb3J0RGlzdGFuY2UuYm90dG9tIC0gdGhpcy5hbmNob3JNYXJnaW5fLmJvdHRvbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF4SGVpZ2h0O1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGF1dG9Qb3NpdGlvbl8oKSB7XG4gICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmhhc0FuY2hvcigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBtZWFzdXJlbWVudHMgZm9yIGF1dG9wb3NpdGlvbiBtZXRob2RzIHJldXNlLlxuICAgIHRoaXMubWVhc3VyZXNfID0gdGhpcy5nZXRBdXRvTGF5b3V0TWVhc3VyZW1lbnRzXygpO1xuXG4gICAgY29uc3QgY29ybmVyID0gdGhpcy5nZXRPcmlnaW5Db3JuZXJfKCk7XG4gICAgY29uc3QgbWF4TWVudUhlaWdodCA9IHRoaXMuZ2V0TWVudU1heEhlaWdodF8oY29ybmVyKTtcbiAgICBsZXQgdmVydGljYWxBbGlnbm1lbnQgPSAoY29ybmVyICYgQ29ybmVyQml0LkJPVFRPTSkgPyAnYm90dG9tJyA6ICd0b3AnO1xuICAgIGxldCBob3Jpem9udGFsQWxpZ25tZW50ID0gKGNvcm5lciAmIENvcm5lckJpdC5SSUdIVCkgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgIGNvbnN0IGhvcml6b250YWxPZmZzZXQgPSB0aGlzLmdldEhvcml6b250YWxPcmlnaW5PZmZzZXRfKGNvcm5lcik7XG4gICAgY29uc3QgdmVydGljYWxPZmZzZXQgPSB0aGlzLmdldFZlcnRpY2FsT3JpZ2luT2Zmc2V0Xyhjb3JuZXIpO1xuICAgIGNvbnN0IHBvc2l0aW9uID0ge1xuICAgICAgW2hvcml6b250YWxBbGlnbm1lbnRdOiBob3Jpem9udGFsT2Zmc2V0ID8gaG9yaXpvbnRhbE9mZnNldCArICdweCcgOiAnMCcsXG4gICAgICBbdmVydGljYWxBbGlnbm1lbnRdOiB2ZXJ0aWNhbE9mZnNldCA/IHZlcnRpY2FsT2Zmc2V0ICsgJ3B4JyA6ICcwJyxcbiAgICB9O1xuICAgIGNvbnN0IHthbmNob3JXaWR0aCwgbWVudUhlaWdodCwgbWVudVdpZHRofSA9IHRoaXMubWVhc3VyZXNfO1xuICAgIC8vIENlbnRlciBhbGlnbiB3aGVuIGFuY2hvciB3aWR0aCBpcyBjb21wYXJhYmxlIG9yIGdyZWF0ZXIgdGhhbiBtZW51LCBvdGhlcndpc2Uga2VlcCBjb3JuZXIuXG4gICAgaWYgKGFuY2hvcldpZHRoIC8gbWVudVdpZHRoID4gbnVtYmVycy5BTkNIT1JfVE9fTUVOVV9XSURUSF9SQVRJTykge1xuICAgICAgaG9yaXpvbnRhbEFsaWdubWVudCA9ICdjZW50ZXInO1xuICAgIH1cblxuICAgIC8vIEFkanVzdCB2ZXJ0aWNhbCBvcmlnaW4gd2hlbiBtZW51IGlzIHBvc2l0aW9uZWQgd2l0aCBzaWduaWZpY2FudCBvZmZzZXQgZnJvbSBhbmNob3IuIFRoaXMgaXMgZG9uZSBzbyB0aGF0XG4gICAgLy8gc2NhbGUgYW5pbWF0aW9uIGlzIFwiYW5jaG9yZWRcIiBvbiB0aGUgYW5jaG9yLlxuICAgIGlmICghKHRoaXMuYW5jaG9yQ29ybmVyXyAmIENvcm5lckJpdC5CT1RUT00pICYmXG4gICAgICAgIE1hdGguYWJzKHZlcnRpY2FsT2Zmc2V0IC8gbWVudUhlaWdodCkgPiBudW1iZXJzLk9GRlNFVF9UT19NRU5VX0hFSUdIVF9SQVRJTykge1xuICAgICAgY29uc3QgdmVydGljYWxPZmZzZXRQZXJjZW50ID0gTWF0aC5hYnModmVydGljYWxPZmZzZXQgLyBtZW51SGVpZ2h0KSAqIDEwMDtcbiAgICAgIGNvbnN0IG9yaWdpblBlcmNlbnQgPSAoY29ybmVyICYgQ29ybmVyQml0LkJPVFRPTSkgPyAxMDAgLSB2ZXJ0aWNhbE9mZnNldFBlcmNlbnQgOiB2ZXJ0aWNhbE9mZnNldFBlcmNlbnQ7XG4gICAgICB2ZXJ0aWNhbEFsaWdubWVudCA9IE1hdGgucm91bmQob3JpZ2luUGVyY2VudCAqIDEwMCkgLyAxMDAgKyAnJSc7XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy5zZXRUcmFuc2Zvcm1PcmlnaW4oYCR7aG9yaXpvbnRhbEFsaWdubWVudH0gJHt2ZXJ0aWNhbEFsaWdubWVudH1gKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldE1heEhlaWdodChtYXhNZW51SGVpZ2h0ID8gbWF4TWVudUhlaWdodCArICdweCcgOiAnJyk7XG5cbiAgICAvLyBDbGVhciBtZWFzdXJlcyBhZnRlciBwb3NpdGlvbmluZyBpcyBjb21wbGV0ZS5cbiAgICB0aGlzLm1lYXN1cmVzXyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogT3BlbiB0aGUgbWVudS5cbiAgICogQHBhcmFtIHt7Zm9jdXNJbmRleDogP251bWJlcn09fSBvcHRpb25zXG4gICAqL1xuICBvcGVuKHtmb2N1c0luZGV4ID0gbnVsbH0gPSB7fSkge1xuICAgIHRoaXMuYWRhcHRlcl8uc2F2ZUZvY3VzKCk7XG5cbiAgICBpZiAoIXRoaXMucXVpY2tPcGVuXykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENNZW51Rm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElOR19PUEVOKTtcbiAgICB9XG5cbiAgICB0aGlzLmFuaW1hdGlvblJlcXVlc3RJZF8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5kaW1lbnNpb25zXyA9IHRoaXMuYWRhcHRlcl8uZ2V0SW5uZXJEaW1lbnNpb25zKCk7XG4gICAgICB0aGlzLmF1dG9Qb3NpdGlvbl8oKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDTWVudUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5PUEVOKTtcbiAgICAgIHRoaXMuZm9jdXNPbk9wZW5fKGZvY3VzSW5kZXgpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckJvZHlDbGlja0hhbmRsZXIodGhpcy5kb2N1bWVudENsaWNrSGFuZGxlcl8pO1xuICAgICAgaWYgKCF0aGlzLnF1aWNrT3Blbl8pIHtcbiAgICAgICAgdGhpcy5vcGVuQW5pbWF0aW9uRW5kVGltZXJJZF8gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLm9wZW5BbmltYXRpb25FbmRUaW1lcklkXyA9IDA7XG4gICAgICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENNZW51Rm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElOR19PUEVOKTtcbiAgICAgICAgfSwgbnVtYmVycy5UUkFOU0lUSU9OX09QRU5fRFVSQVRJT04pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuaXNPcGVuXyA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBtZW51LlxuICAgKiBAcGFyYW0ge0V2ZW50PX0gZXZ0XG4gICAqL1xuICBjbG9zZShldnQgPSBudWxsKSB7XG4gICAgY29uc3QgdGFyZ2V0SXNEaXNhYmxlZCA9IGV2dCA/XG4gICAgICB0aGlzLmFkYXB0ZXJfLmdldEF0dHJpYnV0ZUZvckV2ZW50VGFyZ2V0KGV2dC50YXJnZXQsIHN0cmluZ3MuQVJJQV9ESVNBQkxFRF9BVFRSKSA9PT0gJ3RydWUnIDpcbiAgICAgIGZhbHNlO1xuXG4gICAgaWYgKHRhcmdldElzRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJCb2R5Q2xpY2tIYW5kbGVyKHRoaXMuZG9jdW1lbnRDbGlja0hhbmRsZXJfKTtcblxuICAgIGlmICghdGhpcy5xdWlja09wZW5fKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ01lbnVGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQU5JTUFUSU5HX0NMT1NFRCk7XG4gICAgfVxuXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDTWVudUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5PUEVOKTtcbiAgICAgIGlmICghdGhpcy5xdWlja09wZW5fKSB7XG4gICAgICAgIHRoaXMuY2xvc2VBbmltYXRpb25FbmRUaW1lcklkXyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuY2xvc2VBbmltYXRpb25FbmRUaW1lcklkXyA9IDA7XG4gICAgICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENNZW51Rm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElOR19DTE9TRUQpO1xuICAgICAgICB9LCBudW1iZXJzLlRSQU5TSVRJT05fQ0xPU0VfRFVSQVRJT04pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuaXNPcGVuXyA9IGZhbHNlO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVzdG9yZUZvY3VzKCk7XG4gIH1cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLmlzT3Blbl87XG4gIH1cblxuICAvKiogQHJldHVybiB7bnVtYmVyfSAqL1xuICBnZXRTZWxlY3RlZEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGVkSW5kZXhfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBvZiB0aGUgaXRlbSB0byBzZXQgYXMgc2VsZWN0ZWQuXG4gICAqL1xuICBzZXRTZWxlY3RlZEluZGV4KGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSB0aGlzLnNlbGVjdGVkSW5kZXhfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcHJldlNlbGVjdGVkSW5kZXggPSB0aGlzLnNlbGVjdGVkSW5kZXhfO1xuICAgIGlmIChwcmV2U2VsZWN0ZWRJbmRleCA+PSAwKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJtQXR0ckZvck9wdGlvbkF0SW5kZXgocHJldlNlbGVjdGVkSW5kZXgsICdhcmlhLXNlbGVjdGVkJyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJtQ2xhc3NGb3JPcHRpb25BdEluZGV4KHByZXZTZWxlY3RlZEluZGV4LCBjc3NDbGFzc2VzLlNFTEVDVEVEX0xJU1RfSVRFTSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZWxlY3RlZEluZGV4XyA9IGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLmFkYXB0ZXJfLmdldE51bWJlck9mSXRlbXMoKSA/IGluZGV4IDogLTE7XG4gICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmRleF8gPj0gMCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyRm9yT3B0aW9uQXRJbmRleCh0aGlzLnNlbGVjdGVkSW5kZXhfLCAnYXJpYS1zZWxlY3RlZCcsICd0cnVlJyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzRm9yT3B0aW9uQXRJbmRleCh0aGlzLnNlbGVjdGVkSW5kZXhfLCBjc3NDbGFzc2VzLlNFTEVDVEVEX0xJU1RfSVRFTSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7TURDTWVudUZvdW5kYXRpb24sIEFuY2hvck1hcmdpbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9ICovXG5sZXQgc3RvcmVkVHJhbnNmb3JtUHJvcGVydHlOYW1lXztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBjb3JyZWN0IHRyYW5zZm9ybSBwcm9wZXJ0eSB0byB1c2Ugb24gdGhlIGN1cnJlbnQgYnJvd3Nlci5cbiAqIEBwYXJhbSB7IVdpbmRvd30gZ2xvYmFsT2JqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBmb3JjZVJlZnJlc2hcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtUHJvcGVydHlOYW1lKGdsb2JhbE9iaiwgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgaWYgKHN0b3JlZFRyYW5zZm9ybVByb3BlcnR5TmFtZV8gPT09IHVuZGVmaW5lZCB8fCBmb3JjZVJlZnJlc2gpIHtcbiAgICBjb25zdCBlbCA9IGdsb2JhbE9iai5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb25zdCB0cmFuc2Zvcm1Qcm9wZXJ0eU5hbWUgPSAoJ3RyYW5zZm9ybScgaW4gZWwuc3R5bGUgPyAndHJhbnNmb3JtJyA6ICd3ZWJraXRUcmFuc2Zvcm0nKTtcbiAgICBzdG9yZWRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWVfID0gdHJhbnNmb3JtUHJvcGVydHlOYW1lO1xuICB9XG5cbiAgcmV0dXJuIHN0b3JlZFRyYW5zZm9ybVByb3BlcnR5TmFtZV87XG59XG5cbi8qKlxuICogQ2xhbXBzIGEgdmFsdWUgYmV0d2VlbiB0aGUgbWluaW11bSBhbmQgdGhlIG1heGltdW0sIHJldHVybmluZyB0aGUgY2xhbXBlZCB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluID0gMCwgbWF4ID0gMSkge1xuICByZXR1cm4gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHZhbHVlKSk7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlYXNpbmcgdmFsdWUgdG8gYXBwbHkgYXQgdGltZSB0LCBmb3IgYSBnaXZlbiBjdWJpYyBiZXppZXIgY3VydmUuXG4gKiBDb250cm9sIHBvaW50cyBQMCBhbmQgUDMgYXJlIGFzc3VtZWQgdG8gYmUgKDAsMCkgYW5kICgxLDEpLCByZXNwZWN0aXZlbHkuXG4gKiBQYXJhbWV0ZXJzIGFyZSBhcyBmb2xsb3dzOlxuICogLSB0aW1lOiBUaGUgY3VycmVudCB0aW1lIGluIHRoZSBhbmltYXRpb24sIHNjYWxlZCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiAtIHgxOiBUaGUgeCB2YWx1ZSBvZiBjb250cm9sIHBvaW50IFAxLlxuICogLSB5MTogVGhlIHkgdmFsdWUgb2YgY29udHJvbCBwb2ludCBQMS5cbiAqIC0geDI6IFRoZSB4IHZhbHVlIG9mIGNvbnRyb2wgcG9pbnQgUDIuXG4gKiAtIHkyOiBUaGUgeSB2YWx1ZSBvZiBjb250cm9sIHBvaW50IFAyLlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gKiBAcGFyYW0ge251bWJlcn0geDJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBiZXppZXJQcm9ncmVzcyh0aW1lLCB4MSwgeTEsIHgyLCB5Mikge1xuICByZXR1cm4gZ2V0QmV6aWVyQ29vcmRpbmF0ZV8oc29sdmVQb3NpdGlvbkZyb21YVmFsdWVfKHRpbWUsIHgxLCB4MiksIHkxLCB5Mik7XG59XG5cbi8qKlxuICogQ29tcHV0ZSBhIHNpbmdsZSBjb29yZGluYXRlIGF0IGEgcG9zaXRpb24gcG9pbnQgYmV0d2VlbiAwIGFuZCAxLlxuICogYzEgYW5kIGMyIGFyZSB0aGUgbWF0Y2hpbmcgY29vcmRpbmF0ZSBvbiBjb250cm9sIHBvaW50cyBQMSBhbmQgUDIsIHJlc3BlY3RpdmVseS5cbiAqIENvbnRyb2wgcG9pbnRzIFAwIGFuZCBQMyBhcmUgYXNzdW1lZCB0byBiZSAoMCwwKSBhbmQgKDEsMSksIHJlc3BlY3RpdmVseS5cbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtbGlicmFyeS9ibG9iL21hc3Rlci9jbG9zdXJlL2dvb2cvbWF0aC9iZXppZXIuanMuXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHBhcmFtIHtudW1iZXJ9IGMxXG4gKiBAcGFyYW0ge251bWJlcn0gYzJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0QmV6aWVyQ29vcmRpbmF0ZV8odCwgYzEsIGMyKSB7XG4gIC8vIFNwZWNpYWwgY2FzZSBzdGFydCBhbmQgZW5kLlxuICBpZiAodCA9PT0gMCB8fCB0ID09PSAxKSB7XG4gICAgcmV0dXJuIHQ7XG4gIH1cblxuICAvLyBTdGVwIG9uZSAtIGZyb20gNCBwb2ludHMgdG8gM1xuICBsZXQgaWMwID0gdCAqIGMxO1xuICBsZXQgaWMxID0gYzEgKyB0ICogKGMyIC0gYzEpO1xuICBjb25zdCBpYzIgPSBjMiArIHQgKiAoMSAtIGMyKTtcblxuICAvLyBTdGVwIHR3byAtIGZyb20gMyBwb2ludHMgdG8gMlxuICBpYzAgKz0gdCAqIChpYzEgLSBpYzApO1xuICBpYzEgKz0gdCAqIChpYzIgLSBpYzEpO1xuXG4gIC8vIEZpbmFsIHN0ZXAgLSBsYXN0IHBvaW50XG4gIHJldHVybiBpYzAgKyB0ICogKGljMSAtIGljMCk7XG59XG5cbi8qKlxuICogUHJvamVjdCBhIHBvaW50IG9udG8gdGhlIEJlemllciBjdXJ2ZSwgZnJvbSBhIGdpdmVuIFguIENhbGN1bGF0ZXMgdGhlIHBvc2l0aW9uIHQgYWxvbmcgdGhlIGN1cnZlLlxuICogQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1saWJyYXJ5L2Jsb2IvbWFzdGVyL2Nsb3N1cmUvZ29vZy9tYXRoL2Jlemllci5qcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4VmFsXG4gKiBAcGFyYW0ge251bWJlcn0geDFcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBzb2x2ZVBvc2l0aW9uRnJvbVhWYWx1ZV8oeFZhbCwgeDEsIHgyKSB7XG4gIGNvbnN0IEVQU0lMT04gPSAxZS02O1xuICBjb25zdCBNQVhfSVRFUkFUSU9OUyA9IDg7XG5cbiAgaWYgKHhWYWwgPD0gMCkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2UgaWYgKHhWYWwgPj0gMSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLy8gSW5pdGlhbCBlc3RpbWF0ZSBvZiB0IHVzaW5nIGxpbmVhciBpbnRlcnBvbGF0aW9uLlxuICBsZXQgdCA9IHhWYWw7XG5cbiAgLy8gVHJ5IGdyYWRpZW50IGRlc2NlbnQgdG8gc29sdmUgZm9yIHQuIElmIGl0IHdvcmtzLCBpdCBpcyB2ZXJ5IGZhc3QuXG4gIGxldCB0TWluID0gMDtcbiAgbGV0IHRNYXggPSAxO1xuICBsZXQgdmFsdWUgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IE1BWF9JVEVSQVRJT05TOyBpKyspIHtcbiAgICB2YWx1ZSA9IGdldEJlemllckNvb3JkaW5hdGVfKHQsIHgxLCB4Mik7XG4gICAgY29uc3QgZGVyaXZhdGl2ZSA9IChnZXRCZXppZXJDb29yZGluYXRlXyh0ICsgRVBTSUxPTiwgeDEsIHgyKSAtIHZhbHVlKSAvIEVQU0lMT047XG4gICAgaWYgKE1hdGguYWJzKHZhbHVlIC0geFZhbCkgPCBFUFNJTE9OKSB7XG4gICAgICByZXR1cm4gdDtcbiAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGRlcml2YXRpdmUpIDwgRVBTSUxPTikge1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2YWx1ZSA8IHhWYWwpIHtcbiAgICAgICAgdE1pbiA9IHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0TWF4ID0gdDtcbiAgICAgIH1cbiAgICAgIHQgLT0gKHZhbHVlIC0geFZhbCkgLyBkZXJpdmF0aXZlO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZSBncmFkaWVudCBkZXNjZW50IGdvdCBzdHVjayBpbiBhIGxvY2FsIG1pbmltdW0sIGUuZy4gYmVjYXVzZVxuICAvLyB0aGUgZGVyaXZhdGl2ZSB3YXMgY2xvc2UgdG8gMCwgdXNlIGEgRGljaG90b215IHJlZmluZW1lbnQgaW5zdGVhZC5cbiAgLy8gV2UgbGltaXQgdGhlIG51bWJlciBvZiBpbnRlcmF0aW9ucyB0byA4LlxuICBmb3IgKGxldCBpID0gMDsgTWF0aC5hYnModmFsdWUgLSB4VmFsKSA+IEVQU0lMT04gJiYgaSA8IE1BWF9JVEVSQVRJT05TOyBpKyspIHtcbiAgICBpZiAodmFsdWUgPCB4VmFsKSB7XG4gICAgICB0TWluID0gdDtcbiAgICAgIHQgPSAodCArIHRNYXgpIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgdE1heCA9IHQ7XG4gICAgICB0ID0gKHQgKyB0TWluKSAvIDI7XG4gICAgfVxuICAgIHZhbHVlID0gZ2V0QmV6aWVyQ29vcmRpbmF0ZV8odCwgeDEsIHgyKTtcbiAgfVxuICByZXR1cm4gdDtcbn1cblxuZXhwb3J0IHtnZXRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWUsIGNsYW1wLCBiZXppZXJQcm9ncmVzc307XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgXG4gICAgcmVmPVwicm9vdFwiIFxuICAgIDpjbGFzcz1cImNsYXNzZXNcIiBcbiAgICA6c3R5bGU9XCJzdHlsZXNcIiBcbiAgICBjbGFzcz1cIm1kYy1tZW51IG1kYy1zaW1wbGUtbWVudVwiIFxuICAgIHRhYmluZGV4PVwiLTFcIj5cbiAgICA8dWwgXG4gICAgICByZWY9XCJpdGVtc1wiIFxuICAgICAgY2xhc3M9XCJtZGMtc2ltcGxlLW1lbnVfX2l0ZW1zIG1kYy1saXN0XCIgXG4gICAgICByb2xlPVwibWVudVwiIFxuICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCI+XG4gICAgICA8c2xvdC8+XG4gICAgPC91bD5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgTURDTWVudUZvdW5kYXRpb24gfSBmcm9tICdAbWF0ZXJpYWwvbWVudS9mb3VuZGF0aW9uJ1xuaW1wb3J0IHsgZ2V0VHJhbnNmb3JtUHJvcGVydHlOYW1lIH0gZnJvbSAnQG1hdGVyaWFsL21lbnUvdXRpbCdcbmltcG9ydCB7IGVtaXRDdXN0b21FdmVudCB9IGZyb20gJy4uL2Jhc2UnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1tZW51JyxcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAnb3BlbicsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgb3BlbjogW0Jvb2xlYW4sIE9iamVjdF0sXG4gICAgJ3F1aWNrLW9wZW4nOiBCb29sZWFuLFxuICAgICdhbmNob3ItY29ybmVyJzogW1N0cmluZywgTnVtYmVyXSxcbiAgICAnYW5jaG9yLW1hcmdpbic6IE9iamVjdFxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7fSxcbiAgICAgIHN0eWxlczoge30sXG4gICAgICBpdGVtczogW11cbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgb3BlbjogJ29uT3Blbl8nLFxuICAgIHF1aWNrT3Blbihudikge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldFF1aWNrT3BlbihudilcbiAgICB9LFxuICAgIGFuY2hvckNvcm5lcihudikge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldEFuY2hvckNvcm5lcihOdW1iZXIobnYpKVxuICAgIH0sXG4gICAgYW5jaG9yTWFyZ2luKG52KSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0QW5jaG9yTWFyZ2luKG52KVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICBjb25zdCByZWZyZXNoSXRlbXMgPSAoKSA9PiB7XG4gICAgICB0aGlzLml0ZW1zID0gW10uc2xpY2UuY2FsbChcbiAgICAgICAgdGhpcy4kcmVmcy5pdGVtcy5xdWVyeVNlbGVjdG9yQWxsKCcubWRjLWxpc3QtaXRlbVtyb2xlXScpXG4gICAgICApXG4gICAgICB0aGlzLiRlbWl0KCd1cGRhdGUnKVxuICAgIH1cbiAgICB0aGlzLnNsb3RPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHJlZnJlc2hJdGVtcygpKVxuICAgIHRoaXMuc2xvdE9ic2VydmVyLm9ic2VydmUodGhpcy4kZWwsIHtcbiAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgIHN1YnRyZWU6IHRydWVcbiAgICB9KVxuXG4gICAgdGhpcy5fcHJldmlvdXNGb2N1cyA9IHVuZGVmaW5lZFxuXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ01lbnVGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kcmVmcy5yb290LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpLFxuICAgICAgaGFzTmVjZXNzYXJ5RG9tOiAoKSA9PiBCb29sZWFuKHRoaXMuJHJlZnMuaXRlbXMpLFxuICAgICAgZ2V0QXR0cmlidXRlRm9yRXZlbnRUYXJnZXQ6ICh0YXJnZXQsIGF0dHJpYnV0ZU5hbWUpID0+XG4gICAgICAgIHRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSksXG4gICAgICBnZXRJbm5lckRpbWVuc2lvbnM6ICgpID0+ICh7XG4gICAgICAgIHdpZHRoOiB0aGlzLiRyZWZzLml0ZW1zLm9mZnNldFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuJHJlZnMuaXRlbXMub2Zmc2V0SGVpZ2h0XG4gICAgICB9KSxcbiAgICAgIGhhc0FuY2hvcjogKCkgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5yb290LnBhcmVudEVsZW1lbnQgJiZcbiAgICAgICAgdGhpcy4kcmVmcy5yb290LnBhcmVudEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdtZGMtbWVudS1hbmNob3InKSxcbiAgICAgIGdldEFuY2hvckRpbWVuc2lvbnM6ICgpID0+XG4gICAgICAgIHRoaXMuJHJlZnMucm9vdC5wYXJlbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgZ2V0V2luZG93RGltZW5zaW9uczogKCkgPT4gKHtcbiAgICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodFxuICAgICAgfSksXG4gICAgICBnZXROdW1iZXJPZkl0ZW1zOiAoKSA9PiB0aGlzLml0ZW1zLmxlbmd0aCxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5yb290LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciksXG4gICAgICByZWdpc3RlckJvZHlDbGlja0hhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlckJvZHlDbGlja0hhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIpLFxuICAgICAgZ2V0SW5kZXhGb3JFdmVudFRhcmdldDogdGFyZ2V0ID0+IHRoaXMuaXRlbXMuaW5kZXhPZih0YXJnZXQpLFxuICAgICAgbm90aWZ5U2VsZWN0ZWQ6IGV2dERhdGEgPT4ge1xuICAgICAgICBjb25zdCBldnQgPSB7XG4gICAgICAgICAgaW5kZXg6IGV2dERhdGEuaW5kZXgsXG4gICAgICAgICAgaXRlbTogdGhpcy5pdGVtc1tldnREYXRhLmluZGV4XVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGZhbHNlKVxuICAgICAgICB0aGlzLiRlbWl0KCdzZWxlY3QnLCBldnQpXG4gICAgICAgIGVtaXRDdXN0b21FdmVudCh0aGlzLiRlbCwgTURDTWVudUZvdW5kYXRpb24uc3RyaW5ncy5TRUxFQ1RFRF9FVkVOVCwgZXZ0KVxuICAgICAgfSxcbiAgICAgIG5vdGlmeUNhbmNlbDogKCkgPT4ge1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBmYWxzZSlcbiAgICAgICAgdGhpcy4kZW1pdCgnY2FuY2VsJylcbiAgICAgICAgZW1pdEN1c3RvbUV2ZW50KHRoaXMuJGVsLCBNRENNZW51Rm91bmRhdGlvbi5zdHJpbmdzLkNBTkNFTF9FVkVOVCwge30pXG4gICAgICB9LFxuICAgICAgc2F2ZUZvY3VzOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50XG4gICAgICB9LFxuICAgICAgcmVzdG9yZUZvY3VzOiAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9wcmV2aW91c0ZvY3VzKSB7XG4gICAgICAgICAgdGhpcy5fcHJldmlvdXNGb2N1cy5mb2N1cygpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpc0ZvY3VzZWQ6ICgpID0+IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuJHJlZnMucm9vdCxcbiAgICAgIGZvY3VzOiAoKSA9PiB0aGlzLiRyZWZzLnJvb3QuZm9jdXMoKSxcbiAgICAgIGdldEZvY3VzZWRJdGVtSW5kZXg6ICgpID0+IHRoaXMuaXRlbXMuaW5kZXhPZihkb2N1bWVudC5hY3RpdmVFbGVtZW50KSxcbiAgICAgIGZvY3VzSXRlbUF0SW5kZXg6IGluZGV4ID0+IHRoaXMuaXRlbXNbaW5kZXhdLmZvY3VzKCksXG4gICAgICBpc1J0bDogKCkgPT5cbiAgICAgICAgZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRyZWZzLnJvb3QpLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpID09PVxuICAgICAgICAncnRsJyxcbiAgICAgIHNldFRyYW5zZm9ybU9yaWdpbjogb3JpZ2luID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KFxuICAgICAgICAgIHRoaXMuc3R5bGVzLFxuICAgICAgICAgIGAke2dldFRyYW5zZm9ybVByb3BlcnR5TmFtZSh3aW5kb3cpfS1vcmlnaW5gLFxuICAgICAgICAgIG9yaWdpblxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgc2V0UG9zaXRpb246IHBvc2l0aW9uID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuc3R5bGVzLCAnbGVmdCcsIHBvc2l0aW9uLmxlZnQpXG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnN0eWxlcywgJ3JpZ2h0JywgcG9zaXRpb24ucmlnaHQpXG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnN0eWxlcywgJ3RvcCcsIHBvc2l0aW9uLnRvcClcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuc3R5bGVzLCAnYm90dG9tJywgcG9zaXRpb24uYm90dG9tKVxuICAgICAgfSxcbiAgICAgIHNldE1heEhlaWdodDogaGVpZ2h0ID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuc3R5bGVzLCAnbWF4LWhlaWdodCcsIGhlaWdodClcbiAgICAgIH0sXG4gICAgICBzZXRBdHRyRm9yT3B0aW9uQXRJbmRleDogKGluZGV4LCBhdHRyLCB2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLml0ZW1zW2luZGV4XS5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpXG4gICAgICB9LFxuICAgICAgcm1BdHRyRm9yT3B0aW9uQXRJbmRleDogKGluZGV4LCBhdHRyKSA9PiB7XG4gICAgICAgIHRoaXMuaXRlbXNbaW5kZXhdLnJlbW92ZUF0dHJpYnV0ZShhdHRyKVxuICAgICAgfSxcbiAgICAgIGFkZENsYXNzRm9yT3B0aW9uQXRJbmRleDogKGluZGV4LCBjbGFzc05hbWUpID0+IHtcbiAgICAgICAgdGhpcy5pdGVtc1tpbmRleF0uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgcm1DbGFzc0Zvck9wdGlvbkF0SW5kZXg6IChpbmRleCwgY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgIHRoaXMuaXRlbXNbaW5kZXhdLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZWZyZXNoSXRlbXMoKVxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgICBpZiAodGhpcy5hbmNob3JDb3JuZXIgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldEFuY2hvckNvcm5lcihOdW1iZXIodGhpcy5hbmNob3JDb3JuZXIpKVxuICAgIH1cbiAgICBpZiAodGhpcy5hbmNob3JNYXJnaW4gIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldEFuY2hvck1hcmdpbih0aGlzLmFuY2hvck1hcmdpbilcbiAgICB9XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5fcHJldmlvdXNGb2N1cyA9IG51bGxcbiAgICB0aGlzLnNsb3RPYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIG9uT3Blbl8odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24ub3Blbih0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gdmFsdWUgOiB2b2lkIDApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24uY2xvc2UoKVxuICAgICAgfVxuICAgIH0sXG4gICAgc2hvdyhvcHRpb25zKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24ub3BlbihvcHRpb25zKVxuICAgIH0sXG4gICAgaGlkZSgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5jbG9zZSgpXG4gICAgfSxcbiAgICBpc09wZW4oKSB7XG4gICAgICByZXR1cm4gdGhpcy5mb3VuZGF0aW9uID8gdGhpcy5mb3VuZGF0aW9uLmlzT3BlbigpIDogZmFsc2VcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8bGkgXG4gICAgOnRhYmluZGV4PVwiZGlzYWJsZWQ/Jy0xJzonMCdcIiBcbiAgICA6YXJpYS1kaXNhYmxlZD1cImRpc2FibGVkXCIgXG4gICAgY2xhc3M9XCJtZGMtbWVudS1pdGVtIG1kYy1saXN0LWl0ZW1cIlxuICAgIHJvbGU9XCJtZW51aXRlbVwiXG4gID5cbiAgICA8c2xvdC8+XG4gIDwvbGk+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLW1lbnUtaXRlbScsXG4gIHByb3BzOiB7XG4gICAgZGlzYWJsZWQ6IEJvb2xlYW5cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxsaSBcbiAgICByb2xlPVwic2VwYXJhdG9yXCIgXG4gICAgY2xhc3M9XCJtZGMtbWVudS1kaXZpZGVyIG1kYy1saXN0LWRpdmlkZXJcIi8+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLW1lbnUtZGl2aWRlcidcbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwibWRjLW1lbnUtYW5jaG9yXCI+XG4gICAgPHNsb3QvPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbWVudS1hbmNob3InXG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY01lbnUgZnJvbSAnLi9tZGMtbWVudS52dWUnXG5pbXBvcnQgbWRjTWVudUl0ZW0gZnJvbSAnLi9tZGMtbWVudS1pdGVtLnZ1ZSdcbmltcG9ydCBtZGNNZW51RGl2aWRlciBmcm9tICcuL21kYy1tZW51LWRpdmlkZXIudnVlJ1xuaW1wb3J0IG1kY01lbnVBbmNob3IgZnJvbSAnLi9tZGMtbWVudS1hbmNob3IudnVlJ1xuXG5leHBvcnQgeyBtZGNNZW51LCBtZGNNZW51SXRlbSwgbWRjTWVudURpdmlkZXIsIG1kY01lbnVBbmNob3IgfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjTWVudSxcbiAgbWRjTWVudUl0ZW0sXG4gIG1kY01lbnVEaXZpZGVyLFxuICBtZGNNZW51QW5jaG9yXG59KVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZX0gZnJvbSAnQG1hdGVyaWFsL3NlbGVjdGlvbi1jb250cm9sL2luZGV4JztcblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFJhZGlvLiBQcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIG1hbmFnaW5nXG4gKiAtIGNsYXNzZXNcbiAqIC0gZG9tXG4gKlxuICogQWRkaXRpb25hbGx5LCBwcm92aWRlcyB0eXBlIGluZm9ybWF0aW9uIGZvciB0aGUgYWRhcHRlciB0byB0aGUgQ2xvc3VyZVxuICogY29tcGlsZXIuXG4gKlxuICogSW1wbGVtZW50IHRoaXMgYWRhcHRlciBmb3IgeW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlIHRvIGRlbGVnYXRlIHVwZGF0ZXMgdG9cbiAqIHRoZSBjb21wb25lbnQgaW4geW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlLiBTZWUgYXJjaGl0ZWN0dXJlIGRvY3VtZW50YXRpb25cbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2NvZGUvYXJjaGl0ZWN0dXJlLm1kXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENSYWRpb0FkYXB0ZXIge1xuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHshTURDU2VsZWN0aW9uQ29udHJvbFN0YXRlfSAqL1xuICBnZXROYXRpdmVDb250cm9sKCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDUmFkaW9BZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgTkFUSVZFX0NPTlRST0xfU0VMRUNUT1I6ICcubWRjLXJhZGlvX19uYXRpdmUtY29udHJvbCcsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIFJPT1Q6ICdtZGMtcmFkaW8nLFxuICBESVNBQkxFRDogJ21kYy1yYWRpby0tZGlzYWJsZWQnLFxufTtcblxuZXhwb3J0IHtzdHJpbmdzLCBjc3NDbGFzc2VzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZX0gZnJvbSAnQG1hdGVyaWFsL3NlbGVjdGlvbi1jb250cm9sL2luZGV4JztcbmltcG9ydCBNRENSYWRpb0FkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENSYWRpb0FkYXB0ZXI+fVxuICovXG5jbGFzcyBNRENSYWRpb0ZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7Y3NzQ2xhc3Nlc30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nc30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4geyFNRENSYWRpb0FkYXB0ZXJ9ICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1JhZGlvQWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBnZXROYXRpdmVDb250cm9sOiAoKSA9PiAvKiAhTURDU2VsZWN0aW9uQ29udHJvbFN0YXRlICovIHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzQ2hlY2tlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVDb250cm9sXygpLmNoZWNrZWQ7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBjaGVja2VkICovXG4gIHNldENoZWNrZWQoY2hlY2tlZCkge1xuICAgIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS5jaGVja2VkID0gY2hlY2tlZDtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc0Rpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkuZGlzYWJsZWQ7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZCAqL1xuICBzZXREaXNhYmxlZChkaXNhYmxlZCkge1xuICAgIGNvbnN0IHtESVNBQkxFRH0gPSBNRENSYWRpb0ZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoRElTQUJMRUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKERJU0FCTEVEKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHJldHVybiB7P3N0cmluZ30gKi9cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS52YWx1ZTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlICovXG4gIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5nZXROYXRpdmVDb250cm9sXygpLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IU1EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldE5hdGl2ZUNvbnRyb2xfKCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmdldE5hdGl2ZUNvbnRyb2woKSB8fCB7XG4gICAgICBjaGVja2VkOiBmYWxzZSxcbiAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDUmFkaW9Gb3VuZGF0aW9uO1xuIiwiPHRlbXBsYXRlPlxuICA8ZGl2XG4gICAgOmNsYXNzPVwiZm9ybUZpZWxkQ2xhc3Nlc1wiXG4gICAgY2xhc3M9XCJtZGMtcmFkaW8td3JhcHBlclwiPlxuICAgIDxkaXZcbiAgICAgIHJlZj1cInJvb3RcIlxuICAgICAgOmNsYXNzPVwiY2xhc3Nlc1wiXG4gICAgICA6c3R5bGU9XCJzdHlsZXNcIlxuICAgICAgY2xhc3M9XCJtZGMtcmFkaW9cIj5cbiAgICAgIDxpbnB1dFxuICAgICAgICByZWY9XCJjb250cm9sXCJcbiAgICAgICAgOmlkPVwidm1hX3VpZF9cIlxuICAgICAgICA6bmFtZT1cIm5hbWVcIlxuICAgICAgICB0eXBlPVwicmFkaW9cIlxuICAgICAgICBjbGFzcz1cIm1kYy1yYWRpb19fbmF0aXZlLWNvbnRyb2xcIlxuICAgICAgICBAY2hhbmdlPVwic3luY1wiPlxuXG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzPVwibWRjLXJhZGlvX19iYWNrZ3JvdW5kXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJtZGMtcmFkaW9fX291dGVyLWNpcmNsZVwiLz5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm1kYy1yYWRpb19faW5uZXItY2lyY2xlXCIvPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGxhYmVsXG4gICAgICByZWY9XCJsYWJlbFwiXG4gICAgICA6Zm9yPVwidm1hX3VpZF9cIj48c2xvdD57eyBsYWJlbCB9fTwvc2xvdD48L2xhYmVsPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDUmFkaW9Gb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9yYWRpby9mb3VuZGF0aW9uJ1xuaW1wb3J0IE1EQ0Zvcm1GaWVsZEZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Zvcm0tZmllbGQvZm91bmRhdGlvbidcbmltcG9ydCB7IERpc3BhdGNoRm9jdXNNaXhpbiwgVk1BVW5pcXVlSWRNaXhpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgeyBSaXBwbGVCYXNlIH0gZnJvbSAnLi4vcmlwcGxlJ1xuaW1wb3J0IHsgYXBwbHlQYXNzaXZlIH0gZnJvbSAnLi4vYmFzZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXJhZGlvJyxcbiAgbWl4aW5zOiBbRGlzcGF0Y2hGb2N1c01peGluLCBWTUFVbmlxdWVJZE1peGluXSxcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAncGlja2VkJyxcbiAgICBldmVudDogJ2NoYW5nZSdcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBuYW1lOiB7IHR5cGU6IFN0cmluZywgcmVxdWlyZWQ6IHRydWUgfSxcbiAgICB2YWx1ZTogU3RyaW5nLFxuICAgIHBpY2tlZDogU3RyaW5nLFxuICAgIGNoZWNrZWQ6IEJvb2xlYW4sXG4gICAgbGFiZWw6IFN0cmluZyxcbiAgICAnYWxpZ24tZW5kJzogQm9vbGVhbixcbiAgICBkaXNhYmxlZDogQm9vbGVhblxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7fSxcbiAgICAgIHN0eWxlczoge30sXG4gICAgICBmb3JtRmllbGRDbGFzc2VzOiB7XG4gICAgICAgICdtZGMtZm9ybS1maWVsZCc6IHRoaXMubGFiZWwsXG4gICAgICAgICdtZGMtZm9ybS1maWVsZC0tYWxpZ24tZW5kJzogdGhpcy5sYWJlbCAmJiB0aGlzLmFsaWduRW5kXG4gICAgICB9XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGNoZWNrZWQ6ICdzZXRDaGVja2VkJyxcbiAgICBkaXNhYmxlZCh2YWx1ZSkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHZhbHVlKVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICAvLyBhZGQgZm91bmRhdGlvblxuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENSYWRpb0ZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpLFxuICAgICAgZ2V0TmF0aXZlQ29udHJvbDogKCkgPT4gdGhpcy4kcmVmcy5jb250cm9sXG4gICAgfSlcblxuICAgIC8vIGFkZCByaXBwbGVcbiAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMsIHtcbiAgICAgIGlzVW5ib3VuZGVkOiAoKSA9PiB0cnVlLFxuICAgICAgaXNTdXJmYWNlQWN0aXZlOiAoKSA9PiBmYWxzZSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuY29udHJvbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciwgYXBwbHlQYXNzaXZlKCkpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmNvbnRyb2wucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIsIGFwcGx5UGFzc2l2ZSgpKVxuICAgICAgfSxcbiAgICAgIGNvbXB1dGVCb3VuZGluZ1JlY3Q6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMucm9vdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLmZvcm1GaWVsZCA9IG5ldyBNRENGb3JtRmllbGRGb3VuZGF0aW9uKHtcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmxhYmVsLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmxhYmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBhY3RpdmF0ZUlucHV0UmlwcGxlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMucmlwcGxlICYmIHRoaXMucmlwcGxlLmFjdGl2YXRlKClcbiAgICAgIH0sXG4gICAgICBkZWFjdGl2YXRlSW5wdXRSaXBwbGU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5yaXBwbGUgJiYgdGhpcy5yaXBwbGUuZGVhY3RpdmF0ZSgpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgICB0aGlzLnJpcHBsZS5pbml0KClcbiAgICB0aGlzLmZvcm1GaWVsZC5pbml0KClcblxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXRWYWx1ZSh0aGlzLnZhbHVlIHx8IHRoaXMubGFiZWwpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldENoZWNrZWQoXG4gICAgICB0aGlzLmNoZWNrZWQgfHwgdGhpcy5waWNrZWQgPT0gdGhpcy5mb3VuZGF0aW9uLmdldFZhbHVlKClcbiAgICApXG5cbiAgICAvLyByZWZyZXNoIG1vZGVsXG4gICAgdGhpcy5jaGVja2VkICYmIHRoaXMuc3luYygpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5mb3JtRmllbGQuZGVzdHJveSgpXG4gICAgdGhpcy5yaXBwbGUuZGVzdHJveSgpXG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgc2V0Q2hlY2tlZChjaGVja2VkKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0Q2hlY2tlZChjaGVja2VkKVxuICAgIH0sXG4gICAgaXNDaGVja2VkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZm91bmRhdGlvbi5pc0NoZWNrZWQoKVxuICAgIH0sXG4gICAgc3luYygpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIHRoaXMuZm91bmRhdGlvbi5nZXRWYWx1ZSgpKVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNSYWRpbyBmcm9tICcuL21kYy1yYWRpby52dWUnXG5cbmV4cG9ydCB7IG1kY1JhZGlvIH1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY1JhZGlvXG59KVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBTZWxlY3QuIFByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgbWFuYWdpbmdcbiAqIC0gY2xhc3Nlc1xuICogLSBkb21cbiAqIC0gZXZlbnQgaGFuZGxlcnNcbiAqXG4gKiBBZGRpdGlvbmFsbHksIHByb3ZpZGVzIHR5cGUgaW5mb3JtYXRpb24gZm9yIHRoZSBhZGFwdGVyIHRvIHRoZSBDbG9zdXJlXG4gKiBjb21waWxlci5cbiAqXG4gKiBJbXBsZW1lbnQgdGhpcyBhZGFwdGVyIGZvciB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UgdG8gZGVsZWdhdGUgdXBkYXRlcyB0b1xuICogdGhlIGNvbXBvbmVudCBpbiB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UuIFNlZSBhcmNoaXRlY3R1cmUgZG9jdW1lbnRhdGlvblxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvY29kZS9hcmNoaXRlY3R1cmUubWRcbiAqXG4gKiBAcmVjb3JkXG4gKi9cblxuY2xhc3MgTURDU2VsZWN0QWRhcHRlciB7XG4gIC8qKlxuICAgKiBBZGRzIGNsYXNzIHRvIHJvb3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2xhc3MgZnJvbSB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcm9vdCBlbGVtZW50IGNvbnRhaW5zIHRoZSBnaXZlbiBjbGFzcyBuYW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyB0aGUgYm90dG9tIGxpbmUsIHNob3dpbmcgYSBmb2N1c2VkIHN0YXRlLlxuICAgKi9cbiAgYWN0aXZhdGVCb3R0b21MaW5lKCkge31cblxuICAvKipcbiAgICogRGVhY3RpdmF0ZXMgdGhlIGJvdHRvbSBsaW5lLlxuICAgKi9cbiAgZGVhY3RpdmF0ZUJvdHRvbUxpbmUoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzZWxlY3RlZCB2YWx1ZSBvZiB0aGUgc2VsZWN0IGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldFZhbHVlKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHJvb3QgZWxlbWVudCBpcyBzZXQgdG8gUlRMLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNSdGwoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgbGFiZWwgZWxlbWVudCBleGlzdHMsIGZhbHNlIGlmIGl0IGRvZXNuJ3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNMYWJlbCgpIHt9XG5cbiAgLyoqXG4gICAqIEZsb2F0cyBsYWJlbCBkZXRlcm1pbmVkIGJhc2VkIG9mZiBvZiB0aGUgc2hvdWxkRmxvYXQgYXJndW1lbnQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkRmxvYXRcbiAgICovXG4gIGZsb2F0TGFiZWwoc2hvdWxkRmxvYXQpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2lkdGggb2YgbGFiZWwgaW4gcGl4ZWxzLCBpZiB0aGUgbGFiZWwgZXhpc3RzLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMYWJlbFdpZHRoKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIG91dGxpbmUgZWxlbWVudCBleGlzdHMsIGZhbHNlIGlmIGl0IGRvZXNuJ3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNPdXRsaW5lKCkge31cblxuICAvKipcbiAgICogVXBkYXRlcyBTVkcgUGF0aCBhbmQgb3V0bGluZSBlbGVtZW50IGJhc2VkIG9uIHRoZVxuICAgKiBsYWJlbCBlbGVtZW50IHdpZHRoIGFuZCBSVEwgY29udGV4dCwgaWYgdGhlIG91dGxpbmUgZXhpc3RzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGFiZWxXaWR0aFxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpc1J0bFxuICAgKi9cbiAgbm90Y2hPdXRsaW5lKGxhYmVsV2lkdGgsIGlzUnRsKSB7fVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgbm90Y2ggaW4gb3V0bGluZSBlbGVtZW50LCBpZiB0aGUgb3V0bGluZSBleGlzdHMuXG4gICAqL1xuICBjbG9zZU91dGxpbmUoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENTZWxlY3RBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgQk9YOiAnbWRjLXNlbGVjdC0tYm94JyxcbiAgRElTQUJMRUQ6ICdtZGMtc2VsZWN0LS1kaXNhYmxlZCcsXG4gIFJPT1Q6ICdtZGMtc2VsZWN0JyxcbiAgT1VUTElORUQ6ICdtZGMtc2VsZWN0LS1vdXRsaW5lZCcsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIENIQU5HRV9FVkVOVDogJ01EQ1NlbGVjdDpjaGFuZ2UnLFxuICBMSU5FX1JJUFBMRV9TRUxFQ1RPUjogJy5tZGMtbGluZS1yaXBwbGUnLFxuICBMQUJFTF9TRUxFQ1RPUjogJy5tZGMtZmxvYXRpbmctbGFiZWwnLFxuICBOQVRJVkVfQ09OVFJPTF9TRUxFQ1RPUjogJy5tZGMtc2VsZWN0X19uYXRpdmUtY29udHJvbCcsXG4gIE9VVExJTkVfU0VMRUNUT1I6ICcubWRjLW5vdGNoZWQtb3V0bGluZScsXG59O1xuXG4vKiogQGVudW0ge251bWJlcn0gKi9cbmNvbnN0IG51bWJlcnMgPSB7XG4gIExBQkVMX1NDQUxFOiAwLjc1LFxufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7TURDRm91bmRhdGlvbn0gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvaW5kZXgnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCBNRENTZWxlY3RBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDU2VsZWN0QWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDU2VsZWN0Rm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge251bWJlcn0gKi9cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIHJldHVybiBudW1iZXJzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgTURDU2VsZWN0QWRhcHRlcn0gZm9yIHR5cGluZyBpbmZvcm1hdGlvbiBvbiBwYXJhbWV0ZXJzIGFuZCByZXR1cm5cbiAgICogdHlwZXMuXG4gICAqIEByZXR1cm4geyFNRENTZWxlY3RBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDU2VsZWN0QWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBoYXNDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiBmYWxzZSxcbiAgICAgIGFjdGl2YXRlQm90dG9tTGluZTogKCkgPT4ge30sXG4gICAgICBkZWFjdGl2YXRlQm90dG9tTGluZTogKCkgPT4ge30sXG4gICAgICBnZXRWYWx1ZTogKCkgPT4ge30sXG4gICAgICBpc1J0bDogKCkgPT4gZmFsc2UsXG4gICAgICBoYXNMYWJlbDogKCkgPT4gZmFsc2UsXG4gICAgICBmbG9hdExhYmVsOiAoLyogdmFsdWU6IGJvb2xlYW4gKi8pID0+IHt9LFxuICAgICAgZ2V0TGFiZWxXaWR0aDogKCkgPT4ge30sXG4gICAgICBoYXNPdXRsaW5lOiAoKSA9PiBmYWxzZSxcbiAgICAgIG5vdGNoT3V0bGluZTogKC8qIGxhYmVsV2lkdGg6IG51bWJlciwgaXNSdGw6IGJvb2xlYW4gKi8pID0+IHt9LFxuICAgICAgY2xvc2VPdXRsaW5lOiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENTZWxlY3RBZGFwdGVyfSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENTZWxlY3RGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc3R5bGVzIG9mIHRoZSBzZWxlY3QgdG8gc2hvdyB0aGUgZGlzYXNibGVkIHN0YXRlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVkXG4gICAqL1xuICB1cGRhdGVEaXNhYmxlZFN0eWxlKGRpc2FibGVkKSB7XG4gICAgY29uc3Qge0RJU0FCTEVEfSA9IE1EQ1NlbGVjdEZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoRElTQUJMRUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKERJU0FCTEVEKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB2YWx1ZSBjaGFuZ2VzLCB2aWEgY2hhbmdlIGV2ZW50IG9yIHByb2dyYW1tYXRpYyB1cGRhdGVzLlxuICAgKi9cbiAgaGFuZGxlQ2hhbmdlKCkge1xuICAgIGNvbnN0IG9wdGlvbkhhc1ZhbHVlID0gdGhpcy5hZGFwdGVyXy5nZXRWYWx1ZSgpLmxlbmd0aCA+IDA7XG4gICAgdGhpcy5hZGFwdGVyXy5mbG9hdExhYmVsKG9wdGlvbkhhc1ZhbHVlKTtcbiAgICB0aGlzLm5vdGNoT3V0bGluZShvcHRpb25IYXNWYWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBmb2N1cyBldmVudHMgZnJvbSByb290IGVsZW1lbnQuXG4gICAqL1xuICBoYW5kbGVGb2N1cygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmZsb2F0TGFiZWwodHJ1ZSk7XG4gICAgdGhpcy5ub3RjaE91dGxpbmUodHJ1ZSk7XG4gICAgdGhpcy5hZGFwdGVyXy5hY3RpdmF0ZUJvdHRvbUxpbmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGJsdXIgZXZlbnRzIGZyb20gcm9vdCBlbGVtZW50LlxuICAgKi9cbiAgaGFuZGxlQmx1cigpIHtcbiAgICB0aGlzLmhhbmRsZUNoYW5nZSgpO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVhY3RpdmF0ZUJvdHRvbUxpbmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucy9jbG9zZXMgdGhlIG5vdGNoZWQgb3V0bGluZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBvcGVuTm90Y2hcbiAgICovXG4gIG5vdGNoT3V0bGluZShvcGVuTm90Y2gpIHtcbiAgICBpZiAoIXRoaXMuYWRhcHRlcl8uaGFzT3V0bGluZSgpIHx8ICF0aGlzLmFkYXB0ZXJfLmhhc0xhYmVsKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3Blbk5vdGNoKSB7XG4gICAgICBjb25zdCBsYWJlbFNjYWxlID0gbnVtYmVycy5MQUJFTF9TQ0FMRTtcbiAgICAgIGNvbnN0IGxhYmVsV2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldExhYmVsV2lkdGgoKSAqIGxhYmVsU2NhbGU7XG4gICAgICBjb25zdCBpc1J0bCA9IHRoaXMuYWRhcHRlcl8uaXNSdGwoKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90Y2hPdXRsaW5lKGxhYmVsV2lkdGgsIGlzUnRsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5jbG9zZU91dGxpbmUoKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDU2VsZWN0Rm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgRmxvYXRpbmcgTGFiZWwuXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgZmxvYXRpbmcgbGFiZWwgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ0Zsb2F0aW5nTGFiZWxBZGFwdGVyIHtcbiAgLyoqXG4gICAqIEFkZHMgYSBjbGFzcyB0byB0aGUgbGFiZWwgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2xhc3MgZnJvbSB0aGUgbGFiZWwgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgbGFiZWwgZWxlbWVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0V2lkdGgoKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIHJvb3QgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSByb290IGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0Zsb2F0aW5nTGFiZWxBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgTEFCRUxfRkxPQVRfQUJPVkU6ICdtZGMtZmxvYXRpbmctbGFiZWwtLWZsb2F0LWFib3ZlJyxcbiAgTEFCRUxfU0hBS0U6ICdtZGMtZmxvYXRpbmctbGFiZWwtLXNoYWtlJyxcbn07XG5cbmV4cG9ydCB7Y3NzQ2xhc3Nlc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDRmxvYXRpbmdMYWJlbEFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7Y3NzQ2xhc3Nlc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENGbG9hdGluZ0xhYmVsQWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDRmxvYXRpbmdMYWJlbEZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgTURDRmxvYXRpbmdMYWJlbEFkYXB0ZXJ9IGZvciB0eXBpbmcgaW5mb3JtYXRpb24gb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAqIHR5cGVzLlxuICAgKiBAcmV0dXJuIHshTURDRmxvYXRpbmdMYWJlbEFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENGbG9hdGluZ0xhYmVsQWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoKSA9PiB7fSxcbiAgICAgIGdldFdpZHRoOiAoKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU1EQ0Zsb2F0aW5nTGFiZWxBZGFwdGVyfSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENGbG9hdGluZ0xhYmVsRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy5zaGFrZUFuaW1hdGlvbkVuZEhhbmRsZXJfID0gKCkgPT4gdGhpcy5oYW5kbGVTaGFrZUFuaW1hdGlvbkVuZF8oKTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignYW5pbWF0aW9uZW5kJywgdGhpcy5zaGFrZUFuaW1hdGlvbkVuZEhhbmRsZXJfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdhbmltYXRpb25lbmQnLCB0aGlzLnNoYWtlQW5pbWF0aW9uRW5kSGFuZGxlcl8pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBsYWJlbCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5nZXRXaWR0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0eWxlcyB0aGUgbGFiZWwgdG8gcHJvZHVjZSB0aGUgbGFiZWwgc2hha2UgZm9yIGVycm9ycy5cbiAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRTaGFrZSBhZGRzIHNoYWtlIGNsYXNzIGlmIHRydWUsXG4gICAqIG90aGVyd2lzZSByZW1vdmVzIHNoYWtlIGNsYXNzLlxuICAgKi9cbiAgc2hha2Uoc2hvdWxkU2hha2UpIHtcbiAgICBjb25zdCB7TEFCRUxfU0hBS0V9ID0gTURDRmxvYXRpbmdMYWJlbEZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICBpZiAoc2hvdWxkU2hha2UpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTEFCRUxfU0hBS0UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKExBQkVMX1NIQUtFKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3R5bGVzIHRoZSBsYWJlbCB0byBmbG9hdCBvciBkb2NrLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZEZsb2F0IGFkZHMgZmxvYXQgY2xhc3MgaWYgdHJ1ZSwgb3RoZXJ3aXNlIHJlbW92ZVxuICAgKiBmbG9hdCBhbmQgc2hha2UgY2xhc3MgdG8gZG9jayBsYWJlbC5cbiAgICovXG4gIGZsb2F0KHNob3VsZEZsb2F0KSB7XG4gICAgY29uc3Qge0xBQkVMX0ZMT0FUX0FCT1ZFLCBMQUJFTF9TSEFLRX0gPSBNRENGbG9hdGluZ0xhYmVsRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIGlmIChzaG91bGRGbG9hdCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhMQUJFTF9GTE9BVF9BQk9WRSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTEFCRUxfRkxPQVRfQUJPVkUpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhMQUJFTF9TSEFLRSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYW4gaW50ZXJhY3Rpb24gZXZlbnQgb24gdGhlIHJvb3QgZWxlbWVudC5cbiAgICovXG4gIGhhbmRsZVNoYWtlQW5pbWF0aW9uRW5kXygpIHtcbiAgICBjb25zdCB7TEFCRUxfU0hBS0V9ID0gTURDRmxvYXRpbmdMYWJlbEZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKExBQkVMX1NIQUtFKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENGbG9hdGluZ0xhYmVsRm91bmRhdGlvbjtcbiIsIjx0ZW1wbGF0ZT5cbiAgPGxhYmVsXG4gICAgOmNsYXNzPVwibGFiZWxDbGFzc2VzXCJcbiAgICBjbGFzcz1cIm1kYy1mbG9hdGluZy1sYWJlbFwiPlxuICAgIDxzbG90IC8+XG4gIDwvbGFiZWw+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ0Zsb2F0aW5nTGFiZWxGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9mbG9hdGluZy1sYWJlbC9mb3VuZGF0aW9uJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtc2VsZWN0LWxhYmVsJyxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWxDbGFzc2VzOiB7fVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDRmxvYXRpbmdMYWJlbEZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLmxhYmVsQ2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgfSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5sYWJlbENsYXNzZXMsIGNsYXNzTmFtZSlcbiAgICAgIH0sXG4gICAgICBnZXRXaWR0aDogKCkgPT4gdGhpcy4kZWwub2Zmc2V0V2lkdGgsXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlcilcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICBsZXQgZm91bmRhdGlvbiA9IHRoaXMuZm91bmRhdGlvblxuICAgIHRoaXMuZm91bmRhdGlvbiA9IG51bGxcbiAgICBmb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9XG59XG48L3NjcmlwdD5cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgVGV4dEZpZWxkIExpbmUgUmlwcGxlLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIGxpbmUgcmlwcGxlIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENMaW5lUmlwcGxlQWRhcHRlciB7XG4gIC8qKlxuICAgKiBBZGRzIGEgY2xhc3MgdG8gdGhlIGxpbmUgcmlwcGxlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNsYXNzIGZyb20gdGhlIGxpbmUgcmlwcGxlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdHlsZSBwcm9wZXJ0eSB3aXRoIHByb3BlcnR5TmFtZSB0byB2YWx1ZSBvbiB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0U3R5bGUocHJvcGVydHlOYW1lLCB2YWx1ZSkge31cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSBsaW5lIHJpcHBsZSBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJFdmVudEhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIGxpbmUgcmlwcGxlIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyRXZlbnRIYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0xpbmVSaXBwbGVBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgTElORV9SSVBQTEVfQUNUSVZFOiAnbWRjLWxpbmUtcmlwcGxlLS1hY3RpdmUnLFxuICBMSU5FX1JJUFBMRV9ERUFDVElWQVRJTkc6ICdtZGMtbGluZS1yaXBwbGUtLWRlYWN0aXZhdGluZycsXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXN9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ0xpbmVSaXBwbGVBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENMaW5lUmlwcGxlQWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDTGluZVJpcHBsZUZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgTURDTGluZVJpcHBsZUFkYXB0ZXJ9IGZvciB0eXBpbmcgaW5mb3JtYXRpb24gb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAqIHR5cGVzLlxuICAgKiBAcmV0dXJuIHshTURDTGluZVJpcHBsZUFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENMaW5lUmlwcGxlQWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoKSA9PiB7fSxcbiAgICAgIGhhc0NsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHNldFN0eWxlOiAoKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyRXZlbnRIYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJFdmVudEhhbmRsZXI6ICgpID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU1EQ0xpbmVSaXBwbGVBZGFwdGVyPX0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlciA9IC8qKiBAdHlwZSB7IU1EQ0xpbmVSaXBwbGVBZGFwdGVyfSAqLyAoe30pKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENMaW5lUmlwcGxlRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZVRyYW5zaXRpb25FbmQoZXZ0KTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckV2ZW50SGFuZGxlcigndHJhbnNpdGlvbmVuZCcsIHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyRXZlbnRIYW5kbGVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcl8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyB0aGUgbGluZSByaXBwbGVcbiAgICovXG4gIGFjdGl2YXRlKCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5MSU5FX1JJUFBMRV9ERUFDVElWQVRJTkcpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5MSU5FX1JJUFBMRV9BQ1RJVkUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNlbnRlciBvZiB0aGUgcmlwcGxlIGFuaW1hdGlvbiB0byB0aGUgZ2l2ZW4gWCBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0geENvb3JkaW5hdGVcbiAgICovXG4gIHNldFJpcHBsZUNlbnRlcih4Q29vcmRpbmF0ZSkge1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGUoJ3RyYW5zZm9ybS1vcmlnaW4nLCBgJHt4Q29vcmRpbmF0ZX1weCBjZW50ZXJgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWFjdGl2YXRlcyB0aGUgbGluZSByaXBwbGVcbiAgICovXG4gIGRlYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLkxJTkVfUklQUExFX0RFQUNUSVZBVElORyk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIHRyYW5zaXRpb24gZW5kIGV2ZW50XG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICovXG4gIGhhbmRsZVRyYW5zaXRpb25FbmQoZXZ0KSB7XG4gICAgLy8gV2FpdCBmb3IgdGhlIGxpbmUgcmlwcGxlIHRvIGJlIGVpdGhlciB0cmFuc3BhcmVudCBvciBvcGFxdWVcbiAgICAvLyBiZWZvcmUgZW1pdHRpbmcgdGhlIGFuaW1hdGlvbiBlbmQgZXZlbnRcbiAgICBjb25zdCBpc0RlYWN0aXZhdGluZyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5MSU5FX1JJUFBMRV9ERUFDVElWQVRJTkcpO1xuXG4gICAgaWYgKGV2dC5wcm9wZXJ0eU5hbWUgPT09ICdvcGFjaXR5Jykge1xuICAgICAgaWYgKGlzRGVhY3RpdmF0aW5nKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5MSU5FX1JJUFBMRV9BQ1RJVkUpO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuTElORV9SSVBQTEVfREVBQ1RJVkFUSU5HKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDTGluZVJpcHBsZUZvdW5kYXRpb247XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXZcbiAgICA6Y2xhc3M9XCJsaW5lQ2xhc3Nlc1wiXG4gICAgOnN0eWxlPVwibGluZVN0eWxlc1wiXG4gICAgY2xhc3M9XCJtZGMtbGluZS1yaXBwbGVcIi8+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ0xpbmVSaXBwbGVGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9saW5lLXJpcHBsZS9mb3VuZGF0aW9uJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtc2VsZWN0LWxpbmUtcmlwcGxlJyxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGluZUNsYXNzZXM6IHt9LFxuICAgICAgbGluZVN0eWxlczoge31cbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ0xpbmVSaXBwbGVGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5saW5lQ2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgfSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5saW5lQ2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIHNldFN0eWxlOiAobmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMubGluZVN0eWxlcywgbmFtZSwgdmFsdWUpXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJFdmVudEhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyRXZlbnRIYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgbGV0IGZvdW5kYXRpb24gPSB0aGlzLmZvdW5kYXRpb25cbiAgICB0aGlzLmZvdW5kYXRpb24gPSBudWxsXG4gICAgZm91bmRhdGlvbi5kZXN0cm95KClcbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIE5vdGNoZWQgT3V0bGluZS5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBOb3RjaGVkIE91dGxpbmUgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ05vdGNoZWRPdXRsaW5lQWRhcHRlciB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRXaWR0aCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRIZWlnaHQoKSB7fVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY2xhc3MgdG8gdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2xhc3MgZnJvbSB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIFwiZFwiIGF0dHJpYnV0ZSBvZiB0aGUgb3V0bGluZSBlbGVtZW50J3MgU1ZHIHBhdGguXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0T3V0bGluZVBhdGhBdHRyKHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpZGxlIG91dGxpbmUgZWxlbWVudCdzIGNvbXB1dGVkIHN0eWxlIHZhbHVlIG9mIHRoZSBnaXZlbiBjc3MgcHJvcGVydHkgYHByb3BlcnR5TmFtZWAuXG4gICAqIFdlIGFjaGlldmUgdGhpcyB2aWEgYGdldENvbXB1dGVkU3R5bGUoLi4uKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5TmFtZSlgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldElkbGVPdXRsaW5lU3R5bGVWYWx1ZShwcm9wZXJ0eU5hbWUpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ05vdGNoZWRPdXRsaW5lQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIFBBVEhfU0VMRUNUT1I6ICcubWRjLW5vdGNoZWQtb3V0bGluZV9fcGF0aCcsXG4gIElETEVfT1VUTElORV9TRUxFQ1RPUjogJy5tZGMtbm90Y2hlZC1vdXRsaW5lX19pZGxlJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgT1VUTElORV9OT1RDSEVEOiAnbWRjLW5vdGNoZWQtb3V0bGluZS0tbm90Y2hlZCcsXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ05vdGNoZWRPdXRsaW5lQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ05vdGNoZWRPdXRsaW5lQWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDTm90Y2hlZE91dGxpbmVGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgTURDTm90Y2hlZE91dGxpbmVBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ05vdGNoZWRPdXRsaW5lQWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ05vdGNoZWRPdXRsaW5lQWRhcHRlcn0gKi8gKHtcbiAgICAgIGdldFdpZHRoOiAoKSA9PiB7fSxcbiAgICAgIGdldEhlaWdodDogKCkgPT4ge30sXG4gICAgICBhZGRDbGFzczogKCkgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKCkgPT4ge30sXG4gICAgICBzZXRPdXRsaW5lUGF0aEF0dHI6ICgpID0+IHt9LFxuICAgICAgZ2V0SWRsZU91dGxpbmVTdHlsZVZhbHVlOiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENOb3RjaGVkT3V0bGluZUFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ05vdGNoZWRPdXRsaW5lRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIG91dGxpbmUgbm90Y2hlZCBzZWxlY3RvciBhbmQgdXBkYXRlcyB0aGUgbm90Y2ggd2lkdGhcbiAgICogY2FsY3VsYXRlZCBiYXNlZCBvZmYgb2Ygbm90Y2hXaWR0aCBhbmQgaXNSdGwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBub3RjaFdpZHRoXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGlzUnRsXG4gICAqL1xuICBub3RjaChub3RjaFdpZHRoLCBpc1J0bCA9IGZhbHNlKSB7XG4gICAgY29uc3Qge09VVExJTkVfTk9UQ0hFRH0gPSBNRENOb3RjaGVkT3V0bGluZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE9VVExJTkVfTk9UQ0hFRCk7XG4gICAgdGhpcy51cGRhdGVTdmdQYXRoXyhub3RjaFdpZHRoLCBpc1J0bCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBub3RjaGVkIG91dGxpbmUgc2VsZWN0b3IgdG8gY2xvc2UgdGhlIG5vdGNoIGluIHRoZSBvdXRsaW5lLlxuICAgKi9cbiAgY2xvc2VOb3RjaCgpIHtcbiAgICBjb25zdCB7T1VUTElORV9OT1RDSEVEfSA9IE1EQ05vdGNoZWRPdXRsaW5lRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoT1VUTElORV9OT1RDSEVEKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBTVkcgcGF0aCBvZiB0aGUgZm9jdXMgb3V0bGluZSBlbGVtZW50IGJhc2VkIG9uIHRoZSBub3RjaFdpZHRoXG4gICAqIGFuZCB0aGUgUlRMIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBub3RjaFdpZHRoXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGlzUnRsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGVTdmdQYXRoXyhub3RjaFdpZHRoLCBpc1J0bCkge1xuICAgIC8vIEZhbGwgYmFjayB0byByZWFkaW5nIGEgc3BlY2lmaWMgY29ybmVyJ3Mgc3R5bGUgYmVjYXVzZSBGaXJlZm94IGRvZXNuJ3QgcmVwb3J0IHRoZSBzdHlsZSBvbiBib3JkZXItcmFkaXVzLlxuICAgIGNvbnN0IHJhZGl1c1N0eWxlVmFsdWUgPSB0aGlzLmFkYXB0ZXJfLmdldElkbGVPdXRsaW5lU3R5bGVWYWx1ZSgnYm9yZGVyLXJhZGl1cycpIHx8XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZ2V0SWRsZU91dGxpbmVTdHlsZVZhbHVlKCdib3JkZXItdG9wLWxlZnQtcmFkaXVzJyk7XG4gICAgY29uc3QgcmFkaXVzID0gcGFyc2VGbG9hdChyYWRpdXNTdHlsZVZhbHVlKTtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0V2lkdGgoKTtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmFkYXB0ZXJfLmdldEhlaWdodCgpO1xuICAgIGNvbnN0IGNvcm5lcldpZHRoID0gcmFkaXVzICsgMS4yO1xuICAgIGNvbnN0IGxlYWRpbmdTdHJva2VMZW5ndGggPSBNYXRoLmFicygxMSAtIGNvcm5lcldpZHRoKTtcbiAgICBjb25zdCBwYWRkZWROb3RjaFdpZHRoID0gbm90Y2hXaWR0aCArIDg7XG5cbiAgICAvLyBUaGUgcmlnaHQsIGJvdHRvbSwgYW5kIGxlZnQgc2lkZXMgb2YgdGhlIG91dGxpbmUgZm9sbG93IHRoZSBzYW1lIFNWRyBwYXRoLlxuICAgIGNvbnN0IHBhdGhNaWRkbGUgPSAnYScgKyByYWRpdXMgKyAnLCcgKyByYWRpdXMgKyAnIDAgMCAxICcgKyByYWRpdXMgKyAnLCcgKyByYWRpdXNcbiAgICAgICsgJ3YnICsgKGhlaWdodCAtICgyICogY29ybmVyV2lkdGgpKVxuICAgICAgKyAnYScgKyByYWRpdXMgKyAnLCcgKyByYWRpdXMgKyAnIDAgMCAxICcgKyAtcmFkaXVzICsgJywnICsgcmFkaXVzXG4gICAgICArICdoJyArICgtd2lkdGggKyAoMiAqIGNvcm5lcldpZHRoKSlcbiAgICAgICsgJ2EnICsgcmFkaXVzICsgJywnICsgcmFkaXVzICsgJyAwIDAgMSAnICsgLXJhZGl1cyArICcsJyArIC1yYWRpdXNcbiAgICAgICsgJ3YnICsgKC1oZWlnaHQgKyAoMiAqIGNvcm5lcldpZHRoKSlcbiAgICAgICsgJ2EnICsgcmFkaXVzICsgJywnICsgcmFkaXVzICsgJyAwIDAgMSAnICsgcmFkaXVzICsgJywnICsgLXJhZGl1cztcblxuICAgIGxldCBwYXRoO1xuICAgIGlmICghaXNSdGwpIHtcbiAgICAgIHBhdGggPSAnTScgKyAoY29ybmVyV2lkdGggKyBsZWFkaW5nU3Ryb2tlTGVuZ3RoICsgcGFkZGVkTm90Y2hXaWR0aCkgKyAnLCcgKyAxXG4gICAgICAgICsgJ2gnICsgKHdpZHRoIC0gKDIgKiBjb3JuZXJXaWR0aCkgLSBwYWRkZWROb3RjaFdpZHRoIC0gbGVhZGluZ1N0cm9rZUxlbmd0aClcbiAgICAgICAgKyBwYXRoTWlkZGxlXG4gICAgICAgICsgJ2gnICsgbGVhZGluZ1N0cm9rZUxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9ICdNJyArICh3aWR0aCAtIGNvcm5lcldpZHRoIC0gbGVhZGluZ1N0cm9rZUxlbmd0aCkgKyAnLCcgKyAxXG4gICAgICAgICsgJ2gnICsgbGVhZGluZ1N0cm9rZUxlbmd0aFxuICAgICAgICArIHBhdGhNaWRkbGVcbiAgICAgICAgKyAnaCcgKyAod2lkdGggLSAoMiAqIGNvcm5lcldpZHRoKSAtIHBhZGRlZE5vdGNoV2lkdGggLSBsZWFkaW5nU3Ryb2tlTGVuZ3RoKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnNldE91dGxpbmVQYXRoQXR0cihwYXRoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENOb3RjaGVkT3V0bGluZUZvdW5kYXRpb247XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXY+XG4gICAgPGRpdlxuICAgICAgcmVmPVwib3V0bGluZWRcIlxuICAgICAgOmNsYXNzPVwib3V0bGluZWRDbGFzc2VzXCJcbiAgICAgIGNsYXNzPVwibWRjLW5vdGNoZWQtb3V0bGluZVwiPlxuICAgICAgPHN2Zz5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICByZWY9XCJvdXRsaW5lZFBhdGhcIlxuICAgICAgICAgIGNsYXNzPVwibWRjLW5vdGNoZWQtb3V0bGluZV9fcGF0aFwiLz5cbiAgICAgIDwvc3ZnPlxuICAgIDwvZGl2PlxuICAgIDxkaXZcbiAgICAgIHJlZj1cIm91dGxpbmVkSWRsZVwiXG4gICAgICBjbGFzcz1cIm1kYy1ub3RjaGVkLW91dGxpbmVfX2lkbGVcIi8+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENub3RjaGVkT3V0bGluZUZvdW5kYXRpb25Gb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9ub3RjaGVkLW91dGxpbmUvZm91bmRhdGlvbidcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXNlbGVjdC1ub3RjaGVkLW91dGxpbmUnLFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvdXRsaW5lZENsYXNzZXM6IHt9XG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENub3RjaGVkT3V0bGluZUZvdW5kYXRpb25Gb3VuZGF0aW9uKHtcbiAgICAgIGdldFdpZHRoOiAoKSA9PiB0aGlzLiRyZWZzLm91dGxpbmVkLm9mZnNldFdpZHRoLFxuICAgICAgZ2V0SGVpZ2h0OiAoKSA9PiB0aGlzLiRyZWZzLm91dGxpbmVkLm9mZnNldEhlaWdodCxcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5vdXRsaW5lZENsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSlcbiAgICAgIH0sXG4gICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMub3V0bGluZWRDbGFzc2VzLCBjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgc2V0T3V0bGluZVBhdGhBdHRyOiB2YWx1ZSA9PiB7XG4gICAgICAgIGNvbnN0IHBhdGggPSB0aGlzLiRyZWZzLm91dGxpbmVkUGF0aFxuICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHZhbHVlKVxuICAgICAgfSxcbiAgICAgIGdldElkbGVPdXRsaW5lU3R5bGVWYWx1ZTogcHJvcGVydHlOYW1lID0+IHtcbiAgICAgICAgcmV0dXJuIHdpbmRvd1xuICAgICAgICAgIC5nZXRDb21wdXRlZFN0eWxlKHRoaXMuJHJlZnMub3V0bGluZWRJZGxlKVxuICAgICAgICAgIC5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5TmFtZSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICBsZXQgZm91bmRhdGlvbiA9IHRoaXMuZm91bmRhdGlvblxuICAgIHRoaXMuZm91bmRhdGlvbiA9IG51bGxcbiAgICBmb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdlxuICAgIDppZD1cImlkXCJcbiAgICA6Y2xhc3M9XCJyb290Q2xhc3Nlc1wiXG4gICAgOnN0eWxlPVwic3R5bGVzXCJcbiAgICBjbGFzcz1cIm1kYy1zZWxlY3RcIj5cbiAgICA8c2VsZWN0XG4gICAgICByZWY9XCJuYXRpdmVfY29udHJvbFwiXG4gICAgICA6ZGlzYWJsZWQ9XCJkaXNhYmxlZFwiXG4gICAgICB2LWJpbmQ9XCIkYXR0cnNcIlxuICAgICAgY2xhc3M9XCJtZGMtc2VsZWN0X19uYXRpdmUtY29udHJvbFwiXG4gICAgICB2LW9uPVwibGlzdGVuZXJzXCI+XG4gICAgICA8b3B0aW9uXG4gICAgICAgIHYtaWY9XCIhIWxhYmVsXCJcbiAgICAgICAgY2xhc3M9XCJtZGMtb3B0aW9uXCJcbiAgICAgICAgdmFsdWU9XCJcIlxuICAgICAgICBkaXNhYmxlZFxuICAgICAgICBzZWxlY3RlZC8+XG4gICAgICA8c2xvdC8+XG4gICAgPC9zZWxlY3Q+XG4gICAgPCEtLSBsYWJlbCAtLT5cbiAgICA8c2VsZWN0LWxhYmVsXG4gICAgICB2LWlmPVwibGFiZWxcIlxuICAgICAgcmVmPVwibGFiZWxcIj57eyBsYWJlbCB9fTwvc2VsZWN0LWxhYmVsPlxuICAgIDwhLS0gbGluZSByaXBwbGUgLS0+XG4gICAgPHNlbGVjdC1saW5lLXJpcGxlXG4gICAgICB2LWlmPVwiIW91dGxpbmVkXCJcbiAgICAgIHJlZj1cImxpbmVcIi8+XG4gICAgPCEtLSBvdXRsaW5lIC0tPlxuICAgIDxzZWxlY3Qtbm90Y2hlZC1vdXRsaW5lXG4gICAgICB2LWlmPVwib3V0bGluZWRcIlxuICAgICAgcmVmPVwib3V0bGluZVwiXG4gICAgLz5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ1NlbGVjdEZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3NlbGVjdC9mb3VuZGF0aW9uJ1xuaW1wb3J0IHsgUmlwcGxlQmFzZSB9IGZyb20gJy4uL3JpcHBsZSdcblxuaW1wb3J0IFNlbGVjdExhYmVsIGZyb20gJy4vbWRjLXNlbGVjdC1sYWJlbC52dWUnXG5pbXBvcnQgU2VsZWN0TGluZVJpcGxlIGZyb20gJy4vbWRjLXNlbGVjdC1saW5lLXJpcHBsZS52dWUnXG5pbXBvcnQgU2VsZWN0Tm90Y2hlZE91dGxpbmUgZnJvbSAnLi9tZGMtc2VsZWN0LW5vdGNoZWQtb3V0bGluZS52dWUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1zZWxlY3QnLFxuICBjb21wb25lbnRzOiB7XG4gICAgU2VsZWN0TGFiZWwsXG4gICAgU2VsZWN0TGluZVJpcGxlLFxuICAgIFNlbGVjdE5vdGNoZWRPdXRsaW5lXG4gIH0sXG4gIGluaGVyaXRBdHRyczogZmFsc2UsXG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ3ZhbHVlJyxcbiAgICBldmVudDogJ2NoYW5nZSdcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICB2YWx1ZTogU3RyaW5nLFxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgIGxhYmVsOiBTdHJpbmcsXG4gICAgb3V0bGluZWQ6IEJvb2xlYW4sXG4gICAgaWQ6IHsgdHlwZTogU3RyaW5nIH1cbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3R5bGVzOiB7fSxcbiAgICAgIGNsYXNzZXM6IHt9XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIHJvb3RDbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21kYy1zZWxlY3QtLWJveCc6ICF0aGlzLm91dGxpbmVkLFxuICAgICAgICAnbWRjLXNlbGVjdC0tb3V0bGluZWQnOiB0aGlzLm91dGxpbmVkLFxuICAgICAgICAuLi50aGlzLmNsYXNzZXNcbiAgICAgIH1cbiAgICB9LFxuICAgIGxpc3RlbmVycygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnRoaXMuJGxpc3RlbmVycyxcbiAgICAgICAgY2hhbmdlOiBldmVudCA9PiB0aGlzLm9uQ2hhbmdlKGV2ZW50KVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBkaXNhYmxlZCh2YWx1ZSkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi51cGRhdGVEaXNhYmxlZFN0eWxlKHZhbHVlKVxuICAgIH0sXG4gICAgdmFsdWU6ICdyZWZyZXNoSW5kZXgnXG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ1NlbGVjdEZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpLFxuICAgICAgaGFzQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSxcbiAgICAgIGFjdGl2YXRlQm90dG9tTGluZTogKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy4kcmVmcy5saW5lKSB7XG4gICAgICAgICAgdGhpcy4kcmVmcy5saW5lLmZvdW5kYXRpb24uYWN0aXZhdGUoKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVhY3RpdmF0ZUJvdHRvbUxpbmU6ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuJHJlZnMubGluZSkge1xuICAgICAgICAgIHRoaXMuJHJlZnMubGluZS5mb3VuZGF0aW9uLmRlYWN0aXZhdGUoKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2V0VmFsdWU6ICgpID0+IHRoaXMuJHJlZnMubmF0aXZlX2NvbnRyb2wudmFsdWUsXG4gICAgICBpc1J0bDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuJGVsKS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXJlY3Rpb24nKSA9PT1cbiAgICAgICAgICAncnRsJ1xuICAgICAgICApXG4gICAgICB9LFxuICAgICAgbm90Y2hPdXRsaW5lOiAobGFiZWxXaWR0aCwgaXNSdGwpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuJHJlZnMub3V0bGluZSkge1xuICAgICAgICAgIHRoaXMuJHJlZnMub3V0bGluZS5mb3VuZGF0aW9uLm5vdGNoKGxhYmVsV2lkdGgsIGlzUnRsKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2xvc2VPdXRsaW5lOiAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLiRyZWZzLm91dGxpbmUpIHtcbiAgICAgICAgICB0aGlzLiRyZWZzLm91dGxpbmUuZm91bmRhdGlvbi5jbG9zZU5vdGNoKClcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhhc091dGxpbmU6ICgpID0+ICEhdGhpcy4kcmVmcy5vdXRsaW5lLFxuICAgICAgZmxvYXRMYWJlbDogdmFsdWUgPT4ge1xuICAgICAgICBpZiAodGhpcy4kcmVmcy5sYWJlbCkge1xuICAgICAgICAgIHRoaXMuJHJlZnMubGFiZWwuZm91bmRhdGlvbi5mbG9hdCh2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhhc0xhYmVsOiAoKSA9PiAhIXRoaXMuJHJlZnMubGFiZWwsXG4gICAgICBnZXRMYWJlbFdpZHRoOiAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLiRyZWZzLmxhYmVsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMubGFiZWwuZm91bmRhdGlvbi5nZXRXaWR0aCgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICAgIHRoaXMuZm91bmRhdGlvbi5oYW5kbGVDaGFuZ2UoKVxuXG4gICAgLy8gaW5pdGlhbCBzeW5jIHdpdGggRE9NXG4gICAgdGhpcy5yZWZyZXNoSW5kZXgoKVxuICAgIHRoaXMuc2xvdE9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4gdGhpcy5yZWZyZXNoSW5kZXgoKSlcbiAgICB0aGlzLnNsb3RPYnNlcnZlci5vYnNlcnZlKHRoaXMuJHJlZnMubmF0aXZlX2NvbnRyb2wsIHtcbiAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgIHN1YnRyZWU6IHRydWVcbiAgICB9KVxuXG4gICAgdGhpcy5yaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzKVxuICAgIHRoaXMucmlwcGxlLmluaXQoKVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuc2xvdE9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuXG4gICAgbGV0IGZvdW5kYXRpb24gPSB0aGlzLmZvdW5kYXRpb25cbiAgICB0aGlzLmZvdW5kYXRpb24gPSBudWxsXG4gICAgZm91bmRhdGlvbi5kZXN0cm95KClcblxuICAgIHRoaXMucmlwcGxlICYmIHRoaXMucmlwcGxlLmRlc3Ryb3koKVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgcmVmcmVzaEluZGV4KCkge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IFsuLi50aGlzLiRyZWZzLm5hdGl2ZV9jb250cm9sLnF1ZXJ5U2VsZWN0b3JBbGwoJ29wdGlvbicpXVxuXG4gICAgICBjb25zdCBpZHggPSBvcHRpb25zLmZpbmRJbmRleCgoeyB2YWx1ZSB9KSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSB2YWx1ZVxuICAgICAgfSlcblxuICAgICAgaWYgKHRoaXMuJHJlZnMubmF0aXZlX2NvbnRyb2wuc2VsZWN0ZWRJbmRleCAhPT0gaWR4KSB7XG4gICAgICAgIHRoaXMuJHJlZnMubmF0aXZlX2NvbnRyb2wuc2VsZWN0ZWRJbmRleCA9IGlkeFxuICAgICAgICB0aGlzLmZvdW5kYXRpb24uaGFuZGxlQ2hhbmdlKClcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uQ2hhbmdlKGV2ZW50KSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uaGFuZGxlQ2hhbmdlKClcbiAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGV2ZW50LnRhcmdldC52YWx1ZSlcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjU2VsZWN0IGZyb20gJy4vbWRjLXNlbGVjdC52dWUnXG5cbmV4cG9ydCB7IG1kY1NlbGVjdCB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNTZWxlY3Rcbn0pXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgQUNUSVZFOiAnbWRjLXNsaWRlci0tYWN0aXZlJyxcbiAgRElTQUJMRUQ6ICdtZGMtc2xpZGVyLS1kaXNhYmxlZCcsXG4gIERJU0NSRVRFOiAnbWRjLXNsaWRlci0tZGlzY3JldGUnLFxuICBGT0NVUzogJ21kYy1zbGlkZXItLWZvY3VzJyxcbiAgSU5fVFJBTlNJVDogJ21kYy1zbGlkZXItLWluLXRyYW5zaXQnLFxuICBJU19ESVNDUkVURTogJ21kYy1zbGlkZXItLWRpc2NyZXRlJyxcbiAgSEFTX1RSQUNLX01BUktFUjogJ21kYy1zbGlkZXItLWRpc3BsYXktbWFya2VycycsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIFRSQUNLX1NFTEVDVE9SOiAnLm1kYy1zbGlkZXJfX3RyYWNrJyxcbiAgVFJBQ0tfTUFSS0VSX0NPTlRBSU5FUl9TRUxFQ1RPUjogJy5tZGMtc2xpZGVyX190cmFjay1tYXJrZXItY29udGFpbmVyJyxcbiAgTEFTVF9UUkFDS19NQVJLRVJfU0VMRUNUT1I6ICcubWRjLXNsaWRlcl9fdHJhY2stbWFya2VyOmxhc3QtY2hpbGQnLFxuICBUSFVNQl9DT05UQUlORVJfU0VMRUNUT1I6ICcubWRjLXNsaWRlcl9fdGh1bWItY29udGFpbmVyJyxcbiAgUElOX1ZBTFVFX01BUktFUl9TRUxFQ1RPUjogJy5tZGMtc2xpZGVyX19waW4tdmFsdWUtbWFya2VyJyxcbiAgQVJJQV9WQUxVRU1JTjogJ2FyaWEtdmFsdWVtaW4nLFxuICBBUklBX1ZBTFVFTUFYOiAnYXJpYS12YWx1ZW1heCcsXG4gIEFSSUFfVkFMVUVOT1c6ICdhcmlhLXZhbHVlbm93JyxcbiAgQVJJQV9ESVNBQkxFRDogJ2FyaWEtZGlzYWJsZWQnLFxuICBTVEVQX0RBVEFfQVRUUjogJ2RhdGEtc3RlcCcsXG4gIENIQU5HRV9FVkVOVDogJ01EQ1NsaWRlcjpjaGFuZ2UnLFxuICBJTlBVVF9FVkVOVDogJ01EQ1NsaWRlcjppbnB1dCcsXG59O1xuXG4vKiogQGVudW0ge251bWJlcn0gKi9cbmNvbnN0IG51bWJlcnMgPSB7XG4gIFBBR0VfRkFDVE9SOiA0LFxufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgU2xpZGVyLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIFNsaWRlciBpbnRvIHlvdXIgZnJhbWV3b3JrLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvYXV0aG9yaW5nLWNvbXBvbmVudHMubWRcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDU2xpZGVyQWRhcHRlciB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgY2xhc3NOYW1lIGV4aXN0cyBmb3IgdGhlIHNsaWRlciBFbGVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogQWRkcyBhIGNsYXNzIHRvIHRoZSBzbGlkZXIgRWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIHRoZSBzbGlkZXIgRWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgaWYgYXR0cmlidXRlIG5hbWUgZXhpc3RzIG9uIHRoZSBzbGlkZXIgRWxlbWVudCxcbiAgICogb3RoZXJ3aXNlIHJldHVybnMgbnVsbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfVxuICAgKi9cbiAgZ2V0QXR0cmlidXRlKG5hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYXR0cmlidXRlIG5hbWUgb24gc2xpZGVyIEVsZW1lbnQgdG8gdmFsdWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYXR0cmlidXRlIG5hbWUgZnJvbSBzbGlkZXIgRWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKi9cbiAgcmVtb3ZlQXR0cmlidXRlKG5hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGNsaWVudCByZWN0IGZvciB0aGUgc2xpZGVyIEVsZW1lbnRcbiAgICogQHJldHVybiB7P0NsaWVudFJlY3R9XG4gICAqL1xuICBjb21wdXRlQm91bmRpbmdSZWN0KCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGFiIGluZGV4IG9mIHRoZSBzbGlkZXIgRWxlbWVudFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRUYWJJbmRleCgpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIG9uIHRoZSByb290IGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIG9uIHRoZSByb290IGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIG9uIHRoZSB0aHVtYiBjb250YWluZXIgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgdGh1bWIgY29udGFpbmVyIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgb24gdGhlIGJvZHkgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgYm9keSBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIGZvciB0aGUgd2luZG93IHJlc2l6ZSBldmVudFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSB3aW5kb3cgcmVzaXplIGV2ZW50XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBFbWl0cyBhIGN1c3RvbSBldmVudCBNRENTbGlkZXI6aW5wdXQgZnJvbSB0aGUgcm9vdFxuICAgKi9cbiAgbm90aWZ5SW5wdXQoKSB7fVxuXG4gIC8qKlxuICAgKiBFbWl0cyBhIGN1c3RvbSBldmVudCBNRENTbGlkZXI6Y2hhbmdlIGZyb20gdGhlIHJvb3RcbiAgICovXG4gIG5vdGlmeUNoYW5nZSgpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdHlsZSBwcm9wZXJ0eSBvZiB0aGUgdGh1bWIgY29udGFpbmVyIGVsZW1lbnQgdG8gdGhlIHBhc3NlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0VGh1bWJDb250YWluZXJTdHlsZVByb3BlcnR5KHByb3BlcnR5TmFtZSwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdHlsZSBwcm9wZXJ0eSBvZiB0aGUgdHJhY2sgZWxlbWVudCB0byB0aGUgcGFzc2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRUcmFja1N0eWxlUHJvcGVydHkocHJvcGVydHlOYW1lLCB2YWx1ZSkge31cblxuICAvKipcbiAgICogU2V0cyB0aGUgaW5uZXIgdGV4dCBvZiB0aGUgcGluIG1hcmtlciB0byB0aGUgcGFzc2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgKi9cbiAgc2V0TWFya2VyVmFsdWUodmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgdGhlIHBhc3NlZCBudW1iZXIgb2YgdHJhY2sgbWFya2VycyB0byB0aGUgdHJhY2sgbWFyayBjb250YWluZXIgZWxlbWVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gbnVtTWFya2Vyc1xuICAgKi9cbiAgYXBwZW5kVHJhY2tNYXJrZXJzKG51bU1hcmtlcnMpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIHRyYWNrIG1hcmtlcnMgZnJvbXQgaGUgdHJhY2sgbWFyayBjb250YWluZXIgZWxlbWVudFxuICAgKi9cbiAgcmVtb3ZlVHJhY2tNYXJrZXJzKCkge31cblxuICAvKipcbiAgICogU2V0cyBhIHN0eWxlIHByb3BlcnR5IG9mIHRoZSBsYXN0IHRyYWNrIG1hcmtlciB0byB0aGUgcGFzc2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRMYXN0VHJhY2tNYXJrZXJzU3R5bGVQcm9wZXJ0eShwcm9wZXJ0eU5hbWUsIHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJvb3QgZWxlbWVudCBpcyBSVEwsIG90aGVyd2lzZSBmYWxzZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNSVEwoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENTbGlkZXJBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICp5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc30gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IE1EQ1NsaWRlckFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcblxuaW1wb3J0IHtnZXRDb3JyZWN0RXZlbnROYW1lLCBnZXRDb3JyZWN0UHJvcGVydHlOYW1lfSBmcm9tICdAbWF0ZXJpYWwvYW5pbWF0aW9uL2luZGV4JztcbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IEtFWV9JRFMgPSB7XG4gIEFSUk9XX0xFRlQ6ICdBcnJvd0xlZnQnLFxuICBBUlJPV19SSUdIVDogJ0Fycm93UmlnaHQnLFxuICBBUlJPV19VUDogJ0Fycm93VXAnLFxuICBBUlJPV19ET1dOOiAnQXJyb3dEb3duJyxcbiAgSE9NRTogJ0hvbWUnLFxuICBFTkQ6ICdFbmQnLFxuICBQQUdFX1VQOiAnUGFnZVVwJyxcbiAgUEFHRV9ET1dOOiAnUGFnZURvd24nLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBNT1ZFX0VWRU5UX01BUCA9IHtcbiAgJ21vdXNlZG93bic6ICdtb3VzZW1vdmUnLFxuICAndG91Y2hzdGFydCc6ICd0b3VjaG1vdmUnLFxuICAncG9pbnRlcmRvd24nOiAncG9pbnRlcm1vdmUnLFxufTtcblxuY29uc3QgRE9XTl9FVkVOVFMgPSBbJ21vdXNlZG93bicsICdwb2ludGVyZG93bicsICd0b3VjaHN0YXJ0J107XG5jb25zdCBVUF9FVkVOVFMgPSBbJ21vdXNldXAnLCAncG9pbnRlcnVwJywgJ3RvdWNoZW5kJ107XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ1NsaWRlckFkYXB0ZXI+fVxuICovXG5jbGFzcyBNRENTbGlkZXJGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge2Nzc0NsYXNzZXN9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ3N9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge251bWJlcnN9ICovXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICByZXR1cm4gbnVtYmVycztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshTURDU2xpZGVyQWRhcHRlcn0gKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDU2xpZGVyQWRhcHRlcn0gKi8gKHtcbiAgICAgIGhhc0NsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZ2V0QXR0cmlidXRlOiAoLyogbmFtZTogc3RyaW5nICovKSA9PiAvKiBzdHJpbmd8bnVsbCAqLyBudWxsLFxuICAgICAgc2V0QXR0cmlidXRlOiAoLyogbmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUF0dHJpYnV0ZTogKC8qIG5hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBjb21wdXRlQm91bmRpbmdSZWN0OiAoKSA9PiAvKiBDbGllbnRSZWN0ICovICh7XG4gICAgICAgIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMCwgd2lkdGg6IDAsIGhlaWdodDogMCxcbiAgICAgIH0pLFxuICAgICAgZ2V0VGFiSW5kZXg6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgbm90aWZ5SW5wdXQ6ICgpID0+IHt9LFxuICAgICAgbm90aWZ5Q2hhbmdlOiAoKSA9PiB7fSxcbiAgICAgIHNldFRodW1iQ29udGFpbmVyU3R5bGVQcm9wZXJ0eTogKC8qIHByb3BlcnR5TmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldFRyYWNrU3R5bGVQcm9wZXJ0eTogKC8qIHByb3BlcnR5TmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldE1hcmtlclZhbHVlOiAoLyogdmFsdWU6IG51bWJlciAqLykgPT4ge30sXG4gICAgICBhcHBlbmRUcmFja01hcmtlcnM6ICgvKiBudW1NYXJrZXJzOiBudW1iZXIgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlVHJhY2tNYXJrZXJzOiAoKSA9PiB7fSxcbiAgICAgIHNldExhc3RUcmFja01hcmtlcnNTdHlsZVByb3BlcnR5OiAoLyogcHJvcGVydHlOYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgaXNSVEw6ICgpID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBNRENTbGlkZXJGb3VuZGF0aW9uXG4gICAqIEBwYXJhbSB7P01EQ1NsaWRlckFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1NsaWRlckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcbiAgICAvKiogQHByaXZhdGUgez9DbGllbnRSZWN0fSAqL1xuICAgIHRoaXMucmVjdF8gPSBudWxsO1xuICAgIC8vIFdlIHNldCB0aGlzIHRvIE5hTiBzaW5jZSB3ZSB3YW50IGl0IHRvIGJlIGEgbnVtYmVyLCBidXQgd2UgY2FuJ3QgdXNlICcwJyBvciAnLTEnXG4gICAgLy8gYmVjYXVzZSB0aG9zZSBjb3VsZCBiZSB2YWxpZCB0YWJpbmRpY2VzIHNldCBieSB0aGUgY2xpZW50IGNvZGUuXG4gICAgdGhpcy5zYXZlZFRhYkluZGV4XyA9IE5hTjtcbiAgICB0aGlzLmFjdGl2ZV8gPSBmYWxzZTtcbiAgICB0aGlzLmluVHJhbnNpdF8gPSBmYWxzZTtcbiAgICB0aGlzLmlzRGlzY3JldGVfID0gZmFsc2U7XG4gICAgdGhpcy5oYXNUcmFja01hcmtlcl8gPSBmYWxzZTtcbiAgICB0aGlzLmhhbmRsaW5nVGh1bWJUYXJnZXRFdnRfID0gZmFsc2U7XG4gICAgdGhpcy5taW5fID0gMDtcbiAgICB0aGlzLm1heF8gPSAxMDA7XG4gICAgdGhpcy5zdGVwXyA9IDA7XG4gICAgdGhpcy52YWx1ZV8gPSAwO1xuICAgIHRoaXMuZGlzYWJsZWRfID0gZmFsc2U7XG4gICAgdGhpcy5wcmV2ZW50Rm9jdXNTdGF0ZV8gPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZVVJRnJhbWVfID0gMDtcbiAgICB0aGlzLnRodW1iQ29udGFpbmVyUG9pbnRlckhhbmRsZXJfID0gKCkgPT4ge1xuICAgICAgdGhpcy5oYW5kbGluZ1RodW1iVGFyZ2V0RXZ0XyA9IHRydWU7XG4gICAgfTtcbiAgICB0aGlzLmludGVyYWN0aW9uU3RhcnRIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlRG93bl8oZXZ0KTtcbiAgICB0aGlzLmtleWRvd25IYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlS2V5ZG93bl8oZXZ0KTtcbiAgICB0aGlzLmZvY3VzSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmhhbmRsZUZvY3VzXygpO1xuICAgIHRoaXMuYmx1ckhhbmRsZXJfID0gKCkgPT4gdGhpcy5oYW5kbGVCbHVyXygpO1xuICAgIHRoaXMucmVzaXplSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmxheW91dCgpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmlzRGlzY3JldGVfID0gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhjc3NDbGFzc2VzLklTX0RJU0NSRVRFKTtcbiAgICB0aGlzLmhhc1RyYWNrTWFya2VyXyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5IQVNfVFJBQ0tfTUFSS0VSKTtcbiAgICBET1dOX0VWRU5UUy5mb3JFYWNoKChldnROYW1lKSA9PiB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dE5hbWUsIHRoaXMuaW50ZXJhY3Rpb25TdGFydEhhbmRsZXJfKSk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdmb2N1cycsIHRoaXMuZm9jdXNIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignYmx1cicsIHRoaXMuYmx1ckhhbmRsZXJfKTtcbiAgICBET1dOX0VWRU5UUy5mb3JFYWNoKChldnROYW1lKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0TmFtZSwgdGhpcy50aHVtYkNvbnRhaW5lclBvaW50ZXJIYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclJlc2l6ZUhhbmRsZXIodGhpcy5yZXNpemVIYW5kbGVyXyk7XG4gICAgdGhpcy5sYXlvdXQoKTtcbiAgICAvLyBBdCBsYXN0IHN0ZXAsIHByb3ZpZGUgYSByZWFzb25hYmxlIGRlZmF1bHQgdmFsdWUgdG8gZGlzY3JldGUgc2xpZGVyXG4gICAgaWYgKHRoaXMuaXNEaXNjcmV0ZV8gJiYgdGhpcy5nZXRTdGVwKCkgPT0gMCkge1xuICAgICAgdGhpcy5zdGVwXyA9IDE7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBET1dOX0VWRU5UUy5mb3JFYWNoKChldnROYW1lKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0TmFtZSwgdGhpcy5pbnRlcmFjdGlvblN0YXJ0SGFuZGxlcl8pO1xuICAgIH0pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyXyk7XG4gICAgRE9XTl9FVkVOVFMuZm9yRWFjaCgoZXZ0TmFtZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0TmFtZSwgdGhpcy50aHVtYkNvbnRhaW5lclBvaW50ZXJIYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgfVxuXG4gIHNldHVwVHJhY2tNYXJrZXIoKSB7XG4gICAgaWYgKHRoaXMuaXNEaXNjcmV0ZV8gJiYgdGhpcy5oYXNUcmFja01hcmtlcl8mJiB0aGlzLmdldFN0ZXAoKSAhPSAwKSB7XG4gICAgICBjb25zdCBtaW4gPSB0aGlzLmdldE1pbigpO1xuICAgICAgY29uc3QgbWF4ID0gdGhpcy5nZXRNYXgoKTtcbiAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLmdldFN0ZXAoKTtcbiAgICAgIGxldCBudW1NYXJrZXJzID0gKG1heCAtIG1pbikgLyBzdGVwO1xuXG4gICAgICAvLyBJbiBjYXNlIGRpc3RhbmNlIGJldHdlZW4gbWF4ICYgbWluIGlzIGluZGl2aXNpYmxlIHRvIHN0ZXAsXG4gICAgICAvLyB3ZSBwbGFjZSB0aGUgc2Vjb25kYXJ5IHRvIGxhc3QgbWFya2VyIHByb3BvcnRpb25hbGx5IGF0IHdoZXJlIHRodW1iXG4gICAgICAvLyBjb3VsZCByZWFjaCBhbmQgcGxhY2UgdGhlIGxhc3QgbWFya2VyIGF0IG1heCB2YWx1ZVxuICAgICAgY29uc3QgaW5kaXZpc2libGUgPSBNYXRoLmNlaWwobnVtTWFya2VycykgIT09IG51bU1hcmtlcnM7XG4gICAgICBpZiAoaW5kaXZpc2libGUpIHtcbiAgICAgICAgbnVtTWFya2VycyA9IE1hdGguY2VpbChudW1NYXJrZXJzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVUcmFja01hcmtlcnMoKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYXBwZW5kVHJhY2tNYXJrZXJzKG51bU1hcmtlcnMpO1xuXG4gICAgICBpZiAoaW5kaXZpc2libGUpIHtcbiAgICAgICAgY29uc3QgbGFzdFN0ZXBSYXRpbyA9IChtYXggLSBudW1NYXJrZXJzICogc3RlcCkgLyBzdGVwICsgMTtcbiAgICAgICAgY29uc3QgZmxleCA9IGdldENvcnJlY3RQcm9wZXJ0eU5hbWUod2luZG93LCAnZmxleCcpO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnNldExhc3RUcmFja01hcmtlcnNTdHlsZVByb3BlcnR5KGZsZXgsIFN0cmluZyhsYXN0U3RlcFJhdGlvKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGF5b3V0KCkge1xuICAgIHRoaXMucmVjdF8gPSB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKTtcbiAgICB0aGlzLnVwZGF0ZVVJRm9yQ3VycmVudFZhbHVlXygpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVfO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAqL1xuICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuc2V0VmFsdWVfKHZhbHVlLCBmYWxzZSk7XG4gIH1cblxuICAvKiogQHJldHVybiB7bnVtYmVyfSAqL1xuICBnZXRNYXgoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4XztcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge251bWJlcn0gbWF4ICovXG4gIHNldE1heChtYXgpIHtcbiAgICBpZiAobWF4IDwgdGhpcy5taW5fKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgbWF4IHRvIGJlIGxlc3MgdGhhbiB0aGUgc2xpZGVyXFwncyBtaW5pbXVtIHZhbHVlJyk7XG4gICAgfVxuICAgIHRoaXMubWF4XyA9IG1heDtcbiAgICB0aGlzLnNldFZhbHVlXyh0aGlzLnZhbHVlXywgZmFsc2UsIHRydWUpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cmlidXRlKHN0cmluZ3MuQVJJQV9WQUxVRU1BWCwgU3RyaW5nKHRoaXMubWF4XykpO1xuICAgIHRoaXMuc2V0dXBUcmFja01hcmtlcigpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0TWluKCkge1xuICAgIHJldHVybiB0aGlzLm1pbl87XG4gIH1cblxuICAvKiogQHBhcmFtIHtudW1iZXJ9IG1pbiAqL1xuICBzZXRNaW4obWluKSB7XG4gICAgaWYgKG1pbiA+IHRoaXMubWF4Xykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2V0IG1pbiB0byBiZSBncmVhdGVyIHRoYW4gdGhlIHNsaWRlclxcJ3MgbWF4aW11bSB2YWx1ZScpO1xuICAgIH1cbiAgICB0aGlzLm1pbl8gPSBtaW47XG4gICAgdGhpcy5zZXRWYWx1ZV8odGhpcy52YWx1ZV8sIGZhbHNlLCB0cnVlKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHJpYnV0ZShzdHJpbmdzLkFSSUFfVkFMVUVNSU4sIFN0cmluZyh0aGlzLm1pbl8pKTtcbiAgICB0aGlzLnNldHVwVHJhY2tNYXJrZXIoKTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXG4gIGdldFN0ZXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RlcF87XG4gIH1cblxuICAvKiogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgKi9cbiAgc2V0U3RlcChzdGVwKSB7XG4gICAgaWYgKHN0ZXAgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0ZXAgY2Fubm90IGJlIHNldCB0byBhIG5lZ2F0aXZlIG51bWJlcicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0Rpc2NyZXRlXyAmJiAodHlwZW9mKHN0ZXApICE9PSAnbnVtYmVyJyB8fCBzdGVwIDwgMSkpIHtcbiAgICAgIHN0ZXAgPSAxO1xuICAgIH1cbiAgICB0aGlzLnN0ZXBfID0gc3RlcDtcbiAgICB0aGlzLnNldFZhbHVlXyh0aGlzLnZhbHVlXywgZmFsc2UsIHRydWUpO1xuICAgIHRoaXMuc2V0dXBUcmFja01hcmtlcigpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzYWJsZWRfO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWQgKi9cbiAgc2V0RGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICB0aGlzLmRpc2FibGVkXyA9IGRpc2FibGVkO1xuICAgIHRoaXMudG9nZ2xlQ2xhc3NfKGNzc0NsYXNzZXMuRElTQUJMRUQsIHRoaXMuZGlzYWJsZWRfKTtcbiAgICBpZiAodGhpcy5kaXNhYmxlZF8pIHtcbiAgICAgIHRoaXMuc2F2ZWRUYWJJbmRleF8gPSB0aGlzLmFkYXB0ZXJfLmdldFRhYkluZGV4KCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHJpYnV0ZShzdHJpbmdzLkFSSUFfRElTQUJMRUQsICd0cnVlJyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVBdHRyaWJ1dGUoc3RyaW5ncy5BUklBX0RJU0FCTEVEKTtcbiAgICAgIGlmICghaXNOYU4odGhpcy5zYXZlZFRhYkluZGV4XykpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgU3RyaW5nKHRoaXMuc2F2ZWRUYWJJbmRleF8pKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGludGVyYWN0aW5nIHdpdGggdGhlIHNsaWRlclxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVEb3duXyhldnQpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnByZXZlbnRGb2N1c1N0YXRlXyA9IHRydWU7XG4gICAgdGhpcy5zZXRJblRyYW5zaXRfKCF0aGlzLmhhbmRsaW5nVGh1bWJUYXJnZXRFdnRfKTtcbiAgICB0aGlzLmhhbmRsaW5nVGh1bWJUYXJnZXRFdnRfID0gZmFsc2U7XG4gICAgdGhpcy5zZXRBY3RpdmVfKHRydWUpO1xuXG4gICAgY29uc3QgbW92ZUhhbmRsZXIgPSAoZXZ0KSA9PiB7XG4gICAgICB0aGlzLmhhbmRsZU1vdmVfKGV2dCk7XG4gICAgfTtcblxuICAgIC8vIE5vdGU6IHVwSGFuZGxlciBpcyBbZGVdcmVnaXN0ZXJlZCBvbiBBTEwgcG90ZW50aWFsIHBvaW50ZXItcmVsYXRlZCByZWxlYXNlIGV2ZW50IHR5cGVzLCBzaW5jZSBzb21lIGJyb3dzZXJzXG4gICAgLy8gZG8gbm90IGFsd2F5cyBmaXJlIHRoZXNlIGNvbnNpc3RlbnRseSBpbiBwYWlycy5cbiAgICAvLyAoU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2lzc3Vlcy8xMTkyKVxuICAgIGNvbnN0IHVwSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlVXBfKCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyKE1PVkVfRVZFTlRfTUFQW2V2dC50eXBlXSwgbW92ZUhhbmRsZXIpO1xuICAgICAgVVBfRVZFTlRTLmZvckVhY2goKGV2dE5hbWUpID0+IHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0TmFtZSwgdXBIYW5kbGVyKSk7XG4gICAgfTtcblxuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyKE1PVkVfRVZFTlRfTUFQW2V2dC50eXBlXSwgbW92ZUhhbmRsZXIpO1xuICAgIFVQX0VWRU5UUy5mb3JFYWNoKChldnROYW1lKSA9PiB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlcihldnROYW1lLCB1cEhhbmRsZXIpKTtcbiAgICB0aGlzLnNldFZhbHVlRnJvbUV2dF8oZXZ0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgdXNlciBtb3ZlcyB0aGUgc2xpZGVyXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZU1vdmVfKGV2dCkge1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuc2V0VmFsdWVGcm9tRXZ0XyhldnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSB1c2VyJ3MgaW50ZXJhY3Rpb24gd2l0aCB0aGUgc2xpZGVyIGVuZHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVVwXygpIHtcbiAgICB0aGlzLnNldEFjdGl2ZV8oZmFsc2UpO1xuICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2hhbmdlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGFnZVggb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UGFnZVhfKGV2dCkge1xuICAgIGlmIChldnQudGFyZ2V0VG91Y2hlcyAmJiBldnQudGFyZ2V0VG91Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gZXZ0LnRhcmdldFRvdWNoZXNbMF0ucGFnZVg7XG4gICAgfVxuICAgIHJldHVybiBldnQucGFnZVg7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc2xpZGVyIHZhbHVlIGZyb20gYW4gZXZlbnRcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0VmFsdWVGcm9tRXZ0XyhldnQpIHtcbiAgICBjb25zdCBwYWdlWCA9IHRoaXMuZ2V0UGFnZVhfKGV2dCk7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmNvbXB1dGVWYWx1ZUZyb21QYWdlWF8ocGFnZVgpO1xuICAgIHRoaXMuc2V0VmFsdWVfKHZhbHVlLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgbmV3IHZhbHVlIGZyb20gdGhlIHBhZ2VYIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwYWdlWFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBjb21wdXRlVmFsdWVGcm9tUGFnZVhfKHBhZ2VYKSB7XG4gICAgY29uc3Qge21heF86IG1heCwgbWluXzogbWlufSA9IHRoaXM7XG4gICAgY29uc3QgeFBvcyA9IHBhZ2VYIC0gdGhpcy5yZWN0Xy5sZWZ0O1xuICAgIGxldCBwY3RDb21wbGV0ZSA9IHhQb3MgLyB0aGlzLnJlY3RfLndpZHRoO1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzUlRMKCkpIHtcbiAgICAgIHBjdENvbXBsZXRlID0gMSAtIHBjdENvbXBsZXRlO1xuICAgIH1cbiAgICAvLyBGaXQgdGhlIHBlcmNlbnRhZ2UgY29tcGxldGUgYmV0d2VlbiB0aGUgcmFuZ2UgW21pbixtYXhdXG4gICAgLy8gYnkgcmVtYXBwaW5nIGZyb20gWzAsIDFdIHRvIFttaW4sIG1pbisobWF4LW1pbildLlxuICAgIHJldHVybiBtaW4gKyBwY3RDb21wbGV0ZSAqIChtYXggLSBtaW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMga2V5ZG93biBldmVudHNcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgaGFuZGxlS2V5ZG93bl8oZXZ0KSB7XG4gICAgY29uc3Qga2V5SWQgPSB0aGlzLmdldEtleUlkXyhldnQpO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXRWYWx1ZUZvcktleUlkXyhrZXlJZCk7XG4gICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFByZXZlbnQgcGFnZSBmcm9tIHNjcm9sbGluZyBkdWUgdG8ga2V5IHByZXNzZXMgdGhhdCB3b3VsZCBub3JtYWxseSBzY3JvbGwgdGhlIHBhZ2VcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuRk9DVVMpO1xuICAgIHRoaXMuc2V0VmFsdWVfKHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUNoYW5nZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbXB1dGVkIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7IUV2ZW50fSBrYmRFdnRcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0S2V5SWRfKGtiZEV2dCkge1xuICAgIGlmIChrYmRFdnQua2V5ID09PSBLRVlfSURTLkFSUk9XX0xFRlQgfHwga2JkRXZ0LmtleUNvZGUgPT09IDM3KSB7XG4gICAgICByZXR1cm4gS0VZX0lEUy5BUlJPV19MRUZUO1xuICAgIH1cbiAgICBpZiAoa2JkRXZ0LmtleSA9PT0gS0VZX0lEUy5BUlJPV19SSUdIVCB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzkpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLkFSUk9XX1JJR0hUO1xuICAgIH1cbiAgICBpZiAoa2JkRXZ0LmtleSA9PT0gS0VZX0lEUy5BUlJPV19VUCB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzgpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLkFSUk9XX1VQO1xuICAgIH1cbiAgICBpZiAoa2JkRXZ0LmtleSA9PT0gS0VZX0lEUy5BUlJPV19ET1dOIHx8IGtiZEV2dC5rZXlDb2RlID09PSA0MCkge1xuICAgICAgcmV0dXJuIEtFWV9JRFMuQVJST1dfRE9XTjtcbiAgICB9XG4gICAgaWYgKGtiZEV2dC5rZXkgPT09IEtFWV9JRFMuSE9NRSB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzYpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLkhPTUU7XG4gICAgfVxuICAgIGlmIChrYmRFdnQua2V5ID09PSBLRVlfSURTLkVORCB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzUpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLkVORDtcbiAgICB9XG4gICAgaWYgKGtiZEV2dC5rZXkgPT09IEtFWV9JRFMuUEFHRV9VUCB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzMpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLlBBR0VfVVA7XG4gICAgfVxuICAgIGlmIChrYmRFdnQua2V5ID09PSBLRVlfSURTLlBBR0VfRE9XTiB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzQpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLlBBR0VfRE9XTjtcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHZhbHVlIGdpdmVuIGEga2V5Ym9hcmQga2V5IElEXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlJZFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRWYWx1ZUZvcktleUlkXyhrZXlJZCkge1xuICAgIGNvbnN0IHttYXhfOiBtYXgsIG1pbl86IG1pbiwgc3RlcF86IHN0ZXB9ID0gdGhpcztcbiAgICBsZXQgZGVsdGEgPSBzdGVwIHx8IChtYXggLSBtaW4pIC8gMTAwO1xuICAgIGNvbnN0IHZhbHVlTmVlZHNUb0JlRmxpcHBlZCA9IHRoaXMuYWRhcHRlcl8uaXNSVEwoKSAmJiAoXG4gICAgICBrZXlJZCA9PT0gS0VZX0lEUy5BUlJPV19MRUZUIHx8IGtleUlkID09PSBLRVlfSURTLkFSUk9XX1JJR0hUXG4gICAgKTtcbiAgICBpZiAodmFsdWVOZWVkc1RvQmVGbGlwcGVkKSB7XG4gICAgICBkZWx0YSA9IC1kZWx0YTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGtleUlkKSB7XG4gICAgY2FzZSBLRVlfSURTLkFSUk9XX0xFRlQ6XG4gICAgY2FzZSBLRVlfSURTLkFSUk9XX0RPV046XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZV8gLSBkZWx0YTtcbiAgICBjYXNlIEtFWV9JRFMuQVJST1dfUklHSFQ6XG4gICAgY2FzZSBLRVlfSURTLkFSUk9XX1VQOlxuICAgICAgcmV0dXJuIHRoaXMudmFsdWVfICsgZGVsdGE7XG4gICAgY2FzZSBLRVlfSURTLkhPTUU6XG4gICAgICByZXR1cm4gdGhpcy5taW5fO1xuICAgIGNhc2UgS0VZX0lEUy5FTkQ6XG4gICAgICByZXR1cm4gdGhpcy5tYXhfO1xuICAgIGNhc2UgS0VZX0lEUy5QQUdFX1VQOlxuICAgICAgcmV0dXJuIHRoaXMudmFsdWVfICsgZGVsdGEgKiBudW1iZXJzLlBBR0VfRkFDVE9SO1xuICAgIGNhc2UgS0VZX0lEUy5QQUdFX0RPV046XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZV8gLSBkZWx0YSAqIG51bWJlcnMuUEFHRV9GQUNUT1I7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlRm9jdXNfKCkge1xuICAgIGlmICh0aGlzLnByZXZlbnRGb2N1c1N0YXRlXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuRk9DVVMpO1xuICB9XG5cbiAgaGFuZGxlQmx1cl8oKSB7XG4gICAgdGhpcy5wcmV2ZW50Rm9jdXNTdGF0ZV8gPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuRk9DVVMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBzbGlkZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkRmlyZUlucHV0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGZvcmNlXG4gICAqL1xuICBzZXRWYWx1ZV8odmFsdWUsIHNob3VsZEZpcmVJbnB1dCwgZm9yY2UgPSBmYWxzZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdGhpcy52YWx1ZV8gJiYgIWZvcmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge21pbl86IG1pbiwgbWF4XzogbWF4fSA9IHRoaXM7XG4gICAgY29uc3QgdmFsdWVTZXRUb0JvdW5kYXJ5ID0gdmFsdWUgPT09IG1pbiB8fCB2YWx1ZSA9PT0gbWF4O1xuICAgIGlmICh0aGlzLnN0ZXBfICYmICF2YWx1ZVNldFRvQm91bmRhcnkpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5xdWFudGl6ZV8odmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgIHZhbHVlID0gbWluO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgIHZhbHVlID0gbWF4O1xuICAgIH1cbiAgICB0aGlzLnZhbHVlXyA9IHZhbHVlO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cmlidXRlKHN0cmluZ3MuQVJJQV9WQUxVRU5PVywgU3RyaW5nKHRoaXMudmFsdWVfKSk7XG4gICAgdGhpcy51cGRhdGVVSUZvckN1cnJlbnRWYWx1ZV8oKTtcblxuICAgIGlmIChzaG91bGRGaXJlSW5wdXQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5SW5wdXQoKTtcbiAgICAgIGlmICh0aGlzLmlzRGlzY3JldGVfKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uc2V0TWFya2VyVmFsdWUodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBxdWFudGl6ZWQgdmFsdWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHF1YW50aXplXyh2YWx1ZSkge1xuICAgIGNvbnN0IG51bVN0ZXBzID0gTWF0aC5yb3VuZCh2YWx1ZSAvIHRoaXMuc3RlcF8pO1xuICAgIGNvbnN0IHF1YW50aXplZFZhbCA9IG51bVN0ZXBzICogdGhpcy5zdGVwXztcbiAgICByZXR1cm4gcXVhbnRpemVkVmFsO1xuICB9XG5cbiAgdXBkYXRlVUlGb3JDdXJyZW50VmFsdWVfKCkge1xuICAgIGNvbnN0IHttYXhfOiBtYXgsIG1pbl86IG1pbiwgdmFsdWVfOiB2YWx1ZX0gPSB0aGlzO1xuICAgIGNvbnN0IHBjdENvbXBsZXRlID0gKHZhbHVlIC0gbWluKSAvIChtYXggLSBtaW4pO1xuICAgIGxldCB0cmFuc2xhdGVQeCA9IHBjdENvbXBsZXRlICogdGhpcy5yZWN0Xy53aWR0aDtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc1JUTCgpKSB7XG4gICAgICB0cmFuc2xhdGVQeCA9IHRoaXMucmVjdF8ud2lkdGggLSB0cmFuc2xhdGVQeDtcbiAgICB9XG5cbiAgICBjb25zdCB0cmFuc2Zvcm1Qcm9wID0gZ2V0Q29ycmVjdFByb3BlcnR5TmFtZSh3aW5kb3csICd0cmFuc2Zvcm0nKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uZW5kRXZ0TmFtZSA9IGdldENvcnJlY3RFdmVudE5hbWUod2luZG93LCAndHJhbnNpdGlvbmVuZCcpO1xuXG4gICAgaWYgKHRoaXMuaW5UcmFuc2l0Xykge1xuICAgICAgY29uc3Qgb25UcmFuc2l0aW9uRW5kID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnNldEluVHJhbnNpdF8oZmFsc2UpO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlcih0cmFuc2l0aW9uZW5kRXZ0TmFtZSwgb25UcmFuc2l0aW9uRW5kKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIodHJhbnNpdGlvbmVuZEV2dE5hbWUsIG9uVHJhbnNpdGlvbkVuZCk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVVSUZyYW1lXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAvLyBOT1RFKHRyYXZpc2thdWZtYW4pOiBJdCB3b3VsZCBiZSBuaWNlIHRvIHVzZSBjYWxjKCkgaGVyZSxcbiAgICAgIC8vIGJ1dCBJRSBjYW5ub3QgaGFuZGxlIGNhbGNzIGluIHRyYW5zZm9ybXMgY29ycmVjdGx5LlxuICAgICAgLy8gU2VlOiBodHRwczovL2dvby5nbC9OQzJpdGtcbiAgICAgIC8vIEFsc28gbm90ZSB0aGF0IHRoZSAtNTAlIG9mZnNldCBpcyB1c2VkIHRvIGNlbnRlciB0aGUgc2xpZGVyIHRodW1iLlxuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRUaHVtYkNvbnRhaW5lclN0eWxlUHJvcGVydHkodHJhbnNmb3JtUHJvcCwgYHRyYW5zbGF0ZVgoJHt0cmFuc2xhdGVQeH1weCkgdHJhbnNsYXRlWCgtNTAlKWApO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRUcmFja1N0eWxlUHJvcGVydHkodHJhbnNmb3JtUHJvcCwgYHNjYWxlWCgke3BjdENvbXBsZXRlfSlgKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBhY3RpdmUgc3RhdGUgb2YgdGhlIHNsaWRlclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFjdGl2ZVxuICAgKi9cbiAgc2V0QWN0aXZlXyhhY3RpdmUpIHtcbiAgICB0aGlzLmFjdGl2ZV8gPSBhY3RpdmU7XG4gICAgdGhpcy50b2dnbGVDbGFzc18oY3NzQ2xhc3Nlcy5BQ1RJVkUsIHRoaXMuYWN0aXZlXyk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgaW5UcmFuc2l0IHN0YXRlIG9mIHRoZSBzbGlkZXJcbiAgICogQHBhcmFtIHtib29sZWFufSBpblRyYW5zaXRcbiAgICovXG4gIHNldEluVHJhbnNpdF8oaW5UcmFuc2l0KSB7XG4gICAgdGhpcy5pblRyYW5zaXRfID0gaW5UcmFuc2l0O1xuICAgIHRoaXMudG9nZ2xlQ2xhc3NfKGNzc0NsYXNzZXMuSU5fVFJBTlNJVCwgdGhpcy5pblRyYW5zaXRfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25kaXRpb25hbGx5IGFkZHMgb3IgcmVtb3ZlcyBhIGNsYXNzIGJhc2VkIG9uIHNob3VsZEJlUHJlc2VudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkQmVQcmVzZW50XG4gICAqL1xuICB0b2dnbGVDbGFzc18oY2xhc3NOYW1lLCBzaG91bGRCZVByZXNlbnQpIHtcbiAgICBpZiAoc2hvdWxkQmVQcmVzZW50KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNsYXNzTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDU2xpZGVyRm91bmRhdGlvbjtcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdlxuICAgIDpjbGFzcz1cImNsYXNzZXNcIlxuICAgIGNsYXNzPVwibWRjLXNsaWRlclwiXG4gICAgdGFiaW5kZXg9XCIwXCJcbiAgICByb2xlPVwic2xpZGVyXCI+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1zbGlkZXJfX3RyYWNrLWNvbnRhaW5lclwiPlxuICAgICAgPGRpdlxuICAgICAgICA6c3R5bGU9XCJ0cmFja1N0eWxlc1wiXG4gICAgICAgIGNsYXNzPVwibWRjLXNsaWRlcl9fdHJhY2tcIi8+XG4gICAgICA8ZGl2XG4gICAgICAgIHYtaWY9XCJoYXNNYXJrZXJzXCJcbiAgICAgICAgY2xhc3M9XCJtZGMtc2xpZGVyX190cmFjay1tYXJrZXItY29udGFpbmVyXCI+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICB2LWZvcj1cIm1hcmtlck51bSBpbiBudW1NYXJrZXJzXCJcbiAgICAgICAgICA6a2V5PVwibWFya2VyTnVtXCJcbiAgICAgICAgICA6c3R5bGU9XCIobWFya2VyTnVtID09IG51bU1hcmtlcnMpID8gbGFzdFRyYWNrTWFya2Vyc1N0eWxlcyA6IHt9XCJcbiAgICAgICAgICBjbGFzcz1cIm1kYy1zbGlkZXJfX3RyYWNrLW1hcmtlclwiXG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2XG4gICAgICByZWY9XCJ0aHVtYkNvbnRhaW5lclwiXG4gICAgICA6c3R5bGU9XCJ0aHVtYlN0eWxlc1wiXG4gICAgICBjbGFzcz1cIm1kYy1zbGlkZXJfX3RodW1iLWNvbnRhaW5lclwiPlxuICAgICAgPGRpdlxuICAgICAgICB2LWlmPVwiaXNEaXNjcmV0ZVwiXG4gICAgICAgIGNsYXNzPVwibWRjLXNsaWRlcl9fcGluXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwibWRjLXNsaWRlcl9fcGluLXZhbHVlLW1hcmtlclwiPnt7IG1hcmtlclZhbHVlIH19PC9zcGFuPlxuICAgICAgPC9kaXY+XG4gICAgICA8c3ZnXG4gICAgICAgIGNsYXNzPVwibWRjLXNsaWRlcl9fdGh1bWJcIlxuICAgICAgICB3aWR0aD1cIjIxXCJcbiAgICAgICAgaGVpZ2h0PVwiMjFcIj5cbiAgICAgICAgPGNpcmNsZVxuICAgICAgICAgIGN4PVwiMTAuNVwiXG4gICAgICAgICAgY3k9XCIxMC41XCJcbiAgICAgICAgICByPVwiNy44NzVcIi8+XG4gICAgICA8L3N2Zz5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtc2xpZGVyX19mb2N1cy1yaW5nXCIvPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDU2xpZGVyRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvc2xpZGVyL2ZvdW5kYXRpb24nXG5pbXBvcnQgeyBEaXNwYXRjaEZvY3VzTWl4aW4sIGFwcGx5UGFzc2l2ZSB9IGZyb20gJy4uL2Jhc2UnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1zbGlkZXInLFxuICBtaXhpbnM6IFtEaXNwYXRjaEZvY3VzTWl4aW5dLFxuICBtb2RlbDoge1xuICAgIHByb3A6ICd2YWx1ZScsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgdmFsdWU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgbWluOiB7IHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sIGRlZmF1bHQ6IDAgfSxcbiAgICBtYXg6IHsgdHlwZTogW051bWJlciwgU3RyaW5nXSwgZGVmYXVsdDogMTAwIH0sXG4gICAgc3RlcDogeyB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLCBkZWZhdWx0OiAwIH0sXG4gICAgZGlzcGxheU1hcmtlcnM6IEJvb2xlYW4sXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgbGF5b3V0T246IFN0cmluZyxcbiAgICBsYXlvdXRPblNvdXJjZTogeyB0eXBlOiBPYmplY3QsIHJlcXVpcmVkOiBmYWxzZSB9XG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1zbGlkZXItLWRpc2NyZXRlJzogISF0aGlzLnN0ZXAsXG4gICAgICAgICdtZGMtc2xpZGVyLS1kaXNwbGF5LW1hcmtlcnMnOiB0aGlzLmRpc3BsYXlNYXJrZXJzXG4gICAgICB9LFxuICAgICAgdHJhY2tTdHlsZXM6IHt9LFxuICAgICAgbGFzdFRyYWNrTWFya2Vyc1N0eWxlczoge30sXG4gICAgICB0aHVtYlN0eWxlczoge30sXG4gICAgICBtYXJrZXJWYWx1ZTogJycsXG4gICAgICBudW1NYXJrZXJzOiAwXG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGlzRGlzY3JldGUoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnN0ZXBcbiAgICB9LFxuICAgIGhhc01hcmtlcnMoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnN0ZXAgJiYgdGhpcy5kaXNwbGF5TWFya2VycyAmJiB0aGlzLm51bU1hcmtlcnNcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgdmFsdWUoKSB7XG4gICAgICBpZiAodGhpcy5mb3VuZGF0aW9uLmdldFZhbHVlKCkgIT09IE51bWJlcih0aGlzLnZhbHVlKSkge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24uc2V0VmFsdWUodGhpcy52YWx1ZSlcbiAgICAgIH1cbiAgICB9LFxuICAgIG1pbigpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRNaW4oTnVtYmVyKHRoaXMubWluKSlcbiAgICB9LFxuICAgIG1heCgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRNYXgoTnVtYmVyKHRoaXMubWF4KSlcbiAgICB9LFxuICAgIHN0ZXAoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0U3RlcChOdW1iZXIodGhpcy5zdGVwKSlcbiAgICB9LFxuICAgIGRpc2FibGVkKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpXG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENTbGlkZXJGb3VuZGF0aW9uKHtcbiAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSksXG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgfSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICB9LFxuICAgICAgZ2V0QXR0cmlidXRlOiBuYW1lID0+IHRoaXMuJGVsLmdldEF0dHJpYnV0ZShuYW1lKSxcbiAgICAgIHNldEF0dHJpYnV0ZTogKG5hbWUsIHZhbHVlKSA9PiB0aGlzLiRlbC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpLFxuICAgICAgcmVtb3ZlQXR0cmlidXRlOiBuYW1lID0+IHRoaXMuJGVsLnJlbW92ZUF0dHJpYnV0ZShuYW1lKSxcbiAgICAgIGNvbXB1dGVCb3VuZGluZ1JlY3Q6ICgpID0+IHRoaXMuJGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgZ2V0VGFiSW5kZXg6ICgpID0+IHRoaXMuJGVsLnRhYkluZGV4LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgYXBwbHlQYXNzaXZlKCkpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBhcHBseVBhc3NpdmUoKSlcbiAgICAgIH0sXG4gICAgICByZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLnRodW1iQ29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgIGFwcGx5UGFzc2l2ZSgpXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMudGh1bWJDb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgYXBwbHlQYXNzaXZlKClcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgbm90aWZ5SW5wdXQ6ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCB0aGlzLmZvdW5kYXRpb24uZ2V0VmFsdWUoKSlcbiAgICAgIH0sXG4gICAgICBub3RpZnlDaGFuZ2U6ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdGhpcy5mb3VuZGF0aW9uLmdldFZhbHVlKCkpXG4gICAgICB9LFxuICAgICAgc2V0VGh1bWJDb250YWluZXJTdHlsZVByb3BlcnR5OiAocHJvcGVydHlOYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy50aHVtYlN0eWxlcywgcHJvcGVydHlOYW1lLCB2YWx1ZSlcbiAgICAgIH0sXG4gICAgICBzZXRUcmFja1N0eWxlUHJvcGVydHk6IChwcm9wZXJ0eU5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnRyYWNrU3R5bGVzLCBwcm9wZXJ0eU5hbWUsIHZhbHVlKVxuICAgICAgfSxcbiAgICAgIHNldE1hcmtlclZhbHVlOiB2YWx1ZSA9PiB7XG4gICAgICAgIHRoaXMubWFya2VyVmFsdWUgPSB2YWx1ZVxuICAgICAgfSxcbiAgICAgIGFwcGVuZFRyYWNrTWFya2VyczogbnVtTWFya2VycyA9PiB7XG4gICAgICAgIHRoaXMubnVtTWFya2VycyA9IG51bU1hcmtlcnNcbiAgICAgIH0sXG4gICAgICByZW1vdmVUcmFja01hcmtlcnM6ICgpID0+IHtcbiAgICAgICAgdGhpcy5udW1NYXJrZXJzID0gMFxuICAgICAgfSxcbiAgICAgIHNldExhc3RUcmFja01hcmtlcnNTdHlsZVByb3BlcnR5OiAocHJvcGVydHlOYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5sYXN0VHJhY2tNYXJrZXJzU3R5bGVzLCBwcm9wZXJ0eU5hbWUsIHZhbHVlKVxuICAgICAgfSxcbiAgICAgIGlzUlRMOiAoKSA9PiBmYWxzZVxuICAgIH0pXG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpXG4gICAgaWYgKE51bWJlcih0aGlzLm1pbikgPD0gdGhpcy5mb3VuZGF0aW9uLmdldE1heCgpKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0TWluKE51bWJlcih0aGlzLm1pbikpXG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0TWF4KE51bWJlcih0aGlzLm1heCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRNYXgoTnVtYmVyKHRoaXMubWF4KSlcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRNaW4oTnVtYmVyKHRoaXMubWluKSlcbiAgICB9XG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldFN0ZXAoTnVtYmVyKHRoaXMuc3RlcCkpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldFZhbHVlKE51bWJlcih0aGlzLnZhbHVlKSlcbiAgICBpZiAodGhpcy5oYXNNYXJrZXJzKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0dXBUcmFja01hcmtlcigpXG4gICAgfVxuXG4gICAgdGhpcy4kcm9vdC4kb24oJ3ZtYTpsYXlvdXQnLCB0aGlzLmxheW91dClcblxuICAgIGlmICh0aGlzLmxheW91dE9uKSB7XG4gICAgICB0aGlzLmxheW91dE9uRXZlbnRTb3VyY2UgPSB0aGlzLmxheW91dE9uU291cmNlIHx8IHRoaXMuJHJvb3RcbiAgICAgIHRoaXMubGF5b3V0T25FdmVudFNvdXJjZS4kb24odGhpcy5sYXlvdXRPbiwgdGhpcy5sYXlvdXQpXG4gICAgfVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuJHJvb3QuJG9mZigndm1hOmxheW91dCcsIHRoaXMubGF5b3V0KVxuICAgIGlmICh0aGlzLmxheW91dE9uRXZlbnRTb3VyY2UpIHtcbiAgICAgIHRoaXMubGF5b3V0T25FdmVudFNvdXJjZS4kb2ZmKHRoaXMubGF5b3V0T24sIHRoaXMubGF5b3V0KVxuICAgIH1cbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBsYXlvdXQoKSB7XG4gICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24ubGF5b3V0KClcbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY1NsaWRlciBmcm9tICcuL21kYy1zbGlkZXIudnVlJ1xuXG5leHBvcnQgeyBtZGNTbGlkZXIgfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjU2xpZGVyXG59KVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xuICBST09UOiAnbWRjLXNuYWNrYmFyJyxcbiAgVEVYVDogJ21kYy1zbmFja2Jhcl9fdGV4dCcsXG4gIEFDVElPTl9XUkFQUEVSOiAnbWRjLXNuYWNrYmFyX19hY3Rpb24td3JhcHBlcicsXG4gIEFDVElPTl9CVVRUT046ICdtZGMtc25hY2tiYXJfX2FjdGlvbi1idXR0b24nLFxuICBBQ1RJVkU6ICdtZGMtc25hY2tiYXItLWFjdGl2ZScsXG4gIE1VTFRJTElORTogJ21kYy1zbmFja2Jhci0tbXVsdGlsaW5lJyxcbiAgQUNUSU9OX09OX0JPVFRPTTogJ21kYy1zbmFja2Jhci0tYWN0aW9uLW9uLWJvdHRvbScsXG59O1xuXG5leHBvcnQgY29uc3Qgc3RyaW5ncyA9IHtcbiAgVEVYVF9TRUxFQ1RPUjogJy5tZGMtc25hY2tiYXJfX3RleHQnLFxuICBBQ1RJT05fV1JBUFBFUl9TRUxFQ1RPUjogJy5tZGMtc25hY2tiYXJfX2FjdGlvbi13cmFwcGVyJyxcbiAgQUNUSU9OX0JVVFRPTl9TRUxFQ1RPUjogJy5tZGMtc25hY2tiYXJfX2FjdGlvbi1idXR0b24nLFxuICBTSE9XX0VWRU5UOiAnTURDU25hY2tiYXI6c2hvdycsXG4gIEhJREVfRVZFTlQ6ICdNRENTbmFja2JhcjpoaWRlJyxcbn07XG5cbmV4cG9ydCBjb25zdCBudW1iZXJzID0ge1xuICBNRVNTQUdFX1RJTUVPVVQ6IDI3NTAsXG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtNRENGb3VuZGF0aW9ufSBmcm9tICdAbWF0ZXJpYWwvYmFzZS9pbmRleCc7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURDU25hY2tiYXJGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXRBcmlhSGlkZGVuOiAoKSA9PiB7fSxcbiAgICAgIHVuc2V0QXJpYUhpZGRlbjogKCkgPT4ge30sXG4gICAgICBzZXRBY3Rpb25BcmlhSGlkZGVuOiAoKSA9PiB7fSxcbiAgICAgIHVuc2V0QWN0aW9uQXJpYUhpZGRlbjogKCkgPT4ge30sXG4gICAgICBzZXRBY3Rpb25UZXh0OiAoLyogYWN0aW9uVGV4dDogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldE1lc3NhZ2VUZXh0OiAoLyogbWVzc2FnZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldEZvY3VzOiAoKSA9PiB7fSxcbiAgICAgIHZpc2liaWxpdHlJc0hpZGRlbjogKCkgPT4gLyogYm9vbGVhbiAqLyBmYWxzZSxcbiAgICAgIHJlZ2lzdGVyQ2FwdHVyZWRCbHVySGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckNhcHR1cmVkQmx1ckhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyVmlzaWJpbGl0eUNoYW5nZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJWaXNpYmlsaXR5Q2hhbmdlSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJDYXB0dXJlZEludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dFR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyQ2FwdHVyZWRJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnRUeXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJBY3Rpb25DbGlja0hhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJBY3Rpb25DbGlja0hhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgbm90aWZ5U2hvdzogKCkgPT4ge30sXG4gICAgICBub3RpZnlIaWRlOiAoKSA9PiB7fSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVfO1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDU25hY2tiYXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICB0aGlzLmFjdGl2ZV8gPSBmYWxzZTtcbiAgICB0aGlzLmFjdGlvbldhc0NsaWNrZWRfID0gZmFsc2U7XG4gICAgdGhpcy5kaXNtaXNzT25BY3Rpb25fID0gdHJ1ZTtcbiAgICB0aGlzLmZpcnN0Rm9jdXNfID0gdHJ1ZTtcbiAgICB0aGlzLnBvaW50ZXJEb3duUmVjb2duaXplZF8gPSBmYWxzZTtcbiAgICB0aGlzLnNuYWNrYmFySGFzRm9jdXNfID0gZmFsc2U7XG4gICAgdGhpcy5zbmFja2JhckRhdGFfID0gbnVsbDtcbiAgICB0aGlzLnF1ZXVlXyA9IFtdO1xuICAgIHRoaXMuYWN0aW9uQ2xpY2tIYW5kbGVyXyA9ICgpID0+IHtcbiAgICAgIHRoaXMuYWN0aW9uV2FzQ2xpY2tlZF8gPSB0cnVlO1xuICAgICAgdGhpcy5pbnZva2VBY3Rpb25fKCk7XG4gICAgfTtcbiAgICB0aGlzLnZpc2liaWxpdHljaGFuZ2VIYW5kbGVyXyA9ICgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZF8pO1xuICAgICAgdGhpcy5zbmFja2Jhckhhc0ZvY3VzXyA9IHRydWU7XG5cbiAgICAgIGlmICghdGhpcy5hZGFwdGVyXy52aXNpYmlsaXR5SXNIaWRkZW4oKSkge1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMuY2xlYW51cF8uYmluZCh0aGlzKSwgdGhpcy5zbmFja2JhckRhdGFfLnRpbWVvdXQgfHwgbnVtYmVycy5NRVNTQUdFX1RJTUVPVVQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXJfID0gKGV2dCkgPT4ge1xuICAgICAgaWYgKGV2dC50eXBlID09ICd0b3VjaHN0YXJ0JyB8fCBldnQudHlwZSA9PSAnbW91c2Vkb3duJykge1xuICAgICAgICB0aGlzLnBvaW50ZXJEb3duUmVjb2duaXplZF8gPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5oYW5kbGVQb3NzaWJsZVRhYktleWJvYXJkRm9jdXNfKGV2dCk7XG5cbiAgICAgIGlmIChldnQudHlwZSA9PSAnZm9jdXMnKSB7XG4gICAgICAgIHRoaXMucG9pbnRlckRvd25SZWNvZ25pemVkXyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5ibHVySGFuZGxlcl8gPSAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWRfKTtcbiAgICAgIHRoaXMuc25hY2tiYXJIYXNGb2N1c18gPSBmYWxzZTtcbiAgICAgIHRoaXMudGltZW91dElkXyA9IHNldFRpbWVvdXQodGhpcy5jbGVhbnVwXy5iaW5kKHRoaXMpLCB0aGlzLnNuYWNrYmFyRGF0YV8udGltZW91dCB8fCBudW1iZXJzLk1FU1NBR0VfVElNRU9VVCk7XG4gICAgfTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckFjdGlvbkNsaWNrSGFuZGxlcih0aGlzLmFjdGlvbkNsaWNrSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXJpYUhpZGRlbigpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QWN0aW9uQXJpYUhpZGRlbigpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJBY3Rpb25DbGlja0hhbmRsZXIodGhpcy5hY3Rpb25DbGlja0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJDYXB0dXJlZEJsdXJIYW5kbGVyKHRoaXMuYmx1ckhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJWaXNpYmlsaXR5Q2hhbmdlSGFuZGxlcih0aGlzLnZpc2liaWxpdHljaGFuZ2VIYW5kbGVyXyk7XG4gICAgWyd0b3VjaHN0YXJ0JywgJ21vdXNlZG93bicsICdmb2N1cyddLmZvckVhY2goKGV2dFR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckNhcHR1cmVkSW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyXyk7XG4gICAgfSk7XG4gIH1cblxuICBkaXNtaXNzZXNPbkFjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNtaXNzT25BY3Rpb25fO1xuICB9XG5cbiAgc2V0RGlzbWlzc09uQWN0aW9uKGRpc21pc3NPbkFjdGlvbikge1xuICAgIHRoaXMuZGlzbWlzc09uQWN0aW9uXyA9ICEhZGlzbWlzc09uQWN0aW9uO1xuICB9XG5cbiAgc2hvdyhkYXRhKSB7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdQbGVhc2UgcHJvdmlkZSBhIGRhdGEgb2JqZWN0IHdpdGggYXQgbGVhc3QgYSBtZXNzYWdlIHRvIGRpc3BsYXkuJyk7XG4gICAgfVxuICAgIGlmICghZGF0YS5tZXNzYWdlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWQuJyk7XG4gICAgfVxuICAgIGlmIChkYXRhLmFjdGlvbkhhbmRsZXIgJiYgIWRhdGEuYWN0aW9uVGV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcHJvdmlkZSBhY3Rpb24gdGV4dCB3aXRoIHRoZSBoYW5kbGVyLicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgIHRoaXMucXVldWVfLnB1c2goZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZF8pO1xuICAgIHRoaXMuc25hY2tiYXJEYXRhXyA9IGRhdGE7XG4gICAgdGhpcy5maXJzdEZvY3VzXyA9IHRydWU7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclZpc2liaWxpdHlDaGFuZ2VIYW5kbGVyKHRoaXMudmlzaWJpbGl0eWNoYW5nZUhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyQ2FwdHVyZWRCbHVySGFuZGxlcih0aGlzLmJsdXJIYW5kbGVyXyk7XG4gICAgWyd0b3VjaHN0YXJ0JywgJ21vdXNlZG93bicsICdmb2N1cyddLmZvckVhY2goKGV2dFR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJDYXB0dXJlZEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCB0aGlzLmludGVyYWN0aW9uSGFuZGxlcl8pO1xuICAgIH0pO1xuXG4gICAgY29uc3Qge0FDVElWRSwgTVVMVElMSU5FLCBBQ1RJT05fT05fQk9UVE9NfSA9IGNzc0NsYXNzZXM7XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnNldE1lc3NhZ2VUZXh0KHRoaXMuc25hY2tiYXJEYXRhXy5tZXNzYWdlKTtcblxuICAgIGlmICh0aGlzLnNuYWNrYmFyRGF0YV8ubXVsdGlsaW5lKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1VTFRJTElORSk7XG4gICAgICBpZiAodGhpcy5zbmFja2JhckRhdGFfLmFjdGlvbk9uQm90dG9tKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoQUNUSU9OX09OX0JPVFRPTSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc25hY2tiYXJEYXRhXy5hY3Rpb25IYW5kbGVyKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEFjdGlvblRleHQodGhpcy5zbmFja2JhckRhdGFfLmFjdGlvblRleHQpO1xuICAgICAgdGhpcy5hY3Rpb25IYW5kbGVyXyA9IHRoaXMuc25hY2tiYXJEYXRhXy5hY3Rpb25IYW5kbGVyO1xuICAgICAgdGhpcy5zZXRBY3Rpb25IaWRkZW5fKGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRBY3Rpb25IaWRkZW5fKHRydWUpO1xuICAgICAgdGhpcy5hY3Rpb25IYW5kbGVyXyA9IG51bGw7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEFjdGlvblRleHQobnVsbCk7XG4gICAgfVxuXG4gICAgdGhpcy5hY3RpdmVfID0gdHJ1ZTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKEFDVElWRSk7XG4gICAgdGhpcy5hZGFwdGVyXy51bnNldEFyaWFIaWRkZW4oKTtcbiAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeVNob3coKTtcblxuICAgIHRoaXMudGltZW91dElkXyA9IHNldFRpbWVvdXQodGhpcy5jbGVhbnVwXy5iaW5kKHRoaXMpLCB0aGlzLnNuYWNrYmFyRGF0YV8udGltZW91dCB8fCBudW1iZXJzLk1FU1NBR0VfVElNRU9VVCk7XG4gIH1cblxuICBoYW5kbGVQb3NzaWJsZVRhYktleWJvYXJkRm9jdXNfKCkge1xuICAgIGNvbnN0IGhpamFja0ZvY3VzID1cbiAgICAgIHRoaXMuZmlyc3RGb2N1c18gJiYgIXRoaXMucG9pbnRlckRvd25SZWNvZ25pemVkXztcblxuICAgIGlmIChoaWphY2tGb2N1cykge1xuICAgICAgdGhpcy5zZXRGb2N1c09uQWN0aW9uXygpO1xuICAgIH1cblxuICAgIHRoaXMuZmlyc3RGb2N1c18gPSBmYWxzZTtcbiAgfVxuXG4gIHNldEZvY3VzT25BY3Rpb25fKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0Rm9jdXMoKTtcbiAgICB0aGlzLnNuYWNrYmFySGFzRm9jdXNfID0gdHJ1ZTtcbiAgICB0aGlzLmZpcnN0Rm9jdXNfID0gZmFsc2U7XG4gIH1cblxuICBpbnZva2VBY3Rpb25fKCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXRoaXMuYWN0aW9uSGFuZGxlcl8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFjdGlvbkhhbmRsZXJfKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh0aGlzLmRpc21pc3NPbkFjdGlvbl8pIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwXygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNsZWFudXBfKCkge1xuICAgIGNvbnN0IGFsbG93RGlzbWlzc2FsID0gIXRoaXMuc25hY2tiYXJIYXNGb2N1c18gfHwgdGhpcy5hY3Rpb25XYXNDbGlja2VkXztcblxuICAgIGlmIChhbGxvd0Rpc21pc3NhbCkge1xuICAgICAgY29uc3Qge0FDVElWRSwgTVVMVElMSU5FLCBBQ1RJT05fT05fQk9UVE9NfSA9IGNzc0NsYXNzZXM7XG5cbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoQUNUSVZFKTtcblxuICAgICAgY29uc3QgaGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkXyk7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyKGhhbmRsZXIpO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1VTFRJTElORSk7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoQUNUSU9OX09OX0JPVFRPTSk7XG4gICAgICAgIHRoaXMuc2V0QWN0aW9uSGlkZGVuXyh0cnVlKTtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBcmlhSGlkZGVuKCk7XG4gICAgICAgIHRoaXMuYWN0aXZlXyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNuYWNrYmFySGFzRm9jdXNfID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5SGlkZSgpO1xuICAgICAgICB0aGlzLnNob3dOZXh0XygpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyKGhhbmRsZXIpO1xuICAgIH1cbiAgfVxuXG4gIHNob3dOZXh0XygpIHtcbiAgICBpZiAoIXRoaXMucXVldWVfLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNob3codGhpcy5xdWV1ZV8uc2hpZnQoKSk7XG4gIH1cblxuICBzZXRBY3Rpb25IaWRkZW5fKGlzSGlkZGVuKSB7XG4gICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEFjdGlvbkFyaWFIaWRkZW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy51bnNldEFjdGlvbkFyaWFIaWRkZW4oKTtcbiAgICB9XG4gIH1cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBcbiAgICByZWY9XCJyb290XCIgXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIFxuICAgIDphcmlhLWhpZGRlbj1cImhpZGRlblwiIFxuICAgIGNsYXNzPVwibWRjLXNuYWNrYmFyXCIgXG4gICAgYXJpYS1saXZlPVwiYXNzZXJ0aXZlXCIgXG4gICAgYXJpYS1hdG9taWM9XCJ0cnVlXCI+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1zbmFja2Jhcl9fdGV4dFwiPnt7IG1lc3NhZ2UgfX08L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLXNuYWNrYmFyX19hY3Rpb24td3JhcHBlclwiPlxuICAgICAgPGJ1dHRvbiBcbiAgICAgICAgcmVmPVwiYnV0dG9uXCIgXG4gICAgICAgIDphcmlhLWhpZGRlbj1cImFjdGlvbkhpZGRlblwiIFxuICAgICAgICB0eXBlPVwiYnV0dG9uXCIgXG4gICAgICAgIGNsYXNzPVwibWRjLXNuYWNrYmFyX19hY3Rpb24tYnV0dG9uXCI+e3sgYWN0aW9uVGV4dCB9fTwvYnV0dG9uPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDU25hY2tiYXJGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9zbmFja2Jhci9mb3VuZGF0aW9uJ1xuaW1wb3J0IHsgZ2V0Q29ycmVjdEV2ZW50TmFtZSB9IGZyb20gJ0BtYXRlcmlhbC9hbmltYXRpb24nXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1zbmFja2JhcicsXG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ3NuYWNrJyxcbiAgICBldmVudDogJ3F1ZXVlZCdcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICAnYWxpZ24tc3RhcnQnOiBCb29sZWFuLFxuICAgIHNuYWNrOiBPYmplY3QsXG4gICAgZXZlbnQ6IFN0cmluZyxcbiAgICAnZXZlbnQtc291cmNlJzoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJvb3RcbiAgICAgIH1cbiAgICB9LFxuICAgICdkaXNtaXNzZXMtb24tYWN0aW9uJzoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1zbmFja2Jhci0tYWxpZ24tc3RhcnQnOiB0aGlzLmFsaWduU3RhcnRcbiAgICAgIH0sXG4gICAgICBtZXNzYWdlOiAnJyxcbiAgICAgIGFjdGlvblRleHQ6ICcnLFxuICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgIGFjdGlvbkhpZGRlbjogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgc25hY2s6ICdvblNuYWNrJ1xuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENTbmFja2JhckZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpLFxuICAgICAgc2V0QXJpYUhpZGRlbjogKCkgPT4gKHRoaXMuaGlkZGVuID0gdHJ1ZSksXG4gICAgICB1bnNldEFyaWFIaWRkZW46ICgpID0+ICh0aGlzLmhpZGRlbiA9IGZhbHNlKSxcbiAgICAgIHNldEFjdGlvbkFyaWFIaWRkZW46ICgpID0+ICh0aGlzLmFjdGlvbkhpZGRlbiA9IHRydWUpLFxuICAgICAgdW5zZXRBY3Rpb25BcmlhSGlkZGVuOiAoKSA9PiAodGhpcy5hY3Rpb25IaWRkZW4gPSBmYWxzZSksXG4gICAgICBzZXRBY3Rpb25UZXh0OiB0ZXh0ID0+IHtcbiAgICAgICAgdGhpcy5hY3Rpb25UZXh0ID0gdGV4dFxuICAgICAgfSxcbiAgICAgIHNldE1lc3NhZ2VUZXh0OiB0ZXh0ID0+IHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdGV4dFxuICAgICAgfSxcbiAgICAgIHNldEZvY3VzOiAoKSA9PiB0aGlzLiRyZWZzLmJ1dHRvbi5mb2N1cygpLFxuICAgICAgdmlzaWJpbGl0eUlzSGlkZGVuOiAoKSA9PiBkb2N1bWVudC5oaWRkZW4sXG4gICAgICByZWdpc3RlckNhcHR1cmVkQmx1ckhhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5idXR0b24uYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZXIsIHRydWUpLFxuICAgICAgZGVyZWdpc3RlckNhcHR1cmVkQmx1ckhhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5idXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZXIsIHRydWUpLFxuICAgICAgcmVnaXN0ZXJWaXNpYmlsaXR5Q2hhbmdlSGFuZGxlcjogaGFuZGxlciA9PlxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVyVmlzaWJpbGl0eUNoYW5nZUhhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGhhbmRsZXIpLFxuICAgICAgcmVnaXN0ZXJDYXB0dXJlZEludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciwgdHJ1ZSksXG4gICAgICBkZXJlZ2lzdGVyQ2FwdHVyZWRJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIsIHRydWUpLFxuICAgICAgcmVnaXN0ZXJBY3Rpb25DbGlja0hhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5idXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJBY3Rpb25DbGlja0hhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5idXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVyKSxcbiAgICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICBjb25zdCByb290ID0gdGhpcy4kcmVmcy5yb290XG4gICAgICAgIHJvb3QgJiZcbiAgICAgICAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICBnZXRDb3JyZWN0RXZlbnROYW1lKHdpbmRvdywgJ3RyYW5zaXRpb25lbmQnKSxcbiAgICAgICAgICAgIGhhbmRsZXJcbiAgICAgICAgICApXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMuJHJlZnMucm9vdFxuICAgICAgICByb290ICYmXG4gICAgICAgICAgcm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgZ2V0Q29ycmVjdEV2ZW50TmFtZSh3aW5kb3csICd0cmFuc2l0aW9uZW5kJyksXG4gICAgICAgICAgICBoYW5kbGVyXG4gICAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIG5vdGlmeVNob3c6ICgpID0+IHRoaXMuJGVtaXQoJ3Nob3cnKSxcbiAgICAgIG5vdGlmeUhpZGU6ICgpID0+IHRoaXMuJGVtaXQoJ2hpZGUnKVxuICAgIH0pXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuXG4gICAgLy8gaWYgZXZlbnQgc3BlY2lmaWVkIHVzZSBpdCwgZWxzZSBpZiBubyBzbmFjayBwcm9wIHRoZW4gdXNlIGRlZmF1bHQuXG4gICAgdGhpcy5ldmVudE5hbWUgPVxuICAgICAgdGhpcy5ldmVudCB8fCAodGhpcy5zbmFjayA9PT0gdm9pZCAwID8gJ3Nob3ctc25hY2tiYXInIDogbnVsbClcbiAgICBpZiAodGhpcy5ldmVudE5hbWUpIHtcbiAgICAgIHRoaXMuZXZlbnRTb3VyY2UuJG9uKHRoaXMuZXZlbnROYW1lLCB0aGlzLnNob3cpXG4gICAgfVxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXREaXNtaXNzT25BY3Rpb24odGhpcy5kaXNtaXNzZXNPbkFjdGlvbilcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5ldmVudFNvdXJjZSkge1xuICAgICAgdGhpcy5ldmVudFNvdXJjZS4kb2ZmKHRoaXMuZXZlbnROYW1lLCB0aGlzLnNob3cpXG4gICAgfVxuICAgIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uU25hY2soc25hY2spIHtcbiAgICAgIGlmIChzbmFjayAmJiBzbmFjay5tZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5zaG93KHNuYWNrKVxuICAgICAgICB0aGlzLiRlbWl0KCdxdWV1ZWQnLCBzbmFjaylcbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3coZGF0YSkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNob3coZGF0YSlcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjU25hY2tiYXIgZnJvbSAnLi9tZGMtc25hY2tiYXIudnVlJ1xuXG5leHBvcnQgeyBtZGNTbmFja2JhciB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNTbmFja2JhclxufSlcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgU3dpdGNoLiBQcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIG1hbmFnaW5nXG4gKiAtIGNsYXNzZXNcbiAqIC0gZG9tXG4gKlxuICogQWRkaXRpb25hbGx5LCBwcm92aWRlcyB0eXBlIGluZm9ybWF0aW9uIGZvciB0aGUgYWRhcHRlciB0byB0aGUgQ2xvc3VyZVxuICogY29tcGlsZXIuXG4gKlxuICogSW1wbGVtZW50IHRoaXMgYWRhcHRlciBmb3IgeW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlIHRvIGRlbGVnYXRlIHVwZGF0ZXMgdG9cbiAqIHRoZSBjb21wb25lbnQgaW4geW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlLiBTZWUgYXJjaGl0ZWN0dXJlIGRvY3VtZW50YXRpb25cbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2NvZGUvYXJjaGl0ZWN0dXJlLm1kXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENTd2l0Y2hBZGFwdGVyIHtcbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBjaGVja2VkICovXG4gIHNldE5hdGl2ZUNvbnRyb2xDaGVja2VkKGNoZWNrZWQpIHt9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59IGNoZWNrZWQgKi9cbiAgaXNOYXRpdmVDb250cm9sQ2hlY2tlZCgpIHt9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWQgKi9cbiAgc2V0TmF0aXZlQ29udHJvbERpc2FibGVkKGRpc2FibGVkKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSBkaXNhYmxlZCAqL1xuICBpc05hdGl2ZUNvbnRyb2xEaXNhYmxlZCgpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1N3aXRjaEFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBDSEVDS0VEOiAnbWRjLXN3aXRjaC0tY2hlY2tlZCcsXG4gIERJU0FCTEVEOiAnbWRjLXN3aXRjaC0tZGlzYWJsZWQnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBOQVRJVkVfQ09OVFJPTF9TRUxFQ1RPUjogJy5tZGMtc3dpdGNoX19uYXRpdmUtY29udHJvbCcsXG4gIFJJUFBMRV9TVVJGQUNFX1NFTEVDVE9SOiAnLm1kYy1zd2l0Y2hfX3RodW1iLXVuZGVybGF5Jyxcbn07XG5cblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENTd2l0Y2hBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDU3dpdGNoQWRhcHRlcj59XG4gKi9cbmNsYXNzIE1EQ1N3aXRjaEZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshTURDU3dpdGNoQWRhcHRlcn0gKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDU3dpdGNoQWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXROYXRpdmVDb250cm9sQ2hlY2tlZDogKC8qIGNoZWNrZWQ6IGJvb2xlYW4gKi8pID0+IHt9LFxuICAgICAgaXNOYXRpdmVDb250cm9sQ2hlY2tlZDogKCkgPT4gLyogYm9vbGVhbiAqLyB7fSxcbiAgICAgIHNldE5hdGl2ZUNvbnRyb2xEaXNhYmxlZDogKC8qIGRpc2FibGVkOiBib29sZWFuICovKSA9PiB7fSxcbiAgICAgIGlzTmF0aXZlQ29udHJvbERpc2FibGVkOiAoKSA9PiAvKiBib29sZWFuICovIHt9LFxuICAgIH0pO1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDU3dpdGNoRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBpbml0KCkge1xuICAgIC8vIERvIGFuIGluaXRpYWwgc3RhdGUgdXBkYXRlIGJhc2VkIG9uIHRoZSBzdGF0ZSBvZiB0aGUgbmF0aXZlIGNvbnRyb2wuXG4gICAgdGhpcy5oYW5kbGVDaGFuZ2UoKTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc0NoZWNrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uaXNOYXRpdmVDb250cm9sQ2hlY2tlZCgpO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2tlZCAqL1xuICBzZXRDaGVja2VkKGNoZWNrZWQpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldE5hdGl2ZUNvbnRyb2xDaGVja2VkKGNoZWNrZWQpO1xuICAgIHRoaXMudXBkYXRlQ2hlY2tlZFN0eWxpbmdfKGNoZWNrZWQpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uaXNOYXRpdmVDb250cm9sRGlzYWJsZWQoKTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVkICovXG4gIHNldERpc2FibGVkKGRpc2FibGVkKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXROYXRpdmVDb250cm9sRGlzYWJsZWQoZGlzYWJsZWQpO1xuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLkRJU0FCTEVEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkRJU0FCTEVEKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgY2hhbmdlIGV2ZW50IGZvciB0aGUgc3dpdGNoIG5hdGl2ZSBjb250cm9sLlxuICAgKi9cbiAgaGFuZGxlQ2hhbmdlKCkge1xuICAgIHRoaXMudXBkYXRlQ2hlY2tlZFN0eWxpbmdfKHRoaXMuaXNDaGVja2VkKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHN0eWxpbmcgb2YgdGhlIHN3aXRjaCBiYXNlZCBvbiBpdHMgY2hlY2tlZCBzdGF0ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBjaGVja2VkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGVDaGVja2VkU3R5bGluZ18oY2hlY2tlZCkge1xuICAgIGlmIChjaGVja2VkKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuQ0hFQ0tFRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5DSEVDS0VEKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDU3dpdGNoRm91bmRhdGlvbjtcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdlxuICAgIDpjbGFzcz1cIntcbiAgICAgICdtZGMtZm9ybS1maWVsZCc6IGhhc0xhYmVsLFxuICAgICAgJ21kYy1mb3JtLWZpZWxkLS1hbGlnbi1lbmQnOiBoYXNMYWJlbCAmJiBhbGlnbkVuZFxuICAgIH1cIlxuICAgIGNsYXNzPVwibWRjLXN3aXRjaC13cmFwcGVyXCIgPlxuXG4gICAgPGRpdlxuICAgICAgOmNsYXNzPVwiY2xhc3Nlc1wiXG4gICAgICA6c3R5bGVzPVwic3R5bGVzXCJcbiAgICAgIGNsYXNzPVwibWRjLXN3aXRjaFwiPlxuICAgICAgPGRpdiBjbGFzcz1cIm1kYy1zd2l0Y2hfX3RyYWNrXCIgLz5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtc3dpdGNoX190aHVtYi11bmRlcmxheVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwibWRjLXN3aXRjaF9fdGh1bWJcIj5cbiAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgIHJlZj1cImNvbnRyb2xcIlxuICAgICAgICAgICAgOm5hbWU9XCJuYW1lXCJcbiAgICAgICAgICAgIDppZD1cInZtYV91aWRfXCJcbiAgICAgICAgICAgIDp2YWx1ZT1cInZhbHVlXCJcbiAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICByb2xlPVwic3dpdGNoXCJcbiAgICAgICAgICAgIGNsYXNzPVwibWRjLXN3aXRjaF9fbmF0aXZlLWNvbnRyb2xcIlxuICAgICAgICAgICAgQGNoYW5nZT1cIm9uQ2hhbmdlZFwiID5cblxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuXG4gICAgPGxhYmVsXG4gICAgICB2LWlmPVwiaGFzTGFiZWxcIlxuICAgICAgOmZvcj1cInZtYV91aWRfXCJcbiAgICAgIGNsYXNzPVwibWRjLXN3aXRjaC1sYWJlbFwiPlxuICAgICAgPHNsb3Q+e3sgbGFiZWwgfX08L3Nsb3Q+XG4gICAgPC9sYWJlbD5cblxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBEaXNwYXRjaEZvY3VzTWl4aW4sIFZNQVVuaXF1ZUlkTWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IHsgUmlwcGxlQmFzZSB9IGZyb20gJy4uL3JpcHBsZSdcbmltcG9ydCBNRENTd2l0Y2hGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9zd2l0Y2gvZm91bmRhdGlvbidcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXN3aXRjaCcsXG4gIG1peGluczogW0Rpc3BhdGNoRm9jdXNNaXhpbiwgVk1BVW5pcXVlSWRNaXhpbl0sXG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ2NoZWNrZWQnLFxuICAgIGV2ZW50OiAnY2hhbmdlJ1xuICB9LFxuICBwcm9wczoge1xuICAgIGNoZWNrZWQ6IEJvb2xlYW4sXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgdmFsdWU6IFN0cmluZyxcbiAgICBsYWJlbDogU3RyaW5nLFxuICAgIGFsaWduRW5kOiBCb29sZWFuLFxuICAgIG5hbWU6IFN0cmluZ1xuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaGFzTGFiZWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYWJlbCB8fCB0aGlzLiRzbG90cy5kZWZhdWx0XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGNoZWNrZWQodmFsdWUpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uc2V0Q2hlY2tlZCh2YWx1ZSlcbiAgICB9LFxuICAgIGRpc2FibGVkKHZhbHVlKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHZhbHVlKVxuICAgIH1cbiAgfSxcblxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENTd2l0Y2hGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIHNldE5hdGl2ZUNvbnRyb2xDaGVja2VkOiBjaGVja2VkID0+XG4gICAgICAgICh0aGlzLiRyZWZzLmNvbnRyb2wuY2hlY2tlZCA9IGNoZWNrZWQpLFxuICAgICAgaXNOYXRpdmVDb250cm9sQ2hlY2tlZDogKCkgPT4gdGhpcy4kcmVmcy5jb250cm9sLmNoZWNrZWQsXG4gICAgICBzZXROYXRpdmVDb250cm9sRGlzYWJsZWQ6IGRpc2FibGVkID0+XG4gICAgICAgICh0aGlzLiRyZWZzLmNvbnRyb2wuZGlzYWJsZWQgPSBkaXNhYmxlZCksXG4gICAgICBpc05hdGl2ZUNvbnRyb2xEaXNhYmxlZDogKCkgPT4gdGhpcy5uYXRpdmVDb250cm9sXy5kaXNhYmxlZFxuICAgIH0pXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXRDaGVja2VkKHRoaXMuY2hlY2tlZClcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0RGlzYWJsZWQodGhpcy5kaXNhYmxlZClcblxuICAgIHRoaXMucmlwcGxlID0gbmV3IFJpcHBsZUJhc2UodGhpcylcbiAgICB0aGlzLnJpcHBsZS5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICAgIHRoaXMucmlwcGxlICYmIHRoaXMucmlwcGxlLmRlc3Ryb3koKVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25DaGFuZ2VkKGV2ZW50KSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLmhhbmRsZUNoYW5nZSgpXG4gICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBldmVudC50YXJnZXQuY2hlY2tlZClcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjU3dpdGNoIGZyb20gJy4vbWRjLXN3aXRjaC52dWUnXG5cbmV4cG9ydCB7IG1kY1N3aXRjaCB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNTd2l0Y2hcbn0pXG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgQUNUSVZFOiAnbWRjLXRhYi0tYWN0aXZlJyxcbn07XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBTRUxFQ1RFRF9FVkVOVDogJ01EQ1RhYjpzZWxlY3RlZCcsXG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURDVGFiRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBnZXRPZmZzZXRXaWR0aDogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBnZXRPZmZzZXRMZWZ0OiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIG5vdGlmeVNlbGVjdGVkOiAoKSA9PiB7fSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlciA9IHt9KSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENUYWJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICB0aGlzLmNvbXB1dGVkV2lkdGhfID0gMDtcbiAgICB0aGlzLmNvbXB1dGVkTGVmdF8gPSAwO1xuICAgIHRoaXMuaXNBY3RpdmVfID0gZmFsc2U7XG4gICAgdGhpcy5wcmV2ZW50RGVmYXVsdE9uQ2xpY2tfID0gZmFsc2U7XG5cbiAgICB0aGlzLmNsaWNrSGFuZGxlcl8gPSAoZXZ0KSA9PiB7XG4gICAgICBpZiAodGhpcy5wcmV2ZW50RGVmYXVsdE9uQ2xpY2tfKSB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlTZWxlY3RlZCgpO1xuICAgIH07XG5cbiAgICB0aGlzLmtleWRvd25IYW5kbGVyXyA9IChldnQpID0+IHtcbiAgICAgIGlmIChldnQua2V5ICYmIGV2dC5rZXkgPT09ICdFbnRlcicgfHwgZXZ0LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5U2VsZWN0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXJfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXlkb3duJywgdGhpcy5rZXlkb3duSGFuZGxlcl8pO1xuICB9XG5cbiAgZ2V0Q29tcHV0ZWRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wdXRlZFdpZHRoXztcbiAgfVxuXG4gIGdldENvbXB1dGVkTGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wdXRlZExlZnRfO1xuICB9XG5cbiAgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNBY3RpdmVfO1xuICB9XG5cbiAgc2V0QWN0aXZlKGlzQWN0aXZlKSB7XG4gICAgdGhpcy5pc0FjdGl2ZV8gPSBpc0FjdGl2ZTtcbiAgICBpZiAodGhpcy5pc0FjdGl2ZV8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5BQ1RJVkUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuQUNUSVZFKTtcbiAgICB9XG4gIH1cblxuICBwcmV2ZW50c0RlZmF1bHRPbkNsaWNrKCkge1xuICAgIHJldHVybiB0aGlzLnByZXZlbnREZWZhdWx0T25DbGlja187XG4gIH1cblxuICBzZXRQcmV2ZW50RGVmYXVsdE9uQ2xpY2socHJldmVudERlZmF1bHRPbkNsaWNrKSB7XG4gICAgdGhpcy5wcmV2ZW50RGVmYXVsdE9uQ2xpY2tfID0gcHJldmVudERlZmF1bHRPbkNsaWNrO1xuICB9XG5cbiAgbWVhc3VyZVNlbGYoKSB7XG4gICAgdGhpcy5jb21wdXRlZFdpZHRoXyA9IHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0V2lkdGgoKTtcbiAgICB0aGlzLmNvbXB1dGVkTGVmdF8gPSB0aGlzLmFkYXB0ZXJfLmdldE9mZnNldExlZnQoKTtcbiAgfVxufVxuIiwiPHRlbXBsYXRlPlxyXG4gIDxjdXN0b20tbGluayBcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCJcclxuICAgIDpzdHlsZT1cInN0eWxlc1wiIFxuICAgIDpsaW5rPVwibGlua1wiXHJcbiAgICBjbGFzcz1cIm1kYy10YWJcIlxyXG4gICAgdi1vbj1cImxpc3RlbmVyc1wiPlxyXG5cclxuICAgIDxpIFxuICAgICAgdi1pZj1cIiEhaGFzSWNvblwiIFxuICAgICAgcmVmPVwiaWNvblwiXHJcbiAgICAgIDpjbGFzcz1cImhhc0ljb24uY2xhc3Nlc1wiXHJcbiAgICAgIHRhYmluZGV4PVwiMFwiXHJcbiAgICAgIGNsYXNzPVwibWRjLXRhYl9faWNvblwiPlxyXG4gICAgICA8c2xvdCBuYW1lPVwiaWNvblwiPnt7IGhhc0ljb24uY29udGVudCB9fTwvc2xvdD5cclxuICAgIDwvaT5cclxuXHJcbiAgICA8c3BhbiBcbiAgICAgIHYtaWY9XCJoYXNUZXh0XCIgXG4gICAgICA6Y2xhc3M9XCJ7J21kYy10YWJfX2ljb24tdGV4dCc6ICEhaGFzSWNvbn1cIj5cclxuICAgICAgPHNsb3QvPlxyXG4gICAgPC9zcGFuPlxyXG5cclxuICA8L2N1c3RvbS1saW5rPlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IE1EQ1RhYkZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3RhYnMvdGFiL2ZvdW5kYXRpb24nXHJcbmltcG9ydCB7XHJcbiAgQ3VzdG9tTGlua01peGluLFxyXG4gIERpc3BhdGNoRXZlbnRNaXhpbixcclxuICBlbWl0Q3VzdG9tRXZlbnQsXHJcbiAgZXh0cmFjdEljb25Qcm9wXHJcbn0gZnJvbSAnLi4vYmFzZSdcclxuaW1wb3J0IHsgUmlwcGxlQmFzZSB9IGZyb20gJy4uL3JpcHBsZSdcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnbWRjLXRhYicsXHJcbiAgbWl4aW5zOiBbQ3VzdG9tTGlua01peGluLCBEaXNwYXRjaEV2ZW50TWl4aW5dLFxyXG4gIHByb3BzOiB7XHJcbiAgICBhY3RpdmU6IEJvb2xlYW4sXHJcbiAgICBpY29uOiBbU3RyaW5nLCBBcnJheSwgT2JqZWN0XVxyXG4gIH0sXHJcbiAgZGF0YSgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNsYXNzZXM6IHt9LFxyXG4gICAgICBzdHlsZXM6IHt9XHJcbiAgICB9XHJcbiAgfSxcclxuICBjb21wdXRlZDoge1xyXG4gICAgaGFzSWNvbigpIHtcclxuICAgICAgaWYgKHRoaXMuaWNvbiB8fCB0aGlzLiRzbG90cy5pY29uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaWNvbiA/IGV4dHJhY3RJY29uUHJvcCh0aGlzLmljb24pIDoge31cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH0sXHJcbiAgICBoYXNUZXh0KCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLiRzbG90cy5kZWZhdWx0XHJcbiAgICB9XHJcbiAgfSxcclxuICB3YXRjaDoge1xyXG4gICAgYWN0aXZlKHZhbHVlKSB7XHJcbiAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5hZGFwdGVyXy5ub3RpZnlTZWxlY3RlZCgpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG4gIG1vdW50ZWQoKSB7XHJcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDVGFiRm91bmRhdGlvbih7XHJcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKSxcclxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpLFxyXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+XHJcbiAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSxcclxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+XHJcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSxcclxuICAgICAgZ2V0T2Zmc2V0V2lkdGg6ICgpID0+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy4kZWwub2Zmc2V0V2lkdGhcclxuICAgICAgfSxcclxuICAgICAgZ2V0T2Zmc2V0TGVmdDogKCkgPT4gdGhpcy4kZWwub2Zmc2V0TGVmdCxcclxuICAgICAgbm90aWZ5U2VsZWN0ZWQ6ICgpID0+IHtcclxuICAgICAgICBlbWl0Q3VzdG9tRXZlbnQoXHJcbiAgICAgICAgICB0aGlzLiRlbCxcclxuICAgICAgICAgIE1EQ1RhYkZvdW5kYXRpb24uc3RyaW5ncy5TRUxFQ1RFRF9FVkVOVCxcclxuICAgICAgICAgIHsgdGFiOiB0aGlzIH0sXHJcbiAgICAgICAgICB0cnVlXHJcbiAgICAgICAgKVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxyXG4gICAgdGhpcy5zZXRBY3RpdmUodGhpcy5hY3RpdmUpXHJcbiAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMpXHJcbiAgICB0aGlzLnJpcHBsZS5pbml0KClcclxuICB9LFxyXG4gIGJlZm9yZURlc3Ryb3koKSB7XHJcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXHJcbiAgICB0aGlzLnJpcHBsZS5kZXN0cm95KClcclxuICB9LFxyXG4gIG1ldGhvZHM6IHtcclxuICAgIGdldENvbXB1dGVkV2lkdGgoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZvdW5kYXRpb24uZ2V0Q29tcHV0ZWRXaWR0aCgpXHJcbiAgICB9LFxyXG4gICAgZ2V0Q29tcHV0ZWRMZWZ0KCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5mb3VuZGF0aW9uLmdldENvbXB1dGVkTGVmdCgpXHJcbiAgICB9LFxyXG4gICAgaXNBY3RpdmUoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZvdW5kYXRpb24uaXNBY3RpdmUoKVxyXG4gICAgfSxcclxuICAgIHNldEFjdGl2ZShpc0FjdGl2ZSkge1xyXG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0QWN0aXZlKGlzQWN0aXZlKVxyXG4gICAgfSxcclxuICAgIGlzRGVmYXVsdFByZXZlbnRlZE9uQ2xpY2soKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZvdW5kYXRpb24ucHJldmVudHNEZWZhdWx0T25DbGljaygpXHJcbiAgICB9LFxyXG4gICAgc2V0UHJldmVudERlZmF1bHRPbkNsaWNrKHByZXZlbnREZWZhdWx0T25DbGljaykge1xyXG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0UHJldmVudERlZmF1bHRPbkNsaWNrKHByZXZlbnREZWZhdWx0T25DbGljaylcclxuICAgIH0sXHJcbiAgICBtZWFzdXJlU2VsZigpIHtcclxuICAgICAgdGhpcy5mb3VuZGF0aW9uLm1lYXN1cmVTZWxmKClcclxuICAgIH1cclxuICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xuICBVUEdSQURFRDogJ21kYy10YWItYmFyLXVwZ3JhZGVkJyxcbn07XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBUQUJfU0VMRUNUT1I6ICcubWRjLXRhYicsXG4gIElORElDQVRPUl9TRUxFQ1RPUjogJy5tZGMtdGFiLWJhcl9faW5kaWNhdG9yJyxcbiAgQ0hBTkdFX0VWRU5UOiAnTURDVGFiQmFyOmNoYW5nZScsXG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQge2dldENvcnJlY3RQcm9wZXJ0eU5hbWV9IGZyb20gJ0BtYXRlcmlhbC9hbmltYXRpb24vaW5kZXgnO1xuXG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURDVGFiQmFyRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgYmluZE9uTURDVGFiU2VsZWN0ZWRFdmVudDogKCkgPT4ge30sXG4gICAgICB1bmJpbmRPbk1EQ1RhYlNlbGVjdGVkRXZlbnQ6ICgpID0+IHt9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZ2V0T2Zmc2V0V2lkdGg6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgc2V0U3R5bGVGb3JJbmRpY2F0b3I6ICgvKiBwcm9wZXJ0eU5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBnZXRPZmZzZXRXaWR0aEZvckluZGljYXRvcjogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBub3RpZnlDaGFuZ2U6ICgvKiBldnREYXRhOiB7YWN0aXZlVGFiSW5kZXg6IG51bWJlcn0gKi8pID0+IHt9LFxuICAgICAgZ2V0TnVtYmVyT2ZUYWJzOiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIGlzVGFiQWN0aXZlQXRJbmRleDogKC8qIGluZGV4OiBudW1iZXIgKi8pID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgICBzZXRUYWJBY3RpdmVBdEluZGV4OiAoLyogaW5kZXg6IG51bWJlciwgaXNBY3RpdmU6IHRydWUgKi8pID0+IHt9LFxuICAgICAgaXNEZWZhdWx0UHJldmVudGVkT25DbGlja0ZvclRhYkF0SW5kZXg6ICgvKiBpbmRleDogbnVtYmVyICovKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgICAgc2V0UHJldmVudERlZmF1bHRPbkNsaWNrRm9yVGFiQXRJbmRleDogKC8qIGluZGV4OiBudW1iZXIsIHByZXZlbnREZWZhdWx0T25DbGljazogYm9vbGVhbiAqLykgPT4ge30sXG4gICAgICBtZWFzdXJlVGFiQXRJbmRleDogKC8qIGluZGV4OiBudW1iZXIgKi8pID0+IHt9LFxuICAgICAgZ2V0Q29tcHV0ZWRXaWR0aEZvclRhYkF0SW5kZXg6ICgvKiBpbmRleDogbnVtYmVyICovKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIGdldENvbXB1dGVkTGVmdEZvclRhYkF0SW5kZXg6ICgvKiBpbmRleDogbnVtYmVyICovKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICB9O1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDVGFiQmFyRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgdGhpcy5pc0luZGljYXRvclNob3duXyA9IGZhbHNlO1xuICAgIHRoaXMuY29tcHV0ZWRXaWR0aF8gPSAwO1xuICAgIHRoaXMuY29tcHV0ZWRMZWZ0XyA9IDA7XG4gICAgdGhpcy5hY3RpdmVUYWJJbmRleF8gPSAwO1xuICAgIHRoaXMubGF5b3V0RnJhbWVfID0gMDtcbiAgICB0aGlzLnJlc2l6ZUhhbmRsZXJfID0gKCkgPT4gdGhpcy5sYXlvdXQoKTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLlVQR1JBREVEKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmJpbmRPbk1EQ1RhYlNlbGVjdGVkRXZlbnQoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgICBjb25zdCBhY3RpdmVUYWJJbmRleCA9IHRoaXMuZmluZEFjdGl2ZVRhYkluZGV4XygpO1xuICAgIGlmIChhY3RpdmVUYWJJbmRleCA+PSAwKSB7XG4gICAgICB0aGlzLmFjdGl2ZVRhYkluZGV4XyA9IGFjdGl2ZVRhYkluZGV4O1xuICAgIH1cbiAgICB0aGlzLmxheW91dCgpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuVVBHUkFERUQpO1xuICAgIHRoaXMuYWRhcHRlcl8udW5iaW5kT25NRENUYWJTZWxlY3RlZEV2ZW50KCk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgfVxuXG4gIGxheW91dEludGVybmFsXygpIHtcbiAgICB0aGlzLmZvckVhY2hUYWJJbmRleF8oKGluZGV4KSA9PiB0aGlzLmFkYXB0ZXJfLm1lYXN1cmVUYWJBdEluZGV4KGluZGV4KSk7XG4gICAgdGhpcy5jb21wdXRlZFdpZHRoXyA9IHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0V2lkdGgoKTtcbiAgICB0aGlzLmxheW91dEluZGljYXRvcl8oKTtcbiAgfVxuXG4gIGxheW91dEluZGljYXRvcl8oKSB7XG4gICAgY29uc3QgaXNJbmRpY2F0b3JGaXJzdFJlbmRlciA9ICF0aGlzLmlzSW5kaWNhdG9yU2hvd25fO1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgaW5kaWNhdG9yIGFwcGVhcnMgaW4gdGhlIHJpZ2h0IHBvc2l0aW9uIGltbWVkaWF0ZWx5IGZvciBjb3JyZWN0IGZpcnN0IHJlbmRlci5cbiAgICBpZiAoaXNJbmRpY2F0b3JGaXJzdFJlbmRlcikge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZUZvckluZGljYXRvcigndHJhbnNpdGlvbicsICdub25lJyk7XG4gICAgfVxuXG4gICAgY29uc3QgdHJhbnNsYXRlQW10Rm9yQWN0aXZlVGFiTGVmdCA9IHRoaXMuYWRhcHRlcl8uZ2V0Q29tcHV0ZWRMZWZ0Rm9yVGFiQXRJbmRleCh0aGlzLmFjdGl2ZVRhYkluZGV4Xyk7XG4gICAgY29uc3Qgc2NhbGVBbXRGb3JBY3RpdmVUYWJXaWR0aCA9XG4gICAgICB0aGlzLmFkYXB0ZXJfLmdldENvbXB1dGVkV2lkdGhGb3JUYWJBdEluZGV4KHRoaXMuYWN0aXZlVGFiSW5kZXhfKSAvIHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0V2lkdGgoKTtcblxuICAgIGNvbnN0IHRyYW5zZm9ybVZhbHVlID0gYHRyYW5zbGF0ZVgoJHt0cmFuc2xhdGVBbXRGb3JBY3RpdmVUYWJMZWZ0fXB4KSBzY2FsZSgke3NjYWxlQW10Rm9yQWN0aXZlVGFiV2lkdGh9LCAxKWA7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZUZvckluZGljYXRvcihnZXRDb3JyZWN0UHJvcGVydHlOYW1lKHdpbmRvdywgJ3RyYW5zZm9ybScpLCB0cmFuc2Zvcm1WYWx1ZSk7XG5cbiAgICBpZiAoaXNJbmRpY2F0b3JGaXJzdFJlbmRlcikge1xuICAgICAgLy8gRm9yY2UgbGF5b3V0IHNvIHRoYXQgdHJhbnNmb3JtIHN0eWxlcyB0byB0YWtlIGVmZmVjdC5cbiAgICAgIHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0V2lkdGhGb3JJbmRpY2F0b3IoKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGVGb3JJbmRpY2F0b3IoJ3RyYW5zaXRpb24nLCAnJyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlRm9ySW5kaWNhdG9yKCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcbiAgICAgIHRoaXMuaXNJbmRpY2F0b3JTaG93bl8gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGZpbmRBY3RpdmVUYWJJbmRleF8oKSB7XG4gICAgbGV0IGFjdGl2ZVRhYkluZGV4ID0gLTE7XG4gICAgdGhpcy5mb3JFYWNoVGFiSW5kZXhfKChpbmRleCkgPT4ge1xuICAgICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNUYWJBY3RpdmVBdEluZGV4KGluZGV4KSkge1xuICAgICAgICBhY3RpdmVUYWJJbmRleCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYWN0aXZlVGFiSW5kZXg7XG4gIH1cblxuICBmb3JFYWNoVGFiSW5kZXhfKGl0ZXJhdG9yKSB7XG4gICAgY29uc3QgbnVtVGFicyA9IHRoaXMuYWRhcHRlcl8uZ2V0TnVtYmVyT2ZUYWJzKCk7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG51bVRhYnM7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHNob3VsZEJyZWFrID0gaXRlcmF0b3IoaW5kZXgpO1xuICAgICAgaWYgKHNob3VsZEJyZWFrKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxheW91dCgpIHtcbiAgICBpZiAodGhpcy5sYXlvdXRGcmFtZV8pIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubGF5b3V0RnJhbWVfKTtcbiAgICB9XG5cbiAgICB0aGlzLmxheW91dEZyYW1lXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmxheW91dEludGVybmFsXygpO1xuICAgICAgdGhpcy5sYXlvdXRGcmFtZV8gPSAwO1xuICAgIH0pO1xuICB9XG5cbiAgc3dpdGNoVG9UYWJBdEluZGV4KGluZGV4LCBzaG91bGROb3RpZnkpIHtcbiAgICBpZiAoaW5kZXggPT09IHRoaXMuYWN0aXZlVGFiSW5kZXhfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmFkYXB0ZXJfLmdldE51bWJlck9mVGFicygpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE91dCBvZiBib3VuZHMgaW5kZXggc3BlY2lmaWVkIGZvciB0YWI6ICR7aW5kZXh9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJldkFjdGl2ZVRhYkluZGV4ID0gdGhpcy5hY3RpdmVUYWJJbmRleF87XG4gICAgdGhpcy5hY3RpdmVUYWJJbmRleF8gPSBpbmRleDtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgaWYgKHByZXZBY3RpdmVUYWJJbmRleCA+PSAwKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uc2V0VGFiQWN0aXZlQXRJbmRleChwcmV2QWN0aXZlVGFiSW5kZXgsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0VGFiQWN0aXZlQXRJbmRleCh0aGlzLmFjdGl2ZVRhYkluZGV4XywgdHJ1ZSk7XG4gICAgICB0aGlzLmxheW91dEluZGljYXRvcl8oKTtcbiAgICAgIGlmIChzaG91bGROb3RpZnkpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlDaGFuZ2Uoe2FjdGl2ZVRhYkluZGV4OiB0aGlzLmFjdGl2ZVRhYkluZGV4X30pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0QWN0aXZlVGFiSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluZEFjdGl2ZVRhYkluZGV4XygpO1xuICB9XG59XG4iLCI8dGVtcGxhdGU+XG4gIDxuYXYgXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIFxuICAgIGNsYXNzPVwibWRjLXRhYi1iYXJcIiBcbiAgICB2LW9uPVwiJGxpc3RlbmVyc1wiPlxuICAgIDxzbG90Lz5cbiAgICA8c3BhbiBcbiAgICAgIHJlZj1cImluZGljYXRvclwiIFxuICAgICAgOnN0eWxlPVwiaW5kaWNhdG9yU3R5bGVzXCJcbiAgICAgIGNsYXNzPVwibWRjLXRhYi1iYXJfX2luZGljYXRvclwiLz5cbiAgPC9uYXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ1RhYkJhckZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3RhYnMvdGFiLWJhci9mb3VuZGF0aW9uJ1xuaW1wb3J0IE1EQ1RhYkZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3RhYnMvdGFiL2ZvdW5kYXRpb24nXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10YWItYmFyJyxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge30sXG4gICAgICBpbmRpY2F0b3JTdHlsZXM6IHt9LFxuICAgICAgdGFiczogW11cbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ1RhYkJhckZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpLFxuICAgICAgYmluZE9uTURDVGFiU2VsZWN0ZWRFdmVudDogKCkgPT4ge1xuICAgICAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgIE1EQ1RhYkZvdW5kYXRpb24uc3RyaW5ncy5TRUxFQ1RFRF9FVkVOVCxcbiAgICAgICAgICB0aGlzLm9uU2VsZWN0XG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICB1bmJpbmRPbk1EQ1RhYlNlbGVjdGVkRXZlbnQ6ICgpID0+XG4gICAgICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgTURDVGFiRm91bmRhdGlvbi5zdHJpbmdzLlNFTEVDVEVEX0VWRU5ULFxuICAgICAgICAgIHRoaXMub25TZWxlY3RcbiAgICAgICAgKSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogaGFuZGxlciA9PlxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogaGFuZGxlciA9PlxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlciksXG4gICAgICBnZXRPZmZzZXRXaWR0aDogKCkgPT4gdGhpcy4kZWwub2Zmc2V0V2lkdGgsXG4gICAgICBzZXRTdHlsZUZvckluZGljYXRvcjogKHByb3BlcnR5TmFtZSwgdmFsdWUpID0+XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLmluZGljYXRvclN0eWxlcywgcHJvcGVydHlOYW1lLCB2YWx1ZSksXG4gICAgICBnZXRPZmZzZXRXaWR0aEZvckluZGljYXRvcjogKCkgPT4gdGhpcy4kcmVmcy5pbmRpY2F0b3Iub2Zmc2V0V2lkdGgsXG4gICAgICBub3RpZnlDaGFuZ2U6IGV2dERhdGEgPT4ge1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBldnREYXRhLmFjdGl2ZVRhYkluZGV4KVxuICAgICAgfSxcbiAgICAgIGdldE51bWJlck9mVGFiczogKCkgPT4gdGhpcy50YWJzLmxlbmd0aCxcbiAgICAgIGlzVGFiQWN0aXZlQXRJbmRleDogaW5kZXggPT4gdGhpcy50YWJzW2luZGV4XS5pc0FjdGl2ZSgpLFxuICAgICAgc2V0VGFiQWN0aXZlQXRJbmRleDogKGluZGV4LCBpc0FjdGl2ZSkgPT4ge1xuICAgICAgICAvLyBwZ2JyOiAyMDE4LTA0LTA3XG4gICAgICAgIC8vIHNpbmNlIGl0IGlzIHBvc3NpYmxlIHRvIGNoYW5nZSB0aGUgbnVtYmVyIG9mIHRhYnMgcHJvZ3JhbWF0aWNhbGx5XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gZGV0ZWN0IHRoZSBmb3VuZGF0aW9uIGRlYWN0aXZhdGluZyBhIHRhYlxuICAgICAgICAvLyB0aGF0IG5vIGxvbmdlciBleGlzdHMgYnV0IHdhcyBwcmV2aW91c2x5IGFjdGl2ZS5cbiAgICAgICAgaWYgKCFpc0FjdGl2ZSAmJiBpbmRleCA+PSB0aGlzLnRhYnMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50YWJzW2luZGV4XS5zZXRBY3RpdmUoaXNBY3RpdmUpXG4gICAgICB9LFxuICAgICAgaXNEZWZhdWx0UHJldmVudGVkT25DbGlja0ZvclRhYkF0SW5kZXg6IGluZGV4ID0+XG4gICAgICAgIHRoaXMudGFic1tpbmRleF0uaXNEZWZhdWx0UHJldmVudGVkT25DbGljaygpLFxuICAgICAgc2V0UHJldmVudERlZmF1bHRPbkNsaWNrRm9yVGFiQXRJbmRleDogKGluZGV4LCBwcmV2ZW50RGVmYXVsdE9uQ2xpY2spID0+IHtcbiAgICAgICAgdGhpcy50YWJzW2luZGV4XS5zZXRQcmV2ZW50RGVmYXVsdE9uQ2xpY2socHJldmVudERlZmF1bHRPbkNsaWNrKVxuICAgICAgfSxcbiAgICAgIG1lYXN1cmVUYWJBdEluZGV4OiBpbmRleCA9PiB0aGlzLnRhYnNbaW5kZXhdLm1lYXN1cmVTZWxmKCksXG4gICAgICBnZXRDb21wdXRlZFdpZHRoRm9yVGFiQXRJbmRleDogaW5kZXggPT5cbiAgICAgICAgdGhpcy50YWJzW2luZGV4XS5nZXRDb21wdXRlZFdpZHRoKCksXG4gICAgICBnZXRDb21wdXRlZExlZnRGb3JUYWJBdEluZGV4OiBpbmRleCA9PiB0aGlzLnRhYnNbaW5kZXhdLmdldENvbXB1dGVkTGVmdCgpXG4gICAgfSlcblxuICAgIGNvbnN0IHJlc2V0VGFicyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHRhYkVsZW1lbnRzID0gW10uc2xpY2UuY2FsbChcbiAgICAgICAgdGhpcy4kZWwucXVlcnlTZWxlY3RvckFsbChNRENUYWJCYXJGb3VuZGF0aW9uLnN0cmluZ3MuVEFCX1NFTEVDVE9SKVxuICAgICAgKVxuICAgICAgdGhpcy50YWJzID0gdGFiRWxlbWVudHMubWFwKGVsID0+IGVsLl9fdnVlX18pXG5cbiAgICAgIGxldCBoYXNUZXh0LCBoYXNJY29uXG4gICAgICBjb25zdCB0YWJzID0gdGhpcy50YWJzXG4gICAgICBmb3IgKGxldCB0YWIgb2YgdGFicykge1xuICAgICAgICBpZiAodGFiLmhhc1RleHQpIHtcbiAgICAgICAgICBoYXNUZXh0ID0gdHJ1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IHRhYiBvZiB0YWJzKSB7XG4gICAgICAgIGlmICh0YWIuaGFzSWNvbikge1xuICAgICAgICAgIGhhc0ljb24gPSB0cnVlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaGFzVGV4dCAmJiBoYXNJY29uKSB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsICdtZGMtdGFiLWJhci0taWNvbnMtd2l0aC10ZXh0JywgdHJ1ZSlcbiAgICAgIH0gZWxzZSBpZiAoaGFzSWNvbikge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCAnbWRjLXRhYi1iYXItLWljb24tdGFiLWJhcicsIHRydWUpXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmZvdW5kYXRpb24pIHtcbiAgICAgICAgY29uc3QgYWN0aXZlVGFiSW5kZXggPSB0aGlzLmZvdW5kYXRpb24uZ2V0QWN0aXZlVGFiSW5kZXgoKVxuICAgICAgICBpZiAoYWN0aXZlVGFiSW5kZXggPj0gMCkge1xuICAgICAgICAgIHRoaXMuZm91bmRhdGlvbi5zd2l0Y2hUb1RhYkF0SW5kZXgoYWN0aXZlVGFiSW5kZXgsIHRydWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5mb3VuZGF0aW9uLnN3aXRjaFRvVGFiQXRJbmRleCgwLCB0cnVlKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5sYXlvdXQoKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJlc2V0VGFicygpXG5cbiAgICB0aGlzLnNsb3RPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHJlc2V0VGFicygpKVxuICAgIHRoaXMuc2xvdE9ic2VydmVyLm9ic2VydmUodGhpcy4kZWwsIHsgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH0pXG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5zbG90T2JzZXJ2ZXIuZGlzY29ubmVjdCgpXG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25TZWxlY3QoeyBkZXRhaWwgfSkge1xuICAgICAgY29uc3QgeyB0YWIgfSA9IGRldGFpbFxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnRhYnMuaW5kZXhPZih0YWIpXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWRjLXRhYi1iYXIgaW50ZXJuYWwgZXJyb3I6IGluZGV4IG5vdCBmb3VuZCcpXG4gICAgICB9XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc3dpdGNoVG9UYWJBdEluZGV4KGluZGV4LCB0cnVlKVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNUYWIgZnJvbSAnLi9tZGMtdGFiLnZ1ZSdcbmltcG9ydCBtZGNUYWJCYXIgZnJvbSAnLi9tZGMtdGFiLWJhci52dWUnXG5cbmV4cG9ydCB7IG1kY1RhYiwgbWRjVGFiQmFyIH1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY1RhYixcbiAgbWRjVGFiQmFyXG59KVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBUZXh0IEZpZWxkIEhlbHBlciBUZXh0LlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIFRleHRGaWVsZCBoZWxwZXIgdGV4dCBpbnRvIHlvdXIgZnJhbWV3b3JrLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvYXV0aG9yaW5nLWNvbXBvbmVudHMubWRcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDVGV4dEZpZWxkSGVscGVyVGV4dEFkYXB0ZXIge1xuICAvKipcbiAgICogQWRkcyBhIGNsYXNzIHRvIHRoZSBoZWxwZXIgdGV4dCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIHRoZSBoZWxwZXIgdGV4dCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGhlbHBlciB0ZXh0IGVsZW1lbnQgY29udGFpbnMgdGhlIGdpdmVuIGNsYXNzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYW4gYXR0cmlidXRlIHdpdGggYSBnaXZlbiB2YWx1ZSBvbiB0aGUgaGVscGVyIHRleHQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRBdHRyKGF0dHIsIHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGF0dHJpYnV0ZSBmcm9tIHRoZSBoZWxwZXIgdGV4dCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICAgKi9cbiAgcmVtb3ZlQXR0cihhdHRyKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0ZXh0IGNvbnRlbnQgZm9yIHRoZSBoZWxwZXIgdGV4dCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICAgKi9cbiAgc2V0Q29udGVudChjb250ZW50KSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUZXh0RmllbGRIZWxwZXJUZXh0QWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIEFSSUFfSElEREVOOiAnYXJpYS1oaWRkZW4nLFxuICBST0xFOiAncm9sZScsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIEhFTFBFUl9URVhUX1BFUlNJU1RFTlQ6ICdtZGMtdGV4dC1maWVsZC1oZWxwZXItdGV4dC0tcGVyc2lzdGVudCcsXG4gIEhFTFBFUl9URVhUX1ZBTElEQVRJT05fTVNHOiAnbWRjLXRleHQtZmllbGQtaGVscGVyLXRleHQtLXZhbGlkYXRpb24tbXNnJyxcbn07XG5cbmV4cG9ydCB7c3RyaW5ncywgY3NzQ2xhc3Nlc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDVGV4dEZpZWxkSGVscGVyVGV4dEFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ1RleHRGaWVsZEhlbHBlclRleHRBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENUZXh0RmllbGRIZWxwZXJUZXh0Rm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIE1EQ1RleHRGaWVsZEhlbHBlclRleHRBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ1RleHRGaWVsZEhlbHBlclRleHRBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDVGV4dEZpZWxkSGVscGVyVGV4dEFkYXB0ZXJ9ICovICh7XG4gICAgICBhZGRDbGFzczogKCkgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKCkgPT4ge30sXG4gICAgICBoYXNDbGFzczogKCkgPT4ge30sXG4gICAgICBzZXRBdHRyOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUF0dHI6ICgpID0+IHt9LFxuICAgICAgc2V0Q29udGVudDogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDVGV4dEZpZWxkSGVscGVyVGV4dEFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgY29udGVudCBvZiB0aGUgaGVscGVyIHRleHQgZmllbGQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gICAqL1xuICBzZXRDb250ZW50KGNvbnRlbnQpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldENvbnRlbnQoY29udGVudCk7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBpc1BlcnNpc3RlbnQgU2V0cyB0aGUgcGVyc2lzdGVuY3kgb2YgdGhlIGhlbHBlciB0ZXh0LiAqL1xuICBzZXRQZXJzaXN0ZW50KGlzUGVyc2lzdGVudCkge1xuICAgIGlmIChpc1BlcnNpc3RlbnQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5IRUxQRVJfVEVYVF9QRVJTSVNURU5UKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkhFTFBFUl9URVhUX1BFUlNJU1RFTlQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmFsaWRhdGlvbiBUcnVlIHRvIG1ha2UgdGhlIGhlbHBlciB0ZXh0IGFjdCBhcyBhblxuICAgKiAgIGVycm9yIHZhbGlkYXRpb24gbWVzc2FnZS5cbiAgICovXG4gIHNldFZhbGlkYXRpb24oaXNWYWxpZGF0aW9uKSB7XG4gICAgaWYgKGlzVmFsaWRhdGlvbikge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLkhFTFBFUl9URVhUX1ZBTElEQVRJT05fTVNHKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkhFTFBFUl9URVhUX1ZBTElEQVRJT05fTVNHKTtcbiAgICB9XG4gIH1cblxuICAvKiogTWFrZXMgdGhlIGhlbHBlciB0ZXh0IHZpc2libGUgdG8gdGhlIHNjcmVlbiByZWFkZXIuICovXG4gIHNob3dUb1NjcmVlblJlYWRlcigpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUF0dHIoc3RyaW5ncy5BUklBX0hJRERFTik7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsaWRpdHkgb2YgdGhlIGhlbHBlciB0ZXh0IGJhc2VkIG9uIHRoZSBpbnB1dCB2YWxpZGl0eS5cbiAgICogQHBhcmFtIHtib29sZWFufSBpbnB1dElzVmFsaWRcbiAgICovXG4gIHNldFZhbGlkaXR5KGlucHV0SXNWYWxpZCkge1xuICAgIGNvbnN0IGhlbHBlclRleHRJc1BlcnNpc3RlbnQgPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuSEVMUEVSX1RFWFRfUEVSU0lTVEVOVCk7XG4gICAgY29uc3QgaGVscGVyVGV4dElzVmFsaWRhdGlvbk1zZyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5IRUxQRVJfVEVYVF9WQUxJREFUSU9OX01TRyk7XG4gICAgY29uc3QgdmFsaWRhdGlvbk1zZ05lZWRzRGlzcGxheSA9IGhlbHBlclRleHRJc1ZhbGlkYXRpb25Nc2cgJiYgIWlucHV0SXNWYWxpZDtcblxuICAgIGlmICh2YWxpZGF0aW9uTXNnTmVlZHNEaXNwbGF5KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoc3RyaW5ncy5ST0xFLCAnYWxlcnQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVBdHRyKHN0cmluZ3MuUk9MRSk7XG4gICAgfVxuXG4gICAgaWYgKCFoZWxwZXJUZXh0SXNQZXJzaXN0ZW50ICYmICF2YWxpZGF0aW9uTXNnTmVlZHNEaXNwbGF5KSB7XG4gICAgICB0aGlzLmhpZGVfKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSBoZWxwIHRleHQgZnJvbSBzY3JlZW4gcmVhZGVycy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhpZGVfKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cihzdHJpbmdzLkFSSUFfSElEREVOLCAndHJ1ZScpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBUZXh0IEZpZWxkIEljb24uXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgdGV4dCBmaWVsZCBpY29uIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENUZXh0RmllbGRJY29uQWRhcHRlciB7XG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgb24gdGhlIGljb24gZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0QXR0cihhdHRyKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIGFuIGF0dHJpYnV0ZSBvbiB0aGUgaWNvbiBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNldEF0dHIoYXR0ciwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gYXR0cmlidXRlIGZyb20gdGhlIGljb24gZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICovXG4gIHJlbW92ZUF0dHIoYXR0cikge31cblxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBpY29uIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gICAqL1xuICBzZXRDb250ZW50KGNvbnRlbnQpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiB0aGUgaWNvbiBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIGljb24gZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRW1pdHMgYSBjdXN0b20gZXZlbnQgXCJNRENUZXh0RmllbGQ6aWNvblwiIGRlbm90aW5nIGEgdXNlciBoYXMgY2xpY2tlZCB0aGUgaWNvbi5cbiAgICovXG4gIG5vdGlmeUljb25BY3Rpb24oKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUZXh0RmllbGRJY29uQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIElDT05fRVZFTlQ6ICdNRENUZXh0RmllbGQ6aWNvbicsXG4gIElDT05fUk9MRTogJ2J1dHRvbicsXG59O1xuXG5leHBvcnQge3N0cmluZ3N9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ1RleHRGaWVsZEljb25BZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge3N0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENUZXh0RmllbGRJY29uQWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgTURDVGV4dEZpZWxkSWNvbkFkYXB0ZXJ9IGZvciB0eXBpbmcgaW5mb3JtYXRpb24gb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAqIHR5cGVzLlxuICAgKiBAcmV0dXJuIHshTURDVGV4dEZpZWxkSWNvbkFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUZXh0RmllbGRJY29uQWRhcHRlcn0gKi8gKHtcbiAgICAgIGdldEF0dHI6ICgpID0+IHt9LFxuICAgICAgc2V0QXR0cjogKCkgPT4ge30sXG4gICAgICByZW1vdmVBdHRyOiAoKSA9PiB7fSxcbiAgICAgIHNldENvbnRlbnQ6ICgpID0+IHt9LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBub3RpZnlJY29uQWN0aW9uOiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENUZXh0RmllbGRJY29uQWRhcHRlcn0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7c3RyaW5nP30gKi9cbiAgICB0aGlzLnNhdmVkVGFiSW5kZXhfID0gbnVsbDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlSW50ZXJhY3Rpb24oZXZ0KTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5zYXZlZFRhYkluZGV4XyA9IHRoaXMuYWRhcHRlcl8uZ2V0QXR0cigndGFiaW5kZXgnKTtcblxuICAgIFsnY2xpY2snLCAna2V5ZG93biddLmZvckVhY2goKGV2dFR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXJfKTtcbiAgICB9KTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgWydjbGljaycsICdrZXlkb3duJ10uZm9yRWFjaCgoZXZ0VHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyXyk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZCAqL1xuICBzZXREaXNhYmxlZChkaXNhYmxlZCkge1xuICAgIGlmICghdGhpcy5zYXZlZFRhYkluZGV4Xykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVBdHRyKCdyb2xlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cigndGFiaW5kZXgnLCB0aGlzLnNhdmVkVGFiSW5kZXhfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cigncm9sZScsIHN0cmluZ3MuSUNPTl9ST0xFKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGxhYmVsICovXG4gIHNldEFyaWFMYWJlbChsYWJlbCkge1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cignYXJpYS1sYWJlbCcsIGxhYmVsKTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCAqL1xuICBzZXRDb250ZW50KGNvbnRlbnQpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldENvbnRlbnQoY29udGVudCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhbiBpbnRlcmFjdGlvbiBldmVudFxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqL1xuICBoYW5kbGVJbnRlcmFjdGlvbihldnQpIHtcbiAgICBpZiAoZXZ0LnR5cGUgPT09ICdjbGljaycgfHwgZXZ0LmtleSA9PT0gJ0VudGVyJyB8fCBldnQua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5SWNvbkFjdGlvbigpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUZXh0RmllbGRJY29uRm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IE1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9uIGZyb20gJy4vaGVscGVyLXRleHQvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb24gZnJvbSAnLi9pY29uL2ZvdW5kYXRpb24nO1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICB2YWx1ZTogc3RyaW5nLFxuICogICBkaXNhYmxlZDogYm9vbGVhbixcbiAqICAgYmFkSW5wdXQ6IGJvb2xlYW4sXG4gKiAgIHZhbGlkaXR5OiB7XG4gKiAgICAgYmFkSW5wdXQ6IGJvb2xlYW4sXG4gKiAgICAgdmFsaWQ6IGJvb2xlYW4sXG4gKiAgIH0sXG4gKiB9fVxuICovXG5sZXQgTmF0aXZlSW5wdXRUeXBlO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGhlbHBlclRleHQ6ICghTURDVGV4dEZpZWxkSGVscGVyVGV4dEZvdW5kYXRpb258dW5kZWZpbmVkKSxcbiAqICAgaWNvbjogKCFNRENUZXh0RmllbGRJY29uRm91bmRhdGlvbnx1bmRlZmluZWQpLFxuICogfX1cbiAqL1xubGV0IEZvdW5kYXRpb25NYXBUeXBlO1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBUZXh0IEZpZWxkLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIFRleHQgRmllbGQgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1RleHRGaWVsZEFkYXB0ZXIge1xuICAvKipcbiAgICogQWRkcyBhIGNsYXNzIHRvIHRoZSByb290IEVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNsYXNzIGZyb20gdGhlIHJvb3QgRWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJvb3QgZWxlbWVudCBjb250YWlucyB0aGUgZ2l2ZW4gY2xhc3MgbmFtZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgcm9vdCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgcm9vdCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlclRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIG5hdGl2ZSBpbnB1dCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiB0aGUgbmF0aXZlIGlucHV0IGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgdmFsaWRhdGlvbiBhdHRyaWJ1dGUgY2hhbmdlIGxpc3RlbmVyIG9uIHRoZSBpbnB1dCBlbGVtZW50LlxuICAgKiBIYW5kbGVyIGFjY2VwdHMgbGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUFycmF5PHN0cmluZz4pOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICogQHJldHVybiB7IU11dGF0aW9uT2JzZXJ2ZXJ9XG4gICAqL1xuICByZWdpc3RlclZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERpc2Nvbm5lY3RzIGEgdmFsaWRhdGlvbiBhdHRyaWJ1dGUgb2JzZXJ2ZXIgb24gdGhlIGlucHV0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7IU11dGF0aW9uT2JzZXJ2ZXJ9IG9ic2VydmVyXG4gICAqL1xuICBkZXJlZ2lzdGVyVmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXIob2JzZXJ2ZXIpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgbmF0aXZlIHRleHQgaW5wdXQgZWxlbWVudCwgd2l0aCBhXG4gICAqIHNpbWlsYXIgQVBJIHNoYXBlLiBUaGUgb2JqZWN0IHJldHVybmVkIHNob3VsZCBpbmNsdWRlIHRoZSB2YWx1ZSwgZGlzYWJsZWRcbiAgICogYW5kIGJhZElucHV0IHByb3BlcnRpZXMsIGFzIHdlbGwgYXMgdGhlIGNoZWNrVmFsaWRpdHkoKSBmdW5jdGlvbi4gV2UgbmV2ZXJcbiAgICogYWx0ZXIgdGhlIHZhbHVlIHdpdGhpbiBvdXIgY29kZSwgaG93ZXZlciB3ZSBkbyB1cGRhdGUgdGhlIGRpc2FibGVkXG4gICAqIHByb3BlcnR5LCBzbyBpZiB5b3UgY2hvb3NlIHRvIGR1Y2stdHlwZSB0aGUgcmV0dXJuIHZhbHVlIGZvciB0aGlzIG1ldGhvZFxuICAgKiBpbiB5b3VyIGltcGxlbWVudGF0aW9uIGl0J3MgaW1wb3J0YW50IHRvIGtlZXAgdGhpcyBpbiBtaW5kLiBBbHNvIG5vdGUgdGhhdFxuICAgKiB0aGlzIG1ldGhvZCBjYW4gcmV0dXJuIG51bGwsIHdoaWNoIHRoZSBmb3VuZGF0aW9uIHdpbGwgaGFuZGxlIGdyYWNlZnVsbHkuXG4gICAqIEByZXR1cm4gez9FbGVtZW50fD9OYXRpdmVJbnB1dFR5cGV9XG4gICAqL1xuICBnZXROYXRpdmVJbnB1dCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGV4dGZpZWxkIGlzIGZvY3VzZWQuXG4gICAqIFdlIGFjaGlldmUgdGhpcyB2aWEgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMucm9vdF9gLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNGb2N1c2VkKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHJvb3QgZWxlbWVudCBpcyBzZXQgdG8gUlRMLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNSdGwoKSB7fVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIGxpbmUgcmlwcGxlLlxuICAgKi9cbiAgYWN0aXZhdGVMaW5lUmlwcGxlKCkge31cblxuICAvKipcbiAgICogRGVhY3RpdmF0ZXMgdGhlIGxpbmUgcmlwcGxlLlxuICAgKi9cbiAgZGVhY3RpdmF0ZUxpbmVSaXBwbGUoKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0cmFuc2Zvcm0gb3JpZ2luIG9mIHRoZSBsaW5lIHJpcHBsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG5vcm1hbGl6ZWRYXG4gICAqL1xuICBzZXRMaW5lUmlwcGxlVHJhbnNmb3JtT3JpZ2luKG5vcm1hbGl6ZWRYKSB7fVxuXG4gIC8qKlxuICAgKiBPbmx5IGltcGxlbWVudCBpZiBsYWJlbCBleGlzdHMuXG4gICAqIFNoYWtlcyBsYWJlbCBpZiBzaG91bGRTaGFrZSBpcyB0cnVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFNoYWtlXG4gICAqL1xuICBzaGFrZUxhYmVsKHNob3VsZFNoYWtlKSB7fVxuXG4gIC8qKlxuICAgKiBPbmx5IGltcGxlbWVudCBpZiBsYWJlbCBleGlzdHMuXG4gICAqIEZsb2F0cyB0aGUgbGFiZWwgYWJvdmUgdGhlIGlucHV0IGVsZW1lbnQgaWYgc2hvdWxkRmxvYXQgaXMgdHJ1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRGbG9hdFxuICAgKi9cbiAgZmxvYXRMYWJlbChzaG91bGRGbG9hdCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGxhYmVsIGVsZW1lbnQgZXhpc3RzLCBmYWxzZSBpZiBpdCBkb2Vzbid0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzTGFiZWwoKSB7fVxuXG4gIC8qKlxuICAgKiBPbmx5IGltcGxlbWVudCBpZiBsYWJlbCBleGlzdHMuXG4gICAqIFJldHVybnMgd2lkdGggb2YgbGFiZWwgaW4gcGl4ZWxzLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMYWJlbFdpZHRoKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIG91dGxpbmUgZWxlbWVudCBleGlzdHMsIGZhbHNlIGlmIGl0IGRvZXNuJ3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNPdXRsaW5lKCkge31cblxuICAvKipcbiAgICogT25seSBpbXBsZW1lbnQgaWYgb3V0bGluZSBlbGVtZW50IGV4aXN0cy5cbiAgICogVXBkYXRlcyBTVkcgUGF0aCBhbmQgb3V0bGluZSBlbGVtZW50IGJhc2VkIG9uIHRoZVxuICAgKiBsYWJlbCBlbGVtZW50IHdpZHRoIGFuZCBSVEwgY29udGV4dC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxhYmVsV2lkdGhcbiAgICogQHBhcmFtIHtib29sZWFuPX0gaXNSdGxcbiAgICovXG4gIG5vdGNoT3V0bGluZShsYWJlbFdpZHRoLCBpc1J0bCkge31cblxuICAvKipcbiAgICogT25seSBpbXBsZW1lbnQgaWYgb3V0bGluZSBlbGVtZW50IGV4aXN0cy5cbiAgICogQ2xvc2VzIG5vdGNoIGluIG91dGxpbmUgZWxlbWVudC5cbiAgICovXG4gIGNsb3NlT3V0bGluZSgpIHt9XG59XG5cbmV4cG9ydCB7TURDVGV4dEZpZWxkQWRhcHRlciwgTmF0aXZlSW5wdXRUeXBlLCBGb3VuZGF0aW9uTWFwVHlwZX07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBBUklBX0NPTlRST0xTOiAnYXJpYS1jb250cm9scycsXG4gIElOUFVUX1NFTEVDVE9SOiAnLm1kYy10ZXh0LWZpZWxkX19pbnB1dCcsXG4gIExBQkVMX1NFTEVDVE9SOiAnLm1kYy1mbG9hdGluZy1sYWJlbCcsXG4gIElDT05fU0VMRUNUT1I6ICcubWRjLXRleHQtZmllbGRfX2ljb24nLFxuICBPVVRMSU5FX1NFTEVDVE9SOiAnLm1kYy1ub3RjaGVkLW91dGxpbmUnLFxuICBMSU5FX1JJUFBMRV9TRUxFQ1RPUjogJy5tZGMtbGluZS1yaXBwbGUnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBST09UOiAnbWRjLXRleHQtZmllbGQnLFxuICBVUEdSQURFRDogJ21kYy10ZXh0LWZpZWxkLS11cGdyYWRlZCcsXG4gIERJU0FCTEVEOiAnbWRjLXRleHQtZmllbGQtLWRpc2FibGVkJyxcbiAgREVOU0U6ICdtZGMtdGV4dC1maWVsZC0tZGVuc2UnLFxuICBGT0NVU0VEOiAnbWRjLXRleHQtZmllbGQtLWZvY3VzZWQnLFxuICBJTlZBTElEOiAnbWRjLXRleHQtZmllbGQtLWludmFsaWQnLFxuICBCT1g6ICdtZGMtdGV4dC1maWVsZC0tYm94JyxcbiAgT1VUTElORUQ6ICdtZGMtdGV4dC1maWVsZC0tb3V0bGluZWQnLFxufTtcblxuLyoqIEBlbnVtIHtudW1iZXJ9ICovXG5jb25zdCBudW1iZXJzID0ge1xuICBMQUJFTF9TQ0FMRTogMC43NSxcbiAgREVOU0VfTEFCRUxfU0NBTEU6IDAuOTIzLFxufTtcblxuLy8gd2hpdGVsaXN0IGJhc2VkIG9mZiBvZiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9HdWlkZS9IVE1ML0hUTUw1L0NvbnN0cmFpbnRfdmFsaWRhdGlvblxuLy8gdW5kZXIgc2VjdGlvbjogYFZhbGlkYXRpb24tcmVsYXRlZCBhdHRyaWJ1dGVzYFxuY29uc3QgVkFMSURBVElPTl9BVFRSX1dISVRFTElTVCA9IFtcbiAgJ3BhdHRlcm4nLCAnbWluJywgJ21heCcsICdyZXF1aXJlZCcsICdzdGVwJywgJ21pbmxlbmd0aCcsICdtYXhsZW5ndGgnLFxuXTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzLCBWQUxJREFUSU9OX0FUVFJfV0hJVEVMSVNUfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQgTURDVGV4dEZpZWxkSGVscGVyVGV4dEZvdW5kYXRpb24gZnJvbSAnLi9oZWxwZXItdGV4dC9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENUZXh0RmllbGRJY29uRm91bmRhdGlvbiBmcm9tICcuL2ljb24vZm91bmRhdGlvbic7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1RleHRGaWVsZEFkYXB0ZXIsIE5hdGl2ZUlucHV0VHlwZSwgRm91bmRhdGlvbk1hcFR5cGV9IGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnMsIFZBTElEQVRJT05fQVRUUl9XSElURUxJU1R9IGZyb20gJy4vY29uc3RhbnRzJztcblxuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENUZXh0RmllbGRBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENUZXh0RmllbGRGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICByZXR1cm4gbnVtYmVycztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBnZXQgc2hvdWxkU2hha2UoKSB7XG4gICAgcmV0dXJuICF0aGlzLmlzVmFsaWQoKSAmJiAhdGhpcy5pc0ZvY3VzZWRfO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGdldCBzaG91bGRGbG9hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0ZvY3VzZWRfIHx8ICEhdGhpcy5nZXRWYWx1ZSgpIHx8IHRoaXMuaXNCYWRJbnB1dF8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENUZXh0RmllbGRBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ1RleHRGaWVsZEFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUZXh0RmllbGRBZGFwdGVyfSAqLyAoe1xuICAgICAgYWRkQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgaGFzQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICByZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICByZWdpc3RlclZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJWYWxpZGF0aW9uQXR0cmlidXRlQ2hhbmdlSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBnZXROYXRpdmVJbnB1dDogKCkgPT4ge30sXG4gICAgICBpc0ZvY3VzZWQ6ICgpID0+IHt9LFxuICAgICAgaXNSdGw6ICgpID0+IHt9LFxuICAgICAgYWN0aXZhdGVMaW5lUmlwcGxlOiAoKSA9PiB7fSxcbiAgICAgIGRlYWN0aXZhdGVMaW5lUmlwcGxlOiAoKSA9PiB7fSxcbiAgICAgIHNldExpbmVSaXBwbGVUcmFuc2Zvcm1PcmlnaW46ICgpID0+IHt9LFxuICAgICAgc2hha2VMYWJlbDogKCkgPT4ge30sXG4gICAgICBmbG9hdExhYmVsOiAoKSA9PiB7fSxcbiAgICAgIGhhc0xhYmVsOiAoKSA9PiB7fSxcbiAgICAgIGdldExhYmVsV2lkdGg6ICgpID0+IHt9LFxuICAgICAgaGFzT3V0bGluZTogKCkgPT4ge30sXG4gICAgICBub3RjaE91dGxpbmU6ICgpID0+IHt9LFxuICAgICAgY2xvc2VPdXRsaW5lOiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENUZXh0RmllbGRBZGFwdGVyfSBhZGFwdGVyXG4gICAqIEBwYXJhbSB7IUZvdW5kYXRpb25NYXBUeXBlPX0gZm91bmRhdGlvbk1hcCBNYXAgZnJvbSBzdWJjb21wb25lbnQgbmFtZXMgdG8gdGhlaXIgc3ViZm91bmRhdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyLCBmb3VuZGF0aW9uTWFwID0gLyoqIEB0eXBlIHshRm91bmRhdGlvbk1hcFR5cGV9ICovICh7fSkpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1RleHRGaWVsZEZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAdHlwZSB7IU1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9ufHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLmhlbHBlclRleHRfID0gZm91bmRhdGlvbk1hcC5oZWxwZXJUZXh0O1xuICAgIC8qKiBAdHlwZSB7IU1EQ1RleHRGaWVsZEljb25Gb3VuZGF0aW9ufHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLmljb25fID0gZm91bmRhdGlvbk1hcC5pY29uO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMuaXNGb2N1c2VkXyA9IGZhbHNlO1xuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLnJlY2VpdmVkVXNlcklucHV0XyA9IGZhbHNlO1xuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLnVzZUN1c3RvbVZhbGlkaXR5Q2hlY2tpbmdfID0gZmFsc2U7XG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMuaXNWYWxpZF8gPSB0cnVlO1xuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oKTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMuaW5wdXRGb2N1c0hhbmRsZXJfID0gKCkgPT4gdGhpcy5hY3RpdmF0ZUZvY3VzKCk7XG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbigpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy5pbnB1dEJsdXJIYW5kbGVyXyA9ICgpID0+IHRoaXMuZGVhY3RpdmF0ZUZvY3VzKCk7XG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbigpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy5pbnB1dElucHV0SGFuZGxlcl8gPSAoKSA9PiB0aGlzLmF1dG9Db21wbGV0ZUZvY3VzKCk7XG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy5zZXRQb2ludGVyWE9mZnNldF8gPSAoZXZ0KSA9PiB0aGlzLnNldFRyYW5zZm9ybU9yaWdpbihldnQpO1xuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMudGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyXyA9ICgpID0+IHRoaXMuaGFuZGxlVGV4dEZpZWxkSW50ZXJhY3Rpb24oKTtcbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFBcnJheSk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLnZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyXyA9IChhdHRyaWJ1dGVzTGlzdCkgPT4gdGhpcy5oYW5kbGVWYWxpZGF0aW9uQXR0cmlidXRlQ2hhbmdlKGF0dHJpYnV0ZXNMaXN0KTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IU11dGF0aW9uT2JzZXJ2ZXJ9ICovXG4gICAgdGhpcy52YWxpZGF0aW9uT2JzZXJ2ZXJfO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ1RleHRGaWVsZEZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5VUEdSQURFRCk7XG4gICAgLy8gRW5zdXJlIGxhYmVsIGRvZXMgbm90IGNvbGxpZGUgd2l0aCBhbnkgcHJlLWZpbGxlZCB2YWx1ZS5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5oYXNMYWJlbCgpICYmICh0aGlzLmdldFZhbHVlKCkgfHwgdGhpcy5pc0JhZElucHV0XygpKSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5mbG9hdExhYmVsKHRoaXMuc2hvdWxkRmxvYXQpO1xuICAgICAgdGhpcy5ub3RjaE91dGxpbmUodGhpcy5zaG91bGRGbG9hdCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNGb2N1c2VkKCkpIHtcbiAgICAgIHRoaXMuaW5wdXRGb2N1c0hhbmRsZXJfKCk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyKCdmb2N1cycsIHRoaXMuaW5wdXRGb2N1c0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoJ2JsdXInLCB0aGlzLmlucHV0Qmx1ckhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoJ2lucHV0JywgdGhpcy5pbnB1dElucHV0SGFuZGxlcl8pO1xuICAgIFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgdGhpcy5zZXRQb2ludGVyWE9mZnNldF8pO1xuICAgIH0pO1xuICAgIFsnY2xpY2snLCAna2V5ZG93biddLmZvckVhY2goKGV2dFR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgdGhpcy50ZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXJfKTtcbiAgICB9KTtcbiAgICB0aGlzLnZhbGlkYXRpb25PYnNlcnZlcl8gPVxuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyVmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXIodGhpcy52YWxpZGF0aW9uQXR0cmlidXRlQ2hhbmdlSGFuZGxlcl8pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ1RleHRGaWVsZEZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5VUEdSQURFRCk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoJ2ZvY3VzJywgdGhpcy5pbnB1dEZvY3VzSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyKCdibHVyJywgdGhpcy5pbnB1dEJsdXJIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoJ2lucHV0JywgdGhpcy5pbnB1dElucHV0SGFuZGxlcl8pO1xuICAgIFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCB0aGlzLnNldFBvaW50ZXJYT2Zmc2V0Xyk7XG4gICAgfSk7XG4gICAgWydjbGljaycsICdrZXlkb3duJ10uZm9yRWFjaCgoZXZ0VHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyVGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMudGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyVmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXIodGhpcy52YWxpZGF0aW9uT2JzZXJ2ZXJfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHVzZXIgaW50ZXJhY3Rpb25zIHdpdGggdGhlIFRleHQgRmllbGQuXG4gICAqL1xuICBoYW5kbGVUZXh0RmllbGRJbnRlcmFjdGlvbigpIHtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5nZXROYXRpdmVJbnB1dCgpLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVjZWl2ZWRVc2VySW5wdXRfID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHZhbGlkYXRpb24gYXR0cmlidXRlIGNoYW5nZXNcbiAgICogQHBhcmFtIHshQXJyYXk8c3RyaW5nPn0gYXR0cmlidXRlc0xpc3RcbiAgICovXG4gIGhhbmRsZVZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2UoYXR0cmlidXRlc0xpc3QpIHtcbiAgICBhdHRyaWJ1dGVzTGlzdC5zb21lKChhdHRyaWJ1dGVOYW1lKSA9PiB7XG4gICAgICBpZiAoVkFMSURBVElPTl9BVFRSX1dISVRFTElTVC5pbmRleE9mKGF0dHJpYnV0ZU5hbWUpID4gLTEpIHtcbiAgICAgICAgdGhpcy5zdHlsZVZhbGlkaXR5Xyh0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogT3BlbnMvY2xvc2VzIHRoZSBub3RjaGVkIG91dGxpbmUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3Blbk5vdGNoXG4gICAqL1xuICBub3RjaE91dGxpbmUob3Blbk5vdGNoKSB7XG4gICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmhhc091dGxpbmUoKSB8fCAhdGhpcy5hZGFwdGVyXy5oYXNMYWJlbCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9wZW5Ob3RjaCkge1xuICAgICAgY29uc3QgaXNEZW5zZSA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5ERU5TRSk7XG4gICAgICBjb25zdCBsYWJlbFNjYWxlID0gaXNEZW5zZSA/IG51bWJlcnMuREVOU0VfTEFCRUxfU0NBTEUgOiBudW1iZXJzLkxBQkVMX1NDQUxFO1xuICAgICAgY29uc3QgbGFiZWxXaWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0TGFiZWxXaWR0aCgpICogbGFiZWxTY2FsZTtcbiAgICAgIGNvbnN0IGlzUnRsID0gdGhpcy5hZGFwdGVyXy5pc1J0bCgpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RjaE91dGxpbmUobGFiZWxXaWR0aCwgaXNSdGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmNsb3NlT3V0bGluZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIHRleHQgZmllbGQgZm9jdXMgc3RhdGUuXG4gICAqL1xuICBhY3RpdmF0ZUZvY3VzKCkge1xuICAgIHRoaXMuaXNGb2N1c2VkXyA9IHRydWU7XG4gICAgdGhpcy5zdHlsZUZvY3VzZWRfKHRoaXMuaXNGb2N1c2VkXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5hY3RpdmF0ZUxpbmVSaXBwbGUoKTtcbiAgICB0aGlzLm5vdGNoT3V0bGluZSh0aGlzLnNob3VsZEZsb2F0KTtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5oYXNMYWJlbCgpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNoYWtlTGFiZWwodGhpcy5zaG91bGRTaGFrZSk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmZsb2F0TGFiZWwodGhpcy5zaG91bGRGbG9hdCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmhlbHBlclRleHRfKSB7XG4gICAgICB0aGlzLmhlbHBlclRleHRfLnNob3dUb1NjcmVlblJlYWRlcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsaW5lIHJpcHBsZSdzIHRyYW5zZm9ybSBvcmlnaW4sIHNvIHRoYXQgdGhlIGxpbmUgcmlwcGxlIGFjdGl2YXRlXG4gICAqIGFuaW1hdGlvbiB3aWxsIGFuaW1hdGUgb3V0IGZyb20gdGhlIHVzZXIncyBjbGljayBsb2NhdGlvbi5cbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgc2V0VHJhbnNmb3JtT3JpZ2luKGV2dCkge1xuICAgIGNvbnN0IHRhcmdldENsaWVudFJlY3QgPSBldnQudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGV2dENvb3JkcyA9IHt4OiBldnQuY2xpZW50WCwgeTogZXZ0LmNsaWVudFl9O1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRYID0gZXZ0Q29vcmRzLnggLSB0YXJnZXRDbGllbnRSZWN0LmxlZnQ7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRMaW5lUmlwcGxlVHJhbnNmb3JtT3JpZ2luKG5vcm1hbGl6ZWRYKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIFRleHQgRmllbGQncyBmb2N1cyBzdGF0ZSBpbiBjYXNlcyB3aGVuIHRoZSBpbnB1dCB2YWx1ZVxuICAgKiBjaGFuZ2VzIHdpdGhvdXQgdXNlciBpbnB1dCAoZS5nLiBwcm9ncmFtYXRpY2FsbHkpLlxuICAgKi9cbiAgYXV0b0NvbXBsZXRlRm9jdXMoKSB7XG4gICAgaWYgKCF0aGlzLnJlY2VpdmVkVXNlcklucHV0Xykge1xuICAgICAgdGhpcy5hY3RpdmF0ZUZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlYWN0aXZhdGVzIHRoZSBUZXh0IEZpZWxkJ3MgZm9jdXMgc3RhdGUuXG4gICAqL1xuICBkZWFjdGl2YXRlRm9jdXMoKSB7XG4gICAgdGhpcy5pc0ZvY3VzZWRfID0gZmFsc2U7XG4gICAgdGhpcy5hZGFwdGVyXy5kZWFjdGl2YXRlTGluZVJpcHBsZSgpO1xuICAgIGNvbnN0IGlucHV0ID0gdGhpcy5nZXROYXRpdmVJbnB1dF8oKTtcbiAgICBjb25zdCBzaG91bGRSZW1vdmVMYWJlbEZsb2F0ID0gIWlucHV0LnZhbHVlICYmICF0aGlzLmlzQmFkSW5wdXRfKCk7XG4gICAgY29uc3QgaXNWYWxpZCA9IHRoaXMuaXNWYWxpZCgpO1xuICAgIHRoaXMuc3R5bGVWYWxpZGl0eV8oaXNWYWxpZCk7XG4gICAgdGhpcy5zdHlsZUZvY3VzZWRfKHRoaXMuaXNGb2N1c2VkXyk7XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaGFzTGFiZWwoKSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zaGFrZUxhYmVsKHRoaXMuc2hvdWxkU2hha2UpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5mbG9hdExhYmVsKHRoaXMuc2hvdWxkRmxvYXQpO1xuICAgICAgdGhpcy5ub3RjaE91dGxpbmUodGhpcy5zaG91bGRGbG9hdCk7XG4gICAgfVxuICAgIGlmIChzaG91bGRSZW1vdmVMYWJlbEZsb2F0KSB7XG4gICAgICB0aGlzLnJlY2VpdmVkVXNlcklucHV0XyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQgRWxlbWVudC5cbiAgICovXG4gIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZUlucHV0XygpLnZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0IG9uIHRoZSBpbnB1dCBFbGVtZW50LlxuICAgKi9cbiAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLmdldE5hdGl2ZUlucHV0XygpLnZhbHVlID0gdmFsdWU7XG4gICAgY29uc3QgaXNWYWxpZCA9IHRoaXMuaXNWYWxpZCgpO1xuICAgIHRoaXMuc3R5bGVWYWxpZGl0eV8oaXNWYWxpZCk7XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaGFzTGFiZWwoKSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zaGFrZUxhYmVsKHRoaXMuc2hvdWxkU2hha2UpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5mbG9hdExhYmVsKHRoaXMuc2hvdWxkRmxvYXQpO1xuICAgICAgdGhpcy5ub3RjaE91dGxpbmUodGhpcy5zaG91bGRGbG9hdCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIGEgY3VzdG9tIHZhbGlkaXR5IGlzIHNldCwgcmV0dXJucyB0aGF0IHZhbHVlLlxuICAgKiAgICAgT3RoZXJ3aXNlLCByZXR1cm5zIHRoZSByZXN1bHQgb2YgbmF0aXZlIHZhbGlkaXR5IGNoZWNrcy5cbiAgICovXG4gIGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudXNlQ3VzdG9tVmFsaWRpdHlDaGVja2luZ19cbiAgICAgID8gdGhpcy5pc1ZhbGlkXyA6IHRoaXMuaXNOYXRpdmVJbnB1dFZhbGlkXygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNWYWxpZCBTZXRzIHRoZSB2YWxpZGl0eSBzdGF0ZSBvZiB0aGUgVGV4dCBGaWVsZC5cbiAgICovXG4gIHNldFZhbGlkKGlzVmFsaWQpIHtcbiAgICB0aGlzLnVzZUN1c3RvbVZhbGlkaXR5Q2hlY2tpbmdfID0gdHJ1ZTtcbiAgICB0aGlzLmlzVmFsaWRfID0gaXNWYWxpZDtcbiAgICAvLyBSZXRyaWV2ZSBmcm9tIHRoZSBnZXR0ZXIgdG8gZW5zdXJlIGNvcnJlY3QgbG9naWMgaXMgYXBwbGllZC5cbiAgICBpc1ZhbGlkID0gdGhpcy5pc1ZhbGlkKCk7XG4gICAgdGhpcy5zdHlsZVZhbGlkaXR5Xyhpc1ZhbGlkKTtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5oYXNMYWJlbCgpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNoYWtlTGFiZWwodGhpcy5zaG91bGRTaGFrZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIFRleHQgRmllbGQgaXMgZGlzYWJsZWQuXG4gICAqL1xuICBpc0Rpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZUlucHV0XygpLmRpc2FibGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWQgU2V0cyB0aGUgdGV4dC1maWVsZCBkaXNhYmxlZCBvciBlbmFibGVkLlxuICAgKi9cbiAgc2V0RGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICB0aGlzLmdldE5hdGl2ZUlucHV0XygpLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgdGhpcy5zdHlsZURpc2FibGVkXyhkaXNhYmxlZCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgU2V0cyB0aGUgY29udGVudCBvZiB0aGUgaGVscGVyIHRleHQuXG4gICAqL1xuICBzZXRIZWxwZXJUZXh0Q29udGVudChjb250ZW50KSB7XG4gICAgaWYgKHRoaXMuaGVscGVyVGV4dF8pIHtcbiAgICAgIHRoaXMuaGVscGVyVGV4dF8uc2V0Q29udGVudChjb250ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgYXJpYSBsYWJlbCBvZiB0aGUgaWNvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsXG4gICAqL1xuICBzZXRJY29uQXJpYUxhYmVsKGxhYmVsKSB7XG4gICAgaWYgKHRoaXMuaWNvbl8pIHtcbiAgICAgIHRoaXMuaWNvbl8uc2V0QXJpYUxhYmVsKGxhYmVsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBpY29uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICAgKi9cbiAgc2V0SWNvbkNvbnRlbnQoY29udGVudCkge1xuICAgIGlmICh0aGlzLmljb25fKSB7XG4gICAgICB0aGlzLmljb25fLnNldENvbnRlbnQoY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIFRleHQgRmllbGQgaW5wdXQgZmFpbHMgaW4gY29udmVydGluZyB0aGVcbiAgICogICAgIHVzZXItc3VwcGxpZWQgdmFsdWUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc0JhZElucHV0XygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVJbnB1dF8oKS52YWxpZGl0eS5iYWRJbnB1dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgcmVzdWx0IG9mIG5hdGl2ZSB2YWxpZGl0eSBjaGVja2luZ1xuICAgKiAgICAgKFZhbGlkaXR5U3RhdGUudmFsaWQpLlxuICAgKi9cbiAgaXNOYXRpdmVJbnB1dFZhbGlkXygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVJbnB1dF8oKS52YWxpZGl0eS52YWxpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdHlsZXMgdGhlIGNvbXBvbmVudCBiYXNlZCBvbiB0aGUgdmFsaWRpdHkgc3RhdGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNWYWxpZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3R5bGVWYWxpZGl0eV8oaXNWYWxpZCkge1xuICAgIGNvbnN0IHtJTlZBTElEfSA9IE1EQ1RleHRGaWVsZEZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhJTlZBTElEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhJTlZBTElEKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGVscGVyVGV4dF8pIHtcbiAgICAgIHRoaXMuaGVscGVyVGV4dF8uc2V0VmFsaWRpdHkoaXNWYWxpZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0eWxlcyB0aGUgY29tcG9uZW50IGJhc2VkIG9uIHRoZSBmb2N1c2VkIHN0YXRlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRm9jdXNlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3R5bGVGb2N1c2VkXyhpc0ZvY3VzZWQpIHtcbiAgICBjb25zdCB7Rk9DVVNFRH0gPSBNRENUZXh0RmllbGRGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgaWYgKGlzRm9jdXNlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhGT0NVU0VEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhGT0NVU0VEKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3R5bGVzIHRoZSBjb21wb25lbnQgYmFzZWQgb24gdGhlIGRpc2FibGVkIHN0YXRlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRGlzYWJsZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0eWxlRGlzYWJsZWRfKGlzRGlzYWJsZWQpIHtcbiAgICBjb25zdCB7RElTQUJMRUQsIElOVkFMSUR9ID0gTURDVGV4dEZpZWxkRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIGlmIChpc0Rpc2FibGVkKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKERJU0FCTEVEKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoSU5WQUxJRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoRElTQUJMRUQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pY29uXykge1xuICAgICAgdGhpcy5pY29uXy5zZXREaXNhYmxlZChpc0Rpc2FibGVkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IUVsZW1lbnR8IU5hdGl2ZUlucHV0VHlwZX0gVGhlIG5hdGl2ZSB0ZXh0IGlucHV0IGZyb20gdGhlXG4gICAqIGhvc3QgZW52aXJvbm1lbnQsIG9yIGEgZHVtbXkgaWYgbm9uZSBleGlzdHMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXROYXRpdmVJbnB1dF8oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uZ2V0TmF0aXZlSW5wdXQoKSB8fFxuICAgIC8qKiBAdHlwZSB7IU5hdGl2ZUlucHV0VHlwZX0gKi8gKHtcbiAgICAgIHZhbHVlOiAnJyxcbiAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgIHZhbGlkaXR5OiB7XG4gICAgICAgIGJhZElucHV0OiBmYWxzZSxcbiAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1RleHRGaWVsZEZvdW5kYXRpb247XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXZcbiAgICA6c3R5bGU9XCJ7d2lkdGg6ZnVsbHdpZHRoPycxMDAlJzp1bmRlZmluZWR9XCJcbiAgICA6aWQ9XCJpZFwiXG4gICAgY2xhc3M9XCJtZGMtdGV4dGZpZWxkLXdyYXBwZXJcIj5cblxuICAgIDxkaXZcbiAgICAgIHJlZj1cInJvb3RcIlxuICAgICAgOmNsYXNzPVwicm9vdENsYXNzZXNcIj5cblxuICAgICAgPGlcbiAgICAgICAgdi1pZj1cIiEhaGFzTGVhZGluZ0ljb25cIlxuICAgICAgICByZWY9XCJpY29uXCJcbiAgICAgICAgOmNsYXNzPVwiaGFzTGVhZGluZ0ljb24uY2xhc3Nlc1wiXG4gICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgIGNsYXNzPVwibWRjLXRleHQtZmllbGRfX2ljb25cIj5cbiAgICAgICAgPHNsb3QgbmFtZT1cImxlYWRpbmctaWNvblwiPnt7IGhhc0xlYWRpbmdJY29uLmNvbnRlbnQgfX08L3Nsb3Q+XG4gICAgICA8L2k+XG5cbiAgICAgIDwhLS0gd29ya2Fycm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy9yb2xsdXAtcGx1Z2luLXZ1ZS9pc3N1ZXMvMTc0IC0tPlxuICAgICAgPCEtLSBlc2xpbnQtZGlzYWJsZSB2dWUvaHRtbC1zZWxmLWNsb3NpbmcgLS0+XG4gICAgICA8dGV4dGFyZWFcbiAgICAgICAgdi1pZj1cIm11bHRpbGluZVwiXG4gICAgICAgIHJlZj1cImlucHV0XCJcbiAgICAgICAgdi1iaW5kPVwiJGF0dHJzXCJcbiAgICAgICAgOmlkPVwidm1hX3VpZF9cIlxuICAgICAgICA6Y2xhc3M9XCJpbnB1dENsYXNzZXNcIlxuICAgICAgICA6bWlubGVuZ3RoPVwibWlubGVuZ3RoXCJcbiAgICAgICAgOm1heGxlbmd0aD1cIm1heGxlbmd0aFwiXG4gICAgICAgIDpwbGFjZWhvbGRlcj1cImlucHV0UGxhY2VIb2xkZXJcIlxuICAgICAgICA6YXJpYS1sYWJlbD1cImlucHV0UGxhY2VIb2xkZXJcIlxuICAgICAgICA6YXJpYS1jb250cm9scz1cImlucHV0QXJpYUNvbnRyb2xzXCJcbiAgICAgICAgOnJvd3M9XCJyb3dzXCJcbiAgICAgICAgOmNvbHM9XCJjb2xzXCJcbiAgICAgICAgdi1vbj1cIiRsaXN0ZW5lcnNcIlxuICAgICAgICBAaW5wdXQ9XCJ1cGRhdGVWYWx1ZSgkZXZlbnQudGFyZ2V0LnZhbHVlKVwiXG4gICAgICA+PC90ZXh0YXJlYT5cblxuICAgICAgPGlucHV0XG4gICAgICAgIHYtZWxzZVxuICAgICAgICByZWY9XCJpbnB1dFwiXG4gICAgICAgIHYtYmluZD1cIiRhdHRyc1wiXG4gICAgICAgIDppZD1cInZtYV91aWRfXCJcbiAgICAgICAgOmNsYXNzPVwiaW5wdXRDbGFzc2VzXCJcbiAgICAgICAgOnR5cGU9XCJ0eXBlXCJcbiAgICAgICAgOm1pbmxlbmd0aD1cIm1pbmxlbmd0aFwiXG4gICAgICAgIDptYXhsZW5ndGg9XCJtYXhsZW5ndGhcIlxuICAgICAgICA6cGxhY2Vob2xkZXI9XCJpbnB1dFBsYWNlSG9sZGVyXCJcbiAgICAgICAgOmFyaWEtbGFiZWw9XCJpbnB1dFBsYWNlSG9sZGVyXCJcbiAgICAgICAgOmFyaWEtY29udHJvbHM9XCJpbnB1dEFyaWFDb250cm9sc1wiXG4gICAgICAgIHYtb249XCIkbGlzdGVuZXJzXCJcbiAgICAgICAgQGlucHV0PVwidXBkYXRlVmFsdWUoJGV2ZW50LnRhcmdldC52YWx1ZSlcIlxuICAgICAgPlxuXG4gICAgICA8bGFiZWxcbiAgICAgICAgdi1pZj1cImhhc0xhYmVsXCJcbiAgICAgICAgcmVmPVwibGFiZWxcIlxuICAgICAgICA6Y2xhc3M9XCJsYWJlbENsYXNzZXNVcGdyYWRlZFwiXG4gICAgICAgIDpmb3I9XCJ2bWFfdWlkX1wiPlxuICAgICAgICB7eyBsYWJlbCB9fVxuICAgICAgPC9sYWJlbD5cblxuICAgICAgPGlcbiAgICAgICAgdi1pZj1cIiEhaGFzVHJhaWxpbmdJY29uXCJcbiAgICAgICAgcmVmPVwiaWNvblwiXG4gICAgICAgIDpjbGFzcz1cImhhc1RyYWlsaW5nSWNvbi5jbGFzc2VzXCJcbiAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgY2xhc3M9XCJtZGMtdGV4dC1maWVsZF9faWNvblwiPlxuICAgICAgICA8c2xvdCBuYW1lPVwidHJhaWxpbmctaWNvblwiPnt7IGhhc1RyYWlsaW5nSWNvbi5jb250ZW50IH19PC9zbG90PlxuICAgICAgPC9pPlxuXG4gICAgICA8ZGl2XG4gICAgICAgIHYtaWY9XCJoYXNPdXRsaW5lXCJcbiAgICAgICAgcmVmPVwib3V0bGluZVwiXG4gICAgICAgIDpjbGFzcz1cIm91dGxpbmVDbGFzc2VzXCJcbiAgICAgICAgY2xhc3M9XCJtZGMtbm90Y2hlZC1vdXRsaW5lXCI+XG4gICAgICAgIDxzdmc+XG4gICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgIDpkPVwib3V0bGluZVBhdGhBdHRyXCJcbiAgICAgICAgICAgIGNsYXNzPVwibWRjLW5vdGNoZWQtb3V0bGluZV9fcGF0aFwiIC8+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2XG4gICAgICAgIHYtaWY9XCJoYXNPdXRsaW5lXCJcbiAgICAgICAgcmVmPVwib3V0bGluZUlkbGVcIlxuICAgICAgICBjbGFzcz1cIm1kYy1ub3RjaGVkLW91dGxpbmVfX2lkbGVcIi8+XG4gICAgICA8ZGl2XG4gICAgICAgIHYtaWY9XCJoYXNMaW5lUmlwcGxlXCJcbiAgICAgICAgcmVmPVwibGluZVJpcHBsZVwiXG4gICAgICAgIDpjbGFzcz1cImxpbmVSaXBwbGVDbGFzc2VzXCJcbiAgICAgICAgOnN0eWxlPVwibGluZVJpcHBsZVN0eWxlc1wiLz5cblxuICAgIDwvZGl2PlxuXG4gICAgPHBcbiAgICAgIHYtaWY9XCJoZWxwdGV4dFwiXG4gICAgICByZWY9XCJoZWxwXCJcbiAgICAgIDppZD1cIidoZWxwLScrdm1hX3VpZF9cIlxuICAgICAgOmNsYXNzPVwiaGVscENsYXNzZXNcIlxuICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCI+XG4gICAgICB7eyBoZWxwdGV4dCB9fVxuICAgIDwvcD5cblxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDVGV4dGZpZWxkRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvdGV4dGZpZWxkL2ZvdW5kYXRpb24nXG5pbXBvcnQgTURDTGluZVJpcHBsZUZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2xpbmUtcmlwcGxlL2ZvdW5kYXRpb24nXG5pbXBvcnQgTURDVGV4dEZpZWxkSGVscGVyVGV4dEZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3RleHRmaWVsZC9oZWxwZXItdGV4dC9mb3VuZGF0aW9uJ1xuaW1wb3J0IE1EQ1RleHRGaWVsZEljb25Gb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC90ZXh0ZmllbGQvaWNvbi9mb3VuZGF0aW9uJ1xuaW1wb3J0IE1EQ0Zsb2F0aW5nTGFiZWxGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9mbG9hdGluZy1sYWJlbC9mb3VuZGF0aW9uJ1xuaW1wb3J0IE1EQ05vdGNoZWRPdXRsaW5lRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvbm90Y2hlZC1vdXRsaW5lL2ZvdW5kYXRpb24nXG5cbmltcG9ydCB7XG4gIGV4dHJhY3RJY29uUHJvcCxcbiAgRGlzcGF0Y2hGb2N1c01peGluLFxuICBDdXN0b21FbGVtZW50TWl4aW4sXG4gIFZNQVVuaXF1ZUlkTWl4aW4sXG4gIGFwcGx5UGFzc2l2ZVxufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IHsgUmlwcGxlQmFzZSB9IGZyb20gJy4uL3JpcHBsZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXRleHRmaWVsZCcsXG4gIG1peGluczogW0N1c3RvbUVsZW1lbnRNaXhpbiwgRGlzcGF0Y2hGb2N1c01peGluLCBWTUFVbmlxdWVJZE1peGluXSxcbiAgaW5oZXJpdEF0dHJzOiBmYWxzZSxcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAndmFsdWUnLFxuICAgIGV2ZW50OiAnbW9kZWwnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgdmFsdWU6IFN0cmluZyxcbiAgICB0eXBlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAndGV4dCcsXG4gICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJ3RleHQnLFxuICAgICAgICAgICAgJ2VtYWlsJyxcbiAgICAgICAgICAgICdzZWFyY2gnLFxuICAgICAgICAgICAgJ3Bhc3N3b3JkJyxcbiAgICAgICAgICAgICd0ZWwnLFxuICAgICAgICAgICAgJ3VybCcsXG4gICAgICAgICAgICAnbnVtYmVyJ1xuICAgICAgICAgIF0uaW5kZXhPZih2YWx1ZSkgIT09IC0xXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlbnNlOiBCb29sZWFuLFxuICAgIGxhYmVsOiBTdHJpbmcsXG4gICAgaGVscHRleHQ6IFN0cmluZyxcbiAgICBoZWxwdGV4dFBlcnNpc3RlbnQ6IEJvb2xlYW4sXG4gICAgaGVscHRleHRWYWxpZGF0aW9uOiBCb29sZWFuLFxuICAgIGJveDogQm9vbGVhbixcbiAgICBvdXRsaW5lOiBCb29sZWFuLFxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgIHJlcXVpcmVkOiBCb29sZWFuLFxuICAgIHZhbGlkOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IHVuZGVmaW5lZCB9LFxuICAgIGZ1bGx3aWR0aDogQm9vbGVhbixcbiAgICBtdWx0aWxpbmU6IEJvb2xlYW4sXG4gICAgbGVhZGluZ0ljb246IFtTdHJpbmcsIEFycmF5LCBPYmplY3RdLFxuICAgIHRyYWlsaW5nSWNvbjogW1N0cmluZywgQXJyYXksIE9iamVjdF0sXG4gICAgc2l6ZTogeyB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLCBkZWZhdWx0OiAyMCB9LFxuICAgIG1pbmxlbmd0aDogeyB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLCBkZWZhdWx0OiB1bmRlZmluZWQgfSxcbiAgICBtYXhsZW5ndGg6IHsgdHlwZTogW051bWJlciwgU3RyaW5nXSwgZGVmYXVsdDogdW5kZWZpbmVkIH0sXG4gICAgcm93czogeyB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLCBkZWZhdWx0OiA4IH0sXG4gICAgY29sczogeyB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLCBkZWZhdWx0OiA0MCB9LFxuICAgIGlkOiB7IHR5cGU6IFN0cmluZyB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0OiB0aGlzLnZhbHVlLFxuICAgICAgcm9vdENsYXNzZXM6IHtcbiAgICAgICAgJ21kYy10ZXh0ZmllbGQnOiB0cnVlLFxuICAgICAgICAnbWRjLXRleHQtZmllbGQnOiB0cnVlLFxuICAgICAgICAnbWRjLXRleHQtZmllbGQtLXVwZ3JhZGVkJzogdHJ1ZSxcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkLS1kaXNhYmxlZCc6IHRoaXMuZGlzYWJsZWQsXG4gICAgICAgICdtZGMtdGV4dC1maWVsZC0tZGVuc2UnOiB0aGlzLmRlbnNlLFxuICAgICAgICAnbWRjLXRleHQtZmllbGQtLWZ1bGx3aWR0aCc6IHRoaXMuZnVsbHdpZHRoLFxuICAgICAgICAnbWRjLXRleHQtZmllbGQtLXRleHRhcmVhJzogdGhpcy5tdWx0aWxpbmUsXG4gICAgICAgICdtZGMtdGV4dC1maWVsZC0tYm94JzogIXRoaXMuZnVsbHdpZHRoICYmIHRoaXMuYm94LFxuICAgICAgICAnbWRjLXRleHQtZmllbGQtLW91dGxpbmVkJzogIXRoaXMuZnVsbHdpZHRoICYmIHRoaXMub3V0bGluZVxuICAgICAgfSxcbiAgICAgIGlucHV0Q2xhc3Nlczoge1xuICAgICAgICAnbWRjLXRleHQtZmllbGRfX2lucHV0JzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGxhYmVsQ2xhc3Nlczoge1xuICAgICAgICAnbWRjLWZsb2F0aW5nLWxhYmVsJzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGxpbmVSaXBwbGVDbGFzc2VzOiB7XG4gICAgICAgICdtZGMtbGluZS1yaXBwbGUnOiB0cnVlXG4gICAgICB9LFxuICAgICAgbGluZVJpcHBsZVN0eWxlczoge30sXG4gICAgICBoZWxwQ2xhc3Nlczoge1xuICAgICAgICAnbWRjLXRleHQtZmllbGQtaGVscGVyLXRleHQnOiB0cnVlLFxuICAgICAgICAnbWRjLXRleHQtZmllbGQtaGVscGVyLXRleHQtLXBlcnNpc3RlbnQnOiB0aGlzLmhlbHB0ZXh0UGVyc2lzdGVudCxcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkLWhlbHBlci10ZXh0LS12YWxpZGF0aW9uLW1zZyc6IHRoaXMuaGVscHRleHRWYWxpZGF0aW9uXG4gICAgICB9LFxuICAgICAgb3V0bGluZUNsYXNzZXM6IHt9LFxuICAgICAgb3V0bGluZVBhdGhBdHRyOiB1bmRlZmluZWRcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaW5wdXRQbGFjZUhvbGRlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZ1bGx3aWR0aCA/IHRoaXMubGFiZWwgOiB1bmRlZmluZWRcbiAgICB9LFxuICAgIGlucHV0QXJpYUNvbnRyb2xzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGVscCA/ICdoZWxwLScgKyB0aGlzLnZtYV91aWRfIDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICBoYXNMYWJlbCgpIHtcbiAgICAgIHJldHVybiAhdGhpcy5mdWxsd2lkdGggJiYgdGhpcy5sYWJlbFxuICAgIH0sXG4gICAgaGFzT3V0bGluZSgpIHtcbiAgICAgIHJldHVybiAhdGhpcy5mdWxsd2lkdGggJiYgdGhpcy5vdXRsaW5lXG4gICAgfSxcbiAgICBoYXNMaW5lUmlwcGxlKCkge1xuICAgICAgcmV0dXJuICF0aGlzLmhhc091dGxpbmUgJiYgIXRoaXMubXVsdGlsaW5lXG4gICAgfSxcbiAgICBoYXNMZWFkaW5nSWNvbigpIHtcbiAgICAgIGlmIChcbiAgICAgICAgKHRoaXMubGVhZGluZ0ljb24gfHwgdGhpcy4kc2xvdHNbJ2xlYWRpbmctaWNvbiddKSAmJlxuICAgICAgICAhKHRoaXMudHJhaWxpbmdJY29uIHx8IHRoaXMuJHNsb3RzWyd0cmFpbGluZy1pY29uJ10pXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVhZGluZ0ljb24gPyBleHRyYWN0SWNvblByb3AodGhpcy5sZWFkaW5nSWNvbikgOiB7fVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSxcbiAgICBoYXNUcmFpbGluZ0ljb24oKSB7XG4gICAgICBpZiAodGhpcy50cmFpbGluZ0ljb24gfHwgdGhpcy4kc2xvdHNbJ3RyYWlsaW5nLWljb24nXSkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFpbGluZ0ljb24gPyBleHRyYWN0SWNvblByb3AodGhpcy50cmFpbGluZ0ljb24pIDoge31cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0sXG4gICAgbGFiZWxDbGFzc2VzVXBncmFkZWQoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih0aGlzLmxhYmVsQ2xhc3Nlcywge1xuICAgICAgICAnbWRjLWZsb2F0aW5nLWxhYmVsLS1mbG9hdC1hYm92ZSc6IHRoaXMudmFsdWVcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGRpc2FibGVkKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5zZXREaXNhYmxlZCh0aGlzLmRpc2FibGVkKVxuICAgIH0sXG4gICAgcmVxdWlyZWQoKSB7XG4gICAgICB0aGlzLiRyZWZzLmlucHV0ICYmICh0aGlzLiRyZWZzLmlucHV0LnJlcXVpcmVkID0gdGhpcy5yZXF1aXJlZClcbiAgICB9LFxuICAgIHZhbGlkKCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLnZhbGlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLnNldFZhbGlkKHRoaXMudmFsaWQpXG4gICAgICB9XG4gICAgfSxcbiAgICBkZW5zZSgpIHtcbiAgICAgIHRoaXMuJHNldCh0aGlzLnJvb3RDbGFzc2VzLCAnbWRjLXRleHQtZmllbGQtLWRlbnNlJywgdGhpcy5kZW5zZSlcbiAgICB9LFxuICAgIGhlbHB0ZXh0UGVyc2lzdGVudCgpIHtcbiAgICAgIHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24gJiZcbiAgICAgICAgdGhpcy5oZWxwZXJUZXh0Rm91bmRhdGlvbi5zZXRQZXJzaXN0ZW50KHRoaXMuaGVscHRleHRQZXJzaXN0ZW50KVxuICAgIH0sXG4gICAgaGVscHRleHRWYWxpZGF0aW9uKCkge1xuICAgICAgdGhpcy5oZWxwZXJUZXh0Rm91bmRhdGlvbiAmJlxuICAgICAgICB0aGlzLmhlbHBlclRleHRGb3VuZGF0aW9uLnNldFZhbGlkYXRpb24odGhpcy5oZWxwdGV4dFZhbGlkYXRpb24pXG4gICAgfSxcbiAgICB2YWx1ZSh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuZm91bmRhdGlvbikge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuZm91bmRhdGlvbi5nZXRWYWx1ZSgpKSB7XG4gICAgICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldFZhbHVlKHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIGlmICh0aGlzLiRyZWZzLmxpbmVSaXBwbGUpIHtcbiAgICAgIHRoaXMubGluZVJpcHBsZUZvdW5kYXRpb24gPSBuZXcgTURDTGluZVJpcHBsZUZvdW5kYXRpb24oe1xuICAgICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgICB0aGlzLiRzZXQodGhpcy5saW5lUmlwcGxlQ2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5saW5lUmlwcGxlQ2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgICB9LFxuICAgICAgICBoYXNDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgICB0aGlzLiRyZWZzLmxpbmVSaXBwbGUuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSlcbiAgICAgICAgfSxcbiAgICAgICAgc2V0U3R5bGU6IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIHRoaXMuJHNldCh0aGlzLmxpbmVSaXBwbGVTdHlsZXMsIG5hbWUsIHZhbHVlKVxuICAgICAgICB9LFxuICAgICAgICByZWdpc3RlckV2ZW50SGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICB0aGlzLiRyZWZzLmxpbmVSaXBwbGUuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxuICAgICAgICB9LFxuICAgICAgICBkZXJlZ2lzdGVyRXZlbnRIYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMubGluZVJpcHBsZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICB0aGlzLmxpbmVSaXBwbGVGb3VuZGF0aW9uLmluaXQoKVxuICAgIH1cblxuICAgIGlmICh0aGlzLiRyZWZzLmhlbHApIHtcbiAgICAgIHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24gPSBuZXcgTURDVGV4dEZpZWxkSGVscGVyVGV4dEZvdW5kYXRpb24oe1xuICAgICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgICB0aGlzLiRzZXQodGhpcy5oZWxwQ2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5oZWxwQ2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgICB9LFxuICAgICAgICBoYXNDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5oZWxwLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpXG4gICAgICAgIH0sXG4gICAgICAgIHNldEF0dHI6IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMuaGVscC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpXG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUF0dHI6IG5hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMuaGVscC5yZW1vdmVBdHRyaWJ1dGUobmFtZSlcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Q29udGVudDogKC8qY29udGVudCovKSA9PiB7XG4gICAgICAgICAgLy8gaGVscCB0ZXh0IGdldCdzIHVwZGF0ZWQgZnJvbSB7e2hlbHB0ZXh0fX1cbiAgICAgICAgICAvLyB0aGlzLiRyZWZzLmhlbHAudGV4dENvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgdGhpcy5oZWxwZXJUZXh0Rm91bmRhdGlvbi5pbml0KClcbiAgICB9XG5cbiAgICBpZiAodGhpcy4kcmVmcy5pY29uKSB7XG4gICAgICBpZiAodGhpcy5oYXNMZWFkaW5nSWNvbikge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5yb290Q2xhc3NlcywgJ21kYy10ZXh0LWZpZWxkLS13aXRoLWxlYWRpbmctaWNvbicsIHRydWUpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaGFzVHJhaWxpbmdJY29uKSB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnJvb3RDbGFzc2VzLCAnbWRjLXRleHQtZmllbGQtLXdpdGgtdHJhaWxpbmctaWNvbicsIHRydWUpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuaWNvbkZvdW5kYXRpb24gPSBuZXcgTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb24oe1xuICAgICAgICBzZXRBdHRyOiAoYXR0ciwgdmFsdWUpID0+IHRoaXMuJHJlZnMuaWNvbi5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpLFxuICAgICAgICBnZXRBdHRyOiBhdHRyID0+IHRoaXMuJHJlZnMuaWNvbi5nZXRBdHRyaWJ1dGUoYXR0ciksXG4gICAgICAgIHJlbW92ZUF0dHI6IGF0dHIgPT4gdGhpcy4kcmVmcy5pY29uLnJlbW92ZUF0dHJpYnV0ZShhdHRyKSxcbiAgICAgICAgc2V0Q29udGVudDogKC8qY29udGVudCovKSA9PiB7XG4gICAgICAgICAgLy8gaWNvbiB0ZXh0IGdldCdzIHVwZGF0ZWQgZnJvbSB7e3t7IGhhc1RyYWlsaW5nSWNvbi5jb250ZW50IH19fX1cbiAgICAgICAgICAvLyB0aGlzLiRyZWZzLmljb24udGV4dENvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB9LFxuICAgICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICB0aGlzLiRyZWZzLmljb24uYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxuICAgICAgICB9LFxuICAgICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMuaWNvbi5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpXG4gICAgICAgIH0sXG4gICAgICAgIG5vdGlmeUljb25BY3Rpb246ICgpID0+IHRoaXMuJGVtaXQoJ2ljb24tYWN0aW9uJylcbiAgICAgIH0pXG4gICAgICB0aGlzLmljb25Gb3VuZGF0aW9uLmluaXQoKVxuICAgIH1cblxuICAgIGlmICh0aGlzLiRyZWZzLmxhYmVsKSB7XG4gICAgICB0aGlzLmxhYmVsRm91bmRhdGlvbiA9IG5ldyBNRENGbG9hdGluZ0xhYmVsRm91bmRhdGlvbih7XG4gICAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJHNldCh0aGlzLmxhYmVsQ2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5sYWJlbENsYXNzZXMsIGNsYXNzTmFtZSlcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0V2lkdGg6ICgpID0+IHRoaXMuJHJlZnMubGFiZWwub2Zmc2V0V2lkdGgsXG4gICAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMubGFiZWwuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxuICAgICAgICB9LFxuICAgICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMubGFiZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgdGhpcy5sYWJlbEZvdW5kYXRpb24uaW5pdCgpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuJHJlZnMub3V0bGluZSkge1xuICAgICAgdGhpcy5vdXRsaW5lRm91bmRhdGlvbiA9IG5ldyBNRENOb3RjaGVkT3V0bGluZUZvdW5kYXRpb24oe1xuICAgICAgICBnZXRXaWR0aDogKCkgPT4gdGhpcy4kcmVmcy5vdXRsaW5lLm9mZnNldFdpZHRoLFxuICAgICAgICBnZXRIZWlnaHQ6ICgpID0+IHRoaXMuJHJlZnMub3V0bGluZS5vZmZzZXRIZWlnaHQsXG4gICAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJHNldCh0aGlzLm91dGxpbmVDbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLm91dGxpbmVDbGFzc2VzLCBjbGFzc05hbWUpXG4gICAgICAgIH0sXG4gICAgICAgIHNldE91dGxpbmVQYXRoQXR0cjogdmFsdWUgPT4ge1xuICAgICAgICAgIHRoaXMub3V0bGluZVBhdGhBdHRyID0gdmFsdWVcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0SWRsZU91dGxpbmVTdHlsZVZhbHVlOiBwcm9wZXJ0eU5hbWUgPT4ge1xuICAgICAgICAgIGNvbnN0IGlkbGVPdXRsaW5lRWxlbWVudCA9IHRoaXMuJHJlZnMub3V0bGluZUlkbGVcbiAgICAgICAgICBpZiAoaWRsZU91dGxpbmVFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93XG4gICAgICAgICAgICAgIC5nZXRDb21wdXRlZFN0eWxlKGlkbGVPdXRsaW5lRWxlbWVudClcbiAgICAgICAgICAgICAgLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHlOYW1lKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHRoaXMub3V0bGluZUZvdW5kYXRpb24uaW5pdCgpXG4gICAgfVxuXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ1RleHRmaWVsZEZvdW5kYXRpb24oXG4gICAgICB7XG4gICAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJHNldCh0aGlzLnJvb3RDbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLnJvb3RDbGFzc2VzLCBjbGFzc05hbWUpXG4gICAgICAgIH0sXG4gICAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMucm9vdC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKVxuICAgICAgICB9LFxuICAgICAgICByZWdpc3RlclRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICB0aGlzLiRyZWZzLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxuICAgICAgICB9LFxuICAgICAgICBkZXJlZ2lzdGVyVGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpXG4gICAgICAgIH0sXG4gICAgICAgIGlzRm9jdXNlZDogKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLiRyZWZzLmlucHV0XG4gICAgICAgIH0sXG4gICAgICAgIGlzUnRsOiAoKSA9PlxuICAgICAgICAgIHdpbmRvd1xuICAgICAgICAgICAgLmdldENvbXB1dGVkU3R5bGUodGhpcy4kcmVmcy5yb290KVxuICAgICAgICAgICAgLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpID09PSAncnRsJyxcbiAgICAgICAgZGVhY3RpdmF0ZUxpbmVSaXBwbGU6ICgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5saW5lUmlwcGxlRm91bmRhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5saW5lUmlwcGxlRm91bmRhdGlvbi5kZWFjdGl2YXRlKClcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFjdGl2YXRlTGluZVJpcHBsZTogKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmxpbmVSaXBwbGVGb3VuZGF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVSaXBwbGVGb3VuZGF0aW9uLmFjdGl2YXRlKClcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldExpbmVSaXBwbGVUcmFuc2Zvcm1PcmlnaW46IG5vcm1hbGl6ZWRYID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5saW5lUmlwcGxlRm91bmRhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5saW5lUmlwcGxlRm91bmRhdGlvbi5zZXRSaXBwbGVDZW50ZXIobm9ybWFsaXplZFgpXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCBhcHBseVBhc3NpdmUoKSlcbiAgICAgICAgfSxcbiAgICAgICAgZGVyZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMuaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCBhcHBseVBhc3NpdmUoKSlcbiAgICAgICAgfSxcbiAgICAgICAgcmVnaXN0ZXJWYWxpZGF0aW9uQXR0cmlidXRlQ2hhbmdlSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgICAgY29uc3QgZ2V0QXR0cmlidXRlc0xpc3QgPSBtdXRhdGlvbnNMaXN0ID0+XG4gICAgICAgICAgICBtdXRhdGlvbnNMaXN0Lm1hcChtdXRhdGlvbiA9PiBtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lKVxuICAgICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zTGlzdCA9PlxuICAgICAgICAgICAgaGFuZGxlcihnZXRBdHRyaWJ1dGVzTGlzdChtdXRhdGlvbnNMaXN0KSlcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRoaXMuJHJlZnMuaW5wdXRcbiAgICAgICAgICBjb25zdCBjb25maWcgPSB7IGF0dHJpYnV0ZXM6IHRydWUgfVxuICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUodGFyZ2V0Tm9kZSwgY29uZmlnKVxuICAgICAgICAgIHJldHVybiBvYnNlcnZlclxuICAgICAgICB9LFxuICAgICAgICBkZXJlZ2lzdGVyVmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXI6IG9ic2VydmVyID0+IHtcbiAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICAgICAgfSxcbiAgICAgICAgc2hha2VMYWJlbDogc2hvdWxkU2hha2UgPT4ge1xuICAgICAgICAgIHRoaXMubGFiZWxGb3VuZGF0aW9uLnNoYWtlKHNob3VsZFNoYWtlKVxuICAgICAgICB9LFxuICAgICAgICBmbG9hdExhYmVsOiBzaG91bGRGbG9hdCA9PiB7XG4gICAgICAgICAgdGhpcy5sYWJlbEZvdW5kYXRpb24uZmxvYXQoc2hvdWxkRmxvYXQpXG4gICAgICAgIH0sXG4gICAgICAgIGhhc0xhYmVsOiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuICEhdGhpcy4kcmVmcy5sYWJlbFxuICAgICAgICB9LFxuICAgICAgICBnZXRMYWJlbFdpZHRoOiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxGb3VuZGF0aW9uLmdldFdpZHRoKClcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TmF0aXZlSW5wdXQ6ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5pbnB1dFxuICAgICAgICB9LFxuICAgICAgICBoYXNPdXRsaW5lOiAoKSA9PiAhIXRoaXMuaGFzT3V0bGluZSxcbiAgICAgICAgbm90Y2hPdXRsaW5lOiAobm90Y2hXaWR0aCwgaXNSdGwpID0+XG4gICAgICAgICAgdGhpcy5vdXRsaW5lRm91bmRhdGlvbi5ub3RjaChub3RjaFdpZHRoLCBpc1J0bCksXG4gICAgICAgIGNsb3NlT3V0bGluZTogKCkgPT4gdGhpcy5vdXRsaW5lRm91bmRhdGlvbi5jbG9zZU5vdGNoKClcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGhlbHBlclRleHQ6IHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24sXG4gICAgICAgIGljb246IHRoaXMuaWNvbkZvdW5kYXRpb25cbiAgICAgIH1cbiAgICApXG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldFZhbHVlKHRoaXMudmFsdWUpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpXG4gICAgdGhpcy4kcmVmcy5pbnB1dCAmJiAodGhpcy4kcmVmcy5pbnB1dC5yZXF1aXJlZCA9IHRoaXMucmVxdWlyZWQpXG4gICAgaWYgKHR5cGVvZiB0aGlzLnZhbGlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldFZhbGlkKHRoaXMudmFsaWQpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGV4dGJveCkge1xuICAgICAgdGhpcy5yaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzKVxuICAgICAgdGhpcy5yaXBwbGUuaW5pdCgpXG4gICAgfVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gICAgdGhpcy5saW5lUmlwcGxlRm91bmRhdGlvbiAmJiB0aGlzLmxpbmVSaXBwbGVGb3VuZGF0aW9uLmRlc3Ryb3koKVxuICAgIHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24gJiYgdGhpcy5oZWxwZXJUZXh0Rm91bmRhdGlvbi5kZXN0cm95KClcbiAgICB0aGlzLmljb25Gb3VuZGF0aW9uICYmIHRoaXMuaWNvbkZvdW5kYXRpb24uZGVzdHJveSgpXG4gICAgdGhpcy5sYWJlbEZvdW5kYXRpb24gJiYgdGhpcy5sYWJlbEZvdW5kYXRpb24uZGVzdHJveSgpXG4gICAgdGhpcy5vdXRsaW5lRm91bmRhdGlvbiAmJiB0aGlzLm91dGxpbmVGb3VuZGF0aW9uLmRlc3Ryb3koKVxuICAgIHRoaXMucmlwcGxlICYmIHRoaXMucmlwcGxlLmRlc3Ryb3koKVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ21vZGVsJywgdmFsdWUpXG4gICAgfSxcbiAgICBmb2N1cygpIHtcbiAgICAgIHRoaXMuJHJlZnMuaW5wdXQgJiYgdGhpcy4kcmVmcy5pbnB1dC5mb2N1cygpXG4gICAgfSxcbiAgICBibHVyKCkge1xuICAgICAgdGhpcy4kcmVmcy5pbnB1dCAmJiB0aGlzLiRyZWZzLmlucHV0LmJsdXIoKVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNUZXh0RmllbGQgZnJvbSAnLi9tZGMtdGV4dGZpZWxkLnZ1ZSdcblxuZXhwb3J0IHsgbWRjVGV4dEZpZWxkIH1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY1RleHRGaWVsZFxufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPGN1c3RvbS1lbGVtZW50IFxuICAgIDp0YWc9XCJ0YWdcIiBcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCJcbiAgICBjbGFzcz1cIm1kYy10aGVtZVwiPlxuICAgIDxzbG90IC8+XG4gIDwvY3VzdG9tLWVsZW1lbnQ+XG48L3RlbXBsYXRlPlxuXG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBDdXN0b21FbGVtZW50IH0gZnJvbSAnLi4vYmFzZSdcblxuY29uc3QgVEhFTUVfQ09MT1JTID0gW1xuICAncHJpbWFyeScsXG4gICdzZWNvbmRhcnknLFxuICAnYmFja2dyb3VuZCcsXG4gICdwcmltYXJ5LWxpZ2h0JyxcbiAgJ3NlY29uZGFyeS1saWdodCcsXG4gICdzZWNvbmRhcnktZGFyaycsXG4gICdwcmltYXJ5LWRhcmsnXG5dXG5cbmNvbnN0IFRIRU1FX1NUWUxFUyA9IFtcbiAgJ3RleHQtcHJpbWFyeScsXG4gICd0ZXh0LXNlY29uZGFyeScsXG4gICd0ZXh0LWhpbnQnLFxuICAndGV4dC1pY29uJyxcbiAgJ3RleHQtZGlzYWJsZWQnXG5dXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10aGVtZScsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBDdXN0b21FbGVtZW50XG4gIH0sXG4gIHByb3BzOiB7XG4gICAgdGFnOiB7IHR5cGU6IFN0cmluZywgZGVmYXVsdDogJ2RpdicgfSxcbiAgICBjb2xvcjogU3RyaW5nLFxuICAgIGJhY2tncm91bmQ6IFN0cmluZ1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMoKSB7XG4gICAgICBsZXQgY2xhc3NlcyA9IHt9XG5cbiAgICAgIGlmICh0aGlzLmNvbG9yICYmIFRIRU1FX0NPTE9SUy5pbmRleE9mKHRoaXMuY29sb3IpICE9PSAtMSkge1xuICAgICAgICBjbGFzc2VzW2BtZGMtdGhlbWUtLSR7dGhpcy5jb2xvcn1gXSA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZCAmJiBUSEVNRV9DT0xPUlMuaW5kZXhPZih0aGlzLmJhY2tncm91bmQpICE9PSAtMSkge1xuICAgICAgICBjbGFzc2VzW2BtZGMtdGhlbWUtLSR7dGhpcy5iYWNrZ3JvdW5kfS1iZ2BdID0gdHJ1ZVxuXG4gICAgICAgIGlmICh0aGlzLmNvbG9yICYmIFRIRU1FX1NUWUxFUy5pbmRleE9mKHRoaXMuY29sb3IpICE9PSAtMSkge1xuICAgICAgICAgIGNsYXNzZXNbYG1kYy10aGVtZS0tJHt0aGlzLmNvbG9yfS1vbi0ke3RoaXMuYmFja2dyb3VuZH1gXSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNsYXNzZXNcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjVGhlbWUgZnJvbSAnLi9tZGMtdGhlbWUudnVlJ1xuXG5leHBvcnQgeyBtZGNUaGVtZSB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNUaGVtZVxufSlcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xuICBGSVhFRDogJ21kYy10b29sYmFyLS1maXhlZCcsXG4gIEZJWEVEX0xBU1RST1c6ICdtZGMtdG9vbGJhci0tZml4ZWQtbGFzdHJvdy1vbmx5JyxcbiAgRklYRURfQVRfTEFTVF9ST1c6ICdtZGMtdG9vbGJhci0tZml4ZWQtYXQtbGFzdC1yb3cnLFxuICBUT09MQkFSX1JPV19GTEVYSUJMRTogJ21kYy10b29sYmFyLS1mbGV4aWJsZScsXG4gIEZMRVhJQkxFX0RFRkFVTFRfQkVIQVZJT1I6ICdtZGMtdG9vbGJhci0tZmxleGlibGUtZGVmYXVsdC1iZWhhdmlvcicsXG4gIEZMRVhJQkxFX01BWDogJ21kYy10b29sYmFyLS1mbGV4aWJsZS1zcGFjZS1tYXhpbWl6ZWQnLFxuICBGTEVYSUJMRV9NSU46ICdtZGMtdG9vbGJhci0tZmxleGlibGUtc3BhY2UtbWluaW1pemVkJyxcbn07XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBUSVRMRV9TRUxFQ1RPUjogJy5tZGMtdG9vbGJhcl9fdGl0bGUnLFxuICBJQ09OX1NFTEVDVE9SOiAnLm1kYy10b29sYmFyX19pY29uJyxcbiAgRklSU1RfUk9XX1NFTEVDVE9SOiAnLm1kYy10b29sYmFyX19yb3c6Zmlyc3QtY2hpbGQnLFxuICBDSEFOR0VfRVZFTlQ6ICdNRENUb29sYmFyOmNoYW5nZScsXG59O1xuXG5leHBvcnQgY29uc3QgbnVtYmVycyA9IHtcbiAgTUFYX1RJVExFX1NJWkU6IDIuMTI1LFxuICBNSU5fVElUTEVfU0laRTogMS4yNSxcbiAgVE9PTEJBUl9ST1dfSEVJR0hUOiA2NCxcbiAgVE9PTEJBUl9ST1dfTU9CSUxFX0hFSUdIVDogNTYsXG4gIFRPT0xCQVJfTU9CSUxFX0JSRUFLUE9JTlQ6IDYwMCxcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURDVG9vbGJhckZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIHJldHVybiBudW1iZXJzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaGFzQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4gLyogYm9vbGVhbiAqLyBmYWxzZSxcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZWdpc3RlclNjcm9sbEhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJTY3JvbGxIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBnZXRWaWV3cG9ydFdpZHRoOiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIGdldFZpZXdwb3J0U2Nyb2xsWTogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBnZXRPZmZzZXRIZWlnaHQ6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgZ2V0Rmlyc3RSb3dFbGVtZW50T2Zmc2V0SGVpZ2h0OiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIG5vdGlmeUNoYW5nZTogKC8qIGV2dERhdGE6IHtmbGV4aWJsZUV4cGFuc2lvblJhdGlvOiBudW1iZXJ9ICovKSA9PiB7fSxcbiAgICAgIHNldFN0eWxlOiAoLyogcHJvcGVydHk6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXRTdHlsZUZvclRpdGxlRWxlbWVudDogKC8qIHByb3BlcnR5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgc2V0U3R5bGVGb3JGbGV4aWJsZVJvd0VsZW1lbnQ6ICgvKiBwcm9wZXJ0eTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldFN0eWxlRm9yRml4ZWRBZGp1c3RFbGVtZW50OiAoLyogcHJvcGVydHk6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gICAgdGhpcy5yZXNpemVIYW5kbGVyXyA9ICgpID0+IHRoaXMuY2hlY2tSb3dIZWlnaHRfKCk7XG4gICAgdGhpcy5zY3JvbGxIYW5kbGVyXyA9ICgpID0+IHRoaXMudXBkYXRlVG9vbGJhclN0eWxlc18oKTtcbiAgICB0aGlzLmNoZWNrUm93SGVpZ2h0RnJhbWVfID0gMDtcbiAgICB0aGlzLnNjcm9sbEZyYW1lXyA9IDA7XG4gICAgdGhpcy5leGVjdXRlZExhc3RDaGFuZ2VfID0gZmFsc2U7XG5cbiAgICB0aGlzLmNhbGN1bGF0aW9uc18gPSB7XG4gICAgICB0b29sYmFyUm93SGVpZ2h0OiAwLFxuICAgICAgLy8gQ2FsY3VsYXRlZCBIZWlnaHQgcmF0aW8uIFdlIHVzZSByYXRpbyB0byBjYWxjdWxhdGUgY29ycmVzcG9uZGluZyBoZWlnaHRzIGluIHJlc2l6ZSBldmVudC5cbiAgICAgIHRvb2xiYXJSYXRpbzogMCwgLy8gVGhlIHJhdGlvIG9mIHRvb2xiYXIgaGVpZ2h0IHRvIHJvdyBoZWlnaHRcbiAgICAgIGZsZXhpYmxlRXhwYW5zaW9uUmF0aW86IDAsIC8vIFRoZSByYXRpbyBvZiBmbGV4aWJsZSBzcGFjZSBoZWlnaHQgdG8gcm93IGhlaWdodFxuICAgICAgbWF4VHJhbnNsYXRlWVJhdGlvOiAwLCAvLyBUaGUgcmF0aW8gb2YgbWF4IHRvb2xiYXIgbW92ZSB1cCBkaXN0YW5jZSB0byByb3cgaGVpZ2h0XG4gICAgICBzY3JvbGxUaHJlc2hvbGRSYXRpbzogMCwgLy8gVGhlIHJhdGlvIG9mIG1heCBzY3JvbGxUb3AgdGhhdCB3ZSBzaG91bGQgbGlzdGVuIHRvIHRvIHJvdyBoZWlnaHRcbiAgICAgIC8vIERlcml2ZWQgSGVpZ2h0cyBiYXNlZCBvbiB0aGUgYWJvdmUga2V5IHJhdGlvcy5cbiAgICAgIHRvb2xiYXJIZWlnaHQ6IDAsXG4gICAgICBmbGV4aWJsZUV4cGFuc2lvbkhlaWdodDogMCwgLy8gRmxleGlibGUgcm93IG1pbnVzIHRvb2xiYXIgaGVpZ2h0IChkZXJpdmVkKVxuICAgICAgbWF4VHJhbnNsYXRlWURpc3RhbmNlOiAwLCAvLyBXaGVuIHRvb2xiYXIgb25seSBmaXggbGFzdCByb3cgKGRlcml2ZWQpXG4gICAgICBzY3JvbGxUaHJlc2hvbGQ6IDAsXG4gICAgfTtcbiAgICAvLyBUb29sYmFyIGZpeGVkIGJlaGF2aW9yXG4gICAgLy8gSWYgdG9vbGJhciBpcyBmaXhlZFxuICAgIHRoaXMuZml4ZWRfID0gZmFsc2U7XG4gICAgLy8gSWYgZml4ZWQgaXMgdGFyZ2V0ZWQgb25seSBhdCB0aGUgbGFzdCByb3dcbiAgICB0aGlzLmZpeGVkTGFzdHJvd18gPSBmYWxzZTtcbiAgICAvLyBUb29sYmFyIGZsZXhpYmxlIGJlaGF2aW9yXG4gICAgLy8gSWYgdGhlIGZpcnN0IHJvdyBpcyBmbGV4aWJsZVxuICAgIHRoaXMuaGFzRmxleGlibGVSb3dfID0gZmFsc2U7XG4gICAgLy8gSWYgdXNlIHRoZSBkZWZhdWx0IGJlaGF2aW9yXG4gICAgdGhpcy51c2VGbGV4RGVmYXVsdEJlaGF2aW9yXyA9IGZhbHNlO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmZpeGVkXyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoTURDVG9vbGJhckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GSVhFRCk7XG4gICAgdGhpcy5maXhlZExhc3Ryb3dfID0gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhNRENUb29sYmFyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkZJWEVEX0xBU1RST1cpICYgdGhpcy5maXhlZF87XG4gICAgdGhpcy5oYXNGbGV4aWJsZVJvd18gPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuVE9PTEJBUl9ST1dfRkxFWElCTEUpO1xuICAgIGlmICh0aGlzLmhhc0ZsZXhpYmxlUm93Xykge1xuICAgICAgdGhpcy51c2VGbGV4RGVmYXVsdEJlaGF2aW9yXyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoTURDVG9vbGJhckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GTEVYSUJMRV9ERUZBVUxUX0JFSEFWSU9SKTtcbiAgICB9XG4gICAgdGhpcy5pbml0S2V5UmF0aW9fKCk7XG4gICAgdGhpcy5zZXRLZXlIZWlnaHRzXygpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJTY3JvbGxIYW5kbGVyKHRoaXMuc2Nyb2xsSGFuZGxlcl8pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclNjcm9sbEhhbmRsZXIodGhpcy5zY3JvbGxIYW5kbGVyXyk7XG4gIH1cblxuICB1cGRhdGVBZGp1c3RFbGVtZW50U3R5bGVzKCkge1xuICAgIGlmICh0aGlzLmZpeGVkXykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZUZvckZpeGVkQWRqdXN0RWxlbWVudCgnbWFyZ2luLXRvcCcsIGAke3RoaXMuY2FsY3VsYXRpb25zXy50b29sYmFySGVpZ2h0fXB4YCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0RmxleGlibGVFeHBhbnNpb25SYXRpb18oc2Nyb2xsVG9wKSB7XG4gICAgLy8gVG8gcHJldmVudCBkaXZpc2lvbiBieSB6ZXJvIHdoZW4gdGhlcmUgaXMgbm8gZmxleGlibGVFeHBhbnNpb25IZWlnaHRcbiAgICBjb25zdCBkZWx0YSA9IDAuMDAwMTtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgMSAtIHNjcm9sbFRvcCAvICh0aGlzLmNhbGN1bGF0aW9uc18uZmxleGlibGVFeHBhbnNpb25IZWlnaHQgKyBkZWx0YSkpO1xuICB9XG5cbiAgY2hlY2tSb3dIZWlnaHRfKCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuY2hlY2tSb3dIZWlnaHRGcmFtZV8pO1xuICAgIHRoaXMuY2hlY2tSb3dIZWlnaHRGcmFtZV8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5zZXRLZXlIZWlnaHRzXygpKTtcbiAgfVxuXG4gIHNldEtleUhlaWdodHNfKCkge1xuICAgIGNvbnN0IG5ld1Rvb2xiYXJSb3dIZWlnaHQgPSB0aGlzLmdldFJvd0hlaWdodF8oKTtcbiAgICBpZiAobmV3VG9vbGJhclJvd0hlaWdodCAhPT0gdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJSb3dIZWlnaHQpIHtcbiAgICAgIHRoaXMuY2FsY3VsYXRpb25zXy50b29sYmFyUm93SGVpZ2h0ID0gbmV3VG9vbGJhclJvd0hlaWdodDtcbiAgICAgIHRoaXMuY2FsY3VsYXRpb25zXy50b29sYmFySGVpZ2h0ID0gdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJSYXRpbyAqIHRoaXMuY2FsY3VsYXRpb25zXy50b29sYmFyUm93SGVpZ2h0O1xuICAgICAgdGhpcy5jYWxjdWxhdGlvbnNfLmZsZXhpYmxlRXhwYW5zaW9uSGVpZ2h0ID1cbiAgICAgICAgdGhpcy5jYWxjdWxhdGlvbnNfLmZsZXhpYmxlRXhwYW5zaW9uUmF0aW8gKiB0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhclJvd0hlaWdodDtcbiAgICAgIHRoaXMuY2FsY3VsYXRpb25zXy5tYXhUcmFuc2xhdGVZRGlzdGFuY2UgPVxuICAgICAgICB0aGlzLmNhbGN1bGF0aW9uc18ubWF4VHJhbnNsYXRlWVJhdGlvICogdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJSb3dIZWlnaHQ7XG4gICAgICB0aGlzLmNhbGN1bGF0aW9uc18uc2Nyb2xsVGhyZXNob2xkID1cbiAgICAgICAgdGhpcy5jYWxjdWxhdGlvbnNfLnNjcm9sbFRocmVzaG9sZFJhdGlvICogdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJSb3dIZWlnaHQ7XG4gICAgICB0aGlzLnVwZGF0ZUFkanVzdEVsZW1lbnRTdHlsZXMoKTtcbiAgICAgIHRoaXMudXBkYXRlVG9vbGJhclN0eWxlc18oKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVUb29sYmFyU3R5bGVzXygpIHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnNjcm9sbEZyYW1lXyk7XG4gICAgdGhpcy5zY3JvbGxGcmFtZV8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gdGhpcy5hZGFwdGVyXy5nZXRWaWV3cG9ydFNjcm9sbFkoKTtcbiAgICAgIGNvbnN0IGhhc1Njcm9sbGVkT3V0T2ZUaHJlc2hvbGQgPSB0aGlzLnNjcm9sbGVkT3V0T2ZUaHJlc2hvbGRfKHNjcm9sbFRvcCk7XG5cbiAgICAgIGlmIChoYXNTY3JvbGxlZE91dE9mVGhyZXNob2xkICYmIHRoaXMuZXhlY3V0ZWRMYXN0Q2hhbmdlXykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZsZXhpYmxlRXhwYW5zaW9uUmF0aW8gPSB0aGlzLmdldEZsZXhpYmxlRXhwYW5zaW9uUmF0aW9fKHNjcm9sbFRvcCk7XG5cbiAgICAgIHRoaXMudXBkYXRlVG9vbGJhckZsZXhpYmxlU3RhdGVfKGZsZXhpYmxlRXhwYW5zaW9uUmF0aW8pO1xuICAgICAgaWYgKHRoaXMuZml4ZWRMYXN0cm93Xykge1xuICAgICAgICB0aGlzLnVwZGF0ZVRvb2xiYXJGaXhlZFN0YXRlXyhzY3JvbGxUb3ApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGFzRmxleGlibGVSb3dfKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRmxleGlibGVSb3dFbGVtZW50U3R5bGVzXyhmbGV4aWJsZUV4cGFuc2lvblJhdGlvKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhlY3V0ZWRMYXN0Q2hhbmdlXyA9IGhhc1Njcm9sbGVkT3V0T2ZUaHJlc2hvbGQ7XG4gICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUNoYW5nZSh7ZmxleGlibGVFeHBhbnNpb25SYXRpbzogZmxleGlibGVFeHBhbnNpb25SYXRpb30pO1xuICAgIH0pO1xuICB9XG5cbiAgc2Nyb2xsZWRPdXRPZlRocmVzaG9sZF8oc2Nyb2xsVG9wKSB7XG4gICAgcmV0dXJuIHNjcm9sbFRvcCA+IHRoaXMuY2FsY3VsYXRpb25zXy5zY3JvbGxUaHJlc2hvbGQ7XG4gIH1cblxuICBpbml0S2V5UmF0aW9fKCkge1xuICAgIGNvbnN0IHRvb2xiYXJSb3dIZWlnaHQgPSB0aGlzLmdldFJvd0hlaWdodF8oKTtcbiAgICBjb25zdCBmaXJzdFJvd01heFJhdGlvID0gdGhpcy5hZGFwdGVyXy5nZXRGaXJzdFJvd0VsZW1lbnRPZmZzZXRIZWlnaHQoKSAvIHRvb2xiYXJSb3dIZWlnaHQ7XG4gICAgdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJSYXRpbyA9IHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0SGVpZ2h0KCkgLyB0b29sYmFyUm93SGVpZ2h0O1xuICAgIHRoaXMuY2FsY3VsYXRpb25zXy5mbGV4aWJsZUV4cGFuc2lvblJhdGlvID0gZmlyc3RSb3dNYXhSYXRpbyAtIDE7XG4gICAgdGhpcy5jYWxjdWxhdGlvbnNfLm1heFRyYW5zbGF0ZVlSYXRpbyA9XG4gICAgICB0aGlzLmZpeGVkTGFzdHJvd18gPyB0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhclJhdGlvIC0gZmlyc3RSb3dNYXhSYXRpbyA6IDA7XG4gICAgdGhpcy5jYWxjdWxhdGlvbnNfLnNjcm9sbFRocmVzaG9sZFJhdGlvID1cbiAgICAgICh0aGlzLmZpeGVkTGFzdHJvd18gPyB0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhclJhdGlvIDogZmlyc3RSb3dNYXhSYXRpbykgLSAxO1xuICB9XG5cbiAgZ2V0Um93SGVpZ2h0XygpIHtcbiAgICBjb25zdCBicmVha3BvaW50ID0gTURDVG9vbGJhckZvdW5kYXRpb24ubnVtYmVycy5UT09MQkFSX01PQklMRV9CUkVBS1BPSU5UO1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmdldFZpZXdwb3J0V2lkdGgoKSA8IGJyZWFrcG9pbnQgP1xuICAgICAgTURDVG9vbGJhckZvdW5kYXRpb24ubnVtYmVycy5UT09MQkFSX1JPV19NT0JJTEVfSEVJR0hUIDogTURDVG9vbGJhckZvdW5kYXRpb24ubnVtYmVycy5UT09MQkFSX1JPV19IRUlHSFQ7XG4gIH1cblxuICB1cGRhdGVUb29sYmFyRmxleGlibGVTdGF0ZV8oZmxleGlibGVFeHBhbnNpb25SYXRpbykge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDVG9vbGJhckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GTEVYSUJMRV9NQVgpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDVG9vbGJhckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GTEVYSUJMRV9NSU4pO1xuICAgIGlmIChmbGV4aWJsZUV4cGFuc2lvblJhdGlvID09PSAxKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuRkxFWElCTEVfTUFYKTtcbiAgICB9IGVsc2UgaWYgKGZsZXhpYmxlRXhwYW5zaW9uUmF0aW8gPT09IDApIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDVG9vbGJhckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GTEVYSUJMRV9NSU4pO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZVRvb2xiYXJGaXhlZFN0YXRlXyhzY3JvbGxUb3ApIHtcbiAgICBjb25zdCB0cmFuc2xhdGVEaXN0YW5jZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKFxuICAgICAgc2Nyb2xsVG9wIC0gdGhpcy5jYWxjdWxhdGlvbnNfLmZsZXhpYmxlRXhwYW5zaW9uSGVpZ2h0LFxuICAgICAgdGhpcy5jYWxjdWxhdGlvbnNfLm1heFRyYW5zbGF0ZVlEaXN0YW5jZSkpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGUoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGVZKCR7LXRyYW5zbGF0ZURpc3RhbmNlfXB4KWApO1xuXG4gICAgaWYgKHRyYW5zbGF0ZURpc3RhbmNlID09PSB0aGlzLmNhbGN1bGF0aW9uc18ubWF4VHJhbnNsYXRlWURpc3RhbmNlKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuRklYRURfQVRfTEFTVF9ST1cpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuRklYRURfQVRfTEFTVF9ST1cpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUZsZXhpYmxlUm93RWxlbWVudFN0eWxlc18oZmxleGlibGVFeHBhbnNpb25SYXRpbykge1xuICAgIGlmICh0aGlzLmZpeGVkXykge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5jYWxjdWxhdGlvbnNfLmZsZXhpYmxlRXhwYW5zaW9uSGVpZ2h0ICogZmxleGlibGVFeHBhbnNpb25SYXRpbztcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGVGb3JGbGV4aWJsZVJvd0VsZW1lbnQoJ2hlaWdodCcsXG4gICAgICAgIGAke2hlaWdodCArIHRoaXMuY2FsY3VsYXRpb25zXy50b29sYmFyUm93SGVpZ2h0fXB4YCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnVzZUZsZXhEZWZhdWx0QmVoYXZpb3JfKSB7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRTdHlsZXNEZWZhdWx0QmVoYXZpb3JfKGZsZXhpYmxlRXhwYW5zaW9uUmF0aW8pO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRTdHlsZXNEZWZhdWx0QmVoYXZpb3JfKGZsZXhpYmxlRXhwYW5zaW9uUmF0aW8pIHtcbiAgICBjb25zdCBtYXhUaXRsZVNpemUgPSBNRENUb29sYmFyRm91bmRhdGlvbi5udW1iZXJzLk1BWF9USVRMRV9TSVpFO1xuICAgIGNvbnN0IG1pblRpdGxlU2l6ZSA9IE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLm51bWJlcnMuTUlOX1RJVExFX1NJWkU7XG4gICAgY29uc3QgY3VycmVudFRpdGxlU2l6ZSA9IChtYXhUaXRsZVNpemUgLSBtaW5UaXRsZVNpemUpICogZmxleGlibGVFeHBhbnNpb25SYXRpbyArIG1pblRpdGxlU2l6ZTtcblxuICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGVGb3JUaXRsZUVsZW1lbnQoJ2ZvbnQtc2l6ZScsIGAke2N1cnJlbnRUaXRsZVNpemV9cmVtYCk7XG4gIH1cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPGhlYWRlciBjbGFzcz1cIm1kYy10b29sYmFyLXdyYXBwZXJcIj5cbiAgICA8IS0tVG9vbGJhci0tPlxuICAgIDxkaXYgXG4gICAgICByZWY9XCJyb290XCIgXG4gICAgICA6Y2xhc3M9XCJyb290Q2xhc3Nlc1wiIFxuICAgICAgOnN0eWxlPVwicm9vdFN0eWxlc1wiPlxuICAgICAgPHNsb3QvPlxuICAgIDwvZGl2PlxuICAgIDwhLS0gRml4ZWQgQWRqdXN0IEVsZW1lbnQtLT5cbiAgICA8ZGl2IFxuICAgICAgdi1pZj1cImZpeGVkIHx8IHdhdGVyZmFsbCB8fCBmaXhlZExhc3Ryb3dcIiBcbiAgICAgIHJlZj1cImZpeGVkLWFkanVzdFwiIFxuICAgICAgOnN0eWxlPVwiYWRqdXN0U3R5bGVzXCJcbiAgICAgIGNsYXNzPVwibWRjLXRvb2xiYXItZml4ZWQtYWRqdXN0XCIvPlxuICA8L2hlYWRlcj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDVG9vbGJhckZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3Rvb2xiYXIvZm91bmRhdGlvbidcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXRvb2xiYXInLFxuICBwcm9wczoge1xuICAgIGZpeGVkOiBCb29sZWFuLFxuICAgIHdhdGVyZmFsbDogQm9vbGVhbixcbiAgICAnZml4ZWQtbGFzdHJvdyc6IEJvb2xlYW4sXG4gICAgZmxleGlibGU6IEJvb2xlYW4sXG4gICAgJ2ZsZXhpYmxlLWRlZmF1bHQnOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IHRydWUgfVxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICByb290Q2xhc3Nlczoge1xuICAgICAgICAnbWRjLXRvb2xiYXInOiB0cnVlLFxuICAgICAgICAnbWRjLXRvb2xiYXItLWZpeGVkJzogdGhpcy5maXhlZCB8fCB0aGlzLndhdGVyZmFsbCB8fCB0aGlzLmZpeGVkTGFzdHJvdyxcbiAgICAgICAgJ21kYy10b29sYmFyLS13YXRlcmZhbGwnOiB0aGlzLndhdGVyZmFsbCxcbiAgICAgICAgJ21kYy10b29sYmFyLS1maXhlZC1sYXN0cm93LW9ubHknOiB0aGlzLmZpeGVkTGFzdHJvdyxcbiAgICAgICAgJ21kYy10b29sYmFyLS1mbGV4aWJsZSc6IHRoaXMuZmxleGlibGUsXG4gICAgICAgICdtZGMtdG9vbGJhci0tZmxleGlibGUtZGVmYXVsdC1iZWhhdmlvcic6XG4gICAgICAgICAgdGhpcy5mbGV4aWJsZSAmJiB0aGlzLmZsZXhpYmxlRGVmYXVsdFxuICAgICAgfSxcbiAgICAgIHJvb3RTdHlsZXM6IHt9LFxuICAgICAgYWRqdXN0U3R5bGVzOiB7XG4gICAgICAgIC8vIHRvIGF2b2lkIHRvcCBtYXJnaW4gY29sbGFwc2Ugd2l0aCA6YWZ0ZXIgZWxcbiAgICAgICAgLy8gMC4xIHB4IHNob3VsZCBiZSByb3VuZGVkIHRvIDBweFxuICAgICAgICAvLyBUT0RPOiBmaW5kIGEgYmV0dGVyIHRyaWNrXG4gICAgICAgIC8vIGhlaWdodDogJzAuMXB4J1xuICAgICAgfSxcbiAgICAgIGZvdW5kYXRpb246IG51bGxcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ1Rvb2xiYXJGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5yb290Q2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgfSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5yb290Q2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5yb290LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJTY3JvbGxIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlclNjcm9sbEhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGdldFZpZXdwb3J0V2lkdGg6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lcldpZHRoXG4gICAgICB9LFxuICAgICAgZ2V0Vmlld3BvcnRTY3JvbGxZOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB3aW5kb3cucGFnZVlPZmZzZXRcbiAgICAgIH0sXG4gICAgICBnZXRPZmZzZXRIZWlnaHQ6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMucm9vdC5vZmZzZXRIZWlnaHRcbiAgICAgIH0sXG4gICAgICBnZXRGaXJzdFJvd0VsZW1lbnRPZmZzZXRIZWlnaHQ6ICgpID0+IHtcbiAgICAgICAgbGV0IGVsID0gdGhpcy4kcmVmcy5yb290LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgTURDVG9vbGJhckZvdW5kYXRpb24uc3RyaW5ncy5GSVJTVF9ST1dfU0VMRUNUT1JcbiAgICAgICAgKVxuICAgICAgICByZXR1cm4gZWwgPyBlbC5vZmZzZXRIZWlnaHQgOiB1bmRlZmluZWRcbiAgICAgIH0sXG4gICAgICBub3RpZnlDaGFuZ2U6IGV2dERhdGEgPT4ge1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBldnREYXRhKVxuICAgICAgfSxcbiAgICAgIHNldFN0eWxlOiAocHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnJvb3RTdHlsZXMsIHByb3BlcnR5LCB2YWx1ZSlcbiAgICAgIH0sXG4gICAgICBzZXRTdHlsZUZvclRpdGxlRWxlbWVudDogKHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBsZXQgZWwgPSB0aGlzLiRyZWZzLnJvb3QucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICBNRENUb29sYmFyRm91bmRhdGlvbi5zdHJpbmdzLlRJVExFX1NFTEVDVE9SXG4gICAgICAgIClcbiAgICAgICAgaWYgKGVsKSBlbC5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpXG4gICAgICB9LFxuICAgICAgc2V0U3R5bGVGb3JGbGV4aWJsZVJvd0VsZW1lbnQ6IChwcm9wZXJ0eSwgdmFsdWUpID0+IHtcbiAgICAgICAgbGV0IGVsID0gdGhpcy4kcmVmcy5yb290LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgTURDVG9vbGJhckZvdW5kYXRpb24uc3RyaW5ncy5GSVJTVF9ST1dfU0VMRUNUT1JcbiAgICAgICAgKVxuICAgICAgICBpZiAoZWwpIGVsLnN0eWxlLnNldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSlcbiAgICAgIH0sXG4gICAgICBzZXRTdHlsZUZvckZpeGVkQWRqdXN0RWxlbWVudDogKHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5hZGp1c3RTdHlsZXMsIHByb3BlcnR5LCB2YWx1ZSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwibWRjLXRvb2xiYXItcm93IG1kYy10b29sYmFyX19yb3dcIj5cbiAgICA8c2xvdC8+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10b29sYmFyLXJvdydcbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8c2VjdGlvbiBcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgXG4gICAgY2xhc3M9XCJtZGMtdG9vbGJhci1zZWN0aW9uIG1kYy10b29sYmFyX19zZWN0aW9uXCI+XG4gICAgPHNsb3QvPlxuICA8L3NlY3Rpb24+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXRvb2xiYXItc2VjdGlvbicsXG4gIHByb3BzOiB7XG4gICAgJ2FsaWduLXN0YXJ0JzogQm9vbGVhbixcbiAgICAnYWxpZ24tZW5kJzogQm9vbGVhbixcbiAgICAnc2hyaW5rLXRvLWZpdCc6IEJvb2xlYW5cbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge1xuICAgICAgICAnbWRjLXRvb2xiYXJfX3NlY3Rpb24tLWFsaWduLXN0YXJ0JzogdGhpcy5hbGlnblN0YXJ0LFxuICAgICAgICAnbWRjLXRvb2xiYXJfX3NlY3Rpb24tLWFsaWduLWVuZCc6IHRoaXMuYWxpZ25FbmQsXG4gICAgICAgICdtZGMtdG9vbGJhcl9fc2VjdGlvbi0tc2hyaW5rLXRvLWZpdCc6IHRoaXMuc2hyaW5rVG9GaXRcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8YSBcbiAgICA6Y2xhc3M9XCJ7J21hdGVyaWFsLWljb25zJzohIWljb259XCJcbiAgICBjbGFzcz1cIm1kYy10b29sYmFyLW1lbnUtaWNvbiBtZGMtdG9vbGJhcl9fbWVudS1pY29uXCJcbiAgICB2LW9uPVwibGlzdGVuZXJzXCI+XG4gICAgPHNsb3Q+e3sgaWNvbiB9fTwvc2xvdD5cbiAgPC9hPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7IERpc3BhdGNoRXZlbnRNaXhpbiB9IGZyb20gJy4uL2Jhc2UnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10b29sYmFyLW1lbnUtaWNvbicsXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbl0sXG4gIHByb3BzOiB7XG4gICAgaWNvbjogeyB0eXBlOiBTdHJpbmcsIGRlZmF1bHQ6ICdtZW51JyB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8YSBcbiAgICBjbGFzcz1cIm1kYy10b29sYmFyLXRpdGxlIG1kYy10b29sYmFyX190aXRsZVwiIFxuICAgIHYtb249XCJsaXN0ZW5lcnNcIj5cbiAgICA8c2xvdC8+XG4gIDwvYT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBEaXNwYXRjaEV2ZW50TWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtdG9vbGJhci10aXRsZScsXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbl1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8YSBcbiAgICA6Y2xhc3M9XCJ7J21hdGVyaWFsLWljb25zJzohIWljb259XCIgXG4gICAgY2xhc3M9XCJtZGMtdG9vbGJhci1pY29uIG1kYy10b29sYmFyX19pY29uXCJcbiAgICB2LW9uPVwibGlzdGVuZXJzXCI+XG4gICAgPHNsb3Q+e3sgaWNvbiB9fTwvc2xvdD5cbiAgPC9hPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7IERpc3BhdGNoRXZlbnRNaXhpbiB9IGZyb20gJy4uL2Jhc2UnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10b29sYmFyLWljb24nLFxuICBtaXhpbnM6IFtEaXNwYXRjaEV2ZW50TWl4aW5dLFxuICBwcm9wczoge1xuICAgIGljb246IFN0cmluZ1xuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY1Rvb2xiYXIgZnJvbSAnLi9tZGMtdG9vbGJhci52dWUnXG5pbXBvcnQgbWRjVG9vbGJhclJvdyBmcm9tICcuL21kYy10b29sYmFyLXJvdy52dWUnXG5pbXBvcnQgbWRjVG9vbGJhclNlY3Rpb24gZnJvbSAnLi9tZGMtdG9vbGJhci1zZWN0aW9uLnZ1ZSdcbmltcG9ydCBtZGNUb29sYmFyTWVudUljb24gZnJvbSAnLi9tZGMtdG9vbGJhci1tZW51LWljb24udnVlJ1xuaW1wb3J0IG1kY1Rvb2xiYXJUaXRsZSBmcm9tICcuL21kYy10b29sYmFyLXRpdGxlLnZ1ZSdcbmltcG9ydCBtZGNUb29sYmFySWNvbiBmcm9tICcuL21kYy10b29sYmFyLWljb24udnVlJ1xuXG5leHBvcnQge1xuICBtZGNUb29sYmFyLFxuICBtZGNUb29sYmFyUm93LFxuICBtZGNUb29sYmFyU2VjdGlvbixcbiAgbWRjVG9vbGJhck1lbnVJY29uLFxuICBtZGNUb29sYmFyVGl0bGUsXG4gIG1kY1Rvb2xiYXJJY29uXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNUb29sYmFyLFxuICBtZGNUb29sYmFyUm93LFxuICBtZGNUb29sYmFyU2VjdGlvbixcbiAgbWRjVG9vbGJhck1lbnVJY29uLFxuICBtZGNUb29sYmFyVGl0bGUsXG4gIG1kY1Rvb2xiYXJJY29uXG59KVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgRklYRURfQ0xBU1M6ICdtZGMtdG9wLWFwcC1iYXItLWZpeGVkJyxcbiAgRklYRURfU0NST0xMRURfQ0xBU1M6ICdtZGMtdG9wLWFwcC1iYXItLWZpeGVkLXNjcm9sbGVkJyxcbiAgU0hPUlRfQ0xBU1M6ICdtZGMtdG9wLWFwcC1iYXItLXNob3J0JyxcbiAgU0hPUlRfSEFTX0FDVElPTl9JVEVNX0NMQVNTOiAnbWRjLXRvcC1hcHAtYmFyLS1zaG9ydC1oYXMtYWN0aW9uLWl0ZW0nLFxuICBTSE9SVF9DT0xMQVBTRURfQ0xBU1M6ICdtZGMtdG9wLWFwcC1iYXItLXNob3J0LWNvbGxhcHNlZCcsXG59O1xuXG4vKiogQGVudW0ge251bWJlcn0gKi9cbmNvbnN0IG51bWJlcnMgPSB7XG4gIERFQk9VTkNFX1RIUk9UVExFX1JFU0laRV9USU1FX01TOiAxMDAsXG4gIE1BWF9UT1BfQVBQX0JBUl9IRUlHSFQ6IDEyOCxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgQUNUSU9OX0lURU1fU0VMRUNUT1I6ICcubWRjLXRvcC1hcHAtYmFyX19hY3Rpb24taXRlbScsXG4gIE5BVklHQVRJT05fRVZFTlQ6ICdNRENUb3BBcHBCYXI6bmF2JyxcbiAgTkFWSUdBVElPTl9JQ09OX1NFTEVDVE9SOiAnLm1kYy10b3AtYXBwLWJhcl9fbmF2aWdhdGlvbi1pY29uJyxcbiAgUk9PVF9TRUxFQ1RPUjogJy5tZGMtdG9wLWFwcC1iYXInLFxuICBUSVRMRV9TRUxFQ1RPUjogJy5tZGMtdG9wLWFwcC1iYXJfX3RpdGxlJyxcbn07XG5cbmV4cG9ydCB7c3RyaW5ncywgY3NzQ2xhc3NlcywgbnVtYmVyc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFRvcCBBcHAgQmFyXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgVG9wIEFwcCBCYXIgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1RvcEFwcEJhckFkYXB0ZXIge1xuICAvKipcbiAgICogQWRkcyBhIGNsYXNzIHRvIHRoZSByb290IEVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNsYXNzIGZyb20gdGhlIHJvb3QgRWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJvb3QgRWxlbWVudCBjb250YWlucyB0aGUgZ2l2ZW4gY2xhc3MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogU2V0cyB0aGUgc3BlY2lmaWVkIGlubGluZSBzdHlsZSBwcm9wZXJ0eSBvbiB0aGUgcm9vdCBFbGVtZW50IHRvIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0U3R5bGUocHJvcGVydHksIHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBoZWlnaHQgb2YgdGhlIHRvcCBhcHAgYmFyLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRUb3BBcHBCYXJIZWlnaHQoKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgbmF2aWdhdGlvbiBpY29uIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3Rlck5hdmlnYXRpb25JY29uSW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgb24gdGhlIG5hdmlnYXRpb24gaWNvbiBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3Rlck5hdmlnYXRpb25JY29uSW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIG5hdmlnYXRpb24gaWNvbiBpcyBjbGlja2VkLlxuICAgKi9cbiAgbm90aWZ5TmF2aWdhdGlvbkljb25DbGlja2VkKCkge31cblxuICAvKiogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpfSBoYW5kbGVyICovXG4gIHJlZ2lzdGVyU2Nyb2xsSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCl9IGhhbmRsZXIgKi9cbiAgZGVyZWdpc3RlclNjcm9sbEhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKiogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpfSBoYW5kbGVyICovXG4gIHJlZ2lzdGVyUmVzaXplSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCl9IGhhbmRsZXIgKi9cbiAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKiogQHJldHVybiB7bnVtYmVyfSAqL1xuICBnZXRWaWV3cG9ydFNjcm9sbFkoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXG4gIGdldFRvdGFsQWN0aW9uSXRlbXMoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUb3BBcHBCYXJBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7c3RyaW5ncywgY3NzQ2xhc3NlcywgbnVtYmVyc30gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IE1EQ1RvcEFwcEJhckFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENUb3BBcHBCYXJBZGFwdGVyPn1cbiAqL1xuY2xhc3MgTURDVG9wQXBwQmFyQmFzZUZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge251bWJlcn0gKi9cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIHJldHVybiBudW1iZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIE1EQ1RvcEFwcEJhckFkYXB0ZXJ9IGZvciB0eXBpbmcgaW5mb3JtYXRpb24gb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAqIHR5cGVzLlxuICAgKiBAcmV0dXJuIHshTURDVG9wQXBwQmFyQWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RvcEFwcEJhckFkYXB0ZXJ9ICovICh7XG4gICAgICBoYXNDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXRTdHlsZTogKC8qIHByb3BlcnR5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZ2V0VG9wQXBwQmFySGVpZ2h0OiAoKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyTmF2aWdhdGlvbkljb25JbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3Rlck5hdmlnYXRpb25JY29uSW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIG5vdGlmeU5hdmlnYXRpb25JY29uQ2xpY2tlZDogKCkgPT4ge30sXG4gICAgICByZWdpc3RlclNjcm9sbEhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJTY3JvbGxIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBnZXRWaWV3cG9ydFNjcm9sbFk6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgZ2V0VG90YWxBY3Rpb25JdGVtczogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDVG9wQXBwQmFyQWRhcHRlcn0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoLyoqIEB0eXBlIHshTURDVG9wQXBwQmFyQWRhcHRlcn0gKi8gYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDVG9wQXBwQmFyQmFzZUZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIHRoaXMubmF2Q2xpY2tIYW5kbGVyXyA9ICgpID0+IHRoaXMuYWRhcHRlcl8ubm90aWZ5TmF2aWdhdGlvbkljb25DbGlja2VkKCk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJOYXZpZ2F0aW9uSWNvbkludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLm5hdkNsaWNrSGFuZGxlcl8pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJOYXZpZ2F0aW9uSWNvbkludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLm5hdkNsaWNrSGFuZGxlcl8pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1RvcEFwcEJhckJhc2VGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENUb3BBcHBCYXJBZGFwdGVyIGZyb20gJy4uL2FkYXB0ZXInO1xuaW1wb3J0IE1EQ1RvcEFwcEJhckJhc2VGb3VuZGF0aW9uIGZyb20gJy4uL2ZvdW5kYXRpb24nO1xuaW1wb3J0IHtjc3NDbGFzc2VzfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENUb3BBcHBCYXJCYXNlRm91bmRhdGlvbjwhTURDU2hvcnRUb3BBcHBCYXJGb3VuZGF0aW9uPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENTaG9ydFRvcEFwcEJhckZvdW5kYXRpb24gZXh0ZW5kcyBNRENUb3BBcHBCYXJCYXNlRm91bmRhdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENUb3BBcHBCYXJBZGFwdGVyfSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoYWRhcHRlcik7XG4gICAgLy8gU3RhdGUgdmFyaWFibGUgZm9yIHRoZSBjdXJyZW50IHRvcCBhcHAgYmFyIHN0YXRlXG4gICAgdGhpcy5pc0NvbGxhcHNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5zY3JvbGxIYW5kbGVyXyA9ICgpID0+IHRoaXMuc2hvcnRBcHBCYXJTY3JvbGxIYW5kbGVyXygpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBzdXBlci5pbml0KCk7XG4gICAgY29uc3QgaXNBbHdheXNDb2xsYXBzZWQgPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuU0hPUlRfQ09MTEFQU0VEX0NMQVNTKTtcblxuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmdldFRvdGFsQWN0aW9uSXRlbXMoKSA+IDApIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5TSE9SVF9IQVNfQUNUSU9OX0lURU1fQ0xBU1MpO1xuICAgIH1cblxuICAgIGlmICghaXNBbHdheXNDb2xsYXBzZWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJTY3JvbGxIYW5kbGVyKHRoaXMuc2Nyb2xsSGFuZGxlcl8pO1xuICAgICAgdGhpcy5zaG9ydEFwcEJhclNjcm9sbEhhbmRsZXJfKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyU2Nyb2xsSGFuZGxlcih0aGlzLnNjcm9sbEhhbmRsZXJfKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFNjcm9sbCBoYW5kbGVyIGZvciBhcHBseWluZy9yZW1vdmluZyB0aGUgY29sbGFwc2VkIG1vZGlmaWVyIGNsYXNzXG4gICAqIG9uIHRoZSBzaG9ydCB0b3AgYXBwIGJhci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNob3J0QXBwQmFyU2Nyb2xsSGFuZGxlcl8oKSB7XG4gICAgY29uc3QgY3VycmVudFNjcm9sbCA9IHRoaXMuYWRhcHRlcl8uZ2V0Vmlld3BvcnRTY3JvbGxZKCk7XG5cbiAgICBpZiAoY3VycmVudFNjcm9sbCA8PSAwKSB7XG4gICAgICBpZiAodGhpcy5pc0NvbGxhcHNlZCkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuU0hPUlRfQ09MTEFQU0VEX0NMQVNTKTtcbiAgICAgICAgdGhpcy5pc0NvbGxhcHNlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuaXNDb2xsYXBzZWQpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLlNIT1JUX0NPTExBUFNFRF9DTEFTUyk7XG4gICAgICAgIHRoaXMuaXNDb2xsYXBzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENTaG9ydFRvcEFwcEJhckZvdW5kYXRpb247XG4iLCI8dGVtcGxhdGU+XG4gIDxoZWFkZXJcbiAgICByZWY9XCJyb290XCJcbiAgICA6Y2xhc3M9XCJyb290Q2xhc3Nlc1wiXG4gICAgOnN0eWxlPVwicm9vdFN0eWxlc1wiXG4gICAgdi1vbj1cIiRsaXN0ZW5lcnNcIj5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLXRvcC1hcHAtYmFyX19yb3dcIj5cbiAgICAgIDxzZWN0aW9uIGNsYXNzPVwibWRjLXRvcC1hcHAtYmFyX19zZWN0aW9uIG1kYy10b3AtYXBwLWJhcl9fc2VjdGlvbi0tYWxpZ24tc3RhcnRcIj5cbiAgICAgICAgPGFcbiAgICAgICAgICB2LWlmPVwiaGF2ZU5hdmlnYXRpb25JY29uXCJcbiAgICAgICAgICByZWY9XCJuYXZpZ2F0aW9uSWNvblwiXG4gICAgICAgICAgOmNsYXNzPVwibmF2aWNvbkNsYXNzZXNcIlxuICAgICAgICAgIGhyZWY9XCIjXCJcbiAgICAgICAgICB2LW9uPVwibGlzdGVuZXJzXCI+e3sgaWNvbiB9fTwvYT5cbiAgICAgICAgPHNwYW5cbiAgICAgICAgICB2LWlmPVwiISF0aXRsZVwiXG4gICAgICAgICAgY2xhc3M9XCJtZGMtdG9wLWFwcC1iYXJfX3RpdGxlXCI+e3sgdGl0bGUgfX08L3NwYW4+XG4gICAgICA8L3NlY3Rpb24+XG4gICAgICA8c2VjdGlvblxuICAgICAgICB2LWlmPVwiJHNsb3RzLmRlZmF1bHRcIlxuICAgICAgICBjbGFzcz1cIm1kYy10b3AtYXBwLWJhcl9fc2VjdGlvbiBtZGMtdG9wLWFwcC1iYXJfX3NlY3Rpb24tLWFsaWduLWVuZFwiPlxuICAgICAgICA8c2xvdC8+XG4gICAgICA8L3NlY3Rpb24+XG4gICAgPC9kaXY+XG4gICAgPHNsb3QgbmFtZT1cInRhYnNcIi8+XG4gIDwvaGVhZGVyPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENUb3BBcHBCYXJGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC90b3AtYXBwLWJhci9mb3VuZGF0aW9uJ1xuaW1wb3J0IE1EQ1Nob3J0VG9wQXBwQmFyRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvdG9wLWFwcC1iYXIvc2hvcnQvZm91bmRhdGlvbidcbmltcG9ydCB7IERpc3BhdGNoRXZlbnRNaXhpbiB9IGZyb20gJy4uL2Jhc2UnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10b3AtYXBwLWJhcicsXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbl0sXG4gIHByb3BzOiB7XG4gICAgc2hvcnQ6IEJvb2xlYW4sXG4gICAgc2hvcnRDb2xsYXBzZWQ6IEJvb2xlYW4sXG4gICAgcHJvbWluZW50OiBCb29sZWFuLFxuICAgIGZpeGVkOiBCb29sZWFuLFxuICAgIHRpdGxlOiBTdHJpbmcsXG4gICAgaWNvbjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ21lbnUnXG4gICAgfSxcbiAgICBpY29uQ2xhc3NlczogT2JqZWN0LFxuICAgIGRlbnNlOiBCb29sZWFuXG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3RTdHlsZXM6IHt9LFxuICAgICAgcm9vdENsYXNzZXM6IHtcbiAgICAgICAgJ21kYy10b3AtYXBwLWJhcic6IHRydWUsXG4gICAgICAgICdtZGMtdG9wLWFwcC1iYXItLWRlbnNlJzogdGhpcy5kZW5zZSxcbiAgICAgICAgJ21kYy10b3AtYXBwLWJhci0tc2hvcnQnOiB0aGlzLnNob3J0LFxuICAgICAgICAnbWRjLXRvcC1hcHAtYmFyLS1zaG9ydC1jb2xsYXBzZWQnOiB0aGlzLnNob3J0Q29sbGFwc2VkLFxuICAgICAgICAnbWRjLXRvcC1hcHAtYmFyLS1wcm9taW5lbnQnOiB0aGlzLnByb21pbmVudCxcbiAgICAgICAgJ21kYy10b3AtYXBwLWJhci0tZml4ZWQnOiB0aGlzLmZpeGVkXG4gICAgICB9LFxuICAgICAgZm91bmRhdGlvbjogbnVsbFxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBoYXZlTmF2aWdhdGlvbkljb24oKSB7XG4gICAgICByZXR1cm4gISF0aGlzLmljb24gfHwgdGhpcy5pY29uQ2xhc3Nlc1xuICAgIH0sXG4gICAgbmF2aWNvbkNsYXNzZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWRjLXRvcC1hcHAtYmFyX19uYXZpZ2F0aW9uLWljb24nOiB0cnVlLFxuICAgICAgICAnbWF0ZXJpYWwtaWNvbnMnOiAhIXRoaXMuaWNvbixcbiAgICAgICAgLi4udGhpcy5pY29uQ2xhc3Nlc1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICBjb25zdCBhZGFwdGVyID0ge1xuICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnJvb3RDbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICB9LFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLnJvb3RDbGFzc2VzLCBjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgaGFzQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiRyZWZzLnJvb3QuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSlcbiAgICAgIH0sXG4gICAgICBzZXRTdHlsZTogKHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5yb290U3R5bGVzLCBwcm9wZXJ0eSwgdmFsdWUpXG4gICAgICB9LFxuICAgICAgZ2V0VG9wQXBwQmFySGVpZ2h0OiAoKSA9PiB0aGlzLiRlbC5jbGllbnRIZWlnaHQsXG4gICAgICByZWdpc3Rlck5hdmlnYXRpb25JY29uSW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICBpZiAodGhpcy4kcmVmcy5uYXZpZ2F0aW9uSWNvbikge1xuICAgICAgICAgIHRoaXMuJHJlZnMubmF2aWdhdGlvbkljb24uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVyZWdpc3Rlck5hdmlnYXRpb25JY29uSW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICBpZiAodGhpcy4kcmVmcy5uYXZpZ2F0aW9uSWNvbikge1xuICAgICAgICAgIHRoaXMuJHJlZnMubmF2aWdhdGlvbkljb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbm90aWZ5TmF2aWdhdGlvbkljb25DbGlja2VkOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ25hdicpXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJTY3JvbGxIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlclNjcm9sbEhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpLFxuXG4gICAgICBnZXRWaWV3cG9ydFNjcm9sbFk6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5wYWdlWU9mZnNldFxuICAgICAgfSxcbiAgICAgIGdldFRvdGFsQWN0aW9uSXRlbXM6ICgpID0+XG4gICAgICAgIHRoaXMuJHJlZnMucm9vdC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICAgIE1EQ1RvcEFwcEJhckZvdW5kYXRpb24uc3RyaW5ncy5BQ1RJT05fSVRFTV9TRUxFQ1RPUlxuICAgICAgICApLmxlbmd0aFxuICAgIH1cblxuICAgIHRoaXMuZm91bmRhdGlvbiA9IHRoaXMuc2hvcnRcbiAgICAgID8gbmV3IE1EQ1Nob3J0VG9wQXBwQmFyRm91bmRhdGlvbihhZGFwdGVyKVxuICAgICAgOiBuZXcgTURDVG9wQXBwQmFyRm91bmRhdGlvbihhZGFwdGVyKVxuXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxhXG4gICAgOmNsYXNzPVwiYWN0aW9uaWNvbkNsYXNzZXNcIlxuICAgIGhyZWY9XCIjXCJcbiAgICBjbGFzcz1cIm1kYy10b3AtYXBwLWJhci1hY3Rpb24gbWRjLXRvcC1hcHAtYmFyLS1hY3Rpb24gbWRjLXRvcC1hcHAtYmFyX19hY3Rpb24taXRlbVwiXG4gICAgdi1vbj1cImxpc3RlbmVyc1wiPlxuICAgIDxzbG90Pnt7IGljb24gfX08L3Nsb3Q+XG4gIDwvYT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBEaXNwYXRjaEV2ZW50TWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IHsgUmlwcGxlTWl4aW4gfSBmcm9tICcuLi9yaXBwbGUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10b3AtYXBwLWJhci1hY3Rpb24nLFxuICBtaXhpbnM6IFtEaXNwYXRjaEV2ZW50TWl4aW4sIFJpcHBsZU1peGluXSxcbiAgcHJvcHM6IHtcbiAgICBpY29uOiBTdHJpbmcsXG4gICAgaWNvbkNsYXNzZXM6IE9iamVjdFxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGFjdGlvbmljb25DbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21hdGVyaWFsLWljb25zJzogISF0aGlzLmljb24sXG4gICAgICAgIC4uLnRoaXMuaWNvbkNsYXNzZXNcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjVG9wQXBwQmFyIGZyb20gJy4vbWRjLXRvcC1hcHAtYmFyLnZ1ZSdcbmltcG9ydCBtZGNUb3BBcHBCYXJBY3Rpb24gZnJvbSAnLi9tZGMtdG9wLWFwcC1iYXItYWN0aW9uLnZ1ZSdcblxuZXhwb3J0IHsgbWRjVG9wQXBwQmFyLCBtZGNUb3BBcHBCYXJBY3Rpb24gfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjVG9wQXBwQmFyLFxuICBtZGNUb3BBcHBCYXJBY3Rpb25cbn0pXG4iLCJjb25zdCB0eXBvcyA9IFtcbiAgJ2hlYWRsaW5lMScsXG4gICdoZWFkbGluZTInLFxuICAnaGVhZGxpbmUzJyxcbiAgJ2hlYWRsaW5lNCcsXG4gICdoZWFkbGluZTUnLFxuICAnaGVhZGxpbmU2JyxcbiAgJ3N1YnRpdGxlMScsXG4gICdzdWJ0aXRsZTInLFxuICAnYm9keTEnLFxuICAnYm9keTInLFxuICAnY2FwdGlvbicsXG4gICdidXR0b24nLFxuICAnb3ZlcmxpbmUnXG5dXG5cbmV4cG9ydCBjb25zdCBtZGNUeXBvTWl4aW4gPSBuYW1lID0+IHtcbiAgcmV0dXJuIHtcbiAgICByZW5kZXIoY3JlYXRlRWxlbWVudCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIHRoaXMudGFnLFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICdtZGMtdHlwbyc6IHRydWUsXG4gICAgICAgICAgICBbbmFtZV06IHRydWUsXG4gICAgICAgICAgICBbYG1kYy10eXBvZ3JhcGh5LS0ke3RoaXMudHlwb31gXTogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgYXR0cnM6IHRoaXMuJGF0dHJzLFxuICAgICAgICAgIG9uOiB0aGlzLiRsaXN0ZW5lcnNcbiAgICAgICAgfSxcbiAgICAgICAgdGhpcy4kc2xvdHMuZGVmYXVsdFxuICAgICAgKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWRjVHlwb1Byb3BNaXhpbihkZWZhdWx0VGFnLCBkZWZhdWx0VHlwbywgdmFsaWRUeXBvcykge1xuICByZXR1cm4ge1xuICAgIHByb3BzOiB7XG4gICAgICB0YWc6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBkZWZhdWx0VGFnXG4gICAgICB9LFxuICAgICAgdHlwbzoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGRlZmF1bHRUeXBvLFxuICAgICAgICB2YWxpZGF0b3I6IHZhbHVlID0+IHZhbGlkVHlwb3MuaW5kZXhPZih2YWx1ZSkgIT09IC0xXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBtZGNUZXh0U2VjdGlvbiA9IHtcbiAgbmFtZTogJ21kYy10ZXh0LXNlY3Rpb24nLFxuICBwcm9wczoge1xuICAgIHRhZzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ3NlY3Rpb24nXG4gICAgfVxuICB9LFxuICByZW5kZXIoY3JlYXRlRWxlbWVudCkge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFxuICAgICAgdGhpcy50YWcsXG4gICAgICB7XG4gICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgJ21kYy10eXBvZ3JhcGh5JzogdHJ1ZSxcbiAgICAgICAgICAnbWRjLXRleHQtc2VjdGlvbic6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgYXR0cnM6IHRoaXMuJGF0dHJzLFxuICAgICAgICBvbjogdGhpcy4kbGlzdGVuZXJzXG4gICAgICB9LFxuICAgICAgdGhpcy4kc2xvdHMuZGVmYXVsdFxuICAgIClcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbWRjVGV4dCA9IHtcbiAgbmFtZTogJ21kYy10ZXh0JyxcbiAgbWl4aW5zOiBbbWRjVHlwb01peGluKCdtZGMtdGV4dCcpLCBtZGNUeXBvUHJvcE1peGluKCdwJywgJ2JvZHkxJywgdHlwb3MpXVxufVxuXG5leHBvcnQgY29uc3QgbWRjRGlzcGxheSA9IHtcbiAgbmFtZTogJ21kYy1kaXNwbGF5JyxcbiAgbWl4aW5zOiBbXG4gICAgbWRjVHlwb01peGluKCdtZGMtZGlzcGxheScpLFxuICAgIG1kY1R5cG9Qcm9wTWl4aW4oJ2gxJywgJ2hlYWRsaW5lNCcsIFtcbiAgICAgICdoZWFkbGluZTQnLFxuICAgICAgJ2hlYWRsaW5lMycsXG4gICAgICAnaGVhZGxpbmUyJyxcbiAgICAgICdoZWFkbGluZTEnXG4gICAgXSlcbiAgXVxufVxuXG5leHBvcnQgY29uc3QgbWRjSGVhZGxpbmUgPSB7XG4gIG5hbWU6ICdtZGMtaGVhZGxpbmUnLFxuICBtaXhpbnM6IFtcbiAgICBtZGNUeXBvTWl4aW4oJ21kYy1oZWFkbGluZScpLFxuICAgIG1kY1R5cG9Qcm9wTWl4aW4oJ2gyJywgJ2hlYWRsaW5lNScsIFsnaGVhZGxpbmU1J10pXG4gIF1cbn1cblxuZXhwb3J0IGNvbnN0IG1kY1RpdGxlID0ge1xuICBuYW1lOiAnbWRjLXRpdGxlJyxcbiAgbWl4aW5zOiBbXG4gICAgbWRjVHlwb01peGluKCdtZGMtdGl0bGUnKSxcbiAgICBtZGNUeXBvUHJvcE1peGluKCdoMycsICdoZWFkbGluZTYnLCBbJ2hlYWRsaW5lNiddKVxuICBdXG59XG5cbmV4cG9ydCBjb25zdCBtZGNTdWJIZWFkaW5nID0ge1xuICBuYW1lOiAnbWRjLXN1YmhlYWRpbmcnLFxuICBtaXhpbnM6IFtcbiAgICBtZGNUeXBvTWl4aW4oJ21kYy1zdWJoZWFkaW5nJyksXG4gICAgbWRjVHlwb1Byb3BNaXhpbignaDQnLCAnc3VidGl0bGUyJywgWydzdWJ0aXRsZTEnLCAnc3VidGl0bGUyJ10pXG4gIF1cbn1cblxuZXhwb3J0IGNvbnN0IG1kY0JvZHkgPSB7XG4gIG5hbWU6ICdtZGMtYm9keScsXG4gIG1peGluczogW1xuICAgIG1kY1R5cG9NaXhpbignbWRjLWJvZHknKSxcbiAgICBtZGNUeXBvUHJvcE1peGluKCdwJywgJ2JvZHkxJywgWydib2R5MScsICdib2R5MiddKVxuICBdXG59XG5cbmV4cG9ydCBjb25zdCBtZGNDYXB0aW9uID0ge1xuICBuYW1lOiAnbWRjLWNhcHRpb24nLFxuICBtaXhpbnM6IFtcbiAgICBtZGNUeXBvTWl4aW4oJ21kYy1jYXB0aW9uJyksXG4gICAgbWRjVHlwb1Byb3BNaXhpbignc3BhbicsICdjYXB0aW9uJywgWydjYXB0aW9uJ10pXG4gIF1cbn1cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IHtcbiAgbWRjVGV4dFNlY3Rpb24sXG4gIG1kY1RleHQsXG4gIG1kY0JvZHksXG4gIG1kY0NhcHRpb24sXG4gIG1kY0Rpc3BsYXksXG4gIG1kY0hlYWRsaW5lLFxuICBtZGNTdWJIZWFkaW5nLFxuICBtZGNUaXRsZVxufSBmcm9tICcuL21kYy10eXBvZ3JhcGh5LmpzJ1xuXG5leHBvcnQge1xuICBtZGNUZXh0U2VjdGlvbixcbiAgbWRjVGV4dCxcbiAgbWRjQm9keSxcbiAgbWRjQ2FwdGlvbixcbiAgbWRjRGlzcGxheSxcbiAgbWRjSGVhZGxpbmUsXG4gIG1kY1N1YkhlYWRpbmcsXG4gIG1kY1RpdGxlXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNUZXh0U2VjdGlvbixcbiAgbWRjVGV4dCxcbiAgbWRjQm9keSxcbiAgbWRjQ2FwdGlvbixcbiAgbWRjRGlzcGxheSxcbiAgbWRjSGVhZGxpbmUsXG4gIG1kY1N1YkhlYWRpbmcsXG4gIG1kY1RpdGxlXG59KVxuIiwiLy9cbi8vIHZ1ZSBQbHVnSW5cbi8vXG5pbXBvcnQgVnVlTURDQnV0dG9uIGZyb20gJy4vYnV0dG9uJ1xuaW1wb3J0IFZ1ZU1EQ0NhcmQgZnJvbSAnLi9jYXJkJ1xuaW1wb3J0IFZ1ZU1EQ0NoZWNrYm94IGZyb20gJy4vY2hlY2tib3gnXG5pbXBvcnQgVnVlTURDQ2hpcFNldCBmcm9tICcuL2NoaXBzJ1xuaW1wb3J0IFZ1ZU1EQ0RpYWxvZyBmcm9tICcuL2RpYWxvZydcbmltcG9ydCBWdWVNRENEcmF3ZXIgZnJvbSAnLi9kcmF3ZXInXG5pbXBvcnQgVnVlTURDRWxldmF0aW9uIGZyb20gJy4vZWxldmF0aW9uJ1xuaW1wb3J0IFZ1ZU1EQ0ZhYiBmcm9tICcuL2ZhYidcbmltcG9ydCBWdWVNRENHcmlkTGlzdCBmcm9tICcuL2dyaWQtbGlzdCdcbmltcG9ydCBWdWVNRENJY29uIGZyb20gJy4vaWNvbidcbmltcG9ydCBWdWVNRENJY29uVG9nZ2xlIGZyb20gJy4vaWNvbi10b2dnbGUnXG5pbXBvcnQgVnVlTURDTGF5b3V0QXBwIGZyb20gJy4vbGF5b3V0LWFwcCdcbmltcG9ydCBWdWVNRENMYXlvdXRHcmlkIGZyb20gJy4vbGF5b3V0LWdyaWQnXG5pbXBvcnQgVnVlTURDTGluZWFyUHJvZ3Jlc3MgZnJvbSAnLi9saW5lYXItcHJvZ3Jlc3MnXG5pbXBvcnQgVnVlTURDTGlzdCBmcm9tICcuL2xpc3QnXG5pbXBvcnQgVnVlTURDTWVudSBmcm9tICcuL21lbnUnXG5pbXBvcnQgVnVlTURDUmFkaW8gZnJvbSAnLi9yYWRpbydcbmltcG9ydCBWdWVNRENSaXBwbGUgZnJvbSAnLi9yaXBwbGUnXG5pbXBvcnQgVnVlTURDU2VsZWN0IGZyb20gJy4vc2VsZWN0J1xuaW1wb3J0IFZ1ZU1EQ1NsaWRlciBmcm9tICcuL3NsaWRlcidcbmltcG9ydCBWdWVNRENTbmFja2JhciBmcm9tICcuL3NuYWNrYmFyJ1xuaW1wb3J0IFZ1ZU1EQ1N3aXRjaCBmcm9tICcuL3N3aXRjaCdcbmltcG9ydCBWdWVNRENUYWJzIGZyb20gJy4vdGFicydcbmltcG9ydCBWdWVNRENUZXh0ZmllbGQgZnJvbSAnLi90ZXh0ZmllbGQnXG5pbXBvcnQgVnVlTURDVGhlbWUgZnJvbSAnLi90aGVtZSdcbmltcG9ydCBWdWVNRENUb29sYmFyIGZyb20gJy4vdG9vbGJhcidcbmltcG9ydCBWdWVNRENUb3BBcHBCYXIgZnJvbSAnLi90b3AtYXBwLWJhcidcbmltcG9ydCBWdWVNRENUeXBvZ3JhcGh5IGZyb20gJy4vdHlwb2dyYXBoeSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uOiAnX19WRVJTSU9OX18nLFxuICBpbnN0YWxsKHZtKSB7XG4gICAgdm0udXNlKFZ1ZU1EQ0J1dHRvbilcbiAgICB2bS51c2UoVnVlTURDQ2FyZClcbiAgICB2bS51c2UoVnVlTURDQ2hlY2tib3gpXG4gICAgdm0udXNlKFZ1ZU1EQ0NoaXBTZXQpXG4gICAgdm0udXNlKFZ1ZU1EQ0VsZXZhdGlvbilcbiAgICB2bS51c2UoVnVlTURDRGlhbG9nKVxuICAgIHZtLnVzZShWdWVNRENEcmF3ZXIpXG4gICAgdm0udXNlKFZ1ZU1EQ0VsZXZhdGlvbilcbiAgICB2bS51c2UoVnVlTURDRmFiKVxuICAgIHZtLnVzZShWdWVNRENHcmlkTGlzdClcbiAgICB2bS51c2UoVnVlTURDSWNvbilcbiAgICB2bS51c2UoVnVlTURDSWNvblRvZ2dsZSlcbiAgICB2bS51c2UoVnVlTURDTGF5b3V0QXBwKVxuICAgIHZtLnVzZShWdWVNRENMYXlvdXRHcmlkKVxuICAgIHZtLnVzZShWdWVNRENMaW5lYXJQcm9ncmVzcylcbiAgICB2bS51c2UoVnVlTURDTGlzdClcbiAgICB2bS51c2UoVnVlTURDTWVudSlcbiAgICB2bS51c2UoVnVlTURDUmFkaW8pXG4gICAgdm0udXNlKFZ1ZU1EQ1JpcHBsZSlcbiAgICB2bS51c2UoVnVlTURDU2VsZWN0KVxuICAgIHZtLnVzZShWdWVNRENTbGlkZXIpXG4gICAgdm0udXNlKFZ1ZU1EQ1NuYWNrYmFyKVxuICAgIHZtLnVzZShWdWVNRENTd2l0Y2gpXG4gICAgdm0udXNlKFZ1ZU1EQ1RhYnMpXG4gICAgdm0udXNlKFZ1ZU1EQ1RleHRmaWVsZClcbiAgICB2bS51c2UoVnVlTURDVGhlbWUpXG4gICAgdm0udXNlKFZ1ZU1EQ1Rvb2xiYXIpXG4gICAgdm0udXNlKFZ1ZU1EQ1RvcEFwcEJhcilcbiAgICB2bS51c2UoVnVlTURDVHlwb2dyYXBoeSlcbiAgfVxufVxuIiwiaW1wb3J0ICcuL3N0eWxlcy5zY3NzJ1xuaW1wb3J0IHsgYXV0b0luaXQgfSBmcm9tICcuL2Jhc2UnXG5pbXBvcnQgcGx1Z2luIGZyb20gJy4vaW5kZXguanMnXG5leHBvcnQgZGVmYXVsdCBwbHVnaW5cblxuYXV0b0luaXQocGx1Z2luKVxuIl0sIm5hbWVzIjpbInN1cHBvcnRzUGFzc2l2ZV8iLCJhcHBseVBhc3NpdmUiLCJnbG9iYWxPYmoiLCJ3aW5kb3ciLCJmb3JjZVJlZnJlc2giLCJ1bmRlZmluZWQiLCJpc1N1cHBvcnRlZCIsImRvY3VtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJlIiwiYXV0b0luaXQiLCJwbHVnaW4iLCJfVnVlIiwiVnVlIiwiZ2xvYmFsIiwidXNlIiwiQmFzZVBsdWdpbiIsImNvbXBvbmVudHMiLCJ2ZXJzaW9uIiwiaW5zdGFsbCIsImtleSIsImNvbXBvbmVudCIsInZtIiwibmFtZSIsIkN1c3RvbUVsZW1lbnQiLCJmdW5jdGlvbmFsIiwicmVuZGVyIiwiY3JlYXRlRWxlbWVudCIsImNvbnRleHQiLCJwcm9wcyIsImlzIiwidGFnIiwiZGF0YSIsImNoaWxkcmVuIiwiQ3VzdG9tRWxlbWVudE1peGluIiwiQ3VzdG9tTGluayIsInR5cGUiLCJTdHJpbmciLCJkZWZhdWx0IiwibGluayIsIk9iamVjdCIsImgiLCJlbGVtZW50IiwiYmFiZWxIZWxwZXJzLmV4dGVuZHMiLCJwYXJlbnQiLCIkcm91dGVyIiwiJHJvb3QiLCIkb3B0aW9ucyIsIm9uIiwiY2xpY2siLCJuYXRpdmVPbiIsIkN1c3RvbUxpbmtNaXhpbiIsInRvIiwiZXhhY3QiLCJCb29sZWFuIiwiYXBwZW5kIiwicmVwbGFjZSIsImFjdGl2ZUNsYXNzIiwiZXhhY3RBY3RpdmVDbGFzcyIsImNvbXB1dGVkIiwiZW1pdEN1c3RvbUV2ZW50IiwiZWwiLCJldnRUeXBlIiwiZXZ0RGF0YSIsInNob3VsZEJ1YmJsZSIsImV2dCIsIkN1c3RvbUV2ZW50IiwiZGV0YWlsIiwiYnViYmxlcyIsImNyZWF0ZUV2ZW50IiwiaW5pdEN1c3RvbUV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsIkN1c3RvbUJ1dHRvbiIsImF0dHJzIiwicm9sZSIsImhyZWYiLCJDdXN0b21CdXR0b25NaXhpbiIsImRpc2FibGVkIiwiZXh0cmFjdEljb25Qcm9wIiwiaWNvblByb3AiLCJjbGFzc2VzIiwiY29udGVudCIsIkFycmF5IiwicmVkdWNlIiwicmVzdWx0IiwidmFsdWUiLCJjbGFzc05hbWUiLCJzcGxpdCIsInRleHRDb250ZW50IiwiRGlzcGF0Y2hFdmVudE1peGluIiwiZXZlbnQiLCJtZXRob2RzIiwiJGVtaXQiLCJ0YXJnZXQiLCJldmVudFRhcmdldCIsImFyZ3MiLCJldmVudEFyZ3MiLCJsaXN0ZW5lcnMiLCIkbGlzdGVuZXJzIiwiRGlzcGF0Y2hGb2N1c01peGluIiwiaGFzRm9jdXMiLCJvbk1vdXNlRG93biIsIl9hY3RpdmUiLCJvbk1vdXNlVXAiLCJvbkZvY3VzRXZlbnQiLCJzZXRUaW1lb3V0IiwiZGlzcGF0Y2hGb2N1c0V2ZW50Iiwib25CbHVyRXZlbnQiLCIkZWwiLCJhY3RpdmVFbGVtZW50IiwiY29udGFpbnMiLCJtb3VudGVkIiwiYmVmb3JlRGVzdHJveSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzY29wZSIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsInRvU3RyaW5nIiwiVk1BVW5pcXVlSWRNaXhpbiIsImJlZm9yZUNyZWF0ZSIsInZtYV91aWRfIiwiX3VpZCIsIk1EQ0ZvdW5kYXRpb24iLCJhZGFwdGVyIiwiYWRhcHRlcl8iLCJNRENSaXBwbGVBZGFwdGVyIiwiaGFuZGxlciIsInZhck5hbWUiLCJjc3NDbGFzc2VzIiwiUk9PVCIsIlVOQk9VTkRFRCIsIkJHX0ZPQ1VTRUQiLCJGR19BQ1RJVkFUSU9OIiwiRkdfREVBQ1RJVkFUSU9OIiwic3RyaW5ncyIsIlZBUl9MRUZUIiwiVkFSX1RPUCIsIlZBUl9GR19TSVpFIiwiVkFSX0ZHX1NDQUxFIiwiVkFSX0ZHX1RSQU5TTEFURV9TVEFSVCIsIlZBUl9GR19UUkFOU0xBVEVfRU5EIiwibnVtYmVycyIsIlBBRERJTkciLCJJTklUSUFMX09SSUdJTl9TQ0FMRSIsIkRFQUNUSVZBVElPTl9USU1FT1VUX01TIiwiRkdfREVBQ1RJVkFUSU9OX01TIiwiVEFQX0RFTEFZX01TIiwic3VwcG9ydHNDc3NWYXJpYWJsZXNfIiwiZGV0ZWN0RWRnZVBzZXVkb1ZhckJ1ZyIsIndpbmRvd09iaiIsIm5vZGUiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJjb21wdXRlZFN0eWxlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImhhc1BzZXVkb1ZhckJ1ZyIsImJvcmRlclRvcFN0eWxlIiwicmVtb3ZlIiwic3VwcG9ydHNDc3NWYXJpYWJsZXMiLCJzdXBwb3J0c0Z1bmN0aW9uUHJlc2VudCIsIkNTUyIsInN1cHBvcnRzIiwiZXhwbGljaXRseVN1cHBvcnRzQ3NzVmFycyIsIndlQXJlRmVhdHVyZURldGVjdGluZ1NhZmFyaTEwcGx1cyIsImdldE1hdGNoZXNQcm9wZXJ0eSIsIkhUTUxFbGVtZW50UHJvdG90eXBlIiwiZmlsdGVyIiwicCIsInBvcCIsImdldE5vcm1hbGl6ZWRFdmVudENvb3JkcyIsImV2IiwicGFnZU9mZnNldCIsImNsaWVudFJlY3QiLCJ4IiwieSIsImRvY3VtZW50WCIsImxlZnQiLCJkb2N1bWVudFkiLCJ0b3AiLCJub3JtYWxpemVkWCIsIm5vcm1hbGl6ZWRZIiwiY2hhbmdlZFRvdWNoZXMiLCJwYWdlWCIsInBhZ2VZIiwiQUNUSVZBVElPTl9FVkVOVF9UWVBFUyIsIlBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTIiwiYWN0aXZhdGVkVGFyZ2V0cyIsIk1EQ1JpcHBsZUZvdW5kYXRpb24iLCJicm93c2VyU3VwcG9ydHNDc3NWYXJzIiwiaXNVbmJvdW5kZWQiLCJpc1N1cmZhY2VBY3RpdmUiLCJpc1N1cmZhY2VEaXNhYmxlZCIsImFkZENsYXNzIiwicmVtb3ZlQ2xhc3MiLCJjb250YWluc0V2ZW50VGFyZ2V0IiwicmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyIiwicmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlciIsInJlZ2lzdGVyUmVzaXplSGFuZGxlciIsImRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyIiwidXBkYXRlQ3NzVmFyaWFibGUiLCJjb21wdXRlQm91bmRpbmdSZWN0IiwiZ2V0V2luZG93UGFnZU9mZnNldCIsImRlZmF1bHRBZGFwdGVyIiwibGF5b3V0RnJhbWVfIiwiZnJhbWVfIiwid2lkdGgiLCJoZWlnaHQiLCJhY3RpdmF0aW9uU3RhdGVfIiwiZGVmYXVsdEFjdGl2YXRpb25TdGF0ZV8iLCJpbml0aWFsU2l6ZV8iLCJtYXhSYWRpdXNfIiwiYWN0aXZhdGVIYW5kbGVyXyIsImFjdGl2YXRlXyIsImRlYWN0aXZhdGVIYW5kbGVyXyIsImRlYWN0aXZhdGVfIiwiZm9jdXNIYW5kbGVyXyIsImhhbmRsZUZvY3VzIiwiYmx1ckhhbmRsZXJfIiwiaGFuZGxlQmx1ciIsInJlc2l6ZUhhbmRsZXJfIiwibGF5b3V0IiwidW5ib3VuZGVkQ29vcmRzXyIsImZnU2NhbGVfIiwiYWN0aXZhdGlvblRpbWVyXyIsImZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyXyIsImFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF8iLCJhY3RpdmF0aW9uVGltZXJDYWxsYmFja18iLCJydW5EZWFjdGl2YXRpb25VWExvZ2ljSWZSZWFkeV8iLCJwcmV2aW91c0FjdGl2YXRpb25FdmVudF8iLCJpc0FjdGl2YXRlZCIsImhhc0RlYWN0aXZhdGlvblVYUnVuIiwid2FzQWN0aXZhdGVkQnlQb2ludGVyIiwid2FzRWxlbWVudE1hZGVBY3RpdmUiLCJhY3RpdmF0aW9uRXZlbnQiLCJpc1Byb2dyYW1tYXRpYyIsImlzU3VwcG9ydGVkXyIsInJlZ2lzdGVyUm9vdEhhbmRsZXJzXyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImxheW91dEludGVybmFsXyIsImNsZWFyVGltZW91dCIsImRlcmVnaXN0ZXJSb290SGFuZGxlcnNfIiwiZGVyZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXyIsInJlbW92ZUNzc1ZhcnNfIiwiZm9yRWFjaCIsImtleXMiLCJrIiwiaW5kZXhPZiIsImFjdGl2YXRpb25TdGF0ZSIsInByZXZpb3VzQWN0aXZhdGlvbkV2ZW50IiwiaXNTYW1lSW50ZXJhY3Rpb24iLCJoYXNBY3RpdmF0ZWRDaGlsZCIsImxlbmd0aCIsInNvbWUiLCJyZXNldEFjdGl2YXRpb25TdGF0ZV8iLCJwdXNoIiwicmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVyc18iLCJjaGVja0VsZW1lbnRNYWRlQWN0aXZlXyIsImFuaW1hdGVBY3RpdmF0aW9uXyIsImtleUNvZGUiLCJ0cmFuc2xhdGVTdGFydCIsInRyYW5zbGF0ZUVuZCIsImdldEZnVHJhbnNsYXRpb25Db29yZGluYXRlc18iLCJzdGFydFBvaW50IiwiZW5kUG9pbnQiLCJybUJvdW5kZWRBY3RpdmF0aW9uQ2xhc3Nlc18iLCJhY3RpdmF0aW9uSGFzRW5kZWQiLCJzdGF0ZSIsImV2dE9iamVjdCIsImFuaW1hdGVEZWFjdGl2YXRpb25fIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJtYXhEaW0iLCJtYXgiLCJnZXRCb3VuZGVkUmFkaXVzIiwiaHlwb3RlbnVzZSIsInNxcnQiLCJwb3ciLCJ1cGRhdGVMYXlvdXRDc3NWYXJzXyIsInJvdW5kIiwidW5ib3VuZGVkIiwiUmlwcGxlQmFzZSIsInJlZiIsIk1BVENIRVMiLCJfbWF0Y2hlcyIsIkhUTUxFbGVtZW50IiwicHJvdG90eXBlIiwib3B0aW9ucyIsIiRzZXQiLCIkZGVsZXRlIiwiZG9jdW1lbnRFbGVtZW50Iiwic3R5bGVzIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicGFnZVhPZmZzZXQiLCJwYWdlWU9mZnNldCIsIlJpcHBsZU1peGluIiwicmlwcGxlIiwiaW5pdCIsImRlc3Ryb3kiLCJtZGNSaXBwbGUiLCJtZGNCdXR0b24iLCJtZGNDYXJkIiwibWRjQ2FyZFByaW1hcnlBY3Rpb24iLCJtZGNDYXJkTWVkaWEiLCJtZGNDYXJkSGVhZGVyIiwibWRjQ2FyZFRpdGxlIiwibWRjQ2FyZFN1YnRpdGxlIiwibWRjQ2FyZFRleHQiLCJtZGNDYXJkQWN0aW9ucyIsIm1kY0NhcmRBY3Rpb25CdXR0b25zIiwibWRjQ2FyZEFjdGlvbkJ1dHRvbiIsIm1kY0NhcmRBY3Rpb25JY29ucyIsIm1kY0NhcmRBY3Rpb25JY29uIiwiTURDQ29tcG9uZW50Iiwicm9vdCIsImZvdW5kYXRpb24iLCJyb290XyIsImluaXRpYWxpemUiLCJmb3VuZGF0aW9uXyIsImdldERlZmF1bHRGb3VuZGF0aW9uIiwiaW5pdGlhbFN5bmNXaXRoRE9NIiwiRXJyb3IiLCJzdXBwb3J0c1ByZXNzUmlwcGxlIiwic3VwcG9ydHNQcmVzc1JpcHBsZV8iLCJNRENSaXBwbGUiLCJ1bmJvdW5kZWRfIiwic2V0VW5ib3VuZGVkIiwiYWN0aXZhdGUiLCJkZWFjdGl2YXRlIiwiY3JlYXRlQWRhcHRlciIsImRhdGFzZXQiLCJzZXRVbmJvdW5kZWRfIiwiaW5zdGFuY2UiLCJ1dGlsIiwiY2xhc3NMaXN0IiwiYWRkIiwic3R5bGUiLCJzZXRQcm9wZXJ0eSIsIlJpcHBsZUNhcGFibGVTdXJmYWNlIiwiTURDU2VsZWN0aW9uQ29udHJvbCIsIk1EQ0NoZWNrYm94QWRhcHRlciIsImF0dHIiLCJVUEdSQURFRCIsIkNIRUNLRUQiLCJJTkRFVEVSTUlOQVRFIiwiRElTQUJMRUQiLCJBTklNX1VOQ0hFQ0tFRF9DSEVDS0VEIiwiQU5JTV9VTkNIRUNLRURfSU5ERVRFUk1JTkFURSIsIkFOSU1fQ0hFQ0tFRF9VTkNIRUNLRUQiLCJBTklNX0NIRUNLRURfSU5ERVRFUk1JTkFURSIsIkFOSU1fSU5ERVRFUk1JTkFURV9DSEVDS0VEIiwiQU5JTV9JTkRFVEVSTUlOQVRFX1VOQ0hFQ0tFRCIsIk5BVElWRV9DT05UUk9MX1NFTEVDVE9SIiwiVFJBTlNJVElPTl9TVEFURV9JTklUIiwiVFJBTlNJVElPTl9TVEFURV9DSEVDS0VEIiwiVFJBTlNJVElPTl9TVEFURV9VTkNIRUNLRUQiLCJUUkFOU0lUSU9OX1NUQVRFX0lOREVURVJNSU5BVEUiLCJBUklBX0NIRUNLRURfQVRUUiIsIkFSSUFfQ0hFQ0tFRF9JTkRFVEVSTUlOQVRFX1ZBTFVFIiwiQU5JTV9FTkRfTEFUQ0hfTVMiLCJDQl9QUk9UT19QUk9QUyIsIk1EQ0NoZWNrYm94Rm91bmRhdGlvbiIsInNldE5hdGl2ZUNvbnRyb2xBdHRyIiwicmVtb3ZlTmF0aXZlQ29udHJvbEF0dHIiLCJyZWdpc3RlckFuaW1hdGlvbkVuZEhhbmRsZXIiLCJkZXJlZ2lzdGVyQW5pbWF0aW9uRW5kSGFuZGxlciIsInJlZ2lzdGVyQ2hhbmdlSGFuZGxlciIsImRlcmVnaXN0ZXJDaGFuZ2VIYW5kbGVyIiwiZ2V0TmF0aXZlQ29udHJvbCIsImZvcmNlTGF5b3V0IiwiaXNBdHRhY2hlZFRvRE9NIiwiY3VycmVudENoZWNrU3RhdGVfIiwiY3VycmVudEFuaW1hdGlvbkNsYXNzXyIsImFuaW1FbmRMYXRjaFRpbWVyXyIsImFuaW1FbmRIYW5kbGVyXyIsImhhbmRsZUFuaW1hdGlvbkVuZCIsImNoYW5nZUhhbmRsZXJfIiwiaGFuZGxlQ2hhbmdlIiwiZGV0ZXJtaW5lQ2hlY2tTdGF0ZV8iLCJnZXROYXRpdmVDb250cm9sXyIsInVwZGF0ZUFyaWFDaGVja2VkXyIsImluc3RhbGxQcm9wZXJ0eUNoYW5nZUhvb2tzXyIsInVuaW5zdGFsbFByb3BlcnR5Q2hhbmdlSG9va3NfIiwiY2hlY2tlZCIsImluZGV0ZXJtaW5hdGUiLCJ0cmFuc2l0aW9uQ2hlY2tTdGF0ZV8iLCJuYXRpdmVDYiIsImNiUHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsImNvbnRyb2xTdGF0ZSIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJ2YWxpZERlc2NyaXB0b3IiLCJuYXRpdmVDYkRlc2MiLCJnZXQiLCJzZXQiLCJjYWxsIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImRlZmluZVByb3BlcnR5Iiwib2xkU3RhdGUiLCJuZXdTdGF0ZSIsImdldFRyYW5zaXRpb25BbmltYXRpb25DbGFzc18iLCJpc0luZGV0ZXJtaW5hdGUiLCJpbnB1dFByb3BEZXNjIiwiTURDRm9ybUZpZWxkQWRhcHRlciIsIkxBQkVMX1NFTEVDVE9SIiwiTURDRm9ybUZpZWxkRm91bmRhdGlvbiIsImFjdGl2YXRlSW5wdXRSaXBwbGUiLCJkZWFjdGl2YXRlSW5wdXRSaXBwbGUiLCJjbGlja0hhbmRsZXJfIiwiaGFuZGxlQ2xpY2tfIiwiZXZlbnRUeXBlTWFwIiwibm9QcmVmaXgiLCJ3ZWJraXRQcmVmaXgiLCJzdHlsZVByb3BlcnR5IiwiY3NzUHJvcGVydHlNYXAiLCJoYXNQcm9wZXJTaGFwZSIsImV2ZW50Rm91bmRJbk1hcHMiLCJldmVudFR5cGUiLCJnZXRKYXZhU2NyaXB0RXZlbnROYW1lIiwibWFwIiwiZ2V0QW5pbWF0aW9uTmFtZSIsImV2ZW50TmFtZSIsInRyYW5zZm9ybVN0eWxlUHJvcGVydGllcyIsImdldENvcnJlY3RFdmVudE5hbWUiLCJnZXRDb3JyZWN0UHJvcGVydHlOYW1lIiwibWRjQ2hlY2tib3giLCJNRENDaGlwQWRhcHRlciIsInByb3BlcnR5TmFtZSIsIkVOVFJZX0FOSU1BVElPTl9OQU1FIiwiSU5URVJBQ1RJT05fRVZFTlQiLCJUUkFJTElOR19JQ09OX0lOVEVSQUNUSU9OX0VWRU5UIiwiUkVNT1ZBTF9FVkVOVCIsIkNIRUNLTUFSS19TRUxFQ1RPUiIsIkxFQURJTkdfSUNPTl9TRUxFQ1RPUiIsIlRSQUlMSU5HX0lDT05fU0VMRUNUT1IiLCJDSEVDS01BUksiLCJDSElQX0VYSVQiLCJISURERU5fTEVBRElOR19JQ09OIiwiTEVBRElOR19JQ09OIiwiVFJBSUxJTkdfSUNPTiIsIlNFTEVDVEVEIiwiTURDQ2hpcEZvdW5kYXRpb24iLCJoYXNDbGFzcyIsImFkZENsYXNzVG9MZWFkaW5nSWNvbiIsInJlbW92ZUNsYXNzRnJvbUxlYWRpbmdJY29uIiwiZXZlbnRUYXJnZXRIYXNDbGFzcyIsIm5vdGlmeUludGVyYWN0aW9uIiwibm90aWZ5VHJhaWxpbmdJY29uSW50ZXJhY3Rpb24iLCJub3RpZnlSZW1vdmFsIiwiZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlIiwic2V0U3R5bGVQcm9wZXJ0eSIsInNob3VsZFJlbW92ZU9uVHJhaWxpbmdJY29uQ2xpY2tfIiwic2VsZWN0ZWQiLCJzaG91bGRSZW1vdmUiLCJjaGlwV2lkdGgiLCJzdG9wUHJvcGFnYXRpb24iLCJiZWdpbkV4aXQiLCJNRENDaGlwU2V0QWRhcHRlciIsImNoaXAiLCJDSElQX1NFTEVDVE9SIiwiQ0hPSUNFIiwiRklMVEVSIiwiTURDQ2hpcFNldEZvdW5kYXRpb24iLCJyZW1vdmVDaGlwIiwic2VsZWN0ZWRDaGlwc18iLCJjaGlwRm91bmRhdGlvbiIsImRlc2VsZWN0QWxsXyIsInNldFNlbGVjdGVkIiwiaW5kZXgiLCJzcGxpY2UiLCJpc1NlbGVjdGVkIiwiZGVzZWxlY3QiLCJzZWxlY3QiLCJtZGNDaGlwIiwibWRjQ2hpcFNldCIsIk9QRU4iLCJBTklNQVRJTkciLCJCQUNLRFJPUCIsIlNDUk9MTF9MT0NLIiwiQUNDRVBUX0JUTiIsIkNBTkNFTF9CVE4iLCJPUEVOX0RJQUxPR19TRUxFQ1RPUiIsIkRJQUxPR19TVVJGQUNFX1NFTEVDVE9SIiwiQUNDRVBUX1NFTEVDVE9SIiwiQUNDRVBUX0VWRU5UIiwiQ0FOQ0VMX0VWRU5UIiwiRElBTE9HX0FOSU1BVElPTl9USU1FX01TIiwiTURDRGlhbG9nRm91bmRhdGlvbiIsImFkZEJvZHlDbGFzcyIsInJlbW92ZUJvZHlDbGFzcyIsInJlZ2lzdGVyU3VyZmFjZUludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJTdXJmYWNlSW50ZXJhY3Rpb25IYW5kbGVyIiwicmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyIiwiZGVyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXIiLCJub3RpZnlBY2NlcHQiLCJub3RpZnlDYW5jZWwiLCJ0cmFwRm9jdXNPblN1cmZhY2UiLCJ1bnRyYXBGb2N1c09uU3VyZmFjZSIsImlzRGlhbG9nIiwiaXNPcGVuXyIsImNvbXBvbmVudENsaWNrSGFuZGxlcl8iLCJjYW5jZWwiLCJkaWFsb2dDbGlja0hhbmRsZXJfIiwiaGFuZGxlRGlhbG9nQ2xpY2tfIiwiZG9jdW1lbnRLZXlkb3duSGFuZGxlcl8iLCJ0aW1lcklkXyIsImFuaW1hdGlvblRpbWVyRW5kXyIsImhhbmRsZUFuaW1hdGlvblRpbWVyRW5kXyIsImNsb3NlIiwiZGlzYWJsZVNjcm9sbF8iLCJlbmFibGVTY3JvbGxfIiwic2hvdWxkTm90aWZ5IiwiYWNjZXB0IiwibW9kdWxlIiwiZWxlbWVudERvY3VtZW50Iiwib3duZXJEb2N1bWVudCIsImJhc2ljVGFiYmFibGVzIiwib3JkZXJlZFRhYmJhYmxlcyIsImlzVW5hdmFpbGFibGUiLCJjcmVhdGVJc1VuYXZhaWxhYmxlIiwiY2FuZGlkYXRlU2VsZWN0b3JzIiwiY2FuZGlkYXRlcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJqb2luIiwiaW5jbHVkZUNvbnRhaW5lciIsIm1hdGNoZXMiLCJFbGVtZW50IiwibXNNYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJjYW5kaWRhdGVTZWxlY3RvciIsInNsaWNlIiwiYXBwbHkiLCJ1bnNoaWZ0IiwiY2FuZGlkYXRlIiwiY2FuZGlkYXRlSW5kZXhBdHRyIiwiY2FuZGlkYXRlSW5kZXgiLCJpIiwibCIsInBhcnNlSW50IiwiZ2V0QXR0cmlidXRlIiwiaXNOYU4iLCJ0YWJJbmRleCIsInRhZ05hbWUiLCJ0YWJiYWJsZU5vZGVzIiwic29ydCIsImEiLCJiIiwiaXNPZmZDYWNoZSIsImlzT2ZmIiwibm9kZUNvbXB1dGVkU3R5bGUiLCJkZWZhdWx0VmlldyIsImRpc3BsYXkiLCJwYXJlbnROb2RlIiwidmlzaWJpbGl0eSIsImxpc3RlbmluZ0ZvY3VzVHJhcCIsImZvY3VzVHJhcCIsInVzZXJPcHRpb25zIiwiZmlyc3RUYWJiYWJsZU5vZGUiLCJsYXN0VGFiYmFibGVOb2RlIiwibm9kZUZvY3VzZWRCZWZvcmVBY3RpdmF0aW9uIiwiYWN0aXZlIiwicGF1c2VkIiwidGFiRXZlbnQiLCJjb250YWluZXIiLCJxdWVyeVNlbGVjdG9yIiwiY29uZmlnIiwicmV0dXJuRm9jdXNPbkRlYWN0aXZhdGUiLCJlc2NhcGVEZWFjdGl2YXRlcyIsInRyYXAiLCJwYXVzZSIsInVucGF1c2UiLCJhY3RpdmF0ZU9wdGlvbnMiLCJkZWZhdWx0ZWRBY3RpdmF0ZU9wdGlvbnMiLCJvbkFjdGl2YXRlIiwiZGVhY3RpdmF0ZU9wdGlvbnMiLCJkZWZhdWx0ZWREZWFjdGl2YXRlT3B0aW9ucyIsInJldHVybkZvY3VzIiwib25EZWFjdGl2YXRlIiwiYWRkTGlzdGVuZXJzIiwiZmlyc3RGb2N1c05vZGUiLCJjaGVja0ZvY3VzIiwiY2hlY2tDbGljayIsImNoZWNrUG9pbnRlckRvd24iLCJjaGVja0tleSIsInJlbW92ZUxpc3RlbmVycyIsImdldE5vZGVGb3JPcHRpb24iLCJvcHRpb25OYW1lIiwib3B0aW9uVmFsdWUiLCJjbGlja091dHNpZGVEZWFjdGl2YXRlcyIsInByZXZlbnREZWZhdWx0Iiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwiYmx1ciIsImlzRXNjYXBlRXZlbnQiLCJoYW5kbGVUYWIiLCJoYXNBdHRyaWJ1dGUiLCJOdW1iZXIiLCJjdXJyZW50Rm9jdXNJbmRleCIsInNoaWZ0S2V5IiwidHJ5Rm9jdXMiLCJ1cGRhdGVUYWJiYWJsZU5vZGVzIiwidGFiYmFibGUiLCJyZWFkanVzdEZvY3VzIiwiZm9jdXMiLCJ0b0xvd2VyQ2FzZSIsImNyZWF0ZUZvY3VzVHJhcEluc3RhbmNlIiwic3VyZmFjZUVsIiwiYWNjZXB0QnV0dG9uRWwiLCJmb2N1c1RyYXBGYWN0b3J5IiwiY3JlYXRlRm9jdXNUcmFwIiwiaW5pdGlhbEZvY3VzIiwibWRjRGlhbG9nIiwiRk9DVVNBQkxFX0VMRU1FTlRTIiwiTURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9uIiwiaGFzTmVjZXNzYXJ5RG9tIiwicmVnaXN0ZXJEcmF3ZXJJbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyIiwicmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlciIsImRlcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlciIsInNldFRyYW5zbGF0ZVgiLCJnZXRGb2N1c2FibGVFbGVtZW50cyIsInNhdmVFbGVtZW50VGFiU3RhdGUiLCJyZXN0b3JlRWxlbWVudFRhYlN0YXRlIiwibWFrZUVsZW1lbnRVbnRhYmJhYmxlIiwibm90aWZ5T3BlbiIsIm5vdGlmeUNsb3NlIiwiaXNSdGwiLCJnZXREcmF3ZXJXaWR0aCIsInJvb3RDc3NDbGFzcyIsImFuaW1hdGluZ0Nzc0NsYXNzIiwib3BlbkNzc0NsYXNzIiwicm9vdENzc0NsYXNzXyIsImFuaW1hdGluZ0Nzc0NsYXNzXyIsIm9wZW5Dc3NDbGFzc18iLCJ0cmFuc2l0aW9uRW5kSGFuZGxlcl8iLCJoYW5kbGVUcmFuc2l0aW9uRW5kXyIsImluZXJ0XyIsImNvbXBvbmVudFRvdWNoU3RhcnRIYW5kbGVyXyIsImhhbmRsZVRvdWNoU3RhcnRfIiwiY29tcG9uZW50VG91Y2hNb3ZlSGFuZGxlcl8iLCJoYW5kbGVUb3VjaE1vdmVfIiwiY29tcG9uZW50VG91Y2hFbmRIYW5kbGVyXyIsImhhbmRsZVRvdWNoRW5kXyIsImRldGFiaW5hdGVfIiwicmV0YWJpbmF0ZV8iLCJlbGVtZW50cyIsInBvaW50ZXJUeXBlIiwiZGlyZWN0aW9uXyIsImRyYXdlcldpZHRoXyIsInN0YXJ0WF8iLCJ0b3VjaGVzIiwiY3VycmVudFhfIiwidXBkYXRlUmFmXyIsInVwZGF0ZURyYXdlcl8iLCJiaW5kIiwicHJlcGFyZUZvclRvdWNoRW5kXyIsImFicyIsIm5ld1Bvc2l0aW9uXyIsIm9wZW4iLCJpc1Jvb3RUcmFuc2l0aW9uaW5nRXZlbnRUYXJnZXRfIiwibmV3UG9zIiwibWluIiwiRFJBV0VSX1NFTEVDVE9SIiwiT1BFTl9FVkVOVCIsIkNMT1NFX0VWRU5UIiwiTURDUGVyc2lzdGVudERyYXdlckZvdW5kYXRpb24iLCJpc0RyYXdlciIsIlRBQl9EQVRBIiwiVEFCX0RBVEFfSEFORExFRCIsInN0b3JlZFRyYW5zZm9ybVByb3BlcnR5TmFtZV8iLCJyZW1hcEV2ZW50IiwiZ2V0VHJhbnNmb3JtUHJvcGVydHlOYW1lIiwidHJhbnNmb3JtUHJvcGVydHlOYW1lIiwic3VwcG9ydHNDc3NDdXN0b21Qcm9wZXJ0aWVzIiwic2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwiT1BBQ0lUWV9WQVJfTkFNRSIsIk1EQ1RlbXBvcmFyeURyYXdlckZvdW5kYXRpb24iLCJuZXdPcGFjaXR5IiwibWRjRHJhd2VyIiwibWRjRHJhd2VyTGF5b3V0IiwibWRjRHJhd2VySGVhZGVyIiwibWRjRHJhd2VyTGlzdCIsIm1kY0RyYXdlckl0ZW0iLCJtZGNEcmF3ZXJEaXZpZGVyIiwibWRjRWxldmF0aW9uIiwibWRjRkFCIiwiVElMRVNfU0VMRUNUT1IiLCJUSUxFX1NFTEVDVE9SIiwiTURDR3JpZExpc3RGb3VuZGF0aW9uIiwiZ2V0T2Zmc2V0V2lkdGgiLCJnZXROdW1iZXJPZlRpbGVzIiwiZ2V0T2Zmc2V0V2lkdGhGb3JUaWxlQXRJbmRleCIsInNldFN0eWxlRm9yVGlsZXNFbGVtZW50IiwiYWxpZ25DZW50ZXIiLCJyZXNpemVGcmFtZV8iLCJhbGlnbkNlbnRlcl8iLCJncmlkV2lkdGgiLCJpdGVtV2lkdGgiLCJ0aWxlc1dpZHRoIiwibWRjR3JpZExpc3QiLCJtZGNHcmlkVGlsZSIsIm1kY0ljb24iLCJNRENJY29uVG9nZ2xlQWRhcHRlciIsInRleHQiLCJEQVRBX1RPR0dMRV9PTiIsIkRBVEFfVE9HR0xFX09GRiIsIkFSSUFfUFJFU1NFRCIsIkFSSUFfRElTQUJMRUQiLCJBUklBX0xBQkVMIiwiQ0hBTkdFX0VWRU5UIiwiTURDSWNvblRvZ2dsZUZvdW5kYXRpb24iLCJzZXRUZXh0IiwiZ2V0VGFiSW5kZXgiLCJzZXRUYWJJbmRleCIsImdldEF0dHIiLCJzZXRBdHRyIiwicm1BdHRyIiwibm90aWZ5Q2hhbmdlIiwib25fIiwiZGlzYWJsZWRfIiwic2F2ZWRUYWJJbmRleF8iLCJ0b2dnbGVPbkRhdGFfIiwidG9nZ2xlT2ZmRGF0YV8iLCJ0b2dnbGVGcm9tRXZ0XyIsImlzSGFuZGxpbmdLZXlkb3duXyIsImtleWRvd25IYW5kbGVyXyIsImlzU3BhY2UiLCJrZXl1cEhhbmRsZXJfIiwicmVmcmVzaFRvZ2dsZURhdGEiLCJwYXJzZUpzb25EYXRhQXR0cl8iLCJ0b2dnbGUiLCJpc09uIiwiY2xhc3NUb1JlbW92ZSIsImNzc0NsYXNzIiwibGFiZWwiLCJkYXRhQXR0ciIsInZhbCIsIkpTT04iLCJwYXJzZSIsImlzRGlzYWJsZWQiLCJrZXlib2FyZEtleSIsIkljb25Ub2dnbGVTdGF0ZSIsIm1kY0lDb25Ub2dnbGUiLCJtZGNMYXlvdXRBcHAiLCJtZGNMYXlvdXRHcmlkIiwibWRjTGF5b3V0Q2VsbCIsIm1kY0xheW91dElubmVyR3JpZCIsIkNMT1NFRF9DTEFTUyIsIklOREVURVJNSU5BVEVfQ0xBU1MiLCJSRVZFUlNFRF9DTEFTUyIsIlBSSU1BUllfQkFSX1NFTEVDVE9SIiwiQlVGRkVSX1NFTEVDVE9SIiwiTURDTGluZWFyUHJvZ3Jlc3NGb3VuZGF0aW9uIiwiZ2V0UHJpbWFyeUJhciIsImdldEJ1ZmZlciIsInNldFN0eWxlIiwiZGV0ZXJtaW5hdGVfIiwicmV2ZXJzZV8iLCJwcm9ncmVzc18iLCJpc0RldGVybWluYXRlIiwic2V0U2NhbGVfIiwiaXNSZXZlcnNlZCIsInNjYWxlVmFsdWUiLCJ0cmFuc2Zvcm1TdHlsZVByb3BlcnR5IiwibWRjTGluZWFyUHJvZ3Jlc3MiLCJtZGNMaXN0IiwibWRjTGlzdEl0ZW0iLCJtZGNMaXN0RGl2aWRlciIsIm1kY0xpc3RHcm91cCIsIm1kY0xpc3RHcm91cEhlYWRlciIsIm1kY0xpc3RHcm91cERpdmlkZXIiLCJNRENNZW51QWRhcHRlciIsImF0dHJpYnV0ZU5hbWUiLCJvcmlnaW4iLCJwb3NpdGlvbiIsIkFOSU1BVElOR19PUEVOIiwiQU5JTUFUSU5HX0NMT1NFRCIsIlNFTEVDVEVEX0xJU1RfSVRFTSIsIklURU1TX1NFTEVDVE9SIiwiU0VMRUNURURfRVZFTlQiLCJBUklBX0RJU0FCTEVEX0FUVFIiLCJTRUxFQ1RFRF9UUklHR0VSX0RFTEFZIiwiVFJBTlNJVElPTl9PUEVOX0RVUkFUSU9OIiwiVFJBTlNJVElPTl9DTE9TRV9EVVJBVElPTiIsIk1BUkdJTl9UT19FREdFIiwiQU5DSE9SX1RPX01FTlVfV0lEVEhfUkFUSU8iLCJPRkZTRVRfVE9fTUVOVV9IRUlHSFRfUkFUSU8iLCJDb3JuZXJCaXQiLCJCT1RUT00iLCJDRU5URVIiLCJSSUdIVCIsIkZMSVBfUlRMIiwiQ29ybmVyIiwiVE9QX0xFRlQiLCJUT1BfUklHSFQiLCJCT1RUT01fTEVGVCIsIkJPVFRPTV9SSUdIVCIsIlRPUF9TVEFSVCIsIlRPUF9FTkQiLCJCT1RUT01fU1RBUlQiLCJCT1RUT01fRU5EIiwiTURDTWVudUZvdW5kYXRpb24iLCJnZXRBdHRyaWJ1dGVGb3JFdmVudFRhcmdldCIsImdldElubmVyRGltZW5zaW9ucyIsImhhc0FuY2hvciIsImdldEFuY2hvckRpbWVuc2lvbnMiLCJnZXRXaW5kb3dEaW1lbnNpb25zIiwiZ2V0TnVtYmVyT2ZJdGVtcyIsInJlZ2lzdGVyQm9keUNsaWNrSGFuZGxlciIsImRlcmVnaXN0ZXJCb2R5Q2xpY2tIYW5kbGVyIiwiZ2V0SW5kZXhGb3JFdmVudFRhcmdldCIsIm5vdGlmeVNlbGVjdGVkIiwic2F2ZUZvY3VzIiwicmVzdG9yZUZvY3VzIiwiaXNGb2N1c2VkIiwiZ2V0Rm9jdXNlZEl0ZW1JbmRleCIsImZvY3VzSXRlbUF0SW5kZXgiLCJzZXRUcmFuc2Zvcm1PcmlnaW4iLCJzZXRQb3NpdGlvbiIsInNldE1heEhlaWdodCIsInNldEF0dHJGb3JPcHRpb25BdEluZGV4Iiwicm1BdHRyRm9yT3B0aW9uQXRJbmRleCIsImFkZENsYXNzRm9yT3B0aW9uQXRJbmRleCIsInJtQ2xhc3NGb3JPcHRpb25BdEluZGV4IiwiaGFuZGxlUG9zc2libGVTZWxlY3RlZF8iLCJoYW5kbGVLZXlib2FyZERvd25fIiwiaGFuZGxlS2V5Ym9hcmRVcF8iLCJkb2N1bWVudENsaWNrSGFuZGxlcl8iLCJoYW5kbGVEb2N1bWVudENsaWNrXyIsIm9wZW5BbmltYXRpb25FbmRUaW1lcklkXyIsImNsb3NlQW5pbWF0aW9uRW5kVGltZXJJZF8iLCJzZWxlY3RlZFRyaWdnZXJUaW1lcklkXyIsImFuaW1hdGlvblJlcXVlc3RJZF8iLCJkaW1lbnNpb25zXyIsIml0ZW1IZWlnaHRfIiwiYW5jaG9yQ29ybmVyXyIsImFuY2hvck1hcmdpbl8iLCJyaWdodCIsImJvdHRvbSIsIm1lYXN1cmVzXyIsInNlbGVjdGVkSW5kZXhfIiwicmVtZW1iZXJTZWxlY3Rpb25fIiwicXVpY2tPcGVuXyIsImtleURvd25XaXRoaW5NZW51XyIsImNvcm5lciIsIm1hcmdpbiIsInJlbWVtYmVyU2VsZWN0aW9uIiwic2V0U2VsZWN0ZWRJbmRleCIsInF1aWNrT3BlbiIsImZvY3VzSW5kZXgiLCJhbHRLZXkiLCJjdHJsS2V5IiwibWV0YUtleSIsImlzVGFiIiwiaXNBcnJvd1VwIiwiaXNBcnJvd0Rvd24iLCJpc0VudGVyIiwiZm9jdXNlZEl0ZW1JbmRleCIsImxhc3RJdGVtSW5kZXgiLCJpc0VzY2FwZSIsInRhcmdldEluZGV4IiwiYW5jaG9yUmVjdCIsInZpZXdwb3J0Iiwidmlld3BvcnREaXN0YW5jZSIsImFuY2hvckhlaWdodCIsImFuY2hvcldpZHRoIiwibWVudUhlaWdodCIsIm1lbnVXaWR0aCIsImlzQm90dG9tQWxpZ25lZCIsImF2YWlsYWJsZVRvcCIsImF2YWlsYWJsZUJvdHRvbSIsInRvcE92ZXJmbG93IiwiYm90dG9tT3ZlcmZsb3ciLCJpc0ZsaXBSdGwiLCJhdm9pZEhvcml6b250YWxPdmVybGFwIiwiaXNBbGlnbmVkUmlnaHQiLCJhdmFpbGFibGVMZWZ0IiwiYXZhaWxhYmxlUmlnaHQiLCJsZWZ0T3ZlcmZsb3ciLCJyaWdodE92ZXJmbG93IiwiaXNSaWdodEFsaWduZWQiLCJyaWdodE9mZnNldCIsImxlZnRPZmZzZXQiLCJhdm9pZFZlcnRpY2FsT3ZlcmxhcCIsImNhbk92ZXJsYXBWZXJ0aWNhbGx5IiwibWF4SGVpZ2h0IiwiZ2V0QXV0b0xheW91dE1lYXN1cmVtZW50c18iLCJnZXRPcmlnaW5Db3JuZXJfIiwibWF4TWVudUhlaWdodCIsImdldE1lbnVNYXhIZWlnaHRfIiwidmVydGljYWxBbGlnbm1lbnQiLCJob3Jpem9udGFsQWxpZ25tZW50IiwiaG9yaXpvbnRhbE9mZnNldCIsImdldEhvcml6b250YWxPcmlnaW5PZmZzZXRfIiwidmVydGljYWxPZmZzZXQiLCJnZXRWZXJ0aWNhbE9yaWdpbk9mZnNldF8iLCJ2ZXJ0aWNhbE9mZnNldFBlcmNlbnQiLCJvcmlnaW5QZXJjZW50IiwiYXV0b1Bvc2l0aW9uXyIsImZvY3VzT25PcGVuXyIsInRhcmdldElzRGlzYWJsZWQiLCJwcmV2U2VsZWN0ZWRJbmRleCIsIm1kY01lbnUiLCJtZGNNZW51SXRlbSIsIm1kY01lbnVEaXZpZGVyIiwibWRjTWVudUFuY2hvciIsIk1EQ1JhZGlvQWRhcHRlciIsIk1EQ1JhZGlvRm91bmRhdGlvbiIsIm1kY1JhZGlvIiwiTURDU2VsZWN0QWRhcHRlciIsInNob3VsZEZsb2F0IiwibGFiZWxXaWR0aCIsIkJPWCIsIk9VVExJTkVEIiwiTElORV9SSVBQTEVfU0VMRUNUT1IiLCJPVVRMSU5FX1NFTEVDVE9SIiwiTEFCRUxfU0NBTEUiLCJNRENTZWxlY3RGb3VuZGF0aW9uIiwiYWN0aXZhdGVCb3R0b21MaW5lIiwiZGVhY3RpdmF0ZUJvdHRvbUxpbmUiLCJnZXRWYWx1ZSIsImhhc0xhYmVsIiwiZmxvYXRMYWJlbCIsImdldExhYmVsV2lkdGgiLCJoYXNPdXRsaW5lIiwibm90Y2hPdXRsaW5lIiwiY2xvc2VPdXRsaW5lIiwib3B0aW9uSGFzVmFsdWUiLCJvcGVuTm90Y2giLCJsYWJlbFNjYWxlIiwiTURDRmxvYXRpbmdMYWJlbEFkYXB0ZXIiLCJMQUJFTF9GTE9BVF9BQk9WRSIsIkxBQkVMX1NIQUtFIiwiTURDRmxvYXRpbmdMYWJlbEZvdW5kYXRpb24iLCJnZXRXaWR0aCIsInNoYWtlQW5pbWF0aW9uRW5kSGFuZGxlcl8iLCJoYW5kbGVTaGFrZUFuaW1hdGlvbkVuZF8iLCJzaG91bGRTaGFrZSIsIk1EQ0xpbmVSaXBwbGVBZGFwdGVyIiwiTElORV9SSVBQTEVfQUNUSVZFIiwiTElORV9SSVBQTEVfREVBQ1RJVkFUSU5HIiwiTURDTGluZVJpcHBsZUZvdW5kYXRpb24iLCJyZWdpc3RlckV2ZW50SGFuZGxlciIsImRlcmVnaXN0ZXJFdmVudEhhbmRsZXIiLCJoYW5kbGVUcmFuc2l0aW9uRW5kIiwieENvb3JkaW5hdGUiLCJpc0RlYWN0aXZhdGluZyIsIk1EQ05vdGNoZWRPdXRsaW5lQWRhcHRlciIsIlBBVEhfU0VMRUNUT1IiLCJJRExFX09VVExJTkVfU0VMRUNUT1IiLCJPVVRMSU5FX05PVENIRUQiLCJNRENOb3RjaGVkT3V0bGluZUZvdW5kYXRpb24iLCJnZXRIZWlnaHQiLCJzZXRPdXRsaW5lUGF0aEF0dHIiLCJnZXRJZGxlT3V0bGluZVN0eWxlVmFsdWUiLCJub3RjaFdpZHRoIiwidXBkYXRlU3ZnUGF0aF8iLCJyYWRpdXNTdHlsZVZhbHVlIiwicmFkaXVzIiwicGFyc2VGbG9hdCIsImNvcm5lcldpZHRoIiwibGVhZGluZ1N0cm9rZUxlbmd0aCIsInBhZGRlZE5vdGNoV2lkdGgiLCJwYXRoTWlkZGxlIiwicGF0aCIsIm1kY1NlbGVjdCIsIkFDVElWRSIsIkRJU0NSRVRFIiwiRk9DVVMiLCJJTl9UUkFOU0lUIiwiSVNfRElTQ1JFVEUiLCJIQVNfVFJBQ0tfTUFSS0VSIiwiVFJBQ0tfU0VMRUNUT1IiLCJUUkFDS19NQVJLRVJfQ09OVEFJTkVSX1NFTEVDVE9SIiwiTEFTVF9UUkFDS19NQVJLRVJfU0VMRUNUT1IiLCJUSFVNQl9DT05UQUlORVJfU0VMRUNUT1IiLCJQSU5fVkFMVUVfTUFSS0VSX1NFTEVDVE9SIiwiQVJJQV9WQUxVRU1JTiIsIkFSSUFfVkFMVUVNQVgiLCJBUklBX1ZBTFVFTk9XIiwiU1RFUF9EQVRBX0FUVFIiLCJJTlBVVF9FVkVOVCIsIlBBR0VfRkFDVE9SIiwiTURDU2xpZGVyQWRhcHRlciIsIm51bU1hcmtlcnMiLCJLRVlfSURTIiwiQVJST1dfTEVGVCIsIkFSUk9XX1JJR0hUIiwiQVJST1dfVVAiLCJBUlJPV19ET1dOIiwiSE9NRSIsIkVORCIsIlBBR0VfVVAiLCJQQUdFX0RPV04iLCJNT1ZFX0VWRU5UX01BUCIsIkRPV05fRVZFTlRTIiwiVVBfRVZFTlRTIiwiTURDU2xpZGVyRm91bmRhdGlvbiIsInJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIiLCJyZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlciIsIm5vdGlmeUlucHV0Iiwic2V0VGh1bWJDb250YWluZXJTdHlsZVByb3BlcnR5Iiwic2V0VHJhY2tTdHlsZVByb3BlcnR5Iiwic2V0TWFya2VyVmFsdWUiLCJhcHBlbmRUcmFja01hcmtlcnMiLCJyZW1vdmVUcmFja01hcmtlcnMiLCJzZXRMYXN0VHJhY2tNYXJrZXJzU3R5bGVQcm9wZXJ0eSIsImlzUlRMIiwicmVjdF8iLCJOYU4iLCJhY3RpdmVfIiwiaW5UcmFuc2l0XyIsImlzRGlzY3JldGVfIiwiaGFzVHJhY2tNYXJrZXJfIiwiaGFuZGxpbmdUaHVtYlRhcmdldEV2dF8iLCJtaW5fIiwibWF4XyIsInN0ZXBfIiwidmFsdWVfIiwicHJldmVudEZvY3VzU3RhdGVfIiwidXBkYXRlVUlGcmFtZV8iLCJ0aHVtYkNvbnRhaW5lclBvaW50ZXJIYW5kbGVyXyIsImludGVyYWN0aW9uU3RhcnRIYW5kbGVyXyIsImhhbmRsZURvd25fIiwiaGFuZGxlS2V5ZG93bl8iLCJoYW5kbGVGb2N1c18iLCJoYW5kbGVCbHVyXyIsImV2dE5hbWUiLCJnZXRTdGVwIiwiZ2V0TWluIiwiZ2V0TWF4Iiwic3RlcCIsImluZGl2aXNpYmxlIiwiY2VpbCIsImxhc3RTdGVwUmF0aW8iLCJmbGV4IiwidXBkYXRlVUlGb3JDdXJyZW50VmFsdWVfIiwic2V0VmFsdWVfIiwic2V0dXBUcmFja01hcmtlciIsInRvZ2dsZUNsYXNzXyIsInNldEluVHJhbnNpdF8iLCJzZXRBY3RpdmVfIiwibW92ZUhhbmRsZXIiLCJoYW5kbGVNb3ZlXyIsInVwSGFuZGxlciIsImhhbmRsZVVwXyIsInNldFZhbHVlRnJvbUV2dF8iLCJ0YXJnZXRUb3VjaGVzIiwiZ2V0UGFnZVhfIiwiY29tcHV0ZVZhbHVlRnJvbVBhZ2VYXyIsInhQb3MiLCJwY3RDb21wbGV0ZSIsImtleUlkIiwiZ2V0S2V5SWRfIiwiZ2V0VmFsdWVGb3JLZXlJZF8iLCJrYmRFdnQiLCJkZWx0YSIsInZhbHVlTmVlZHNUb0JlRmxpcHBlZCIsInNob3VsZEZpcmVJbnB1dCIsImZvcmNlIiwidmFsdWVTZXRUb0JvdW5kYXJ5IiwicXVhbnRpemVfIiwibnVtU3RlcHMiLCJxdWFudGl6ZWRWYWwiLCJ0cmFuc2xhdGVQeCIsInRyYW5zZm9ybVByb3AiLCJ0cmFuc2l0aW9uZW5kRXZ0TmFtZSIsIm9uVHJhbnNpdGlvbkVuZCIsImluVHJhbnNpdCIsInNob3VsZEJlUHJlc2VudCIsIm1kY1NsaWRlciIsIlRFWFQiLCJBQ1RJT05fV1JBUFBFUiIsIkFDVElPTl9CVVRUT04iLCJNVUxUSUxJTkUiLCJBQ1RJT05fT05fQk9UVE9NIiwiVEVYVF9TRUxFQ1RPUiIsIkFDVElPTl9XUkFQUEVSX1NFTEVDVE9SIiwiQUNUSU9OX0JVVFRPTl9TRUxFQ1RPUiIsIlNIT1dfRVZFTlQiLCJISURFX0VWRU5UIiwiTUVTU0FHRV9USU1FT1VUIiwiTURDU25hY2tiYXJGb3VuZGF0aW9uIiwic2V0QXJpYUhpZGRlbiIsInVuc2V0QXJpYUhpZGRlbiIsInNldEFjdGlvbkFyaWFIaWRkZW4iLCJ1bnNldEFjdGlvbkFyaWFIaWRkZW4iLCJzZXRBY3Rpb25UZXh0Iiwic2V0TWVzc2FnZVRleHQiLCJzZXRGb2N1cyIsInZpc2liaWxpdHlJc0hpZGRlbiIsInJlZ2lzdGVyQ2FwdHVyZWRCbHVySGFuZGxlciIsImRlcmVnaXN0ZXJDYXB0dXJlZEJsdXJIYW5kbGVyIiwicmVnaXN0ZXJWaXNpYmlsaXR5Q2hhbmdlSGFuZGxlciIsImRlcmVnaXN0ZXJWaXNpYmlsaXR5Q2hhbmdlSGFuZGxlciIsInJlZ2lzdGVyQ2FwdHVyZWRJbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVyQ2FwdHVyZWRJbnRlcmFjdGlvbkhhbmRsZXIiLCJyZWdpc3RlckFjdGlvbkNsaWNrSGFuZGxlciIsImRlcmVnaXN0ZXJBY3Rpb25DbGlja0hhbmRsZXIiLCJub3RpZnlTaG93Iiwibm90aWZ5SGlkZSIsImFjdGlvbldhc0NsaWNrZWRfIiwiZGlzbWlzc09uQWN0aW9uXyIsImZpcnN0Rm9jdXNfIiwicG9pbnRlckRvd25SZWNvZ25pemVkXyIsInNuYWNrYmFySGFzRm9jdXNfIiwic25hY2tiYXJEYXRhXyIsInF1ZXVlXyIsImFjdGlvbkNsaWNrSGFuZGxlcl8iLCJpbnZva2VBY3Rpb25fIiwidmlzaWJpbGl0eWNoYW5nZUhhbmRsZXJfIiwidGltZW91dElkXyIsImNsZWFudXBfIiwidGltZW91dCIsImludGVyYWN0aW9uSGFuZGxlcl8iLCJoYW5kbGVQb3NzaWJsZVRhYktleWJvYXJkRm9jdXNfIiwiZGlzbWlzc09uQWN0aW9uIiwibWVzc2FnZSIsImFjdGlvbkhhbmRsZXIiLCJhY3Rpb25UZXh0IiwibXVsdGlsaW5lIiwiYWN0aW9uT25Cb3R0b20iLCJhY3Rpb25IYW5kbGVyXyIsInNldEFjdGlvbkhpZGRlbl8iLCJoaWphY2tGb2N1cyIsInNldEZvY3VzT25BY3Rpb25fIiwiYWxsb3dEaXNtaXNzYWwiLCJzaG93TmV4dF8iLCJzaG93Iiwic2hpZnQiLCJpc0hpZGRlbiIsIm1kY1NuYWNrYmFyIiwiTURDU3dpdGNoQWRhcHRlciIsIlJJUFBMRV9TVVJGQUNFX1NFTEVDVE9SIiwiTURDU3dpdGNoRm91bmRhdGlvbiIsInNldE5hdGl2ZUNvbnRyb2xDaGVja2VkIiwiaXNOYXRpdmVDb250cm9sQ2hlY2tlZCIsInNldE5hdGl2ZUNvbnRyb2xEaXNhYmxlZCIsImlzTmF0aXZlQ29udHJvbERpc2FibGVkIiwidXBkYXRlQ2hlY2tlZFN0eWxpbmdfIiwiaXNDaGVja2VkIiwibWRjU3dpdGNoIiwiTURDVGFiRm91bmRhdGlvbiIsImdldE9mZnNldExlZnQiLCJjb21wdXRlZFdpZHRoXyIsImNvbXB1dGVkTGVmdF8iLCJpc0FjdGl2ZV8iLCJwcmV2ZW50RGVmYXVsdE9uQ2xpY2tfIiwiaXNBY3RpdmUiLCJwcmV2ZW50RGVmYXVsdE9uQ2xpY2siLCJUQUJfU0VMRUNUT1IiLCJJTkRJQ0FUT1JfU0VMRUNUT1IiLCJNRENUYWJCYXJGb3VuZGF0aW9uIiwiYmluZE9uTURDVGFiU2VsZWN0ZWRFdmVudCIsInVuYmluZE9uTURDVGFiU2VsZWN0ZWRFdmVudCIsInNldFN0eWxlRm9ySW5kaWNhdG9yIiwiZ2V0T2Zmc2V0V2lkdGhGb3JJbmRpY2F0b3IiLCJnZXROdW1iZXJPZlRhYnMiLCJpc1RhYkFjdGl2ZUF0SW5kZXgiLCJzZXRUYWJBY3RpdmVBdEluZGV4IiwiaXNEZWZhdWx0UHJldmVudGVkT25DbGlja0ZvclRhYkF0SW5kZXgiLCJzZXRQcmV2ZW50RGVmYXVsdE9uQ2xpY2tGb3JUYWJBdEluZGV4IiwibWVhc3VyZVRhYkF0SW5kZXgiLCJnZXRDb21wdXRlZFdpZHRoRm9yVGFiQXRJbmRleCIsImdldENvbXB1dGVkTGVmdEZvclRhYkF0SW5kZXgiLCJpc0luZGljYXRvclNob3duXyIsImFjdGl2ZVRhYkluZGV4XyIsImFjdGl2ZVRhYkluZGV4IiwiZmluZEFjdGl2ZVRhYkluZGV4XyIsImZvckVhY2hUYWJJbmRleF8iLCJsYXlvdXRJbmRpY2F0b3JfIiwiaXNJbmRpY2F0b3JGaXJzdFJlbmRlciIsInRyYW5zbGF0ZUFtdEZvckFjdGl2ZVRhYkxlZnQiLCJzY2FsZUFtdEZvckFjdGl2ZVRhYldpZHRoIiwidHJhbnNmb3JtVmFsdWUiLCJpdGVyYXRvciIsIm51bVRhYnMiLCJzaG91bGRCcmVhayIsInByZXZBY3RpdmVUYWJJbmRleCIsIm1kY1RhYiIsIm1kY1RhYkJhciIsIk1EQ1RleHRGaWVsZEhlbHBlclRleHRBZGFwdGVyIiwiQVJJQV9ISURERU4iLCJST0xFIiwiSEVMUEVSX1RFWFRfUEVSU0lTVEVOVCIsIkhFTFBFUl9URVhUX1ZBTElEQVRJT05fTVNHIiwiTURDVGV4dEZpZWxkSGVscGVyVGV4dEZvdW5kYXRpb24iLCJyZW1vdmVBdHRyIiwic2V0Q29udGVudCIsImlzUGVyc2lzdGVudCIsImlzVmFsaWRhdGlvbiIsImlucHV0SXNWYWxpZCIsImhlbHBlclRleHRJc1BlcnNpc3RlbnQiLCJoZWxwZXJUZXh0SXNWYWxpZGF0aW9uTXNnIiwidmFsaWRhdGlvbk1zZ05lZWRzRGlzcGxheSIsImhpZGVfIiwiTURDVGV4dEZpZWxkSWNvbkFkYXB0ZXIiLCJJQ09OX0VWRU5UIiwiSUNPTl9ST0xFIiwiTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb24iLCJub3RpZnlJY29uQWN0aW9uIiwiaGFuZGxlSW50ZXJhY3Rpb24iLCJNRENUZXh0RmllbGRBZGFwdGVyIiwib2JzZXJ2ZXIiLCJBUklBX0NPTlRST0xTIiwiSU5QVVRfU0VMRUNUT1IiLCJJQ09OX1NFTEVDVE9SIiwiREVOU0UiLCJGT0NVU0VEIiwiSU5WQUxJRCIsIkRFTlNFX0xBQkVMX1NDQUxFIiwiVkFMSURBVElPTl9BVFRSX1dISVRFTElTVCIsIk1EQ1RleHRGaWVsZEZvdW5kYXRpb24iLCJpc1ZhbGlkIiwiaXNGb2N1c2VkXyIsImlzQmFkSW5wdXRfIiwicmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVyVGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyIiwicmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlciIsInJlZ2lzdGVyVmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXIiLCJkZXJlZ2lzdGVyVmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXIiLCJnZXROYXRpdmVJbnB1dCIsImFjdGl2YXRlTGluZVJpcHBsZSIsImRlYWN0aXZhdGVMaW5lUmlwcGxlIiwic2V0TGluZVJpcHBsZVRyYW5zZm9ybU9yaWdpbiIsInNoYWtlTGFiZWwiLCJmb3VuZGF0aW9uTWFwIiwiaGVscGVyVGV4dF8iLCJoZWxwZXJUZXh0IiwiaWNvbl8iLCJpY29uIiwicmVjZWl2ZWRVc2VySW5wdXRfIiwidXNlQ3VzdG9tVmFsaWRpdHlDaGVja2luZ18iLCJpc1ZhbGlkXyIsImlucHV0Rm9jdXNIYW5kbGVyXyIsImFjdGl2YXRlRm9jdXMiLCJpbnB1dEJsdXJIYW5kbGVyXyIsImRlYWN0aXZhdGVGb2N1cyIsImlucHV0SW5wdXRIYW5kbGVyXyIsImF1dG9Db21wbGV0ZUZvY3VzIiwic2V0UG9pbnRlclhPZmZzZXRfIiwidGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyXyIsImhhbmRsZVRleHRGaWVsZEludGVyYWN0aW9uIiwidmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXJfIiwiYXR0cmlidXRlc0xpc3QiLCJoYW5kbGVWYWxpZGF0aW9uQXR0cmlidXRlQ2hhbmdlIiwidmFsaWRhdGlvbk9ic2VydmVyXyIsInN0eWxlVmFsaWRpdHlfIiwiaXNEZW5zZSIsInN0eWxlRm9jdXNlZF8iLCJzaG93VG9TY3JlZW5SZWFkZXIiLCJ0YXJnZXRDbGllbnRSZWN0IiwiZXZ0Q29vcmRzIiwiY2xpZW50WCIsImNsaWVudFkiLCJpbnB1dCIsImdldE5hdGl2ZUlucHV0XyIsInNob3VsZFJlbW92ZUxhYmVsRmxvYXQiLCJpc05hdGl2ZUlucHV0VmFsaWRfIiwic3R5bGVEaXNhYmxlZF8iLCJzZXRBcmlhTGFiZWwiLCJ2YWxpZGl0eSIsImJhZElucHV0IiwidmFsaWQiLCJzZXRWYWxpZGl0eSIsInNldERpc2FibGVkIiwibWRjVGV4dEZpZWxkIiwibWRjVGhlbWUiLCJGSVhFRCIsIkZJWEVEX0xBU1RST1ciLCJGSVhFRF9BVF9MQVNUX1JPVyIsIlRPT0xCQVJfUk9XX0ZMRVhJQkxFIiwiRkxFWElCTEVfREVGQVVMVF9CRUhBVklPUiIsIkZMRVhJQkxFX01BWCIsIkZMRVhJQkxFX01JTiIsIlRJVExFX1NFTEVDVE9SIiwiRklSU1RfUk9XX1NFTEVDVE9SIiwiTUFYX1RJVExFX1NJWkUiLCJNSU5fVElUTEVfU0laRSIsIlRPT0xCQVJfUk9XX0hFSUdIVCIsIlRPT0xCQVJfUk9XX01PQklMRV9IRUlHSFQiLCJUT09MQkFSX01PQklMRV9CUkVBS1BPSU5UIiwiTURDVG9vbGJhckZvdW5kYXRpb24iLCJyZWdpc3RlclNjcm9sbEhhbmRsZXIiLCJkZXJlZ2lzdGVyU2Nyb2xsSGFuZGxlciIsImdldFZpZXdwb3J0V2lkdGgiLCJnZXRWaWV3cG9ydFNjcm9sbFkiLCJnZXRPZmZzZXRIZWlnaHQiLCJnZXRGaXJzdFJvd0VsZW1lbnRPZmZzZXRIZWlnaHQiLCJzZXRTdHlsZUZvclRpdGxlRWxlbWVudCIsInNldFN0eWxlRm9yRmxleGlibGVSb3dFbGVtZW50Iiwic2V0U3R5bGVGb3JGaXhlZEFkanVzdEVsZW1lbnQiLCJjaGVja1Jvd0hlaWdodF8iLCJzY3JvbGxIYW5kbGVyXyIsInVwZGF0ZVRvb2xiYXJTdHlsZXNfIiwiY2hlY2tSb3dIZWlnaHRGcmFtZV8iLCJzY3JvbGxGcmFtZV8iLCJleGVjdXRlZExhc3RDaGFuZ2VfIiwiY2FsY3VsYXRpb25zXyIsInRvb2xiYXJSb3dIZWlnaHQiLCJ0b29sYmFyUmF0aW8iLCJmbGV4aWJsZUV4cGFuc2lvblJhdGlvIiwibWF4VHJhbnNsYXRlWVJhdGlvIiwic2Nyb2xsVGhyZXNob2xkUmF0aW8iLCJ0b29sYmFySGVpZ2h0IiwiZmxleGlibGVFeHBhbnNpb25IZWlnaHQiLCJtYXhUcmFuc2xhdGVZRGlzdGFuY2UiLCJzY3JvbGxUaHJlc2hvbGQiLCJmaXhlZF8iLCJmaXhlZExhc3Ryb3dfIiwiaGFzRmxleGlibGVSb3dfIiwidXNlRmxleERlZmF1bHRCZWhhdmlvcl8iLCJpbml0S2V5UmF0aW9fIiwic2V0S2V5SGVpZ2h0c18iLCJzY3JvbGxUb3AiLCJuZXdUb29sYmFyUm93SGVpZ2h0IiwiZ2V0Um93SGVpZ2h0XyIsInVwZGF0ZUFkanVzdEVsZW1lbnRTdHlsZXMiLCJoYXNTY3JvbGxlZE91dE9mVGhyZXNob2xkIiwic2Nyb2xsZWRPdXRPZlRocmVzaG9sZF8iLCJnZXRGbGV4aWJsZUV4cGFuc2lvblJhdGlvXyIsInVwZGF0ZVRvb2xiYXJGbGV4aWJsZVN0YXRlXyIsInVwZGF0ZVRvb2xiYXJGaXhlZFN0YXRlXyIsInVwZGF0ZUZsZXhpYmxlUm93RWxlbWVudFN0eWxlc18iLCJmaXJzdFJvd01heFJhdGlvIiwiYnJlYWtwb2ludCIsInRyYW5zbGF0ZURpc3RhbmNlIiwidXBkYXRlRWxlbWVudFN0eWxlc0RlZmF1bHRCZWhhdmlvcl8iLCJtYXhUaXRsZVNpemUiLCJtaW5UaXRsZVNpemUiLCJjdXJyZW50VGl0bGVTaXplIiwibWRjVG9vbGJhciIsIm1kY1Rvb2xiYXJSb3ciLCJtZGNUb29sYmFyU2VjdGlvbiIsIm1kY1Rvb2xiYXJNZW51SWNvbiIsIm1kY1Rvb2xiYXJUaXRsZSIsIm1kY1Rvb2xiYXJJY29uIiwiRklYRURfQ0xBU1MiLCJGSVhFRF9TQ1JPTExFRF9DTEFTUyIsIlNIT1JUX0NMQVNTIiwiU0hPUlRfSEFTX0FDVElPTl9JVEVNX0NMQVNTIiwiU0hPUlRfQ09MTEFQU0VEX0NMQVNTIiwiREVCT1VOQ0VfVEhST1RUTEVfUkVTSVpFX1RJTUVfTVMiLCJNQVhfVE9QX0FQUF9CQVJfSEVJR0hUIiwiQUNUSU9OX0lURU1fU0VMRUNUT1IiLCJOQVZJR0FUSU9OX0VWRU5UIiwiTkFWSUdBVElPTl9JQ09OX1NFTEVDVE9SIiwiUk9PVF9TRUxFQ1RPUiIsIk1EQ1RvcEFwcEJhckFkYXB0ZXIiLCJwcm9wZXJ0eSIsIk1EQ1RvcEFwcEJhckJhc2VGb3VuZGF0aW9uIiwiZ2V0VG9wQXBwQmFySGVpZ2h0IiwicmVnaXN0ZXJOYXZpZ2F0aW9uSWNvbkludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJOYXZpZ2F0aW9uSWNvbkludGVyYWN0aW9uSGFuZGxlciIsIm5vdGlmeU5hdmlnYXRpb25JY29uQ2xpY2tlZCIsImdldFRvdGFsQWN0aW9uSXRlbXMiLCJuYXZDbGlja0hhbmRsZXJfIiwiTURDU2hvcnRUb3BBcHBCYXJGb3VuZGF0aW9uIiwiaXNDb2xsYXBzZWQiLCJzaG9ydEFwcEJhclNjcm9sbEhhbmRsZXJfIiwiaXNBbHdheXNDb2xsYXBzZWQiLCJjdXJyZW50U2Nyb2xsIiwibWRjVG9wQXBwQmFyIiwibWRjVG9wQXBwQmFyQWN0aW9uIiwidHlwb3MiLCJtZGNUeXBvTWl4aW4iLCJjbGFzcyIsInR5cG8iLCIkYXR0cnMiLCIkc2xvdHMiLCJtZGNUeXBvUHJvcE1peGluIiwiZGVmYXVsdFRhZyIsImRlZmF1bHRUeXBvIiwidmFsaWRUeXBvcyIsInZhbGlkYXRvciIsIm1kY1RleHRTZWN0aW9uIiwibWRjVGV4dCIsIm1peGlucyIsIm1kY0Rpc3BsYXkiLCJtZGNIZWFkbGluZSIsIm1kY1RpdGxlIiwibWRjU3ViSGVhZGluZyIsIm1kY0JvZHkiLCJtZGNDYXB0aW9uIiwiVnVlTURDQnV0dG9uIiwiVnVlTURDQ2FyZCIsIlZ1ZU1EQ0NoZWNrYm94IiwiVnVlTURDQ2hpcFNldCIsIlZ1ZU1EQ0VsZXZhdGlvbiIsIlZ1ZU1EQ0RpYWxvZyIsIlZ1ZU1EQ0RyYXdlciIsIlZ1ZU1EQ0ZhYiIsIlZ1ZU1EQ0dyaWRMaXN0IiwiVnVlTURDSWNvbiIsIlZ1ZU1EQ0ljb25Ub2dnbGUiLCJWdWVNRENMYXlvdXRBcHAiLCJWdWVNRENMYXlvdXRHcmlkIiwiVnVlTURDTGluZWFyUHJvZ3Jlc3MiLCJWdWVNRENMaXN0IiwiVnVlTURDTWVudSIsIlZ1ZU1EQ1JhZGlvIiwiVnVlTURDUmlwcGxlIiwiVnVlTURDU2VsZWN0IiwiVnVlTURDU2xpZGVyIiwiVnVlTURDU25hY2tiYXIiLCJWdWVNRENTd2l0Y2giLCJWdWVNRENUYWJzIiwiVnVlTURDVGV4dGZpZWxkIiwiVnVlTURDVGhlbWUiLCJWdWVNRENUb29sYmFyIiwiVnVlTURDVG9wQXBwQmFyIiwiVnVlTURDVHlwb2dyYXBoeSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztFQUFBLElBQUlBLHlCQUFKOztFQUVBOzs7Ozs7QUFNQSxFQUFPLFNBQVNDLFlBQVQsR0FBZ0U7RUFBQSxNQUExQ0MsU0FBMEMsdUVBQTlCQyxNQUE4QjtFQUFBLE1BQXRCQyxZQUFzQix1RUFBUCxLQUFPOztFQUNyRSxNQUFJSixxQkFBcUJLLFNBQXJCLElBQWtDRCxZQUF0QyxFQUFvRDtFQUNsRCxRQUFJRSxjQUFjLEtBQWxCO0VBQ0EsUUFBSTtFQUNGSixnQkFBVUssUUFBVixDQUFtQkMsZ0JBQW5CLENBQW9DLE1BQXBDLEVBQTRDLElBQTVDLEVBQWtEO0VBQ2hELFlBQUlDLE9BQUosR0FBYztFQUNaSCx3QkFBYyxFQUFFRyxTQUFTLElBQVgsRUFBZDtFQUNEO0VBSCtDLE9BQWxEO0VBS0QsS0FORCxDQU1FLE9BQU9DLENBQVAsRUFBVTtFQUNWO0VBQ0Q7O0VBRURWLHVCQUFtQk0sV0FBbkI7RUFDRDs7RUFFRCxTQUFPTixnQkFBUDtFQUNEOztFQ3pCTSxTQUFTVyxRQUFULENBQWtCQyxNQUFsQixFQUEwQjtFQUMvQjtFQUNBLE1BQUlD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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDa0JaOzs7Ozs7O0dBQUE7OztFQWxCWSwrQkFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNNWjs7Ozs7R0FBQTs7O0VBTlksK0JBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTVo7O0dBQUE7OztFQU5ZLCtCQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNJWjs7R0FBQTs7O0VBSlksK0JBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTVo7Ozs7Ozs7Ozs7OztHQUFBOzs7RUFOWSwrQkFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSVo7O0dBQUE7OztFQUpZLCtCQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0FaOzs7Ozs7Ozs7Ozs7R0FB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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUNnQlo7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBQUE7O0FBY0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBQUE7OztFQTlCWSwrQkFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSVo7O0dBQUE7OztFQUpZLCtCQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUVo7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBQUE7OztFQVJZLCtCQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ01aOzs7Ozs7Ozs7Ozs7R0FBQTs7O0VBTlksK0JBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNxQlo7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQUFBOzs7RUFyQlksK0JBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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
